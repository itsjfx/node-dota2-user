/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    /**
     * EDotaUserMessages enum.
     * @exports EDotaUserMessages
     * @enum {number}
     * @property {number} DOTA_UM_AddUnitToSelection=464 DOTA_UM_AddUnitToSelection value
     * @property {number} DOTA_UM_AIDebugLine=465 DOTA_UM_AIDebugLine value
     * @property {number} DOTA_UM_ChatEvent=466 DOTA_UM_ChatEvent value
     * @property {number} DOTA_UM_CombatHeroPositions=467 DOTA_UM_CombatHeroPositions value
     * @property {number} DOTA_UM_CombatLogData=468 DOTA_UM_CombatLogData value
     * @property {number} DOTA_UM_CombatLogBulkData=470 DOTA_UM_CombatLogBulkData value
     * @property {number} DOTA_UM_CreateLinearProjectile=471 DOTA_UM_CreateLinearProjectile value
     * @property {number} DOTA_UM_DestroyLinearProjectile=472 DOTA_UM_DestroyLinearProjectile value
     * @property {number} DOTA_UM_DodgeTrackingProjectiles=473 DOTA_UM_DodgeTrackingProjectiles value
     * @property {number} DOTA_UM_GlobalLightColor=474 DOTA_UM_GlobalLightColor value
     * @property {number} DOTA_UM_GlobalLightDirection=475 DOTA_UM_GlobalLightDirection value
     * @property {number} DOTA_UM_InvalidCommand=476 DOTA_UM_InvalidCommand value
     * @property {number} DOTA_UM_LocationPing=477 DOTA_UM_LocationPing value
     * @property {number} DOTA_UM_MapLine=478 DOTA_UM_MapLine value
     * @property {number} DOTA_UM_MiniKillCamInfo=479 DOTA_UM_MiniKillCamInfo value
     * @property {number} DOTA_UM_MinimapDebugPoint=480 DOTA_UM_MinimapDebugPoint value
     * @property {number} DOTA_UM_MinimapEvent=481 DOTA_UM_MinimapEvent value
     * @property {number} DOTA_UM_NevermoreRequiem=482 DOTA_UM_NevermoreRequiem value
     * @property {number} DOTA_UM_OverheadEvent=483 DOTA_UM_OverheadEvent value
     * @property {number} DOTA_UM_SetNextAutobuyItem=484 DOTA_UM_SetNextAutobuyItem value
     * @property {number} DOTA_UM_SharedCooldown=485 DOTA_UM_SharedCooldown value
     * @property {number} DOTA_UM_SpectatorPlayerClick=486 DOTA_UM_SpectatorPlayerClick value
     * @property {number} DOTA_UM_TutorialTipInfo=487 DOTA_UM_TutorialTipInfo value
     * @property {number} DOTA_UM_UnitEvent=488 DOTA_UM_UnitEvent value
     * @property {number} DOTA_UM_ParticleManager=489 DOTA_UM_ParticleManager value
     * @property {number} DOTA_UM_BotChat=490 DOTA_UM_BotChat value
     * @property {number} DOTA_UM_HudError=491 DOTA_UM_HudError value
     * @property {number} DOTA_UM_ItemPurchased=492 DOTA_UM_ItemPurchased value
     * @property {number} DOTA_UM_Ping=493 DOTA_UM_Ping value
     * @property {number} DOTA_UM_ItemFound=494 DOTA_UM_ItemFound value
     * @property {number} DOTA_UM_CharacterSpeakConcept=495 DOTA_UM_CharacterSpeakConcept value
     * @property {number} DOTA_UM_SwapVerify=496 DOTA_UM_SwapVerify value
     * @property {number} DOTA_UM_WorldLine=497 DOTA_UM_WorldLine value
     * @property {number} DOTA_UM_TournamentDrop=498 DOTA_UM_TournamentDrop value
     * @property {number} DOTA_UM_ItemAlert=499 DOTA_UM_ItemAlert value
     * @property {number} DOTA_UM_HalloweenDrops=500 DOTA_UM_HalloweenDrops value
     * @property {number} DOTA_UM_ChatWheel=501 DOTA_UM_ChatWheel value
     * @property {number} DOTA_UM_ReceivedXmasGift=502 DOTA_UM_ReceivedXmasGift value
     * @property {number} DOTA_UM_UpdateSharedContent=503 DOTA_UM_UpdateSharedContent value
     * @property {number} DOTA_UM_TutorialRequestExp=504 DOTA_UM_TutorialRequestExp value
     * @property {number} DOTA_UM_TutorialPingMinimap=505 DOTA_UM_TutorialPingMinimap value
     * @property {number} DOTA_UM_GamerulesStateChanged=506 DOTA_UM_GamerulesStateChanged value
     * @property {number} DOTA_UM_ShowSurvey=507 DOTA_UM_ShowSurvey value
     * @property {number} DOTA_UM_TutorialFade=508 DOTA_UM_TutorialFade value
     * @property {number} DOTA_UM_AddQuestLogEntry=509 DOTA_UM_AddQuestLogEntry value
     * @property {number} DOTA_UM_SendStatPopup=510 DOTA_UM_SendStatPopup value
     * @property {number} DOTA_UM_TutorialFinish=511 DOTA_UM_TutorialFinish value
     * @property {number} DOTA_UM_SendRoshanPopup=512 DOTA_UM_SendRoshanPopup value
     * @property {number} DOTA_UM_SendGenericToolTip=513 DOTA_UM_SendGenericToolTip value
     * @property {number} DOTA_UM_SendFinalGold=514 DOTA_UM_SendFinalGold value
     * @property {number} DOTA_UM_CustomMsg=515 DOTA_UM_CustomMsg value
     * @property {number} DOTA_UM_CoachHUDPing=516 DOTA_UM_CoachHUDPing value
     * @property {number} DOTA_UM_ClientLoadGridNav=517 DOTA_UM_ClientLoadGridNav value
     * @property {number} DOTA_UM_TE_Projectile=518 DOTA_UM_TE_Projectile value
     * @property {number} DOTA_UM_TE_ProjectileLoc=519 DOTA_UM_TE_ProjectileLoc value
     * @property {number} DOTA_UM_TE_DotaBloodImpact=520 DOTA_UM_TE_DotaBloodImpact value
     * @property {number} DOTA_UM_TE_UnitAnimation=521 DOTA_UM_TE_UnitAnimation value
     * @property {number} DOTA_UM_TE_UnitAnimationEnd=522 DOTA_UM_TE_UnitAnimationEnd value
     * @property {number} DOTA_UM_AbilityPing=523 DOTA_UM_AbilityPing value
     * @property {number} DOTA_UM_ShowGenericPopup=524 DOTA_UM_ShowGenericPopup value
     * @property {number} DOTA_UM_VoteStart=525 DOTA_UM_VoteStart value
     * @property {number} DOTA_UM_VoteUpdate=526 DOTA_UM_VoteUpdate value
     * @property {number} DOTA_UM_VoteEnd=527 DOTA_UM_VoteEnd value
     * @property {number} DOTA_UM_BoosterState=528 DOTA_UM_BoosterState value
     * @property {number} DOTA_UM_WillPurchaseAlert=529 DOTA_UM_WillPurchaseAlert value
     * @property {number} DOTA_UM_TutorialMinimapPosition=530 DOTA_UM_TutorialMinimapPosition value
     * @property {number} DOTA_UM_PlayerMMR=531 DOTA_UM_PlayerMMR value
     * @property {number} DOTA_UM_AbilitySteal=532 DOTA_UM_AbilitySteal value
     * @property {number} DOTA_UM_CourierKilledAlert=533 DOTA_UM_CourierKilledAlert value
     * @property {number} DOTA_UM_EnemyItemAlert=534 DOTA_UM_EnemyItemAlert value
     * @property {number} DOTA_UM_StatsMatchDetails=535 DOTA_UM_StatsMatchDetails value
     * @property {number} DOTA_UM_MiniTaunt=536 DOTA_UM_MiniTaunt value
     * @property {number} DOTA_UM_BuyBackStateAlert=537 DOTA_UM_BuyBackStateAlert value
     * @property {number} DOTA_UM_SpeechBubble=538 DOTA_UM_SpeechBubble value
     * @property {number} DOTA_UM_CustomHeaderMessage=539 DOTA_UM_CustomHeaderMessage value
     * @property {number} DOTA_UM_QuickBuyAlert=540 DOTA_UM_QuickBuyAlert value
     * @property {number} DOTA_UM_StatsHeroDetails=541 DOTA_UM_StatsHeroDetails value
     * @property {number} DOTA_UM_PredictionResult=542 DOTA_UM_PredictionResult value
     * @property {number} DOTA_UM_ModifierAlert=543 DOTA_UM_ModifierAlert value
     * @property {number} DOTA_UM_HPManaAlert=544 DOTA_UM_HPManaAlert value
     * @property {number} DOTA_UM_GlyphAlert=545 DOTA_UM_GlyphAlert value
     * @property {number} DOTA_UM_BeastChat=546 DOTA_UM_BeastChat value
     * @property {number} DOTA_UM_SpectatorPlayerUnitOrders=547 DOTA_UM_SpectatorPlayerUnitOrders value
     * @property {number} DOTA_UM_CustomHudElement_Create=548 DOTA_UM_CustomHudElement_Create value
     * @property {number} DOTA_UM_CustomHudElement_Modify=549 DOTA_UM_CustomHudElement_Modify value
     * @property {number} DOTA_UM_CustomHudElement_Destroy=550 DOTA_UM_CustomHudElement_Destroy value
     * @property {number} DOTA_UM_CompendiumState=551 DOTA_UM_CompendiumState value
     * @property {number} DOTA_UM_ProjectionAbility=552 DOTA_UM_ProjectionAbility value
     * @property {number} DOTA_UM_ProjectionEvent=553 DOTA_UM_ProjectionEvent value
     * @property {number} DOTA_UM_CombatLogDataHLTV=554 DOTA_UM_CombatLogDataHLTV value
     * @property {number} DOTA_UM_XPAlert=555 DOTA_UM_XPAlert value
     * @property {number} DOTA_UM_UpdateQuestProgress=556 DOTA_UM_UpdateQuestProgress value
     * @property {number} DOTA_UM_MatchMetadata=557 DOTA_UM_MatchMetadata value
     * @property {number} DOTA_UM_MatchDetails=558 DOTA_UM_MatchDetails value
     * @property {number} DOTA_UM_QuestStatus=559 DOTA_UM_QuestStatus value
     * @property {number} DOTA_UM_SuggestHeroPick=560 DOTA_UM_SuggestHeroPick value
     * @property {number} DOTA_UM_SuggestHeroRole=561 DOTA_UM_SuggestHeroRole value
     * @property {number} DOTA_UM_KillcamDamageTaken=562 DOTA_UM_KillcamDamageTaken value
     * @property {number} DOTA_UM_SelectPenaltyGold=563 DOTA_UM_SelectPenaltyGold value
     * @property {number} DOTA_UM_RollDiceResult=564 DOTA_UM_RollDiceResult value
     * @property {number} DOTA_UM_FlipCoinResult=565 DOTA_UM_FlipCoinResult value
     * @property {number} DOTA_UM_RequestItemSuggestions=566 DOTA_UM_RequestItemSuggestions value
     * @property {number} DOTA_UM_TeamCaptainChanged=567 DOTA_UM_TeamCaptainChanged value
     * @property {number} DOTA_UM_SendRoshanSpectatorPhase=568 DOTA_UM_SendRoshanSpectatorPhase value
     * @property {number} DOTA_UM_ChatWheelCooldown=569 DOTA_UM_ChatWheelCooldown value
     * @property {number} DOTA_UM_DismissAllStatPopups=570 DOTA_UM_DismissAllStatPopups value
     * @property {number} DOTA_UM_TE_DestroyProjectile=571 DOTA_UM_TE_DestroyProjectile value
     * @property {number} DOTA_UM_HeroRelicProgress=572 DOTA_UM_HeroRelicProgress value
     * @property {number} DOTA_UM_AbilityDraftRequestAbility=573 DOTA_UM_AbilityDraftRequestAbility value
     * @property {number} DOTA_UM_ItemSold=574 DOTA_UM_ItemSold value
     * @property {number} DOTA_UM_DamageReport=575 DOTA_UM_DamageReport value
     * @property {number} DOTA_UM_SalutePlayer=576 DOTA_UM_SalutePlayer value
     * @property {number} DOTA_UM_TipAlert=577 DOTA_UM_TipAlert value
     * @property {number} DOTA_UM_ReplaceQueryUnit=578 DOTA_UM_ReplaceQueryUnit value
     * @property {number} DOTA_UM_EmptyTeleportAlert=579 DOTA_UM_EmptyTeleportAlert value
     * @property {number} DOTA_UM_MarsArenaOfBloodAttack=580 DOTA_UM_MarsArenaOfBloodAttack value
     * @property {number} DOTA_UM_ESArcanaCombo=581 DOTA_UM_ESArcanaCombo value
     * @property {number} DOTA_UM_ESArcanaComboSummary=582 DOTA_UM_ESArcanaComboSummary value
     * @property {number} DOTA_UM_HighFiveLeftHanging=583 DOTA_UM_HighFiveLeftHanging value
     * @property {number} DOTA_UM_HighFiveCompleted=584 DOTA_UM_HighFiveCompleted value
     * @property {number} DOTA_UM_ShovelUnearth=585 DOTA_UM_ShovelUnearth value
     * @property {number} DOTA_EM_InvokerSpellCast=586 DOTA_EM_InvokerSpellCast value
     * @property {number} DOTA_UM_RadarAlert=587 DOTA_UM_RadarAlert value
     * @property {number} DOTA_UM_AllStarEvent=588 DOTA_UM_AllStarEvent value
     * @property {number} DOTA_UM_TalentTreeAlert=589 DOTA_UM_TalentTreeAlert value
     * @property {number} DOTA_UM_QueuedOrderRemoved=590 DOTA_UM_QueuedOrderRemoved value
     * @property {number} DOTA_UM_DebugChallenge=591 DOTA_UM_DebugChallenge value
     * @property {number} DOTA_UM_OMArcanaCombo=592 DOTA_UM_OMArcanaCombo value
     * @property {number} DOTA_UM_FoundNeutralItem=593 DOTA_UM_FoundNeutralItem value
     * @property {number} DOTA_UM_OutpostCaptured=594 DOTA_UM_OutpostCaptured value
     * @property {number} DOTA_UM_OutpostGrantedXP=595 DOTA_UM_OutpostGrantedXP value
     * @property {number} DOTA_UM_MoveCameraToUnit=596 DOTA_UM_MoveCameraToUnit value
     * @property {number} DOTA_UM_PauseMinigameData=597 DOTA_UM_PauseMinigameData value
     * @property {number} DOTA_UM_VersusScene_PlayerBehavior=598 DOTA_UM_VersusScene_PlayerBehavior value
     * @property {number} DOTA_UM_QoP_ArcanaSummary=600 DOTA_UM_QoP_ArcanaSummary value
     * @property {number} DOTA_UM_HotPotato_Created=601 DOTA_UM_HotPotato_Created value
     * @property {number} DOTA_UM_HotPotato_Exploded=602 DOTA_UM_HotPotato_Exploded value
     * @property {number} DOTA_UM_WK_Arcana_Progress=603 DOTA_UM_WK_Arcana_Progress value
     * @property {number} DOTA_UM_GuildChallenge_Progress=604 DOTA_UM_GuildChallenge_Progress value
     * @property {number} DOTA_UM_WRArcanaProgress=605 DOTA_UM_WRArcanaProgress value
     * @property {number} DOTA_UM_WRArcanaSummary=606 DOTA_UM_WRArcanaSummary value
     * @property {number} DOTA_UM_EmptyItemSlotAlert=607 DOTA_UM_EmptyItemSlotAlert value
     */
    $root.EDotaUserMessages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[464] = "DOTA_UM_AddUnitToSelection"] = 464;
        values[valuesById[465] = "DOTA_UM_AIDebugLine"] = 465;
        values[valuesById[466] = "DOTA_UM_ChatEvent"] = 466;
        values[valuesById[467] = "DOTA_UM_CombatHeroPositions"] = 467;
        values[valuesById[468] = "DOTA_UM_CombatLogData"] = 468;
        values[valuesById[470] = "DOTA_UM_CombatLogBulkData"] = 470;
        values[valuesById[471] = "DOTA_UM_CreateLinearProjectile"] = 471;
        values[valuesById[472] = "DOTA_UM_DestroyLinearProjectile"] = 472;
        values[valuesById[473] = "DOTA_UM_DodgeTrackingProjectiles"] = 473;
        values[valuesById[474] = "DOTA_UM_GlobalLightColor"] = 474;
        values[valuesById[475] = "DOTA_UM_GlobalLightDirection"] = 475;
        values[valuesById[476] = "DOTA_UM_InvalidCommand"] = 476;
        values[valuesById[477] = "DOTA_UM_LocationPing"] = 477;
        values[valuesById[478] = "DOTA_UM_MapLine"] = 478;
        values[valuesById[479] = "DOTA_UM_MiniKillCamInfo"] = 479;
        values[valuesById[480] = "DOTA_UM_MinimapDebugPoint"] = 480;
        values[valuesById[481] = "DOTA_UM_MinimapEvent"] = 481;
        values[valuesById[482] = "DOTA_UM_NevermoreRequiem"] = 482;
        values[valuesById[483] = "DOTA_UM_OverheadEvent"] = 483;
        values[valuesById[484] = "DOTA_UM_SetNextAutobuyItem"] = 484;
        values[valuesById[485] = "DOTA_UM_SharedCooldown"] = 485;
        values[valuesById[486] = "DOTA_UM_SpectatorPlayerClick"] = 486;
        values[valuesById[487] = "DOTA_UM_TutorialTipInfo"] = 487;
        values[valuesById[488] = "DOTA_UM_UnitEvent"] = 488;
        values[valuesById[489] = "DOTA_UM_ParticleManager"] = 489;
        values[valuesById[490] = "DOTA_UM_BotChat"] = 490;
        values[valuesById[491] = "DOTA_UM_HudError"] = 491;
        values[valuesById[492] = "DOTA_UM_ItemPurchased"] = 492;
        values[valuesById[493] = "DOTA_UM_Ping"] = 493;
        values[valuesById[494] = "DOTA_UM_ItemFound"] = 494;
        values[valuesById[495] = "DOTA_UM_CharacterSpeakConcept"] = 495;
        values[valuesById[496] = "DOTA_UM_SwapVerify"] = 496;
        values[valuesById[497] = "DOTA_UM_WorldLine"] = 497;
        values[valuesById[498] = "DOTA_UM_TournamentDrop"] = 498;
        values[valuesById[499] = "DOTA_UM_ItemAlert"] = 499;
        values[valuesById[500] = "DOTA_UM_HalloweenDrops"] = 500;
        values[valuesById[501] = "DOTA_UM_ChatWheel"] = 501;
        values[valuesById[502] = "DOTA_UM_ReceivedXmasGift"] = 502;
        values[valuesById[503] = "DOTA_UM_UpdateSharedContent"] = 503;
        values[valuesById[504] = "DOTA_UM_TutorialRequestExp"] = 504;
        values[valuesById[505] = "DOTA_UM_TutorialPingMinimap"] = 505;
        values[valuesById[506] = "DOTA_UM_GamerulesStateChanged"] = 506;
        values[valuesById[507] = "DOTA_UM_ShowSurvey"] = 507;
        values[valuesById[508] = "DOTA_UM_TutorialFade"] = 508;
        values[valuesById[509] = "DOTA_UM_AddQuestLogEntry"] = 509;
        values[valuesById[510] = "DOTA_UM_SendStatPopup"] = 510;
        values[valuesById[511] = "DOTA_UM_TutorialFinish"] = 511;
        values[valuesById[512] = "DOTA_UM_SendRoshanPopup"] = 512;
        values[valuesById[513] = "DOTA_UM_SendGenericToolTip"] = 513;
        values[valuesById[514] = "DOTA_UM_SendFinalGold"] = 514;
        values[valuesById[515] = "DOTA_UM_CustomMsg"] = 515;
        values[valuesById[516] = "DOTA_UM_CoachHUDPing"] = 516;
        values[valuesById[517] = "DOTA_UM_ClientLoadGridNav"] = 517;
        values[valuesById[518] = "DOTA_UM_TE_Projectile"] = 518;
        values[valuesById[519] = "DOTA_UM_TE_ProjectileLoc"] = 519;
        values[valuesById[520] = "DOTA_UM_TE_DotaBloodImpact"] = 520;
        values[valuesById[521] = "DOTA_UM_TE_UnitAnimation"] = 521;
        values[valuesById[522] = "DOTA_UM_TE_UnitAnimationEnd"] = 522;
        values[valuesById[523] = "DOTA_UM_AbilityPing"] = 523;
        values[valuesById[524] = "DOTA_UM_ShowGenericPopup"] = 524;
        values[valuesById[525] = "DOTA_UM_VoteStart"] = 525;
        values[valuesById[526] = "DOTA_UM_VoteUpdate"] = 526;
        values[valuesById[527] = "DOTA_UM_VoteEnd"] = 527;
        values[valuesById[528] = "DOTA_UM_BoosterState"] = 528;
        values[valuesById[529] = "DOTA_UM_WillPurchaseAlert"] = 529;
        values[valuesById[530] = "DOTA_UM_TutorialMinimapPosition"] = 530;
        values[valuesById[531] = "DOTA_UM_PlayerMMR"] = 531;
        values[valuesById[532] = "DOTA_UM_AbilitySteal"] = 532;
        values[valuesById[533] = "DOTA_UM_CourierKilledAlert"] = 533;
        values[valuesById[534] = "DOTA_UM_EnemyItemAlert"] = 534;
        values[valuesById[535] = "DOTA_UM_StatsMatchDetails"] = 535;
        values[valuesById[536] = "DOTA_UM_MiniTaunt"] = 536;
        values[valuesById[537] = "DOTA_UM_BuyBackStateAlert"] = 537;
        values[valuesById[538] = "DOTA_UM_SpeechBubble"] = 538;
        values[valuesById[539] = "DOTA_UM_CustomHeaderMessage"] = 539;
        values[valuesById[540] = "DOTA_UM_QuickBuyAlert"] = 540;
        values[valuesById[541] = "DOTA_UM_StatsHeroDetails"] = 541;
        values[valuesById[542] = "DOTA_UM_PredictionResult"] = 542;
        values[valuesById[543] = "DOTA_UM_ModifierAlert"] = 543;
        values[valuesById[544] = "DOTA_UM_HPManaAlert"] = 544;
        values[valuesById[545] = "DOTA_UM_GlyphAlert"] = 545;
        values[valuesById[546] = "DOTA_UM_BeastChat"] = 546;
        values[valuesById[547] = "DOTA_UM_SpectatorPlayerUnitOrders"] = 547;
        values[valuesById[548] = "DOTA_UM_CustomHudElement_Create"] = 548;
        values[valuesById[549] = "DOTA_UM_CustomHudElement_Modify"] = 549;
        values[valuesById[550] = "DOTA_UM_CustomHudElement_Destroy"] = 550;
        values[valuesById[551] = "DOTA_UM_CompendiumState"] = 551;
        values[valuesById[552] = "DOTA_UM_ProjectionAbility"] = 552;
        values[valuesById[553] = "DOTA_UM_ProjectionEvent"] = 553;
        values[valuesById[554] = "DOTA_UM_CombatLogDataHLTV"] = 554;
        values[valuesById[555] = "DOTA_UM_XPAlert"] = 555;
        values[valuesById[556] = "DOTA_UM_UpdateQuestProgress"] = 556;
        values[valuesById[557] = "DOTA_UM_MatchMetadata"] = 557;
        values[valuesById[558] = "DOTA_UM_MatchDetails"] = 558;
        values[valuesById[559] = "DOTA_UM_QuestStatus"] = 559;
        values[valuesById[560] = "DOTA_UM_SuggestHeroPick"] = 560;
        values[valuesById[561] = "DOTA_UM_SuggestHeroRole"] = 561;
        values[valuesById[562] = "DOTA_UM_KillcamDamageTaken"] = 562;
        values[valuesById[563] = "DOTA_UM_SelectPenaltyGold"] = 563;
        values[valuesById[564] = "DOTA_UM_RollDiceResult"] = 564;
        values[valuesById[565] = "DOTA_UM_FlipCoinResult"] = 565;
        values[valuesById[566] = "DOTA_UM_RequestItemSuggestions"] = 566;
        values[valuesById[567] = "DOTA_UM_TeamCaptainChanged"] = 567;
        values[valuesById[568] = "DOTA_UM_SendRoshanSpectatorPhase"] = 568;
        values[valuesById[569] = "DOTA_UM_ChatWheelCooldown"] = 569;
        values[valuesById[570] = "DOTA_UM_DismissAllStatPopups"] = 570;
        values[valuesById[571] = "DOTA_UM_TE_DestroyProjectile"] = 571;
        values[valuesById[572] = "DOTA_UM_HeroRelicProgress"] = 572;
        values[valuesById[573] = "DOTA_UM_AbilityDraftRequestAbility"] = 573;
        values[valuesById[574] = "DOTA_UM_ItemSold"] = 574;
        values[valuesById[575] = "DOTA_UM_DamageReport"] = 575;
        values[valuesById[576] = "DOTA_UM_SalutePlayer"] = 576;
        values[valuesById[577] = "DOTA_UM_TipAlert"] = 577;
        values[valuesById[578] = "DOTA_UM_ReplaceQueryUnit"] = 578;
        values[valuesById[579] = "DOTA_UM_EmptyTeleportAlert"] = 579;
        values[valuesById[580] = "DOTA_UM_MarsArenaOfBloodAttack"] = 580;
        values[valuesById[581] = "DOTA_UM_ESArcanaCombo"] = 581;
        values[valuesById[582] = "DOTA_UM_ESArcanaComboSummary"] = 582;
        values[valuesById[583] = "DOTA_UM_HighFiveLeftHanging"] = 583;
        values[valuesById[584] = "DOTA_UM_HighFiveCompleted"] = 584;
        values[valuesById[585] = "DOTA_UM_ShovelUnearth"] = 585;
        values[valuesById[586] = "DOTA_EM_InvokerSpellCast"] = 586;
        values[valuesById[587] = "DOTA_UM_RadarAlert"] = 587;
        values[valuesById[588] = "DOTA_UM_AllStarEvent"] = 588;
        values[valuesById[589] = "DOTA_UM_TalentTreeAlert"] = 589;
        values[valuesById[590] = "DOTA_UM_QueuedOrderRemoved"] = 590;
        values[valuesById[591] = "DOTA_UM_DebugChallenge"] = 591;
        values[valuesById[592] = "DOTA_UM_OMArcanaCombo"] = 592;
        values[valuesById[593] = "DOTA_UM_FoundNeutralItem"] = 593;
        values[valuesById[594] = "DOTA_UM_OutpostCaptured"] = 594;
        values[valuesById[595] = "DOTA_UM_OutpostGrantedXP"] = 595;
        values[valuesById[596] = "DOTA_UM_MoveCameraToUnit"] = 596;
        values[valuesById[597] = "DOTA_UM_PauseMinigameData"] = 597;
        values[valuesById[598] = "DOTA_UM_VersusScene_PlayerBehavior"] = 598;
        values[valuesById[600] = "DOTA_UM_QoP_ArcanaSummary"] = 600;
        values[valuesById[601] = "DOTA_UM_HotPotato_Created"] = 601;
        values[valuesById[602] = "DOTA_UM_HotPotato_Exploded"] = 602;
        values[valuesById[603] = "DOTA_UM_WK_Arcana_Progress"] = 603;
        values[valuesById[604] = "DOTA_UM_GuildChallenge_Progress"] = 604;
        values[valuesById[605] = "DOTA_UM_WRArcanaProgress"] = 605;
        values[valuesById[606] = "DOTA_UM_WRArcanaSummary"] = 606;
        values[valuesById[607] = "DOTA_UM_EmptyItemSlotAlert"] = 607;
        return values;
    })();
    
    /**
     * DOTA_CHAT_MESSAGE enum.
     * @exports DOTA_CHAT_MESSAGE
     * @enum {number}
     * @property {number} CHAT_MESSAGE_INVALID=-1 CHAT_MESSAGE_INVALID value
     * @property {number} CHAT_MESSAGE_HERO_KILL=0 CHAT_MESSAGE_HERO_KILL value
     * @property {number} CHAT_MESSAGE_HERO_DENY=1 CHAT_MESSAGE_HERO_DENY value
     * @property {number} CHAT_MESSAGE_BARRACKS_KILL=2 CHAT_MESSAGE_BARRACKS_KILL value
     * @property {number} CHAT_MESSAGE_TOWER_KILL=3 CHAT_MESSAGE_TOWER_KILL value
     * @property {number} CHAT_MESSAGE_TOWER_DENY=4 CHAT_MESSAGE_TOWER_DENY value
     * @property {number} CHAT_MESSAGE_FIRSTBLOOD=5 CHAT_MESSAGE_FIRSTBLOOD value
     * @property {number} CHAT_MESSAGE_STREAK_KILL=6 CHAT_MESSAGE_STREAK_KILL value
     * @property {number} CHAT_MESSAGE_BUYBACK=7 CHAT_MESSAGE_BUYBACK value
     * @property {number} CHAT_MESSAGE_AEGIS=8 CHAT_MESSAGE_AEGIS value
     * @property {number} CHAT_MESSAGE_ROSHAN_KILL=9 CHAT_MESSAGE_ROSHAN_KILL value
     * @property {number} CHAT_MESSAGE_COURIER_LOST=10 CHAT_MESSAGE_COURIER_LOST value
     * @property {number} CHAT_MESSAGE_COURIER_RESPAWNED=11 CHAT_MESSAGE_COURIER_RESPAWNED value
     * @property {number} CHAT_MESSAGE_GLYPH_USED=12 CHAT_MESSAGE_GLYPH_USED value
     * @property {number} CHAT_MESSAGE_ITEM_PURCHASE=13 CHAT_MESSAGE_ITEM_PURCHASE value
     * @property {number} CHAT_MESSAGE_CONNECT=14 CHAT_MESSAGE_CONNECT value
     * @property {number} CHAT_MESSAGE_DISCONNECT=15 CHAT_MESSAGE_DISCONNECT value
     * @property {number} CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT=16 CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT value
     * @property {number} CHAT_MESSAGE_DISCONNECT_TIME_REMAINING=17 CHAT_MESSAGE_DISCONNECT_TIME_REMAINING value
     * @property {number} CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL=18 CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL value
     * @property {number} CHAT_MESSAGE_RECONNECT=19 CHAT_MESSAGE_RECONNECT value
     * @property {number} CHAT_MESSAGE_PLAYER_LEFT=20 CHAT_MESSAGE_PLAYER_LEFT value
     * @property {number} CHAT_MESSAGE_SAFE_TO_LEAVE=21 CHAT_MESSAGE_SAFE_TO_LEAVE value
     * @property {number} CHAT_MESSAGE_RUNE_PICKUP=22 CHAT_MESSAGE_RUNE_PICKUP value
     * @property {number} CHAT_MESSAGE_RUNE_BOTTLE=23 CHAT_MESSAGE_RUNE_BOTTLE value
     * @property {number} CHAT_MESSAGE_INTHEBAG=24 CHAT_MESSAGE_INTHEBAG value
     * @property {number} CHAT_MESSAGE_SECRETSHOP=25 CHAT_MESSAGE_SECRETSHOP value
     * @property {number} CHAT_MESSAGE_ITEM_AUTOPURCHASED=26 CHAT_MESSAGE_ITEM_AUTOPURCHASED value
     * @property {number} CHAT_MESSAGE_ITEMS_COMBINED=27 CHAT_MESSAGE_ITEMS_COMBINED value
     * @property {number} CHAT_MESSAGE_SUPER_CREEPS=28 CHAT_MESSAGE_SUPER_CREEPS value
     * @property {number} CHAT_MESSAGE_CANT_USE_ACTION_ITEM=29 CHAT_MESSAGE_CANT_USE_ACTION_ITEM value
     * @property {number} CHAT_MESSAGE_CANTPAUSE=31 CHAT_MESSAGE_CANTPAUSE value
     * @property {number} CHAT_MESSAGE_NOPAUSESLEFT=32 CHAT_MESSAGE_NOPAUSESLEFT value
     * @property {number} CHAT_MESSAGE_CANTPAUSEYET=33 CHAT_MESSAGE_CANTPAUSEYET value
     * @property {number} CHAT_MESSAGE_PAUSED=34 CHAT_MESSAGE_PAUSED value
     * @property {number} CHAT_MESSAGE_UNPAUSE_COUNTDOWN=35 CHAT_MESSAGE_UNPAUSE_COUNTDOWN value
     * @property {number} CHAT_MESSAGE_UNPAUSED=36 CHAT_MESSAGE_UNPAUSED value
     * @property {number} CHAT_MESSAGE_AUTO_UNPAUSED=37 CHAT_MESSAGE_AUTO_UNPAUSED value
     * @property {number} CHAT_MESSAGE_YOUPAUSED=38 CHAT_MESSAGE_YOUPAUSED value
     * @property {number} CHAT_MESSAGE_CANTUNPAUSETEAM=39 CHAT_MESSAGE_CANTUNPAUSETEAM value
     * @property {number} CHAT_MESSAGE_VOICE_TEXT_BANNED=41 CHAT_MESSAGE_VOICE_TEXT_BANNED value
     * @property {number} CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME=42 CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME value
     * @property {number} CHAT_MESSAGE_REPORT_REMINDER=43 CHAT_MESSAGE_REPORT_REMINDER value
     * @property {number} CHAT_MESSAGE_ECON_ITEM=44 CHAT_MESSAGE_ECON_ITEM value
     * @property {number} CHAT_MESSAGE_TAUNT=45 CHAT_MESSAGE_TAUNT value
     * @property {number} CHAT_MESSAGE_RANDOM=46 CHAT_MESSAGE_RANDOM value
     * @property {number} CHAT_MESSAGE_RD_TURN=47 CHAT_MESSAGE_RD_TURN value
     * @property {number} CHAT_MESSAGE_DROP_RATE_BONUS=49 CHAT_MESSAGE_DROP_RATE_BONUS value
     * @property {number} CHAT_MESSAGE_NO_BATTLE_POINTS=50 CHAT_MESSAGE_NO_BATTLE_POINTS value
     * @property {number} CHAT_MESSAGE_DENIED_AEGIS=51 CHAT_MESSAGE_DENIED_AEGIS value
     * @property {number} CHAT_MESSAGE_INFORMATIONAL=52 CHAT_MESSAGE_INFORMATIONAL value
     * @property {number} CHAT_MESSAGE_AEGIS_STOLEN=53 CHAT_MESSAGE_AEGIS_STOLEN value
     * @property {number} CHAT_MESSAGE_ROSHAN_CANDY=54 CHAT_MESSAGE_ROSHAN_CANDY value
     * @property {number} CHAT_MESSAGE_ITEM_GIFTED=55 CHAT_MESSAGE_ITEM_GIFTED value
     * @property {number} CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL=56 CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL value
     * @property {number} CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED=57 CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED value
     * @property {number} CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED=58 CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED value
     * @property {number} CHAT_MESSAGE_HOLDOUT_WALL_FINISHED=59 CHAT_MESSAGE_HOLDOUT_WALL_FINISHED value
     * @property {number} CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO=62 CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO value
     * @property {number} CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION=63 CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION value
     * @property {number} CHAT_MESSAGE_DISCONNECT_LIMITED_HERO=64 CHAT_MESSAGE_DISCONNECT_LIMITED_HERO value
     * @property {number} CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION=65 CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION value
     * @property {number} CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS=66 CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS value
     * @property {number} CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE=67 CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE value
     * @property {number} CHAT_MESSAGE_PLAYER_LEFT_AFK=73 CHAT_MESSAGE_PLAYER_LEFT_AFK value
     * @property {number} CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG=74 CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG value
     * @property {number} CHAT_MESSAGE_PLAYER_ABANDONED=75 CHAT_MESSAGE_PLAYER_ABANDONED value
     * @property {number} CHAT_MESSAGE_PLAYER_ABANDONED_AFK=76 CHAT_MESSAGE_PLAYER_ABANDONED_AFK value
     * @property {number} CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG=77 CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG value
     * @property {number} CHAT_MESSAGE_WILL_NOT_BE_SCORED=78 CHAT_MESSAGE_WILL_NOT_BE_SCORED value
     * @property {number} CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED=79 CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED value
     * @property {number} CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK=80 CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK value
     * @property {number} CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED=81 CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED value
     * @property {number} CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON=82 CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON value
     * @property {number} CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS=83 CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS value
     * @property {number} CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY=84 CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY value
     * @property {number} CHAT_MESSAGE_COMPENDIUM_LEVEL=85 CHAT_MESSAGE_COMPENDIUM_LEVEL value
     * @property {number} CHAT_MESSAGE_VICTORY_PREDICTION_STREAK=86 CHAT_MESSAGE_VICTORY_PREDICTION_STREAK value
     * @property {number} CHAT_MESSAGE_ASSASSIN_ANNOUNCE=87 CHAT_MESSAGE_ASSASSIN_ANNOUNCE value
     * @property {number} CHAT_MESSAGE_ASSASSIN_SUCCESS=88 CHAT_MESSAGE_ASSASSIN_SUCCESS value
     * @property {number} CHAT_MESSAGE_ASSASSIN_DENIED=89 CHAT_MESSAGE_ASSASSIN_DENIED value
     * @property {number} CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM=90 CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM value
     * @property {number} CHAT_MESSAGE_EFFIGY_KILL=91 CHAT_MESSAGE_EFFIGY_KILL value
     * @property {number} CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW=92 CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW value
     * @property {number} CHAT_MESSAGE_YEAR_BEAST_KILLED=93 CHAT_MESSAGE_YEAR_BEAST_KILLED value
     * @property {number} CHAT_MESSAGE_PAUSE_COUNTDOWN=94 CHAT_MESSAGE_PAUSE_COUNTDOWN value
     * @property {number} CHAT_MESSAGE_COINS_WAGERED=95 CHAT_MESSAGE_COINS_WAGERED value
     * @property {number} CHAT_MESSAGE_HERO_NOMINATED_BAN=96 CHAT_MESSAGE_HERO_NOMINATED_BAN value
     * @property {number} CHAT_MESSAGE_HERO_BANNED=97 CHAT_MESSAGE_HERO_BANNED value
     * @property {number} CHAT_MESSAGE_HERO_BAN_COUNT=98 CHAT_MESSAGE_HERO_BAN_COUNT value
     * @property {number} CHAT_MESSAGE_RIVER_PAINTED=99 CHAT_MESSAGE_RIVER_PAINTED value
     * @property {number} CHAT_MESSAGE_SCAN_USED=100 CHAT_MESSAGE_SCAN_USED value
     * @property {number} CHAT_MESSAGE_SHRINE_KILLED=101 CHAT_MESSAGE_SHRINE_KILLED value
     * @property {number} CHAT_MESSAGE_WAGER_TOKEN_SPENT=102 CHAT_MESSAGE_WAGER_TOKEN_SPENT value
     * @property {number} CHAT_MESSAGE_RANK_WAGER=103 CHAT_MESSAGE_RANK_WAGER value
     * @property {number} CHAT_MESSAGE_NEW_PLAYER_REMINDER=104 CHAT_MESSAGE_NEW_PLAYER_REMINDER value
     * @property {number} CHAT_MESSAGE_OBSERVER_WARD_KILLED=105 CHAT_MESSAGE_OBSERVER_WARD_KILLED value
     * @property {number} CHAT_MESSAGE_SENTRY_WARD_KILLED=106 CHAT_MESSAGE_SENTRY_WARD_KILLED value
     * @property {number} CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH=107 CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH value
     * @property {number} CHAT_MESSAGE_HERO_CHOICE_INVALID=108 CHAT_MESSAGE_HERO_CHOICE_INVALID value
     * @property {number} CHAT_MESSAGE_BOUNTY=109 CHAT_MESSAGE_BOUNTY value
     * @property {number} CHAT_MESSAGE_ABILITY_DRAFT_START=110 CHAT_MESSAGE_ABILITY_DRAFT_START value
     */
    $root.DOTA_CHAT_MESSAGE = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[-1] = "CHAT_MESSAGE_INVALID"] = -1;
        values[valuesById[0] = "CHAT_MESSAGE_HERO_KILL"] = 0;
        values[valuesById[1] = "CHAT_MESSAGE_HERO_DENY"] = 1;
        values[valuesById[2] = "CHAT_MESSAGE_BARRACKS_KILL"] = 2;
        values[valuesById[3] = "CHAT_MESSAGE_TOWER_KILL"] = 3;
        values[valuesById[4] = "CHAT_MESSAGE_TOWER_DENY"] = 4;
        values[valuesById[5] = "CHAT_MESSAGE_FIRSTBLOOD"] = 5;
        values[valuesById[6] = "CHAT_MESSAGE_STREAK_KILL"] = 6;
        values[valuesById[7] = "CHAT_MESSAGE_BUYBACK"] = 7;
        values[valuesById[8] = "CHAT_MESSAGE_AEGIS"] = 8;
        values[valuesById[9] = "CHAT_MESSAGE_ROSHAN_KILL"] = 9;
        values[valuesById[10] = "CHAT_MESSAGE_COURIER_LOST"] = 10;
        values[valuesById[11] = "CHAT_MESSAGE_COURIER_RESPAWNED"] = 11;
        values[valuesById[12] = "CHAT_MESSAGE_GLYPH_USED"] = 12;
        values[valuesById[13] = "CHAT_MESSAGE_ITEM_PURCHASE"] = 13;
        values[valuesById[14] = "CHAT_MESSAGE_CONNECT"] = 14;
        values[valuesById[15] = "CHAT_MESSAGE_DISCONNECT"] = 15;
        values[valuesById[16] = "CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT"] = 16;
        values[valuesById[17] = "CHAT_MESSAGE_DISCONNECT_TIME_REMAINING"] = 17;
        values[valuesById[18] = "CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL"] = 18;
        values[valuesById[19] = "CHAT_MESSAGE_RECONNECT"] = 19;
        values[valuesById[20] = "CHAT_MESSAGE_PLAYER_LEFT"] = 20;
        values[valuesById[21] = "CHAT_MESSAGE_SAFE_TO_LEAVE"] = 21;
        values[valuesById[22] = "CHAT_MESSAGE_RUNE_PICKUP"] = 22;
        values[valuesById[23] = "CHAT_MESSAGE_RUNE_BOTTLE"] = 23;
        values[valuesById[24] = "CHAT_MESSAGE_INTHEBAG"] = 24;
        values[valuesById[25] = "CHAT_MESSAGE_SECRETSHOP"] = 25;
        values[valuesById[26] = "CHAT_MESSAGE_ITEM_AUTOPURCHASED"] = 26;
        values[valuesById[27] = "CHAT_MESSAGE_ITEMS_COMBINED"] = 27;
        values[valuesById[28] = "CHAT_MESSAGE_SUPER_CREEPS"] = 28;
        values[valuesById[29] = "CHAT_MESSAGE_CANT_USE_ACTION_ITEM"] = 29;
        values[valuesById[31] = "CHAT_MESSAGE_CANTPAUSE"] = 31;
        values[valuesById[32] = "CHAT_MESSAGE_NOPAUSESLEFT"] = 32;
        values[valuesById[33] = "CHAT_MESSAGE_CANTPAUSEYET"] = 33;
        values[valuesById[34] = "CHAT_MESSAGE_PAUSED"] = 34;
        values[valuesById[35] = "CHAT_MESSAGE_UNPAUSE_COUNTDOWN"] = 35;
        values[valuesById[36] = "CHAT_MESSAGE_UNPAUSED"] = 36;
        values[valuesById[37] = "CHAT_MESSAGE_AUTO_UNPAUSED"] = 37;
        values[valuesById[38] = "CHAT_MESSAGE_YOUPAUSED"] = 38;
        values[valuesById[39] = "CHAT_MESSAGE_CANTUNPAUSETEAM"] = 39;
        values[valuesById[41] = "CHAT_MESSAGE_VOICE_TEXT_BANNED"] = 41;
        values[valuesById[42] = "CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME"] = 42;
        values[valuesById[43] = "CHAT_MESSAGE_REPORT_REMINDER"] = 43;
        values[valuesById[44] = "CHAT_MESSAGE_ECON_ITEM"] = 44;
        values[valuesById[45] = "CHAT_MESSAGE_TAUNT"] = 45;
        values[valuesById[46] = "CHAT_MESSAGE_RANDOM"] = 46;
        values[valuesById[47] = "CHAT_MESSAGE_RD_TURN"] = 47;
        values[valuesById[49] = "CHAT_MESSAGE_DROP_RATE_BONUS"] = 49;
        values[valuesById[50] = "CHAT_MESSAGE_NO_BATTLE_POINTS"] = 50;
        values[valuesById[51] = "CHAT_MESSAGE_DENIED_AEGIS"] = 51;
        values[valuesById[52] = "CHAT_MESSAGE_INFORMATIONAL"] = 52;
        values[valuesById[53] = "CHAT_MESSAGE_AEGIS_STOLEN"] = 53;
        values[valuesById[54] = "CHAT_MESSAGE_ROSHAN_CANDY"] = 54;
        values[valuesById[55] = "CHAT_MESSAGE_ITEM_GIFTED"] = 55;
        values[valuesById[56] = "CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL"] = 56;
        values[valuesById[57] = "CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED"] = 57;
        values[valuesById[58] = "CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED"] = 58;
        values[valuesById[59] = "CHAT_MESSAGE_HOLDOUT_WALL_FINISHED"] = 59;
        values[valuesById[62] = "CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO"] = 62;
        values[valuesById[63] = "CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION"] = 63;
        values[valuesById[64] = "CHAT_MESSAGE_DISCONNECT_LIMITED_HERO"] = 64;
        values[valuesById[65] = "CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION"] = 65;
        values[valuesById[66] = "CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS"] = 66;
        values[valuesById[67] = "CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE"] = 67;
        values[valuesById[73] = "CHAT_MESSAGE_PLAYER_LEFT_AFK"] = 73;
        values[valuesById[74] = "CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG"] = 74;
        values[valuesById[75] = "CHAT_MESSAGE_PLAYER_ABANDONED"] = 75;
        values[valuesById[76] = "CHAT_MESSAGE_PLAYER_ABANDONED_AFK"] = 76;
        values[valuesById[77] = "CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG"] = 77;
        values[valuesById[78] = "CHAT_MESSAGE_WILL_NOT_BE_SCORED"] = 78;
        values[valuesById[79] = "CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED"] = 79;
        values[valuesById[80] = "CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK"] = 80;
        values[valuesById[81] = "CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED"] = 81;
        values[valuesById[82] = "CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON"] = 82;
        values[valuesById[83] = "CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS"] = 83;
        values[valuesById[84] = "CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY"] = 84;
        values[valuesById[85] = "CHAT_MESSAGE_COMPENDIUM_LEVEL"] = 85;
        values[valuesById[86] = "CHAT_MESSAGE_VICTORY_PREDICTION_STREAK"] = 86;
        values[valuesById[87] = "CHAT_MESSAGE_ASSASSIN_ANNOUNCE"] = 87;
        values[valuesById[88] = "CHAT_MESSAGE_ASSASSIN_SUCCESS"] = 88;
        values[valuesById[89] = "CHAT_MESSAGE_ASSASSIN_DENIED"] = 89;
        values[valuesById[90] = "CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM"] = 90;
        values[valuesById[91] = "CHAT_MESSAGE_EFFIGY_KILL"] = 91;
        values[valuesById[92] = "CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW"] = 92;
        values[valuesById[93] = "CHAT_MESSAGE_YEAR_BEAST_KILLED"] = 93;
        values[valuesById[94] = "CHAT_MESSAGE_PAUSE_COUNTDOWN"] = 94;
        values[valuesById[95] = "CHAT_MESSAGE_COINS_WAGERED"] = 95;
        values[valuesById[96] = "CHAT_MESSAGE_HERO_NOMINATED_BAN"] = 96;
        values[valuesById[97] = "CHAT_MESSAGE_HERO_BANNED"] = 97;
        values[valuesById[98] = "CHAT_MESSAGE_HERO_BAN_COUNT"] = 98;
        values[valuesById[99] = "CHAT_MESSAGE_RIVER_PAINTED"] = 99;
        values[valuesById[100] = "CHAT_MESSAGE_SCAN_USED"] = 100;
        values[valuesById[101] = "CHAT_MESSAGE_SHRINE_KILLED"] = 101;
        values[valuesById[102] = "CHAT_MESSAGE_WAGER_TOKEN_SPENT"] = 102;
        values[valuesById[103] = "CHAT_MESSAGE_RANK_WAGER"] = 103;
        values[valuesById[104] = "CHAT_MESSAGE_NEW_PLAYER_REMINDER"] = 104;
        values[valuesById[105] = "CHAT_MESSAGE_OBSERVER_WARD_KILLED"] = 105;
        values[valuesById[106] = "CHAT_MESSAGE_SENTRY_WARD_KILLED"] = 106;
        values[valuesById[107] = "CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH"] = 107;
        values[valuesById[108] = "CHAT_MESSAGE_HERO_CHOICE_INVALID"] = 108;
        values[valuesById[109] = "CHAT_MESSAGE_BOUNTY"] = 109;
        values[valuesById[110] = "CHAT_MESSAGE_ABILITY_DRAFT_START"] = 110;
        return values;
    })();
    
    /**
     * DOTA_NO_BATTLE_POINTS_REASONS enum.
     * @exports DOTA_NO_BATTLE_POINTS_REASONS
     * @enum {number}
     * @property {number} NO_BATTLE_POINTS_WRONG_LOBBY_TYPE=1 NO_BATTLE_POINTS_WRONG_LOBBY_TYPE value
     * @property {number} NO_BATTLE_POINTS_PRACTICE_BOTS=2 NO_BATTLE_POINTS_PRACTICE_BOTS value
     * @property {number} NO_BATTLE_POINTS_CHEATS_ENABLED=3 NO_BATTLE_POINTS_CHEATS_ENABLED value
     * @property {number} NO_BATTLE_POINTS_LOW_PRIORITY=4 NO_BATTLE_POINTS_LOW_PRIORITY value
     */
    $root.DOTA_NO_BATTLE_POINTS_REASONS = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "NO_BATTLE_POINTS_WRONG_LOBBY_TYPE"] = 1;
        values[valuesById[2] = "NO_BATTLE_POINTS_PRACTICE_BOTS"] = 2;
        values[valuesById[3] = "NO_BATTLE_POINTS_CHEATS_ENABLED"] = 3;
        values[valuesById[4] = "NO_BATTLE_POINTS_LOW_PRIORITY"] = 4;
        return values;
    })();
    
    /**
     * DOTA_CHAT_INFORMATIONAL enum.
     * @exports DOTA_CHAT_INFORMATIONAL
     * @enum {number}
     * @property {number} INFO_COOP_BATTLE_POINTS_RULES=1 INFO_COOP_BATTLE_POINTS_RULES value
     * @property {number} INFO_FROSTIVUS_ABANDON_REMINDER=2 INFO_FROSTIVUS_ABANDON_REMINDER value
     * @property {number} INFO_RANKED_REMINDER=3 INFO_RANKED_REMINDER value
     * @property {number} INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER=4 INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER value
     * @property {number} INFO_CUSTOM_GAME_PENALTY_REMINDER=5 INFO_CUSTOM_GAME_PENALTY_REMINDER value
     */
    $root.DOTA_CHAT_INFORMATIONAL = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "INFO_COOP_BATTLE_POINTS_RULES"] = 1;
        values[valuesById[2] = "INFO_FROSTIVUS_ABANDON_REMINDER"] = 2;
        values[valuesById[3] = "INFO_RANKED_REMINDER"] = 3;
        values[valuesById[4] = "INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER"] = 4;
        values[valuesById[5] = "INFO_CUSTOM_GAME_PENALTY_REMINDER"] = 5;
        return values;
    })();
    
    /**
     * DOTA_ABILITY_PING_TYPE enum.
     * @exports DOTA_ABILITY_PING_TYPE
     * @enum {number}
     * @property {number} ABILITY_PING_READY=1 ABILITY_PING_READY value
     * @property {number} ABILITY_PING_MANA=2 ABILITY_PING_MANA value
     * @property {number} ABILITY_PING_COOLDOWN=3 ABILITY_PING_COOLDOWN value
     * @property {number} ABILITY_PING_ENEMY=4 ABILITY_PING_ENEMY value
     * @property {number} ABILITY_PING_UNLEARNED=5 ABILITY_PING_UNLEARNED value
     * @property {number} ABILITY_PING_INBACKPACK=6 ABILITY_PING_INBACKPACK value
     * @property {number} ABILITY_PING_INSTASH=7 ABILITY_PING_INSTASH value
     * @property {number} ABILITY_PING_ONCOURIER=8 ABILITY_PING_ONCOURIER value
     * @property {number} ABILITY_PING_ALLY=9 ABILITY_PING_ALLY value
     * @property {number} ABILITY_PING_LEARN_READY=10 ABILITY_PING_LEARN_READY value
     * @property {number} ABILITY_PING_WILL_LEARN=11 ABILITY_PING_WILL_LEARN value
     * @property {number} ABILITY_PING_FUTURE_LEARN=12 ABILITY_PING_FUTURE_LEARN value
     * @property {number} ABILITY_PING_NEUTRAL_OFFER=13 ABILITY_PING_NEUTRAL_OFFER value
     * @property {number} ABILITY_PING_NEUTRAL_REQUEST=14 ABILITY_PING_NEUTRAL_REQUEST value
     * @property {number} ABILITY_PING_NEUTRAL_EQUIP=15 ABILITY_PING_NEUTRAL_EQUIP value
     */
    $root.DOTA_ABILITY_PING_TYPE = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "ABILITY_PING_READY"] = 1;
        values[valuesById[2] = "ABILITY_PING_MANA"] = 2;
        values[valuesById[3] = "ABILITY_PING_COOLDOWN"] = 3;
        values[valuesById[4] = "ABILITY_PING_ENEMY"] = 4;
        values[valuesById[5] = "ABILITY_PING_UNLEARNED"] = 5;
        values[valuesById[6] = "ABILITY_PING_INBACKPACK"] = 6;
        values[valuesById[7] = "ABILITY_PING_INSTASH"] = 7;
        values[valuesById[8] = "ABILITY_PING_ONCOURIER"] = 8;
        values[valuesById[9] = "ABILITY_PING_ALLY"] = 9;
        values[valuesById[10] = "ABILITY_PING_LEARN_READY"] = 10;
        values[valuesById[11] = "ABILITY_PING_WILL_LEARN"] = 11;
        values[valuesById[12] = "ABILITY_PING_FUTURE_LEARN"] = 12;
        values[valuesById[13] = "ABILITY_PING_NEUTRAL_OFFER"] = 13;
        values[valuesById[14] = "ABILITY_PING_NEUTRAL_REQUEST"] = 14;
        values[valuesById[15] = "ABILITY_PING_NEUTRAL_EQUIP"] = 15;
        return values;
    })();
    
    /**
     * DOTA_REPLAY_STATE_EVENT enum.
     * @exports DOTA_REPLAY_STATE_EVENT
     * @enum {number}
     * @property {number} DOTA_REPLAY_STATE_EVENT_GAME_START=1 DOTA_REPLAY_STATE_EVENT_GAME_START value
     * @property {number} DOTA_REPLAY_STATE_EVENT_STARTING_HORN=2 DOTA_REPLAY_STATE_EVENT_STARTING_HORN value
     * @property {number} DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD=3 DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD value
     * @property {number} DOTA_REPLAY_STATE_EVENT_SHOWCASE=4 DOTA_REPLAY_STATE_EVENT_SHOWCASE value
     */
    $root.DOTA_REPLAY_STATE_EVENT = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "DOTA_REPLAY_STATE_EVENT_GAME_START"] = 1;
        values[valuesById[2] = "DOTA_REPLAY_STATE_EVENT_STARTING_HORN"] = 2;
        values[valuesById[3] = "DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD"] = 3;
        values[valuesById[4] = "DOTA_REPLAY_STATE_EVENT_SHOWCASE"] = 4;
        return values;
    })();
    
    /**
     * EDotaEntityMessages enum.
     * @exports EDotaEntityMessages
     * @enum {number}
     * @property {number} DOTA_UNIT_SPEECH=0 DOTA_UNIT_SPEECH value
     * @property {number} DOTA_UNIT_SPEECH_MUTE=1 DOTA_UNIT_SPEECH_MUTE value
     * @property {number} DOTA_UNIT_ADD_GESTURE=2 DOTA_UNIT_ADD_GESTURE value
     * @property {number} DOTA_UNIT_REMOVE_GESTURE=3 DOTA_UNIT_REMOVE_GESTURE value
     * @property {number} DOTA_UNIT_REMOVE_ALL_GESTURES=4 DOTA_UNIT_REMOVE_ALL_GESTURES value
     * @property {number} DOTA_UNIT_FADE_GESTURE=6 DOTA_UNIT_FADE_GESTURE value
     * @property {number} DOTA_UNIT_SPEECH_CLIENTSIDE_RULES=7 DOTA_UNIT_SPEECH_CLIENTSIDE_RULES value
     */
    $root.EDotaEntityMessages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_UNIT_SPEECH"] = 0;
        values[valuesById[1] = "DOTA_UNIT_SPEECH_MUTE"] = 1;
        values[valuesById[2] = "DOTA_UNIT_ADD_GESTURE"] = 2;
        values[valuesById[3] = "DOTA_UNIT_REMOVE_GESTURE"] = 3;
        values[valuesById[4] = "DOTA_UNIT_REMOVE_ALL_GESTURES"] = 4;
        values[valuesById[6] = "DOTA_UNIT_FADE_GESTURE"] = 6;
        values[valuesById[7] = "DOTA_UNIT_SPEECH_CLIENTSIDE_RULES"] = 7;
        return values;
    })();
    
    /**
     * DOTA_OVERHEAD_ALERT enum.
     * @exports DOTA_OVERHEAD_ALERT
     * @enum {number}
     * @property {number} OVERHEAD_ALERT_GOLD=0 OVERHEAD_ALERT_GOLD value
     * @property {number} OVERHEAD_ALERT_DENY=1 OVERHEAD_ALERT_DENY value
     * @property {number} OVERHEAD_ALERT_CRITICAL=2 OVERHEAD_ALERT_CRITICAL value
     * @property {number} OVERHEAD_ALERT_XP=3 OVERHEAD_ALERT_XP value
     * @property {number} OVERHEAD_ALERT_BONUS_SPELL_DAMAGE=4 OVERHEAD_ALERT_BONUS_SPELL_DAMAGE value
     * @property {number} OVERHEAD_ALERT_MISS=5 OVERHEAD_ALERT_MISS value
     * @property {number} OVERHEAD_ALERT_DAMAGE=6 OVERHEAD_ALERT_DAMAGE value
     * @property {number} OVERHEAD_ALERT_EVADE=7 OVERHEAD_ALERT_EVADE value
     * @property {number} OVERHEAD_ALERT_BLOCK=8 OVERHEAD_ALERT_BLOCK value
     * @property {number} OVERHEAD_ALERT_BONUS_POISON_DAMAGE=9 OVERHEAD_ALERT_BONUS_POISON_DAMAGE value
     * @property {number} OVERHEAD_ALERT_HEAL=10 OVERHEAD_ALERT_HEAL value
     * @property {number} OVERHEAD_ALERT_MANA_ADD=11 OVERHEAD_ALERT_MANA_ADD value
     * @property {number} OVERHEAD_ALERT_MANA_LOSS=12 OVERHEAD_ALERT_MANA_LOSS value
     * @property {number} OVERHEAD_ALERT_LAST_HIT_EARLY=13 OVERHEAD_ALERT_LAST_HIT_EARLY value
     * @property {number} OVERHEAD_ALERT_LAST_HIT_CLOSE=14 OVERHEAD_ALERT_LAST_HIT_CLOSE value
     * @property {number} OVERHEAD_ALERT_LAST_HIT_MISS=15 OVERHEAD_ALERT_LAST_HIT_MISS value
     * @property {number} OVERHEAD_ALERT_MAGICAL_BLOCK=16 OVERHEAD_ALERT_MAGICAL_BLOCK value
     * @property {number} OVERHEAD_ALERT_INCOMING_DAMAGE=17 OVERHEAD_ALERT_INCOMING_DAMAGE value
     * @property {number} OVERHEAD_ALERT_OUTGOING_DAMAGE=18 OVERHEAD_ALERT_OUTGOING_DAMAGE value
     * @property {number} OVERHEAD_ALERT_DISABLE_RESIST=19 OVERHEAD_ALERT_DISABLE_RESIST value
     * @property {number} OVERHEAD_ALERT_DEATH=20 OVERHEAD_ALERT_DEATH value
     * @property {number} OVERHEAD_ALERT_BLOCKED=21 OVERHEAD_ALERT_BLOCKED value
     * @property {number} OVERHEAD_ALERT_ITEM_RECEIVED=22 OVERHEAD_ALERT_ITEM_RECEIVED value
     */
    $root.DOTA_OVERHEAD_ALERT = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OVERHEAD_ALERT_GOLD"] = 0;
        values[valuesById[1] = "OVERHEAD_ALERT_DENY"] = 1;
        values[valuesById[2] = "OVERHEAD_ALERT_CRITICAL"] = 2;
        values[valuesById[3] = "OVERHEAD_ALERT_XP"] = 3;
        values[valuesById[4] = "OVERHEAD_ALERT_BONUS_SPELL_DAMAGE"] = 4;
        values[valuesById[5] = "OVERHEAD_ALERT_MISS"] = 5;
        values[valuesById[6] = "OVERHEAD_ALERT_DAMAGE"] = 6;
        values[valuesById[7] = "OVERHEAD_ALERT_EVADE"] = 7;
        values[valuesById[8] = "OVERHEAD_ALERT_BLOCK"] = 8;
        values[valuesById[9] = "OVERHEAD_ALERT_BONUS_POISON_DAMAGE"] = 9;
        values[valuesById[10] = "OVERHEAD_ALERT_HEAL"] = 10;
        values[valuesById[11] = "OVERHEAD_ALERT_MANA_ADD"] = 11;
        values[valuesById[12] = "OVERHEAD_ALERT_MANA_LOSS"] = 12;
        values[valuesById[13] = "OVERHEAD_ALERT_LAST_HIT_EARLY"] = 13;
        values[valuesById[14] = "OVERHEAD_ALERT_LAST_HIT_CLOSE"] = 14;
        values[valuesById[15] = "OVERHEAD_ALERT_LAST_HIT_MISS"] = 15;
        values[valuesById[16] = "OVERHEAD_ALERT_MAGICAL_BLOCK"] = 16;
        values[valuesById[17] = "OVERHEAD_ALERT_INCOMING_DAMAGE"] = 17;
        values[valuesById[18] = "OVERHEAD_ALERT_OUTGOING_DAMAGE"] = 18;
        values[valuesById[19] = "OVERHEAD_ALERT_DISABLE_RESIST"] = 19;
        values[valuesById[20] = "OVERHEAD_ALERT_DEATH"] = 20;
        values[valuesById[21] = "OVERHEAD_ALERT_BLOCKED"] = 21;
        values[valuesById[22] = "OVERHEAD_ALERT_ITEM_RECEIVED"] = 22;
        return values;
    })();
    
    /**
     * DOTA_ROSHAN_PHASE enum.
     * @exports DOTA_ROSHAN_PHASE
     * @enum {number}
     * @property {number} k_SRSP_ROSHAN_ALIVE=0 k_SRSP_ROSHAN_ALIVE value
     * @property {number} k_SRSP_ROSHAN_BASE_TIMER=1 k_SRSP_ROSHAN_BASE_TIMER value
     * @property {number} k_SRSP_ROSHAN_VISIBLE_TIMER=2 k_SRSP_ROSHAN_VISIBLE_TIMER value
     */
    $root.DOTA_ROSHAN_PHASE = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_SRSP_ROSHAN_ALIVE"] = 0;
        values[valuesById[1] = "k_SRSP_ROSHAN_BASE_TIMER"] = 1;
        values[valuesById[2] = "k_SRSP_ROSHAN_VISIBLE_TIMER"] = 2;
        return values;
    })();
    
    /**
     * DOTA_POSITION_CATEGORY enum.
     * @exports DOTA_POSITION_CATEGORY
     * @enum {number}
     * @property {number} DOTA_POSITION_NONE=0 DOTA_POSITION_NONE value
     * @property {number} DOTA_POSITION_BOTTOM_LANE=1 DOTA_POSITION_BOTTOM_LANE value
     * @property {number} DOTA_POSITION_MID_LANE=2 DOTA_POSITION_MID_LANE value
     * @property {number} DOTA_POSITION_TOP_LANE=3 DOTA_POSITION_TOP_LANE value
     * @property {number} DOTA_POSITION_RADIANT_JUNGLE=4 DOTA_POSITION_RADIANT_JUNGLE value
     * @property {number} DOTA_POSITION_DIRE_JUNGLE=5 DOTA_POSITION_DIRE_JUNGLE value
     * @property {number} DOTA_POSITION_RADIANT_ANCIENTS=6 DOTA_POSITION_RADIANT_ANCIENTS value
     * @property {number} DOTA_POSITION_DIRE_ANCIENTS=7 DOTA_POSITION_DIRE_ANCIENTS value
     * @property {number} DOTA_POSITION_RADIANT_SECRET_SHOP=8 DOTA_POSITION_RADIANT_SECRET_SHOP value
     * @property {number} DOTA_POSITION_DIRE_SECRET_SHOP=9 DOTA_POSITION_DIRE_SECRET_SHOP value
     * @property {number} DOTA_POSITION_RIVER=10 DOTA_POSITION_RIVER value
     * @property {number} DOTA_POSITION_ROSHAN_PIT=11 DOTA_POSITION_ROSHAN_PIT value
     * @property {number} DOTA_POSITION_RADIANT_BASE=12 DOTA_POSITION_RADIANT_BASE value
     * @property {number} DOTA_POSITION_DIRE_BASE=13 DOTA_POSITION_DIRE_BASE value
     * @property {number} DOTA_POSITION_FOUNTAIN=14 DOTA_POSITION_FOUNTAIN value
     * @property {number} DOTA_POSITION_OTHER=15 DOTA_POSITION_OTHER value
     */
    $root.DOTA_POSITION_CATEGORY = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_POSITION_NONE"] = 0;
        values[valuesById[1] = "DOTA_POSITION_BOTTOM_LANE"] = 1;
        values[valuesById[2] = "DOTA_POSITION_MID_LANE"] = 2;
        values[valuesById[3] = "DOTA_POSITION_TOP_LANE"] = 3;
        values[valuesById[4] = "DOTA_POSITION_RADIANT_JUNGLE"] = 4;
        values[valuesById[5] = "DOTA_POSITION_DIRE_JUNGLE"] = 5;
        values[valuesById[6] = "DOTA_POSITION_RADIANT_ANCIENTS"] = 6;
        values[valuesById[7] = "DOTA_POSITION_DIRE_ANCIENTS"] = 7;
        values[valuesById[8] = "DOTA_POSITION_RADIANT_SECRET_SHOP"] = 8;
        values[valuesById[9] = "DOTA_POSITION_DIRE_SECRET_SHOP"] = 9;
        values[valuesById[10] = "DOTA_POSITION_RIVER"] = 10;
        values[valuesById[11] = "DOTA_POSITION_ROSHAN_PIT"] = 11;
        values[valuesById[12] = "DOTA_POSITION_RADIANT_BASE"] = 12;
        values[valuesById[13] = "DOTA_POSITION_DIRE_BASE"] = 13;
        values[valuesById[14] = "DOTA_POSITION_FOUNTAIN"] = 14;
        values[valuesById[15] = "DOTA_POSITION_OTHER"] = 15;
        return values;
    })();
    
    /**
     * DOTA_ABILITY_TARGET_TYPE enum.
     * @exports DOTA_ABILITY_TARGET_TYPE
     * @enum {number}
     * @property {number} DOTA_ABILITY_TARGET_NONE=0 DOTA_ABILITY_TARGET_NONE value
     * @property {number} DOTA_ABILITY_TARGET_SELF=1 DOTA_ABILITY_TARGET_SELF value
     * @property {number} DOTA_ABILITY_TARGET_ALLY_HERO=2 DOTA_ABILITY_TARGET_ALLY_HERO value
     * @property {number} DOTA_ABILITY_TARGET_ALLY_CREEP=3 DOTA_ABILITY_TARGET_ALLY_CREEP value
     * @property {number} DOTA_ABILITY_TARGET_ENEMY_HERO=4 DOTA_ABILITY_TARGET_ENEMY_HERO value
     * @property {number} DOTA_ABILITY_TARGET_ENEMY_CREEP=5 DOTA_ABILITY_TARGET_ENEMY_CREEP value
     */
    $root.DOTA_ABILITY_TARGET_TYPE = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_ABILITY_TARGET_NONE"] = 0;
        values[valuesById[1] = "DOTA_ABILITY_TARGET_SELF"] = 1;
        values[valuesById[2] = "DOTA_ABILITY_TARGET_ALLY_HERO"] = 2;
        values[valuesById[3] = "DOTA_ABILITY_TARGET_ALLY_CREEP"] = 3;
        values[valuesById[4] = "DOTA_ABILITY_TARGET_ENEMY_HERO"] = 4;
        values[valuesById[5] = "DOTA_ABILITY_TARGET_ENEMY_CREEP"] = 5;
        return values;
    })();
    
    /**
     * EHeroStatType enum.
     * @exports EHeroStatType
     * @enum {number}
     * @property {number} k_EHeroStatType_None=0 k_EHeroStatType_None value
     * @property {number} k_EHeroStatType_AxeTotalDamage=2000 k_EHeroStatType_AxeTotalDamage value
     * @property {number} k_EHeroStatType_BattleHungerDamage=2001 k_EHeroStatType_BattleHungerDamage value
     * @property {number} k_EHeroStatType_CounterHelixDamage=2002 k_EHeroStatType_CounterHelixDamage value
     * @property {number} k_EHeroStatType_CullingBladeDamage=2003 k_EHeroStatType_CullingBladeDamage value
     * @property {number} k_EHeroStatType_BerserkersCallCastCount=2004 k_EHeroStatType_BerserkersCallCastCount value
     * @property {number} k_EHeroStatType_BerserkersCallHeroesHitAverage=2005 k_EHeroStatType_BerserkersCallHeroesHitAverage value
     * @property {number} k_EHeroStatType_BerserkersCallOtherUnitsHit=2006 k_EHeroStatType_BerserkersCallOtherUnitsHit value
     * @property {number} k_EHeroStatType_BerserkersCallHeroAttacksTaken=2007 k_EHeroStatType_BerserkersCallHeroAttacksTaken value
     * @property {number} k_EHeroStatType_BerserkersCallOtherAttacksTaken=2008 k_EHeroStatType_BerserkersCallOtherAttacksTaken value
     * @property {number} k_EHeroStatType_BattleHungerCastCount=2009 k_EHeroStatType_BattleHungerCastCount value
     * @property {number} k_EHeroStatType_BattleHungerPotentialDuration=2010 k_EHeroStatType_BattleHungerPotentialDuration value
     * @property {number} k_EHeroStatType_BattleHungerAverageDuration=2011 k_EHeroStatType_BattleHungerAverageDuration value
     * @property {number} k_EHeroStatType_CounterHelixProcCount=2012 k_EHeroStatType_CounterHelixProcCount value
     * @property {number} k_EHeroStatType_CounterHelixHeroProcCount=2013 k_EHeroStatType_CounterHelixHeroProcCount value
     * @property {number} k_EHeroStatType_CounterHelixHeroesHitAverage=2014 k_EHeroStatType_CounterHelixHeroesHitAverage value
     * @property {number} k_EHeroStatType_CounterHelixOtherUnitsHitCount=2015 k_EHeroStatType_CounterHelixOtherUnitsHitCount value
     * @property {number} k_EHeroStatType_CullingBladeCastCount=2016 k_EHeroStatType_CullingBladeCastCount value
     * @property {number} k_EHeroStatType_CullingBladeKillCount=2017 k_EHeroStatType_CullingBladeKillCount value
     * @property {number} k_EHeroStatType_CullingBladeAverageHealthCulled=2018 k_EHeroStatType_CullingBladeAverageHealthCulled value
     * @property {number} k_EHeroStatType_CullingBladeAverageDamageAvailable=2019 k_EHeroStatType_CullingBladeAverageDamageAvailable value
     * @property {number} k_EHeroStatType_CullingBladeHeroBuffAverage=2020 k_EHeroStatType_CullingBladeHeroBuffAverage value
     */
    $root.EHeroStatType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_EHeroStatType_None"] = 0;
        values[valuesById[2000] = "k_EHeroStatType_AxeTotalDamage"] = 2000;
        values[valuesById[2001] = "k_EHeroStatType_BattleHungerDamage"] = 2001;
        values[valuesById[2002] = "k_EHeroStatType_CounterHelixDamage"] = 2002;
        values[valuesById[2003] = "k_EHeroStatType_CullingBladeDamage"] = 2003;
        values[valuesById[2004] = "k_EHeroStatType_BerserkersCallCastCount"] = 2004;
        values[valuesById[2005] = "k_EHeroStatType_BerserkersCallHeroesHitAverage"] = 2005;
        values[valuesById[2006] = "k_EHeroStatType_BerserkersCallOtherUnitsHit"] = 2006;
        values[valuesById[2007] = "k_EHeroStatType_BerserkersCallHeroAttacksTaken"] = 2007;
        values[valuesById[2008] = "k_EHeroStatType_BerserkersCallOtherAttacksTaken"] = 2008;
        values[valuesById[2009] = "k_EHeroStatType_BattleHungerCastCount"] = 2009;
        values[valuesById[2010] = "k_EHeroStatType_BattleHungerPotentialDuration"] = 2010;
        values[valuesById[2011] = "k_EHeroStatType_BattleHungerAverageDuration"] = 2011;
        values[valuesById[2012] = "k_EHeroStatType_CounterHelixProcCount"] = 2012;
        values[valuesById[2013] = "k_EHeroStatType_CounterHelixHeroProcCount"] = 2013;
        values[valuesById[2014] = "k_EHeroStatType_CounterHelixHeroesHitAverage"] = 2014;
        values[valuesById[2015] = "k_EHeroStatType_CounterHelixOtherUnitsHitCount"] = 2015;
        values[valuesById[2016] = "k_EHeroStatType_CullingBladeCastCount"] = 2016;
        values[valuesById[2017] = "k_EHeroStatType_CullingBladeKillCount"] = 2017;
        values[valuesById[2018] = "k_EHeroStatType_CullingBladeAverageHealthCulled"] = 2018;
        values[valuesById[2019] = "k_EHeroStatType_CullingBladeAverageDamageAvailable"] = 2019;
        values[valuesById[2020] = "k_EHeroStatType_CullingBladeHeroBuffAverage"] = 2020;
        return values;
    })();
    
    /**
     * EPlayerVoiceListenState enum.
     * @exports EPlayerVoiceListenState
     * @enum {number}
     * @property {number} kPVLS_None=0 kPVLS_None value
     * @property {number} kPVLS_DeniedChatBanned=1 kPVLS_DeniedChatBanned value
     * @property {number} kPVLS_DeniedPartner=2 kPVLS_DeniedPartner value
     * @property {number} kPVLS_DeniedHLTVTalkerNotSpectator=3 kPVLS_DeniedHLTVTalkerNotSpectator value
     * @property {number} kPVLS_DeniedHLTVNoTalkerPlayerID=4 kPVLS_DeniedHLTVNoTalkerPlayerID value
     * @property {number} kPVLS_DeniedHLTVTalkerNotBroadcaster=5 kPVLS_DeniedHLTVTalkerNotBroadcaster value
     * @property {number} kPVLS_DeniedTeamSpectator=6 kPVLS_DeniedTeamSpectator value
     * @property {number} kPVLS_DeniedStudent=8 kPVLS_DeniedStudent value
     * @property {number} kPVLS_Denied=64 kPVLS_Denied value
     * @property {number} kPVLS_AllowHLTVTalkerIsBroadcaster=65 kPVLS_AllowHLTVTalkerIsBroadcaster value
     * @property {number} kPVLS_AllowCoBroadcaster=66 kPVLS_AllowCoBroadcaster value
     * @property {number} kPVLS_AllowAllChat=67 kPVLS_AllowAllChat value
     * @property {number} kPVLS_AllowStudentToCoach=68 kPVLS_AllowStudentToCoach value
     * @property {number} kPVLS_AllowFellowStudent=69 kPVLS_AllowFellowStudent value
     * @property {number} kPVLS_AllowTalkerIsCoach=70 kPVLS_AllowTalkerIsCoach value
     * @property {number} kPVLS_AllowCoachHearTeam=71 kPVLS_AllowCoachHearTeam value
     * @property {number} kPVLS_AllowSameTeam=72 kPVLS_AllowSameTeam value
     * @property {number} kPVLS_AllowShowcase=73 kPVLS_AllowShowcase value
     */
    $root.EPlayerVoiceListenState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "kPVLS_None"] = 0;
        values[valuesById[1] = "kPVLS_DeniedChatBanned"] = 1;
        values[valuesById[2] = "kPVLS_DeniedPartner"] = 2;
        values[valuesById[3] = "kPVLS_DeniedHLTVTalkerNotSpectator"] = 3;
        values[valuesById[4] = "kPVLS_DeniedHLTVNoTalkerPlayerID"] = 4;
        values[valuesById[5] = "kPVLS_DeniedHLTVTalkerNotBroadcaster"] = 5;
        values[valuesById[6] = "kPVLS_DeniedTeamSpectator"] = 6;
        values[valuesById[8] = "kPVLS_DeniedStudent"] = 8;
        values[valuesById[64] = "kPVLS_Denied"] = 64;
        values[valuesById[65] = "kPVLS_AllowHLTVTalkerIsBroadcaster"] = 65;
        values[valuesById[66] = "kPVLS_AllowCoBroadcaster"] = 66;
        values[valuesById[67] = "kPVLS_AllowAllChat"] = 67;
        values[valuesById[68] = "kPVLS_AllowStudentToCoach"] = 68;
        values[valuesById[69] = "kPVLS_AllowFellowStudent"] = 69;
        values[valuesById[70] = "kPVLS_AllowTalkerIsCoach"] = 70;
        values[valuesById[71] = "kPVLS_AllowCoachHearTeam"] = 71;
        values[valuesById[72] = "kPVLS_AllowSameTeam"] = 72;
        values[valuesById[73] = "kPVLS_AllowShowcase"] = 73;
        return values;
    })();
    
    /**
     * EProjectionEvent enum.
     * @exports EProjectionEvent
     * @enum {number}
     * @property {number} ePE_FirstBlood=0 ePE_FirstBlood value
     * @property {number} ePE_Killstreak_godlike=1 ePE_Killstreak_godlike value
     */
    $root.EProjectionEvent = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ePE_FirstBlood"] = 0;
        values[valuesById[1] = "ePE_Killstreak_godlike"] = 1;
        return values;
    })();
    
    $root.CDOTAUserMsg_AIDebugLine = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_AIDebugLine.
         * @exports ICDOTAUserMsg_AIDebugLine
         * @interface ICDOTAUserMsg_AIDebugLine
         * @property {string|null} [message] CDOTAUserMsg_AIDebugLine message
         */
    
        /**
         * Constructs a new CDOTAUserMsg_AIDebugLine.
         * @exports CDOTAUserMsg_AIDebugLine
         * @classdesc Represents a CDOTAUserMsg_AIDebugLine.
         * @implements ICDOTAUserMsg_AIDebugLine
         * @constructor
         * @param {ICDOTAUserMsg_AIDebugLine=} [properties] Properties to set
         */
        function CDOTAUserMsg_AIDebugLine(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_AIDebugLine message.
         * @member {string} message
         * @memberof CDOTAUserMsg_AIDebugLine
         * @instance
         */
        CDOTAUserMsg_AIDebugLine.prototype.message = "";
    
        /**
         * Creates a new CDOTAUserMsg_AIDebugLine instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_AIDebugLine
         * @static
         * @param {ICDOTAUserMsg_AIDebugLine=} [properties] Properties to set
         * @returns {CDOTAUserMsg_AIDebugLine} CDOTAUserMsg_AIDebugLine instance
         */
        CDOTAUserMsg_AIDebugLine.create = function create(properties) {
            return new CDOTAUserMsg_AIDebugLine(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_AIDebugLine message. Does not implicitly {@link CDOTAUserMsg_AIDebugLine.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_AIDebugLine
         * @static
         * @param {ICDOTAUserMsg_AIDebugLine} message CDOTAUserMsg_AIDebugLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_AIDebugLine.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_AIDebugLine message, length delimited. Does not implicitly {@link CDOTAUserMsg_AIDebugLine.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_AIDebugLine
         * @static
         * @param {ICDOTAUserMsg_AIDebugLine} message CDOTAUserMsg_AIDebugLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_AIDebugLine.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_AIDebugLine message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_AIDebugLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_AIDebugLine} CDOTAUserMsg_AIDebugLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_AIDebugLine.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_AIDebugLine();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_AIDebugLine message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_AIDebugLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_AIDebugLine} CDOTAUserMsg_AIDebugLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_AIDebugLine.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_AIDebugLine message.
         * @function verify
         * @memberof CDOTAUserMsg_AIDebugLine
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_AIDebugLine.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_AIDebugLine message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_AIDebugLine
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_AIDebugLine} CDOTAUserMsg_AIDebugLine
         */
        CDOTAUserMsg_AIDebugLine.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_AIDebugLine)
                return object;
            var message = new $root.CDOTAUserMsg_AIDebugLine();
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_AIDebugLine message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_AIDebugLine
         * @static
         * @param {CDOTAUserMsg_AIDebugLine} message CDOTAUserMsg_AIDebugLine
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_AIDebugLine.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.message = "";
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_AIDebugLine to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_AIDebugLine
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_AIDebugLine.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_AIDebugLine;
    })();
    
    $root.CDOTAUserMsg_Ping = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_Ping.
         * @exports ICDOTAUserMsg_Ping
         * @interface ICDOTAUserMsg_Ping
         * @property {number|null} [ping] CDOTAUserMsg_Ping ping
         * @property {number|null} [loss] CDOTAUserMsg_Ping loss
         */
    
        /**
         * Constructs a new CDOTAUserMsg_Ping.
         * @exports CDOTAUserMsg_Ping
         * @classdesc Represents a CDOTAUserMsg_Ping.
         * @implements ICDOTAUserMsg_Ping
         * @constructor
         * @param {ICDOTAUserMsg_Ping=} [properties] Properties to set
         */
        function CDOTAUserMsg_Ping(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_Ping ping.
         * @member {number} ping
         * @memberof CDOTAUserMsg_Ping
         * @instance
         */
        CDOTAUserMsg_Ping.prototype.ping = 0;
    
        /**
         * CDOTAUserMsg_Ping loss.
         * @member {number} loss
         * @memberof CDOTAUserMsg_Ping
         * @instance
         */
        CDOTAUserMsg_Ping.prototype.loss = 0;
    
        /**
         * Creates a new CDOTAUserMsg_Ping instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_Ping
         * @static
         * @param {ICDOTAUserMsg_Ping=} [properties] Properties to set
         * @returns {CDOTAUserMsg_Ping} CDOTAUserMsg_Ping instance
         */
        CDOTAUserMsg_Ping.create = function create(properties) {
            return new CDOTAUserMsg_Ping(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_Ping message. Does not implicitly {@link CDOTAUserMsg_Ping.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_Ping
         * @static
         * @param {ICDOTAUserMsg_Ping} message CDOTAUserMsg_Ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_Ping.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ping != null && Object.hasOwnProperty.call(message, "ping"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.ping);
            if (message.loss != null && Object.hasOwnProperty.call(message, "loss"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.loss);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_Ping message, length delimited. Does not implicitly {@link CDOTAUserMsg_Ping.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_Ping
         * @static
         * @param {ICDOTAUserMsg_Ping} message CDOTAUserMsg_Ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_Ping.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_Ping message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_Ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_Ping} CDOTAUserMsg_Ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_Ping.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_Ping();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.ping = reader.uint32();
                    break;
                case 3:
                    message.loss = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_Ping message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_Ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_Ping} CDOTAUserMsg_Ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_Ping.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_Ping message.
         * @function verify
         * @memberof CDOTAUserMsg_Ping
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_Ping.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ping != null && message.hasOwnProperty("ping"))
                if (!$util.isInteger(message.ping))
                    return "ping: integer expected";
            if (message.loss != null && message.hasOwnProperty("loss"))
                if (!$util.isInteger(message.loss))
                    return "loss: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_Ping message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_Ping
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_Ping} CDOTAUserMsg_Ping
         */
        CDOTAUserMsg_Ping.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_Ping)
                return object;
            var message = new $root.CDOTAUserMsg_Ping();
            if (object.ping != null)
                message.ping = object.ping >>> 0;
            if (object.loss != null)
                message.loss = object.loss >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_Ping message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_Ping
         * @static
         * @param {CDOTAUserMsg_Ping} message CDOTAUserMsg_Ping
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_Ping.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ping = 0;
                object.loss = 0;
            }
            if (message.ping != null && message.hasOwnProperty("ping"))
                object.ping = message.ping;
            if (message.loss != null && message.hasOwnProperty("loss"))
                object.loss = message.loss;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_Ping to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_Ping
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_Ping.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_Ping;
    })();
    
    $root.CDOTAUserMsg_SwapVerify = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_SwapVerify.
         * @exports ICDOTAUserMsg_SwapVerify
         * @interface ICDOTAUserMsg_SwapVerify
         * @property {number|null} [player_id] CDOTAUserMsg_SwapVerify player_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_SwapVerify.
         * @exports CDOTAUserMsg_SwapVerify
         * @classdesc Represents a CDOTAUserMsg_SwapVerify.
         * @implements ICDOTAUserMsg_SwapVerify
         * @constructor
         * @param {ICDOTAUserMsg_SwapVerify=} [properties] Properties to set
         */
        function CDOTAUserMsg_SwapVerify(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_SwapVerify player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_SwapVerify
         * @instance
         */
        CDOTAUserMsg_SwapVerify.prototype.player_id = 0;
    
        /**
         * Creates a new CDOTAUserMsg_SwapVerify instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_SwapVerify
         * @static
         * @param {ICDOTAUserMsg_SwapVerify=} [properties] Properties to set
         * @returns {CDOTAUserMsg_SwapVerify} CDOTAUserMsg_SwapVerify instance
         */
        CDOTAUserMsg_SwapVerify.create = function create(properties) {
            return new CDOTAUserMsg_SwapVerify(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SwapVerify message. Does not implicitly {@link CDOTAUserMsg_SwapVerify.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_SwapVerify
         * @static
         * @param {ICDOTAUserMsg_SwapVerify} message CDOTAUserMsg_SwapVerify message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SwapVerify.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SwapVerify message, length delimited. Does not implicitly {@link CDOTAUserMsg_SwapVerify.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_SwapVerify
         * @static
         * @param {ICDOTAUserMsg_SwapVerify} message CDOTAUserMsg_SwapVerify message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SwapVerify.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_SwapVerify message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_SwapVerify
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_SwapVerify} CDOTAUserMsg_SwapVerify
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SwapVerify.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_SwapVerify();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_SwapVerify message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_SwapVerify
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_SwapVerify} CDOTAUserMsg_SwapVerify
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SwapVerify.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_SwapVerify message.
         * @function verify
         * @memberof CDOTAUserMsg_SwapVerify
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_SwapVerify.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_SwapVerify message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_SwapVerify
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_SwapVerify} CDOTAUserMsg_SwapVerify
         */
        CDOTAUserMsg_SwapVerify.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_SwapVerify)
                return object;
            var message = new $root.CDOTAUserMsg_SwapVerify();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_SwapVerify message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_SwapVerify
         * @static
         * @param {CDOTAUserMsg_SwapVerify} message CDOTAUserMsg_SwapVerify
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_SwapVerify.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.player_id = 0;
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_SwapVerify to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_SwapVerify
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_SwapVerify.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_SwapVerify;
    })();
    
    $root.CDOTAUserMsg_ChatEvent = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_ChatEvent.
         * @exports ICDOTAUserMsg_ChatEvent
         * @interface ICDOTAUserMsg_ChatEvent
         * @property {DOTA_CHAT_MESSAGE} type CDOTAUserMsg_ChatEvent type
         * @property {number|null} [value] CDOTAUserMsg_ChatEvent value
         * @property {number|null} [playerid_1] CDOTAUserMsg_ChatEvent playerid_1
         * @property {number|null} [playerid_2] CDOTAUserMsg_ChatEvent playerid_2
         * @property {number|null} [playerid_3] CDOTAUserMsg_ChatEvent playerid_3
         * @property {number|null} [playerid_4] CDOTAUserMsg_ChatEvent playerid_4
         * @property {number|null} [playerid_5] CDOTAUserMsg_ChatEvent playerid_5
         * @property {number|null} [playerid_6] CDOTAUserMsg_ChatEvent playerid_6
         * @property {number|null} [value2] CDOTAUserMsg_ChatEvent value2
         * @property {number|null} [value3] CDOTAUserMsg_ChatEvent value3
         */
    
        /**
         * Constructs a new CDOTAUserMsg_ChatEvent.
         * @exports CDOTAUserMsg_ChatEvent
         * @classdesc Represents a CDOTAUserMsg_ChatEvent.
         * @implements ICDOTAUserMsg_ChatEvent
         * @constructor
         * @param {ICDOTAUserMsg_ChatEvent=} [properties] Properties to set
         */
        function CDOTAUserMsg_ChatEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_ChatEvent type.
         * @member {DOTA_CHAT_MESSAGE} type
         * @memberof CDOTAUserMsg_ChatEvent
         * @instance
         */
        CDOTAUserMsg_ChatEvent.prototype.type = -1;
    
        /**
         * CDOTAUserMsg_ChatEvent value.
         * @member {number} value
         * @memberof CDOTAUserMsg_ChatEvent
         * @instance
         */
        CDOTAUserMsg_ChatEvent.prototype.value = 0;
    
        /**
         * CDOTAUserMsg_ChatEvent playerid_1.
         * @member {number} playerid_1
         * @memberof CDOTAUserMsg_ChatEvent
         * @instance
         */
        CDOTAUserMsg_ChatEvent.prototype.playerid_1 = -1;
    
        /**
         * CDOTAUserMsg_ChatEvent playerid_2.
         * @member {number} playerid_2
         * @memberof CDOTAUserMsg_ChatEvent
         * @instance
         */
        CDOTAUserMsg_ChatEvent.prototype.playerid_2 = -1;
    
        /**
         * CDOTAUserMsg_ChatEvent playerid_3.
         * @member {number} playerid_3
         * @memberof CDOTAUserMsg_ChatEvent
         * @instance
         */
        CDOTAUserMsg_ChatEvent.prototype.playerid_3 = -1;
    
        /**
         * CDOTAUserMsg_ChatEvent playerid_4.
         * @member {number} playerid_4
         * @memberof CDOTAUserMsg_ChatEvent
         * @instance
         */
        CDOTAUserMsg_ChatEvent.prototype.playerid_4 = -1;
    
        /**
         * CDOTAUserMsg_ChatEvent playerid_5.
         * @member {number} playerid_5
         * @memberof CDOTAUserMsg_ChatEvent
         * @instance
         */
        CDOTAUserMsg_ChatEvent.prototype.playerid_5 = -1;
    
        /**
         * CDOTAUserMsg_ChatEvent playerid_6.
         * @member {number} playerid_6
         * @memberof CDOTAUserMsg_ChatEvent
         * @instance
         */
        CDOTAUserMsg_ChatEvent.prototype.playerid_6 = -1;
    
        /**
         * CDOTAUserMsg_ChatEvent value2.
         * @member {number} value2
         * @memberof CDOTAUserMsg_ChatEvent
         * @instance
         */
        CDOTAUserMsg_ChatEvent.prototype.value2 = 0;
    
        /**
         * CDOTAUserMsg_ChatEvent value3.
         * @member {number} value3
         * @memberof CDOTAUserMsg_ChatEvent
         * @instance
         */
        CDOTAUserMsg_ChatEvent.prototype.value3 = 0;
    
        /**
         * Creates a new CDOTAUserMsg_ChatEvent instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_ChatEvent
         * @static
         * @param {ICDOTAUserMsg_ChatEvent=} [properties] Properties to set
         * @returns {CDOTAUserMsg_ChatEvent} CDOTAUserMsg_ChatEvent instance
         */
        CDOTAUserMsg_ChatEvent.create = function create(properties) {
            return new CDOTAUserMsg_ChatEvent(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ChatEvent message. Does not implicitly {@link CDOTAUserMsg_ChatEvent.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_ChatEvent
         * @static
         * @param {ICDOTAUserMsg_ChatEvent} message CDOTAUserMsg_ChatEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ChatEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.value);
            if (message.playerid_1 != null && Object.hasOwnProperty.call(message, "playerid_1"))
                writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.playerid_1);
            if (message.playerid_2 != null && Object.hasOwnProperty.call(message, "playerid_2"))
                writer.uint32(/* id 4, wireType 0 =*/32).sint32(message.playerid_2);
            if (message.playerid_3 != null && Object.hasOwnProperty.call(message, "playerid_3"))
                writer.uint32(/* id 5, wireType 0 =*/40).sint32(message.playerid_3);
            if (message.playerid_4 != null && Object.hasOwnProperty.call(message, "playerid_4"))
                writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.playerid_4);
            if (message.playerid_5 != null && Object.hasOwnProperty.call(message, "playerid_5"))
                writer.uint32(/* id 7, wireType 0 =*/56).sint32(message.playerid_5);
            if (message.playerid_6 != null && Object.hasOwnProperty.call(message, "playerid_6"))
                writer.uint32(/* id 8, wireType 0 =*/64).sint32(message.playerid_6);
            if (message.value2 != null && Object.hasOwnProperty.call(message, "value2"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.value2);
            if (message.value3 != null && Object.hasOwnProperty.call(message, "value3"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.value3);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ChatEvent message, length delimited. Does not implicitly {@link CDOTAUserMsg_ChatEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_ChatEvent
         * @static
         * @param {ICDOTAUserMsg_ChatEvent} message CDOTAUserMsg_ChatEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ChatEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_ChatEvent message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_ChatEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_ChatEvent} CDOTAUserMsg_ChatEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ChatEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_ChatEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.value = reader.uint32();
                    break;
                case 3:
                    message.playerid_1 = reader.sint32();
                    break;
                case 4:
                    message.playerid_2 = reader.sint32();
                    break;
                case 5:
                    message.playerid_3 = reader.sint32();
                    break;
                case 6:
                    message.playerid_4 = reader.sint32();
                    break;
                case 7:
                    message.playerid_5 = reader.sint32();
                    break;
                case 8:
                    message.playerid_6 = reader.sint32();
                    break;
                case 9:
                    message.value2 = reader.uint32();
                    break;
                case 10:
                    message.value3 = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_ChatEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_ChatEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_ChatEvent} CDOTAUserMsg_ChatEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ChatEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_ChatEvent message.
         * @function verify
         * @memberof CDOTAUserMsg_ChatEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_ChatEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.type) {
            default:
                return "type: enum value expected";
            case -1:
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            case 38:
            case 39:
            case 41:
            case 42:
            case 43:
            case 44:
            case 45:
            case 46:
            case 47:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 58:
            case 59:
            case 62:
            case 63:
            case 64:
            case 65:
            case 66:
            case 67:
            case 73:
            case 74:
            case 75:
            case 76:
            case 77:
            case 78:
            case 79:
            case 80:
            case 81:
            case 82:
            case 83:
            case 84:
            case 85:
            case 86:
            case 87:
            case 88:
            case 89:
            case 90:
            case 91:
            case 92:
            case 93:
            case 94:
            case 95:
            case 96:
            case 97:
            case 98:
            case 99:
            case 100:
            case 101:
            case 102:
            case 103:
            case 104:
            case 105:
            case 106:
            case 107:
            case 108:
            case 109:
            case 110:
                break;
            }
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value))
                    return "value: integer expected";
            if (message.playerid_1 != null && message.hasOwnProperty("playerid_1"))
                if (!$util.isInteger(message.playerid_1))
                    return "playerid_1: integer expected";
            if (message.playerid_2 != null && message.hasOwnProperty("playerid_2"))
                if (!$util.isInteger(message.playerid_2))
                    return "playerid_2: integer expected";
            if (message.playerid_3 != null && message.hasOwnProperty("playerid_3"))
                if (!$util.isInteger(message.playerid_3))
                    return "playerid_3: integer expected";
            if (message.playerid_4 != null && message.hasOwnProperty("playerid_4"))
                if (!$util.isInteger(message.playerid_4))
                    return "playerid_4: integer expected";
            if (message.playerid_5 != null && message.hasOwnProperty("playerid_5"))
                if (!$util.isInteger(message.playerid_5))
                    return "playerid_5: integer expected";
            if (message.playerid_6 != null && message.hasOwnProperty("playerid_6"))
                if (!$util.isInteger(message.playerid_6))
                    return "playerid_6: integer expected";
            if (message.value2 != null && message.hasOwnProperty("value2"))
                if (!$util.isInteger(message.value2))
                    return "value2: integer expected";
            if (message.value3 != null && message.hasOwnProperty("value3"))
                if (!$util.isInteger(message.value3))
                    return "value3: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_ChatEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_ChatEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_ChatEvent} CDOTAUserMsg_ChatEvent
         */
        CDOTAUserMsg_ChatEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_ChatEvent)
                return object;
            var message = new $root.CDOTAUserMsg_ChatEvent();
            switch (object.type) {
            case "CHAT_MESSAGE_INVALID":
            case -1:
                message.type = -1;
                break;
            case "CHAT_MESSAGE_HERO_KILL":
            case 0:
                message.type = 0;
                break;
            case "CHAT_MESSAGE_HERO_DENY":
            case 1:
                message.type = 1;
                break;
            case "CHAT_MESSAGE_BARRACKS_KILL":
            case 2:
                message.type = 2;
                break;
            case "CHAT_MESSAGE_TOWER_KILL":
            case 3:
                message.type = 3;
                break;
            case "CHAT_MESSAGE_TOWER_DENY":
            case 4:
                message.type = 4;
                break;
            case "CHAT_MESSAGE_FIRSTBLOOD":
            case 5:
                message.type = 5;
                break;
            case "CHAT_MESSAGE_STREAK_KILL":
            case 6:
                message.type = 6;
                break;
            case "CHAT_MESSAGE_BUYBACK":
            case 7:
                message.type = 7;
                break;
            case "CHAT_MESSAGE_AEGIS":
            case 8:
                message.type = 8;
                break;
            case "CHAT_MESSAGE_ROSHAN_KILL":
            case 9:
                message.type = 9;
                break;
            case "CHAT_MESSAGE_COURIER_LOST":
            case 10:
                message.type = 10;
                break;
            case "CHAT_MESSAGE_COURIER_RESPAWNED":
            case 11:
                message.type = 11;
                break;
            case "CHAT_MESSAGE_GLYPH_USED":
            case 12:
                message.type = 12;
                break;
            case "CHAT_MESSAGE_ITEM_PURCHASE":
            case 13:
                message.type = 13;
                break;
            case "CHAT_MESSAGE_CONNECT":
            case 14:
                message.type = 14;
                break;
            case "CHAT_MESSAGE_DISCONNECT":
            case 15:
                message.type = 15;
                break;
            case "CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT":
            case 16:
                message.type = 16;
                break;
            case "CHAT_MESSAGE_DISCONNECT_TIME_REMAINING":
            case 17:
                message.type = 17;
                break;
            case "CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL":
            case 18:
                message.type = 18;
                break;
            case "CHAT_MESSAGE_RECONNECT":
            case 19:
                message.type = 19;
                break;
            case "CHAT_MESSAGE_PLAYER_LEFT":
            case 20:
                message.type = 20;
                break;
            case "CHAT_MESSAGE_SAFE_TO_LEAVE":
            case 21:
                message.type = 21;
                break;
            case "CHAT_MESSAGE_RUNE_PICKUP":
            case 22:
                message.type = 22;
                break;
            case "CHAT_MESSAGE_RUNE_BOTTLE":
            case 23:
                message.type = 23;
                break;
            case "CHAT_MESSAGE_INTHEBAG":
            case 24:
                message.type = 24;
                break;
            case "CHAT_MESSAGE_SECRETSHOP":
            case 25:
                message.type = 25;
                break;
            case "CHAT_MESSAGE_ITEM_AUTOPURCHASED":
            case 26:
                message.type = 26;
                break;
            case "CHAT_MESSAGE_ITEMS_COMBINED":
            case 27:
                message.type = 27;
                break;
            case "CHAT_MESSAGE_SUPER_CREEPS":
            case 28:
                message.type = 28;
                break;
            case "CHAT_MESSAGE_CANT_USE_ACTION_ITEM":
            case 29:
                message.type = 29;
                break;
            case "CHAT_MESSAGE_CANTPAUSE":
            case 31:
                message.type = 31;
                break;
            case "CHAT_MESSAGE_NOPAUSESLEFT":
            case 32:
                message.type = 32;
                break;
            case "CHAT_MESSAGE_CANTPAUSEYET":
            case 33:
                message.type = 33;
                break;
            case "CHAT_MESSAGE_PAUSED":
            case 34:
                message.type = 34;
                break;
            case "CHAT_MESSAGE_UNPAUSE_COUNTDOWN":
            case 35:
                message.type = 35;
                break;
            case "CHAT_MESSAGE_UNPAUSED":
            case 36:
                message.type = 36;
                break;
            case "CHAT_MESSAGE_AUTO_UNPAUSED":
            case 37:
                message.type = 37;
                break;
            case "CHAT_MESSAGE_YOUPAUSED":
            case 38:
                message.type = 38;
                break;
            case "CHAT_MESSAGE_CANTUNPAUSETEAM":
            case 39:
                message.type = 39;
                break;
            case "CHAT_MESSAGE_VOICE_TEXT_BANNED":
            case 41:
                message.type = 41;
                break;
            case "CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME":
            case 42:
                message.type = 42;
                break;
            case "CHAT_MESSAGE_REPORT_REMINDER":
            case 43:
                message.type = 43;
                break;
            case "CHAT_MESSAGE_ECON_ITEM":
            case 44:
                message.type = 44;
                break;
            case "CHAT_MESSAGE_TAUNT":
            case 45:
                message.type = 45;
                break;
            case "CHAT_MESSAGE_RANDOM":
            case 46:
                message.type = 46;
                break;
            case "CHAT_MESSAGE_RD_TURN":
            case 47:
                message.type = 47;
                break;
            case "CHAT_MESSAGE_DROP_RATE_BONUS":
            case 49:
                message.type = 49;
                break;
            case "CHAT_MESSAGE_NO_BATTLE_POINTS":
            case 50:
                message.type = 50;
                break;
            case "CHAT_MESSAGE_DENIED_AEGIS":
            case 51:
                message.type = 51;
                break;
            case "CHAT_MESSAGE_INFORMATIONAL":
            case 52:
                message.type = 52;
                break;
            case "CHAT_MESSAGE_AEGIS_STOLEN":
            case 53:
                message.type = 53;
                break;
            case "CHAT_MESSAGE_ROSHAN_CANDY":
            case 54:
                message.type = 54;
                break;
            case "CHAT_MESSAGE_ITEM_GIFTED":
            case 55:
                message.type = 55;
                break;
            case "CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL":
            case 56:
                message.type = 56;
                break;
            case "CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED":
            case 57:
                message.type = 57;
                break;
            case "CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED":
            case 58:
                message.type = 58;
                break;
            case "CHAT_MESSAGE_HOLDOUT_WALL_FINISHED":
            case 59:
                message.type = 59;
                break;
            case "CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO":
            case 62:
                message.type = 62;
                break;
            case "CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION":
            case 63:
                message.type = 63;
                break;
            case "CHAT_MESSAGE_DISCONNECT_LIMITED_HERO":
            case 64:
                message.type = 64;
                break;
            case "CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION":
            case 65:
                message.type = 65;
                break;
            case "CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS":
            case 66:
                message.type = 66;
                break;
            case "CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE":
            case 67:
                message.type = 67;
                break;
            case "CHAT_MESSAGE_PLAYER_LEFT_AFK":
            case 73:
                message.type = 73;
                break;
            case "CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG":
            case 74:
                message.type = 74;
                break;
            case "CHAT_MESSAGE_PLAYER_ABANDONED":
            case 75:
                message.type = 75;
                break;
            case "CHAT_MESSAGE_PLAYER_ABANDONED_AFK":
            case 76:
                message.type = 76;
                break;
            case "CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG":
            case 77:
                message.type = 77;
                break;
            case "CHAT_MESSAGE_WILL_NOT_BE_SCORED":
            case 78:
                message.type = 78;
                break;
            case "CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED":
            case 79:
                message.type = 79;
                break;
            case "CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK":
            case 80:
                message.type = 80;
                break;
            case "CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED":
            case 81:
                message.type = 81;
                break;
            case "CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON":
            case 82:
                message.type = 82;
                break;
            case "CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS":
            case 83:
                message.type = 83;
                break;
            case "CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY":
            case 84:
                message.type = 84;
                break;
            case "CHAT_MESSAGE_COMPENDIUM_LEVEL":
            case 85:
                message.type = 85;
                break;
            case "CHAT_MESSAGE_VICTORY_PREDICTION_STREAK":
            case 86:
                message.type = 86;
                break;
            case "CHAT_MESSAGE_ASSASSIN_ANNOUNCE":
            case 87:
                message.type = 87;
                break;
            case "CHAT_MESSAGE_ASSASSIN_SUCCESS":
            case 88:
                message.type = 88;
                break;
            case "CHAT_MESSAGE_ASSASSIN_DENIED":
            case 89:
                message.type = 89;
                break;
            case "CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM":
            case 90:
                message.type = 90;
                break;
            case "CHAT_MESSAGE_EFFIGY_KILL":
            case 91:
                message.type = 91;
                break;
            case "CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW":
            case 92:
                message.type = 92;
                break;
            case "CHAT_MESSAGE_YEAR_BEAST_KILLED":
            case 93:
                message.type = 93;
                break;
            case "CHAT_MESSAGE_PAUSE_COUNTDOWN":
            case 94:
                message.type = 94;
                break;
            case "CHAT_MESSAGE_COINS_WAGERED":
            case 95:
                message.type = 95;
                break;
            case "CHAT_MESSAGE_HERO_NOMINATED_BAN":
            case 96:
                message.type = 96;
                break;
            case "CHAT_MESSAGE_HERO_BANNED":
            case 97:
                message.type = 97;
                break;
            case "CHAT_MESSAGE_HERO_BAN_COUNT":
            case 98:
                message.type = 98;
                break;
            case "CHAT_MESSAGE_RIVER_PAINTED":
            case 99:
                message.type = 99;
                break;
            case "CHAT_MESSAGE_SCAN_USED":
            case 100:
                message.type = 100;
                break;
            case "CHAT_MESSAGE_SHRINE_KILLED":
            case 101:
                message.type = 101;
                break;
            case "CHAT_MESSAGE_WAGER_TOKEN_SPENT":
            case 102:
                message.type = 102;
                break;
            case "CHAT_MESSAGE_RANK_WAGER":
            case 103:
                message.type = 103;
                break;
            case "CHAT_MESSAGE_NEW_PLAYER_REMINDER":
            case 104:
                message.type = 104;
                break;
            case "CHAT_MESSAGE_OBSERVER_WARD_KILLED":
            case 105:
                message.type = 105;
                break;
            case "CHAT_MESSAGE_SENTRY_WARD_KILLED":
            case 106:
                message.type = 106;
                break;
            case "CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH":
            case 107:
                message.type = 107;
                break;
            case "CHAT_MESSAGE_HERO_CHOICE_INVALID":
            case 108:
                message.type = 108;
                break;
            case "CHAT_MESSAGE_BOUNTY":
            case 109:
                message.type = 109;
                break;
            case "CHAT_MESSAGE_ABILITY_DRAFT_START":
            case 110:
                message.type = 110;
                break;
            }
            if (object.value != null)
                message.value = object.value >>> 0;
            if (object.playerid_1 != null)
                message.playerid_1 = object.playerid_1 | 0;
            if (object.playerid_2 != null)
                message.playerid_2 = object.playerid_2 | 0;
            if (object.playerid_3 != null)
                message.playerid_3 = object.playerid_3 | 0;
            if (object.playerid_4 != null)
                message.playerid_4 = object.playerid_4 | 0;
            if (object.playerid_5 != null)
                message.playerid_5 = object.playerid_5 | 0;
            if (object.playerid_6 != null)
                message.playerid_6 = object.playerid_6 | 0;
            if (object.value2 != null)
                message.value2 = object.value2 >>> 0;
            if (object.value3 != null)
                message.value3 = object.value3 >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_ChatEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_ChatEvent
         * @static
         * @param {CDOTAUserMsg_ChatEvent} message CDOTAUserMsg_ChatEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_ChatEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "CHAT_MESSAGE_INVALID" : -1;
                object.value = 0;
                object.playerid_1 = -1;
                object.playerid_2 = -1;
                object.playerid_3 = -1;
                object.playerid_4 = -1;
                object.playerid_5 = -1;
                object.playerid_6 = -1;
                object.value2 = 0;
                object.value3 = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.DOTA_CHAT_MESSAGE[message.type] : message.type;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.playerid_1 != null && message.hasOwnProperty("playerid_1"))
                object.playerid_1 = message.playerid_1;
            if (message.playerid_2 != null && message.hasOwnProperty("playerid_2"))
                object.playerid_2 = message.playerid_2;
            if (message.playerid_3 != null && message.hasOwnProperty("playerid_3"))
                object.playerid_3 = message.playerid_3;
            if (message.playerid_4 != null && message.hasOwnProperty("playerid_4"))
                object.playerid_4 = message.playerid_4;
            if (message.playerid_5 != null && message.hasOwnProperty("playerid_5"))
                object.playerid_5 = message.playerid_5;
            if (message.playerid_6 != null && message.hasOwnProperty("playerid_6"))
                object.playerid_6 = message.playerid_6;
            if (message.value2 != null && message.hasOwnProperty("value2"))
                object.value2 = message.value2;
            if (message.value3 != null && message.hasOwnProperty("value3"))
                object.value3 = message.value3;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_ChatEvent to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_ChatEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_ChatEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_ChatEvent;
    })();
    
    $root.CDOTAUserMsg_BotChat = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_BotChat.
         * @exports ICDOTAUserMsg_BotChat
         * @interface ICDOTAUserMsg_BotChat
         * @property {number|null} [player_id] CDOTAUserMsg_BotChat player_id
         * @property {string|null} [message] CDOTAUserMsg_BotChat message
         * @property {string|null} [target] CDOTAUserMsg_BotChat target
         * @property {boolean|null} [team_only] CDOTAUserMsg_BotChat team_only
         */
    
        /**
         * Constructs a new CDOTAUserMsg_BotChat.
         * @exports CDOTAUserMsg_BotChat
         * @classdesc Represents a CDOTAUserMsg_BotChat.
         * @implements ICDOTAUserMsg_BotChat
         * @constructor
         * @param {ICDOTAUserMsg_BotChat=} [properties] Properties to set
         */
        function CDOTAUserMsg_BotChat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_BotChat player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_BotChat
         * @instance
         */
        CDOTAUserMsg_BotChat.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_BotChat message.
         * @member {string} message
         * @memberof CDOTAUserMsg_BotChat
         * @instance
         */
        CDOTAUserMsg_BotChat.prototype.message = "";
    
        /**
         * CDOTAUserMsg_BotChat target.
         * @member {string} target
         * @memberof CDOTAUserMsg_BotChat
         * @instance
         */
        CDOTAUserMsg_BotChat.prototype.target = "";
    
        /**
         * CDOTAUserMsg_BotChat team_only.
         * @member {boolean} team_only
         * @memberof CDOTAUserMsg_BotChat
         * @instance
         */
        CDOTAUserMsg_BotChat.prototype.team_only = false;
    
        /**
         * Creates a new CDOTAUserMsg_BotChat instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_BotChat
         * @static
         * @param {ICDOTAUserMsg_BotChat=} [properties] Properties to set
         * @returns {CDOTAUserMsg_BotChat} CDOTAUserMsg_BotChat instance
         */
        CDOTAUserMsg_BotChat.create = function create(properties) {
            return new CDOTAUserMsg_BotChat(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_BotChat message. Does not implicitly {@link CDOTAUserMsg_BotChat.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_BotChat
         * @static
         * @param {ICDOTAUserMsg_BotChat} message CDOTAUserMsg_BotChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_BotChat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.message);
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.target);
            if (message.team_only != null && Object.hasOwnProperty.call(message, "team_only"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.team_only);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_BotChat message, length delimited. Does not implicitly {@link CDOTAUserMsg_BotChat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_BotChat
         * @static
         * @param {ICDOTAUserMsg_BotChat} message CDOTAUserMsg_BotChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_BotChat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_BotChat message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_BotChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_BotChat} CDOTAUserMsg_BotChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_BotChat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_BotChat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 3:
                    message.message = reader.string();
                    break;
                case 4:
                    message.target = reader.string();
                    break;
                case 5:
                    message.team_only = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_BotChat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_BotChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_BotChat} CDOTAUserMsg_BotChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_BotChat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_BotChat message.
         * @function verify
         * @memberof CDOTAUserMsg_BotChat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_BotChat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.target != null && message.hasOwnProperty("target"))
                if (!$util.isString(message.target))
                    return "target: string expected";
            if (message.team_only != null && message.hasOwnProperty("team_only"))
                if (typeof message.team_only !== "boolean")
                    return "team_only: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_BotChat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_BotChat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_BotChat} CDOTAUserMsg_BotChat
         */
        CDOTAUserMsg_BotChat.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_BotChat)
                return object;
            var message = new $root.CDOTAUserMsg_BotChat();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.message != null)
                message.message = String(object.message);
            if (object.target != null)
                message.target = String(object.target);
            if (object.team_only != null)
                message.team_only = Boolean(object.team_only);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_BotChat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_BotChat
         * @static
         * @param {CDOTAUserMsg_BotChat} message CDOTAUserMsg_BotChat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_BotChat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.message = "";
                object.target = "";
                object.team_only = false;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = message.target;
            if (message.team_only != null && message.hasOwnProperty("team_only"))
                object.team_only = message.team_only;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_BotChat to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_BotChat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_BotChat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_BotChat;
    })();
    
    $root.CDOTAUserMsg_CombatHeroPositions = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_CombatHeroPositions.
         * @exports ICDOTAUserMsg_CombatHeroPositions
         * @interface ICDOTAUserMsg_CombatHeroPositions
         * @property {number|null} [index] CDOTAUserMsg_CombatHeroPositions index
         * @property {number|null} [time] CDOTAUserMsg_CombatHeroPositions time
         * @property {ICMsgVector2D|null} [world_pos] CDOTAUserMsg_CombatHeroPositions world_pos
         * @property {number|null} [health] CDOTAUserMsg_CombatHeroPositions health
         */
    
        /**
         * Constructs a new CDOTAUserMsg_CombatHeroPositions.
         * @exports CDOTAUserMsg_CombatHeroPositions
         * @classdesc Represents a CDOTAUserMsg_CombatHeroPositions.
         * @implements ICDOTAUserMsg_CombatHeroPositions
         * @constructor
         * @param {ICDOTAUserMsg_CombatHeroPositions=} [properties] Properties to set
         */
        function CDOTAUserMsg_CombatHeroPositions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_CombatHeroPositions index.
         * @member {number} index
         * @memberof CDOTAUserMsg_CombatHeroPositions
         * @instance
         */
        CDOTAUserMsg_CombatHeroPositions.prototype.index = 0;
    
        /**
         * CDOTAUserMsg_CombatHeroPositions time.
         * @member {number} time
         * @memberof CDOTAUserMsg_CombatHeroPositions
         * @instance
         */
        CDOTAUserMsg_CombatHeroPositions.prototype.time = 0;
    
        /**
         * CDOTAUserMsg_CombatHeroPositions world_pos.
         * @member {ICMsgVector2D|null|undefined} world_pos
         * @memberof CDOTAUserMsg_CombatHeroPositions
         * @instance
         */
        CDOTAUserMsg_CombatHeroPositions.prototype.world_pos = null;
    
        /**
         * CDOTAUserMsg_CombatHeroPositions health.
         * @member {number} health
         * @memberof CDOTAUserMsg_CombatHeroPositions
         * @instance
         */
        CDOTAUserMsg_CombatHeroPositions.prototype.health = 0;
    
        /**
         * Creates a new CDOTAUserMsg_CombatHeroPositions instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_CombatHeroPositions
         * @static
         * @param {ICDOTAUserMsg_CombatHeroPositions=} [properties] Properties to set
         * @returns {CDOTAUserMsg_CombatHeroPositions} CDOTAUserMsg_CombatHeroPositions instance
         */
        CDOTAUserMsg_CombatHeroPositions.create = function create(properties) {
            return new CDOTAUserMsg_CombatHeroPositions(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CombatHeroPositions message. Does not implicitly {@link CDOTAUserMsg_CombatHeroPositions.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_CombatHeroPositions
         * @static
         * @param {ICDOTAUserMsg_CombatHeroPositions} message CDOTAUserMsg_CombatHeroPositions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CombatHeroPositions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.time);
            if (message.world_pos != null && Object.hasOwnProperty.call(message, "world_pos"))
                $root.CMsgVector2D.encode(message.world_pos, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.health != null && Object.hasOwnProperty.call(message, "health"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.health);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CombatHeroPositions message, length delimited. Does not implicitly {@link CDOTAUserMsg_CombatHeroPositions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_CombatHeroPositions
         * @static
         * @param {ICDOTAUserMsg_CombatHeroPositions} message CDOTAUserMsg_CombatHeroPositions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CombatHeroPositions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_CombatHeroPositions message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_CombatHeroPositions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_CombatHeroPositions} CDOTAUserMsg_CombatHeroPositions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CombatHeroPositions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_CombatHeroPositions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.uint32();
                    break;
                case 2:
                    message.time = reader.int32();
                    break;
                case 3:
                    message.world_pos = $root.CMsgVector2D.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.health = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_CombatHeroPositions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_CombatHeroPositions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_CombatHeroPositions} CDOTAUserMsg_CombatHeroPositions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CombatHeroPositions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_CombatHeroPositions message.
         * @function verify
         * @memberof CDOTAUserMsg_CombatHeroPositions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_CombatHeroPositions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.world_pos != null && message.hasOwnProperty("world_pos")) {
                var error = $root.CMsgVector2D.verify(message.world_pos);
                if (error)
                    return "world_pos." + error;
            }
            if (message.health != null && message.hasOwnProperty("health"))
                if (!$util.isInteger(message.health))
                    return "health: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_CombatHeroPositions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_CombatHeroPositions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_CombatHeroPositions} CDOTAUserMsg_CombatHeroPositions
         */
        CDOTAUserMsg_CombatHeroPositions.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_CombatHeroPositions)
                return object;
            var message = new $root.CDOTAUserMsg_CombatHeroPositions();
            if (object.index != null)
                message.index = object.index >>> 0;
            if (object.time != null)
                message.time = object.time | 0;
            if (object.world_pos != null) {
                if (typeof object.world_pos !== "object")
                    throw TypeError(".CDOTAUserMsg_CombatHeroPositions.world_pos: object expected");
                message.world_pos = $root.CMsgVector2D.fromObject(object.world_pos);
            }
            if (object.health != null)
                message.health = object.health | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_CombatHeroPositions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_CombatHeroPositions
         * @static
         * @param {CDOTAUserMsg_CombatHeroPositions} message CDOTAUserMsg_CombatHeroPositions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_CombatHeroPositions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.index = 0;
                object.time = 0;
                object.world_pos = null;
                object.health = 0;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.world_pos != null && message.hasOwnProperty("world_pos"))
                object.world_pos = $root.CMsgVector2D.toObject(message.world_pos, options);
            if (message.health != null && message.hasOwnProperty("health"))
                object.health = message.health;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_CombatHeroPositions to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_CombatHeroPositions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_CombatHeroPositions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_CombatHeroPositions;
    })();
    
    $root.CDOTAUserMsg_CombatLogBulkData = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_CombatLogBulkData.
         * @exports ICDOTAUserMsg_CombatLogBulkData
         * @interface ICDOTAUserMsg_CombatLogBulkData
         * @property {Array.<ICMsgDOTACombatLogEntry>|null} [combat_entries] CDOTAUserMsg_CombatLogBulkData combat_entries
         * @property {number|null} [timestamp] CDOTAUserMsg_CombatLogBulkData timestamp
         * @property {number|null} [duration] CDOTAUserMsg_CombatLogBulkData duration
         * @property {number|null} [player_id] CDOTAUserMsg_CombatLogBulkData player_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_CombatLogBulkData.
         * @exports CDOTAUserMsg_CombatLogBulkData
         * @classdesc Represents a CDOTAUserMsg_CombatLogBulkData.
         * @implements ICDOTAUserMsg_CombatLogBulkData
         * @constructor
         * @param {ICDOTAUserMsg_CombatLogBulkData=} [properties] Properties to set
         */
        function CDOTAUserMsg_CombatLogBulkData(properties) {
            this.combat_entries = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_CombatLogBulkData combat_entries.
         * @member {Array.<ICMsgDOTACombatLogEntry>} combat_entries
         * @memberof CDOTAUserMsg_CombatLogBulkData
         * @instance
         */
        CDOTAUserMsg_CombatLogBulkData.prototype.combat_entries = $util.emptyArray;
    
        /**
         * CDOTAUserMsg_CombatLogBulkData timestamp.
         * @member {number} timestamp
         * @memberof CDOTAUserMsg_CombatLogBulkData
         * @instance
         */
        CDOTAUserMsg_CombatLogBulkData.prototype.timestamp = 0;
    
        /**
         * CDOTAUserMsg_CombatLogBulkData duration.
         * @member {number} duration
         * @memberof CDOTAUserMsg_CombatLogBulkData
         * @instance
         */
        CDOTAUserMsg_CombatLogBulkData.prototype.duration = 0;
    
        /**
         * CDOTAUserMsg_CombatLogBulkData player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_CombatLogBulkData
         * @instance
         */
        CDOTAUserMsg_CombatLogBulkData.prototype.player_id = 0;
    
        /**
         * Creates a new CDOTAUserMsg_CombatLogBulkData instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_CombatLogBulkData
         * @static
         * @param {ICDOTAUserMsg_CombatLogBulkData=} [properties] Properties to set
         * @returns {CDOTAUserMsg_CombatLogBulkData} CDOTAUserMsg_CombatLogBulkData instance
         */
        CDOTAUserMsg_CombatLogBulkData.create = function create(properties) {
            return new CDOTAUserMsg_CombatLogBulkData(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CombatLogBulkData message. Does not implicitly {@link CDOTAUserMsg_CombatLogBulkData.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_CombatLogBulkData
         * @static
         * @param {ICDOTAUserMsg_CombatLogBulkData} message CDOTAUserMsg_CombatLogBulkData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CombatLogBulkData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.combat_entries != null && message.combat_entries.length)
                for (var i = 0; i < message.combat_entries.length; ++i)
                    $root.CMsgDOTACombatLogEntry.encode(message.combat_entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.timestamp);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.duration);
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.player_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CombatLogBulkData message, length delimited. Does not implicitly {@link CDOTAUserMsg_CombatLogBulkData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_CombatLogBulkData
         * @static
         * @param {ICDOTAUserMsg_CombatLogBulkData} message CDOTAUserMsg_CombatLogBulkData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CombatLogBulkData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_CombatLogBulkData message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_CombatLogBulkData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_CombatLogBulkData} CDOTAUserMsg_CombatLogBulkData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CombatLogBulkData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_CombatLogBulkData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.combat_entries && message.combat_entries.length))
                        message.combat_entries = [];
                    message.combat_entries.push($root.CMsgDOTACombatLogEntry.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.timestamp = reader.float();
                    break;
                case 3:
                    message.duration = reader.float();
                    break;
                case 4:
                    message.player_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_CombatLogBulkData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_CombatLogBulkData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_CombatLogBulkData} CDOTAUserMsg_CombatLogBulkData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CombatLogBulkData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_CombatLogBulkData message.
         * @function verify
         * @memberof CDOTAUserMsg_CombatLogBulkData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_CombatLogBulkData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.combat_entries != null && message.hasOwnProperty("combat_entries")) {
                if (!Array.isArray(message.combat_entries))
                    return "combat_entries: array expected";
                for (var i = 0; i < message.combat_entries.length; ++i) {
                    var error = $root.CMsgDOTACombatLogEntry.verify(message.combat_entries[i]);
                    if (error)
                        return "combat_entries." + error;
                }
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_CombatLogBulkData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_CombatLogBulkData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_CombatLogBulkData} CDOTAUserMsg_CombatLogBulkData
         */
        CDOTAUserMsg_CombatLogBulkData.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_CombatLogBulkData)
                return object;
            var message = new $root.CDOTAUserMsg_CombatLogBulkData();
            if (object.combat_entries) {
                if (!Array.isArray(object.combat_entries))
                    throw TypeError(".CDOTAUserMsg_CombatLogBulkData.combat_entries: array expected");
                message.combat_entries = [];
                for (var i = 0; i < object.combat_entries.length; ++i) {
                    if (typeof object.combat_entries[i] !== "object")
                        throw TypeError(".CDOTAUserMsg_CombatLogBulkData.combat_entries: object expected");
                    message.combat_entries[i] = $root.CMsgDOTACombatLogEntry.fromObject(object.combat_entries[i]);
                }
            }
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            if (object.duration != null)
                message.duration = Number(object.duration);
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_CombatLogBulkData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_CombatLogBulkData
         * @static
         * @param {CDOTAUserMsg_CombatLogBulkData} message CDOTAUserMsg_CombatLogBulkData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_CombatLogBulkData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.combat_entries = [];
            if (options.defaults) {
                object.timestamp = 0;
                object.duration = 0;
                object.player_id = 0;
            }
            if (message.combat_entries && message.combat_entries.length) {
                object.combat_entries = [];
                for (var j = 0; j < message.combat_entries.length; ++j)
                    object.combat_entries[j] = $root.CMsgDOTACombatLogEntry.toObject(message.combat_entries[j], options);
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_CombatLogBulkData to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_CombatLogBulkData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_CombatLogBulkData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_CombatLogBulkData;
    })();
    
    $root.CDOTAUserMsg_MiniKillCamInfo = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_MiniKillCamInfo.
         * @exports ICDOTAUserMsg_MiniKillCamInfo
         * @interface ICDOTAUserMsg_MiniKillCamInfo
         * @property {Array.<CDOTAUserMsg_MiniKillCamInfo.IAttacker>|null} [attackers] CDOTAUserMsg_MiniKillCamInfo attackers
         */
    
        /**
         * Constructs a new CDOTAUserMsg_MiniKillCamInfo.
         * @exports CDOTAUserMsg_MiniKillCamInfo
         * @classdesc Represents a CDOTAUserMsg_MiniKillCamInfo.
         * @implements ICDOTAUserMsg_MiniKillCamInfo
         * @constructor
         * @param {ICDOTAUserMsg_MiniKillCamInfo=} [properties] Properties to set
         */
        function CDOTAUserMsg_MiniKillCamInfo(properties) {
            this.attackers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_MiniKillCamInfo attackers.
         * @member {Array.<CDOTAUserMsg_MiniKillCamInfo.IAttacker>} attackers
         * @memberof CDOTAUserMsg_MiniKillCamInfo
         * @instance
         */
        CDOTAUserMsg_MiniKillCamInfo.prototype.attackers = $util.emptyArray;
    
        /**
         * Creates a new CDOTAUserMsg_MiniKillCamInfo instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_MiniKillCamInfo
         * @static
         * @param {ICDOTAUserMsg_MiniKillCamInfo=} [properties] Properties to set
         * @returns {CDOTAUserMsg_MiniKillCamInfo} CDOTAUserMsg_MiniKillCamInfo instance
         */
        CDOTAUserMsg_MiniKillCamInfo.create = function create(properties) {
            return new CDOTAUserMsg_MiniKillCamInfo(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_MiniKillCamInfo message. Does not implicitly {@link CDOTAUserMsg_MiniKillCamInfo.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_MiniKillCamInfo
         * @static
         * @param {ICDOTAUserMsg_MiniKillCamInfo} message CDOTAUserMsg_MiniKillCamInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_MiniKillCamInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.attackers != null && message.attackers.length)
                for (var i = 0; i < message.attackers.length; ++i)
                    $root.CDOTAUserMsg_MiniKillCamInfo.Attacker.encode(message.attackers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_MiniKillCamInfo message, length delimited. Does not implicitly {@link CDOTAUserMsg_MiniKillCamInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_MiniKillCamInfo
         * @static
         * @param {ICDOTAUserMsg_MiniKillCamInfo} message CDOTAUserMsg_MiniKillCamInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_MiniKillCamInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_MiniKillCamInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_MiniKillCamInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_MiniKillCamInfo} CDOTAUserMsg_MiniKillCamInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_MiniKillCamInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_MiniKillCamInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.attackers && message.attackers.length))
                        message.attackers = [];
                    message.attackers.push($root.CDOTAUserMsg_MiniKillCamInfo.Attacker.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_MiniKillCamInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_MiniKillCamInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_MiniKillCamInfo} CDOTAUserMsg_MiniKillCamInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_MiniKillCamInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_MiniKillCamInfo message.
         * @function verify
         * @memberof CDOTAUserMsg_MiniKillCamInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_MiniKillCamInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.attackers != null && message.hasOwnProperty("attackers")) {
                if (!Array.isArray(message.attackers))
                    return "attackers: array expected";
                for (var i = 0; i < message.attackers.length; ++i) {
                    var error = $root.CDOTAUserMsg_MiniKillCamInfo.Attacker.verify(message.attackers[i]);
                    if (error)
                        return "attackers." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_MiniKillCamInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_MiniKillCamInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_MiniKillCamInfo} CDOTAUserMsg_MiniKillCamInfo
         */
        CDOTAUserMsg_MiniKillCamInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_MiniKillCamInfo)
                return object;
            var message = new $root.CDOTAUserMsg_MiniKillCamInfo();
            if (object.attackers) {
                if (!Array.isArray(object.attackers))
                    throw TypeError(".CDOTAUserMsg_MiniKillCamInfo.attackers: array expected");
                message.attackers = [];
                for (var i = 0; i < object.attackers.length; ++i) {
                    if (typeof object.attackers[i] !== "object")
                        throw TypeError(".CDOTAUserMsg_MiniKillCamInfo.attackers: object expected");
                    message.attackers[i] = $root.CDOTAUserMsg_MiniKillCamInfo.Attacker.fromObject(object.attackers[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_MiniKillCamInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_MiniKillCamInfo
         * @static
         * @param {CDOTAUserMsg_MiniKillCamInfo} message CDOTAUserMsg_MiniKillCamInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_MiniKillCamInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.attackers = [];
            if (message.attackers && message.attackers.length) {
                object.attackers = [];
                for (var j = 0; j < message.attackers.length; ++j)
                    object.attackers[j] = $root.CDOTAUserMsg_MiniKillCamInfo.Attacker.toObject(message.attackers[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_MiniKillCamInfo to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_MiniKillCamInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_MiniKillCamInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CDOTAUserMsg_MiniKillCamInfo.Attacker = (function() {
    
            /**
             * Properties of an Attacker.
             * @memberof CDOTAUserMsg_MiniKillCamInfo
             * @interface IAttacker
             * @property {number|null} [attacker] Attacker attacker
             * @property {number|null} [total_damage] Attacker total_damage
             * @property {Array.<CDOTAUserMsg_MiniKillCamInfo.Attacker.IAbility>|null} [abilities] Attacker abilities
             * @property {string|null} [attacker_name] Attacker attacker_name
             */
    
            /**
             * Constructs a new Attacker.
             * @memberof CDOTAUserMsg_MiniKillCamInfo
             * @classdesc Represents an Attacker.
             * @implements IAttacker
             * @constructor
             * @param {CDOTAUserMsg_MiniKillCamInfo.IAttacker=} [properties] Properties to set
             */
            function Attacker(properties) {
                this.abilities = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Attacker attacker.
             * @member {number} attacker
             * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker
             * @instance
             */
            Attacker.prototype.attacker = 0;
    
            /**
             * Attacker total_damage.
             * @member {number} total_damage
             * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker
             * @instance
             */
            Attacker.prototype.total_damage = 0;
    
            /**
             * Attacker abilities.
             * @member {Array.<CDOTAUserMsg_MiniKillCamInfo.Attacker.IAbility>} abilities
             * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker
             * @instance
             */
            Attacker.prototype.abilities = $util.emptyArray;
    
            /**
             * Attacker attacker_name.
             * @member {string} attacker_name
             * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker
             * @instance
             */
            Attacker.prototype.attacker_name = "";
    
            /**
             * Creates a new Attacker instance using the specified properties.
             * @function create
             * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker
             * @static
             * @param {CDOTAUserMsg_MiniKillCamInfo.IAttacker=} [properties] Properties to set
             * @returns {CDOTAUserMsg_MiniKillCamInfo.Attacker} Attacker instance
             */
            Attacker.create = function create(properties) {
                return new Attacker(properties);
            };
    
            /**
             * Encodes the specified Attacker message. Does not implicitly {@link CDOTAUserMsg_MiniKillCamInfo.Attacker.verify|verify} messages.
             * @function encode
             * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker
             * @static
             * @param {CDOTAUserMsg_MiniKillCamInfo.IAttacker} message Attacker message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Attacker.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.attacker != null && Object.hasOwnProperty.call(message, "attacker"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.attacker);
                if (message.total_damage != null && Object.hasOwnProperty.call(message, "total_damage"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.total_damage);
                if (message.abilities != null && message.abilities.length)
                    for (var i = 0; i < message.abilities.length; ++i)
                        $root.CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability.encode(message.abilities[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.attacker_name != null && Object.hasOwnProperty.call(message, "attacker_name"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.attacker_name);
                return writer;
            };
    
            /**
             * Encodes the specified Attacker message, length delimited. Does not implicitly {@link CDOTAUserMsg_MiniKillCamInfo.Attacker.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker
             * @static
             * @param {CDOTAUserMsg_MiniKillCamInfo.IAttacker} message Attacker message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Attacker.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Attacker message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTAUserMsg_MiniKillCamInfo.Attacker} Attacker
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Attacker.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_MiniKillCamInfo.Attacker();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.attacker = reader.uint32();
                        break;
                    case 2:
                        message.total_damage = reader.int32();
                        break;
                    case 3:
                        if (!(message.abilities && message.abilities.length))
                            message.abilities = [];
                        message.abilities.push($root.CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.attacker_name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Attacker message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTAUserMsg_MiniKillCamInfo.Attacker} Attacker
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Attacker.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Attacker message.
             * @function verify
             * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Attacker.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.attacker != null && message.hasOwnProperty("attacker"))
                    if (!$util.isInteger(message.attacker))
                        return "attacker: integer expected";
                if (message.total_damage != null && message.hasOwnProperty("total_damage"))
                    if (!$util.isInteger(message.total_damage))
                        return "total_damage: integer expected";
                if (message.abilities != null && message.hasOwnProperty("abilities")) {
                    if (!Array.isArray(message.abilities))
                        return "abilities: array expected";
                    for (var i = 0; i < message.abilities.length; ++i) {
                        var error = $root.CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability.verify(message.abilities[i]);
                        if (error)
                            return "abilities." + error;
                    }
                }
                if (message.attacker_name != null && message.hasOwnProperty("attacker_name"))
                    if (!$util.isString(message.attacker_name))
                        return "attacker_name: string expected";
                return null;
            };
    
            /**
             * Creates an Attacker message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTAUserMsg_MiniKillCamInfo.Attacker} Attacker
             */
            Attacker.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTAUserMsg_MiniKillCamInfo.Attacker)
                    return object;
                var message = new $root.CDOTAUserMsg_MiniKillCamInfo.Attacker();
                if (object.attacker != null)
                    message.attacker = object.attacker >>> 0;
                if (object.total_damage != null)
                    message.total_damage = object.total_damage | 0;
                if (object.abilities) {
                    if (!Array.isArray(object.abilities))
                        throw TypeError(".CDOTAUserMsg_MiniKillCamInfo.Attacker.abilities: array expected");
                    message.abilities = [];
                    for (var i = 0; i < object.abilities.length; ++i) {
                        if (typeof object.abilities[i] !== "object")
                            throw TypeError(".CDOTAUserMsg_MiniKillCamInfo.Attacker.abilities: object expected");
                        message.abilities[i] = $root.CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability.fromObject(object.abilities[i]);
                    }
                }
                if (object.attacker_name != null)
                    message.attacker_name = String(object.attacker_name);
                return message;
            };
    
            /**
             * Creates a plain object from an Attacker message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker
             * @static
             * @param {CDOTAUserMsg_MiniKillCamInfo.Attacker} message Attacker
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Attacker.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.abilities = [];
                if (options.defaults) {
                    object.attacker = 0;
                    object.total_damage = 0;
                    object.attacker_name = "";
                }
                if (message.attacker != null && message.hasOwnProperty("attacker"))
                    object.attacker = message.attacker;
                if (message.total_damage != null && message.hasOwnProperty("total_damage"))
                    object.total_damage = message.total_damage;
                if (message.abilities && message.abilities.length) {
                    object.abilities = [];
                    for (var j = 0; j < message.abilities.length; ++j)
                        object.abilities[j] = $root.CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability.toObject(message.abilities[j], options);
                }
                if (message.attacker_name != null && message.hasOwnProperty("attacker_name"))
                    object.attacker_name = message.attacker_name;
                return object;
            };
    
            /**
             * Converts this Attacker to JSON.
             * @function toJSON
             * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Attacker.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            Attacker.Ability = (function() {
    
                /**
                 * Properties of an Ability.
                 * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker
                 * @interface IAbility
                 * @property {number|null} [ability_id] Ability ability_id
                 * @property {number|null} [damage] Ability damage
                 */
    
                /**
                 * Constructs a new Ability.
                 * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker
                 * @classdesc Represents an Ability.
                 * @implements IAbility
                 * @constructor
                 * @param {CDOTAUserMsg_MiniKillCamInfo.Attacker.IAbility=} [properties] Properties to set
                 */
                function Ability(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Ability ability_id.
                 * @member {number} ability_id
                 * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability
                 * @instance
                 */
                Ability.prototype.ability_id = 0;
    
                /**
                 * Ability damage.
                 * @member {number} damage
                 * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability
                 * @instance
                 */
                Ability.prototype.damage = 0;
    
                /**
                 * Creates a new Ability instance using the specified properties.
                 * @function create
                 * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability
                 * @static
                 * @param {CDOTAUserMsg_MiniKillCamInfo.Attacker.IAbility=} [properties] Properties to set
                 * @returns {CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability} Ability instance
                 */
                Ability.create = function create(properties) {
                    return new Ability(properties);
                };
    
                /**
                 * Encodes the specified Ability message. Does not implicitly {@link CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability.verify|verify} messages.
                 * @function encode
                 * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability
                 * @static
                 * @param {CDOTAUserMsg_MiniKillCamInfo.Attacker.IAbility} message Ability message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ability.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ability_id != null && Object.hasOwnProperty.call(message, "ability_id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ability_id);
                    if (message.damage != null && Object.hasOwnProperty.call(message, "damage"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.damage);
                    return writer;
                };
    
                /**
                 * Encodes the specified Ability message, length delimited. Does not implicitly {@link CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability
                 * @static
                 * @param {CDOTAUserMsg_MiniKillCamInfo.Attacker.IAbility} message Ability message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ability.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Ability message from the specified reader or buffer.
                 * @function decode
                 * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability} Ability
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ability.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ability_id = reader.uint32();
                            break;
                        case 2:
                            message.damage = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Ability message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability} Ability
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ability.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Ability message.
                 * @function verify
                 * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Ability.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ability_id != null && message.hasOwnProperty("ability_id"))
                        if (!$util.isInteger(message.ability_id))
                            return "ability_id: integer expected";
                    if (message.damage != null && message.hasOwnProperty("damage"))
                        if (!$util.isInteger(message.damage))
                            return "damage: integer expected";
                    return null;
                };
    
                /**
                 * Creates an Ability message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability} Ability
                 */
                Ability.fromObject = function fromObject(object) {
                    if (object instanceof $root.CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability)
                        return object;
                    var message = new $root.CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability();
                    if (object.ability_id != null)
                        message.ability_id = object.ability_id >>> 0;
                    if (object.damage != null)
                        message.damage = object.damage | 0;
                    return message;
                };
    
                /**
                 * Creates a plain object from an Ability message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability
                 * @static
                 * @param {CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability} message Ability
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Ability.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.ability_id = 0;
                        object.damage = 0;
                    }
                    if (message.ability_id != null && message.hasOwnProperty("ability_id"))
                        object.ability_id = message.ability_id;
                    if (message.damage != null && message.hasOwnProperty("damage"))
                        object.damage = message.damage;
                    return object;
                };
    
                /**
                 * Converts this Ability to JSON.
                 * @function toJSON
                 * @memberof CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Ability.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Ability;
            })();
    
            return Attacker;
        })();
    
        return CDOTAUserMsg_MiniKillCamInfo;
    })();
    
    $root.CDOTAUserMsg_GlobalLightColor = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_GlobalLightColor.
         * @exports ICDOTAUserMsg_GlobalLightColor
         * @interface ICDOTAUserMsg_GlobalLightColor
         * @property {number|null} [color] CDOTAUserMsg_GlobalLightColor color
         * @property {number|null} [duration] CDOTAUserMsg_GlobalLightColor duration
         */
    
        /**
         * Constructs a new CDOTAUserMsg_GlobalLightColor.
         * @exports CDOTAUserMsg_GlobalLightColor
         * @classdesc Represents a CDOTAUserMsg_GlobalLightColor.
         * @implements ICDOTAUserMsg_GlobalLightColor
         * @constructor
         * @param {ICDOTAUserMsg_GlobalLightColor=} [properties] Properties to set
         */
        function CDOTAUserMsg_GlobalLightColor(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_GlobalLightColor color.
         * @member {number} color
         * @memberof CDOTAUserMsg_GlobalLightColor
         * @instance
         */
        CDOTAUserMsg_GlobalLightColor.prototype.color = 0;
    
        /**
         * CDOTAUserMsg_GlobalLightColor duration.
         * @member {number} duration
         * @memberof CDOTAUserMsg_GlobalLightColor
         * @instance
         */
        CDOTAUserMsg_GlobalLightColor.prototype.duration = 0;
    
        /**
         * Creates a new CDOTAUserMsg_GlobalLightColor instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_GlobalLightColor
         * @static
         * @param {ICDOTAUserMsg_GlobalLightColor=} [properties] Properties to set
         * @returns {CDOTAUserMsg_GlobalLightColor} CDOTAUserMsg_GlobalLightColor instance
         */
        CDOTAUserMsg_GlobalLightColor.create = function create(properties) {
            return new CDOTAUserMsg_GlobalLightColor(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_GlobalLightColor message. Does not implicitly {@link CDOTAUserMsg_GlobalLightColor.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_GlobalLightColor
         * @static
         * @param {ICDOTAUserMsg_GlobalLightColor} message CDOTAUserMsg_GlobalLightColor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_GlobalLightColor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.color);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.duration);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_GlobalLightColor message, length delimited. Does not implicitly {@link CDOTAUserMsg_GlobalLightColor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_GlobalLightColor
         * @static
         * @param {ICDOTAUserMsg_GlobalLightColor} message CDOTAUserMsg_GlobalLightColor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_GlobalLightColor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_GlobalLightColor message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_GlobalLightColor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_GlobalLightColor} CDOTAUserMsg_GlobalLightColor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_GlobalLightColor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_GlobalLightColor();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.color = reader.uint32();
                    break;
                case 2:
                    message.duration = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_GlobalLightColor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_GlobalLightColor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_GlobalLightColor} CDOTAUserMsg_GlobalLightColor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_GlobalLightColor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_GlobalLightColor message.
         * @function verify
         * @memberof CDOTAUserMsg_GlobalLightColor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_GlobalLightColor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isInteger(message.color))
                    return "color: integer expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_GlobalLightColor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_GlobalLightColor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_GlobalLightColor} CDOTAUserMsg_GlobalLightColor
         */
        CDOTAUserMsg_GlobalLightColor.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_GlobalLightColor)
                return object;
            var message = new $root.CDOTAUserMsg_GlobalLightColor();
            if (object.color != null)
                message.color = object.color >>> 0;
            if (object.duration != null)
                message.duration = Number(object.duration);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_GlobalLightColor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_GlobalLightColor
         * @static
         * @param {CDOTAUserMsg_GlobalLightColor} message CDOTAUserMsg_GlobalLightColor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_GlobalLightColor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.color = 0;
                object.duration = 0;
            }
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_GlobalLightColor to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_GlobalLightColor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_GlobalLightColor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_GlobalLightColor;
    })();
    
    $root.CDOTAUserMsg_GlobalLightDirection = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_GlobalLightDirection.
         * @exports ICDOTAUserMsg_GlobalLightDirection
         * @interface ICDOTAUserMsg_GlobalLightDirection
         * @property {ICMsgVector|null} [direction] CDOTAUserMsg_GlobalLightDirection direction
         * @property {number|null} [duration] CDOTAUserMsg_GlobalLightDirection duration
         */
    
        /**
         * Constructs a new CDOTAUserMsg_GlobalLightDirection.
         * @exports CDOTAUserMsg_GlobalLightDirection
         * @classdesc Represents a CDOTAUserMsg_GlobalLightDirection.
         * @implements ICDOTAUserMsg_GlobalLightDirection
         * @constructor
         * @param {ICDOTAUserMsg_GlobalLightDirection=} [properties] Properties to set
         */
        function CDOTAUserMsg_GlobalLightDirection(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_GlobalLightDirection direction.
         * @member {ICMsgVector|null|undefined} direction
         * @memberof CDOTAUserMsg_GlobalLightDirection
         * @instance
         */
        CDOTAUserMsg_GlobalLightDirection.prototype.direction = null;
    
        /**
         * CDOTAUserMsg_GlobalLightDirection duration.
         * @member {number} duration
         * @memberof CDOTAUserMsg_GlobalLightDirection
         * @instance
         */
        CDOTAUserMsg_GlobalLightDirection.prototype.duration = 0;
    
        /**
         * Creates a new CDOTAUserMsg_GlobalLightDirection instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_GlobalLightDirection
         * @static
         * @param {ICDOTAUserMsg_GlobalLightDirection=} [properties] Properties to set
         * @returns {CDOTAUserMsg_GlobalLightDirection} CDOTAUserMsg_GlobalLightDirection instance
         */
        CDOTAUserMsg_GlobalLightDirection.create = function create(properties) {
            return new CDOTAUserMsg_GlobalLightDirection(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_GlobalLightDirection message. Does not implicitly {@link CDOTAUserMsg_GlobalLightDirection.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_GlobalLightDirection
         * @static
         * @param {ICDOTAUserMsg_GlobalLightDirection} message CDOTAUserMsg_GlobalLightDirection message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_GlobalLightDirection.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                $root.CMsgVector.encode(message.direction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.duration);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_GlobalLightDirection message, length delimited. Does not implicitly {@link CDOTAUserMsg_GlobalLightDirection.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_GlobalLightDirection
         * @static
         * @param {ICDOTAUserMsg_GlobalLightDirection} message CDOTAUserMsg_GlobalLightDirection message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_GlobalLightDirection.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_GlobalLightDirection message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_GlobalLightDirection
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_GlobalLightDirection} CDOTAUserMsg_GlobalLightDirection
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_GlobalLightDirection.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_GlobalLightDirection();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.direction = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.duration = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_GlobalLightDirection message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_GlobalLightDirection
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_GlobalLightDirection} CDOTAUserMsg_GlobalLightDirection
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_GlobalLightDirection.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_GlobalLightDirection message.
         * @function verify
         * @memberof CDOTAUserMsg_GlobalLightDirection
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_GlobalLightDirection.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.direction != null && message.hasOwnProperty("direction")) {
                var error = $root.CMsgVector.verify(message.direction);
                if (error)
                    return "direction." + error;
            }
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_GlobalLightDirection message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_GlobalLightDirection
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_GlobalLightDirection} CDOTAUserMsg_GlobalLightDirection
         */
        CDOTAUserMsg_GlobalLightDirection.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_GlobalLightDirection)
                return object;
            var message = new $root.CDOTAUserMsg_GlobalLightDirection();
            if (object.direction != null) {
                if (typeof object.direction !== "object")
                    throw TypeError(".CDOTAUserMsg_GlobalLightDirection.direction: object expected");
                message.direction = $root.CMsgVector.fromObject(object.direction);
            }
            if (object.duration != null)
                message.duration = Number(object.duration);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_GlobalLightDirection message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_GlobalLightDirection
         * @static
         * @param {CDOTAUserMsg_GlobalLightDirection} message CDOTAUserMsg_GlobalLightDirection
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_GlobalLightDirection.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.direction = null;
                object.duration = 0;
            }
            if (message.direction != null && message.hasOwnProperty("direction"))
                object.direction = $root.CMsgVector.toObject(message.direction, options);
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_GlobalLightDirection to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_GlobalLightDirection
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_GlobalLightDirection.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_GlobalLightDirection;
    })();
    
    $root.CDOTAUserMsg_LocationPing = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_LocationPing.
         * @exports ICDOTAUserMsg_LocationPing
         * @interface ICDOTAUserMsg_LocationPing
         * @property {number|null} [player_id] CDOTAUserMsg_LocationPing player_id
         * @property {ICDOTAMsg_LocationPing|null} [location_ping] CDOTAUserMsg_LocationPing location_ping
         */
    
        /**
         * Constructs a new CDOTAUserMsg_LocationPing.
         * @exports CDOTAUserMsg_LocationPing
         * @classdesc Represents a CDOTAUserMsg_LocationPing.
         * @implements ICDOTAUserMsg_LocationPing
         * @constructor
         * @param {ICDOTAUserMsg_LocationPing=} [properties] Properties to set
         */
        function CDOTAUserMsg_LocationPing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_LocationPing player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_LocationPing
         * @instance
         */
        CDOTAUserMsg_LocationPing.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_LocationPing location_ping.
         * @member {ICDOTAMsg_LocationPing|null|undefined} location_ping
         * @memberof CDOTAUserMsg_LocationPing
         * @instance
         */
        CDOTAUserMsg_LocationPing.prototype.location_ping = null;
    
        /**
         * Creates a new CDOTAUserMsg_LocationPing instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_LocationPing
         * @static
         * @param {ICDOTAUserMsg_LocationPing=} [properties] Properties to set
         * @returns {CDOTAUserMsg_LocationPing} CDOTAUserMsg_LocationPing instance
         */
        CDOTAUserMsg_LocationPing.create = function create(properties) {
            return new CDOTAUserMsg_LocationPing(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_LocationPing message. Does not implicitly {@link CDOTAUserMsg_LocationPing.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_LocationPing
         * @static
         * @param {ICDOTAUserMsg_LocationPing} message CDOTAUserMsg_LocationPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_LocationPing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.location_ping != null && Object.hasOwnProperty.call(message, "location_ping"))
                $root.CDOTAMsg_LocationPing.encode(message.location_ping, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_LocationPing message, length delimited. Does not implicitly {@link CDOTAUserMsg_LocationPing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_LocationPing
         * @static
         * @param {ICDOTAUserMsg_LocationPing} message CDOTAUserMsg_LocationPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_LocationPing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_LocationPing message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_LocationPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_LocationPing} CDOTAUserMsg_LocationPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_LocationPing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_LocationPing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.location_ping = $root.CDOTAMsg_LocationPing.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_LocationPing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_LocationPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_LocationPing} CDOTAUserMsg_LocationPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_LocationPing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_LocationPing message.
         * @function verify
         * @memberof CDOTAUserMsg_LocationPing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_LocationPing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.location_ping != null && message.hasOwnProperty("location_ping")) {
                var error = $root.CDOTAMsg_LocationPing.verify(message.location_ping);
                if (error)
                    return "location_ping." + error;
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_LocationPing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_LocationPing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_LocationPing} CDOTAUserMsg_LocationPing
         */
        CDOTAUserMsg_LocationPing.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_LocationPing)
                return object;
            var message = new $root.CDOTAUserMsg_LocationPing();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.location_ping != null) {
                if (typeof object.location_ping !== "object")
                    throw TypeError(".CDOTAUserMsg_LocationPing.location_ping: object expected");
                message.location_ping = $root.CDOTAMsg_LocationPing.fromObject(object.location_ping);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_LocationPing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_LocationPing
         * @static
         * @param {CDOTAUserMsg_LocationPing} message CDOTAUserMsg_LocationPing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_LocationPing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.location_ping = null;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.location_ping != null && message.hasOwnProperty("location_ping"))
                object.location_ping = $root.CDOTAMsg_LocationPing.toObject(message.location_ping, options);
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_LocationPing to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_LocationPing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_LocationPing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_LocationPing;
    })();
    
    $root.CDOTAUserMsg_ItemAlert = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_ItemAlert.
         * @exports ICDOTAUserMsg_ItemAlert
         * @interface ICDOTAUserMsg_ItemAlert
         * @property {number|null} [player_id] CDOTAUserMsg_ItemAlert player_id
         * @property {ICDOTAMsg_ItemAlert|null} [item_alert] CDOTAUserMsg_ItemAlert item_alert
         */
    
        /**
         * Constructs a new CDOTAUserMsg_ItemAlert.
         * @exports CDOTAUserMsg_ItemAlert
         * @classdesc Represents a CDOTAUserMsg_ItemAlert.
         * @implements ICDOTAUserMsg_ItemAlert
         * @constructor
         * @param {ICDOTAUserMsg_ItemAlert=} [properties] Properties to set
         */
        function CDOTAUserMsg_ItemAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_ItemAlert player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_ItemAlert
         * @instance
         */
        CDOTAUserMsg_ItemAlert.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_ItemAlert item_alert.
         * @member {ICDOTAMsg_ItemAlert|null|undefined} item_alert
         * @memberof CDOTAUserMsg_ItemAlert
         * @instance
         */
        CDOTAUserMsg_ItemAlert.prototype.item_alert = null;
    
        /**
         * Creates a new CDOTAUserMsg_ItemAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_ItemAlert
         * @static
         * @param {ICDOTAUserMsg_ItemAlert=} [properties] Properties to set
         * @returns {CDOTAUserMsg_ItemAlert} CDOTAUserMsg_ItemAlert instance
         */
        CDOTAUserMsg_ItemAlert.create = function create(properties) {
            return new CDOTAUserMsg_ItemAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ItemAlert message. Does not implicitly {@link CDOTAUserMsg_ItemAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_ItemAlert
         * @static
         * @param {ICDOTAUserMsg_ItemAlert} message CDOTAUserMsg_ItemAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ItemAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.item_alert != null && Object.hasOwnProperty.call(message, "item_alert"))
                $root.CDOTAMsg_ItemAlert.encode(message.item_alert, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ItemAlert message, length delimited. Does not implicitly {@link CDOTAUserMsg_ItemAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_ItemAlert
         * @static
         * @param {ICDOTAUserMsg_ItemAlert} message CDOTAUserMsg_ItemAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ItemAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_ItemAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_ItemAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_ItemAlert} CDOTAUserMsg_ItemAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ItemAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_ItemAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.item_alert = $root.CDOTAMsg_ItemAlert.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_ItemAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_ItemAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_ItemAlert} CDOTAUserMsg_ItemAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ItemAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_ItemAlert message.
         * @function verify
         * @memberof CDOTAUserMsg_ItemAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_ItemAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.item_alert != null && message.hasOwnProperty("item_alert")) {
                var error = $root.CDOTAMsg_ItemAlert.verify(message.item_alert);
                if (error)
                    return "item_alert." + error;
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_ItemAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_ItemAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_ItemAlert} CDOTAUserMsg_ItemAlert
         */
        CDOTAUserMsg_ItemAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_ItemAlert)
                return object;
            var message = new $root.CDOTAUserMsg_ItemAlert();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.item_alert != null) {
                if (typeof object.item_alert !== "object")
                    throw TypeError(".CDOTAUserMsg_ItemAlert.item_alert: object expected");
                message.item_alert = $root.CDOTAMsg_ItemAlert.fromObject(object.item_alert);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_ItemAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_ItemAlert
         * @static
         * @param {CDOTAUserMsg_ItemAlert} message CDOTAUserMsg_ItemAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_ItemAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.item_alert = null;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.item_alert != null && message.hasOwnProperty("item_alert"))
                object.item_alert = $root.CDOTAMsg_ItemAlert.toObject(message.item_alert, options);
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_ItemAlert to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_ItemAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_ItemAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_ItemAlert;
    })();
    
    $root.CDOTAUserMsg_EnemyItemAlert = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_EnemyItemAlert.
         * @exports ICDOTAUserMsg_EnemyItemAlert
         * @interface ICDOTAUserMsg_EnemyItemAlert
         * @property {number|null} [player_id] CDOTAUserMsg_EnemyItemAlert player_id
         * @property {number|null} [target_player_id] CDOTAUserMsg_EnemyItemAlert target_player_id
         * @property {number|null} [item_ability_id] CDOTAUserMsg_EnemyItemAlert item_ability_id
         * @property {number|null} [rune_type] CDOTAUserMsg_EnemyItemAlert rune_type
         * @property {number|null} [entity_id] CDOTAUserMsg_EnemyItemAlert entity_id
         * @property {number|null} [item_level] CDOTAUserMsg_EnemyItemAlert item_level
         * @property {number|null} [primary_charges] CDOTAUserMsg_EnemyItemAlert primary_charges
         * @property {number|null} [secondary_charges] CDOTAUserMsg_EnemyItemAlert secondary_charges
         */
    
        /**
         * Constructs a new CDOTAUserMsg_EnemyItemAlert.
         * @exports CDOTAUserMsg_EnemyItemAlert
         * @classdesc Represents a CDOTAUserMsg_EnemyItemAlert.
         * @implements ICDOTAUserMsg_EnemyItemAlert
         * @constructor
         * @param {ICDOTAUserMsg_EnemyItemAlert=} [properties] Properties to set
         */
        function CDOTAUserMsg_EnemyItemAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_EnemyItemAlert player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_EnemyItemAlert
         * @instance
         */
        CDOTAUserMsg_EnemyItemAlert.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_EnemyItemAlert target_player_id.
         * @member {number} target_player_id
         * @memberof CDOTAUserMsg_EnemyItemAlert
         * @instance
         */
        CDOTAUserMsg_EnemyItemAlert.prototype.target_player_id = 0;
    
        /**
         * CDOTAUserMsg_EnemyItemAlert item_ability_id.
         * @member {number} item_ability_id
         * @memberof CDOTAUserMsg_EnemyItemAlert
         * @instance
         */
        CDOTAUserMsg_EnemyItemAlert.prototype.item_ability_id = 0;
    
        /**
         * CDOTAUserMsg_EnemyItemAlert rune_type.
         * @member {number} rune_type
         * @memberof CDOTAUserMsg_EnemyItemAlert
         * @instance
         */
        CDOTAUserMsg_EnemyItemAlert.prototype.rune_type = -1;
    
        /**
         * CDOTAUserMsg_EnemyItemAlert entity_id.
         * @member {number} entity_id
         * @memberof CDOTAUserMsg_EnemyItemAlert
         * @instance
         */
        CDOTAUserMsg_EnemyItemAlert.prototype.entity_id = 0;
    
        /**
         * CDOTAUserMsg_EnemyItemAlert item_level.
         * @member {number} item_level
         * @memberof CDOTAUserMsg_EnemyItemAlert
         * @instance
         */
        CDOTAUserMsg_EnemyItemAlert.prototype.item_level = -1;
    
        /**
         * CDOTAUserMsg_EnemyItemAlert primary_charges.
         * @member {number} primary_charges
         * @memberof CDOTAUserMsg_EnemyItemAlert
         * @instance
         */
        CDOTAUserMsg_EnemyItemAlert.prototype.primary_charges = -1;
    
        /**
         * CDOTAUserMsg_EnemyItemAlert secondary_charges.
         * @member {number} secondary_charges
         * @memberof CDOTAUserMsg_EnemyItemAlert
         * @instance
         */
        CDOTAUserMsg_EnemyItemAlert.prototype.secondary_charges = -1;
    
        /**
         * Creates a new CDOTAUserMsg_EnemyItemAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_EnemyItemAlert
         * @static
         * @param {ICDOTAUserMsg_EnemyItemAlert=} [properties] Properties to set
         * @returns {CDOTAUserMsg_EnemyItemAlert} CDOTAUserMsg_EnemyItemAlert instance
         */
        CDOTAUserMsg_EnemyItemAlert.create = function create(properties) {
            return new CDOTAUserMsg_EnemyItemAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_EnemyItemAlert message. Does not implicitly {@link CDOTAUserMsg_EnemyItemAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_EnemyItemAlert
         * @static
         * @param {ICDOTAUserMsg_EnemyItemAlert} message CDOTAUserMsg_EnemyItemAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_EnemyItemAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.target_player_id != null && Object.hasOwnProperty.call(message, "target_player_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.target_player_id);
            if (message.item_ability_id != null && Object.hasOwnProperty.call(message, "item_ability_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.item_ability_id);
            if (message.rune_type != null && Object.hasOwnProperty.call(message, "rune_type"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.rune_type);
            if (message.entity_id != null && Object.hasOwnProperty.call(message, "entity_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.entity_id);
            if (message.item_level != null && Object.hasOwnProperty.call(message, "item_level"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.item_level);
            if (message.primary_charges != null && Object.hasOwnProperty.call(message, "primary_charges"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.primary_charges);
            if (message.secondary_charges != null && Object.hasOwnProperty.call(message, "secondary_charges"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.secondary_charges);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_EnemyItemAlert message, length delimited. Does not implicitly {@link CDOTAUserMsg_EnemyItemAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_EnemyItemAlert
         * @static
         * @param {ICDOTAUserMsg_EnemyItemAlert} message CDOTAUserMsg_EnemyItemAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_EnemyItemAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_EnemyItemAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_EnemyItemAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_EnemyItemAlert} CDOTAUserMsg_EnemyItemAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_EnemyItemAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_EnemyItemAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.target_player_id = reader.uint32();
                    break;
                case 3:
                    message.item_ability_id = reader.int32();
                    break;
                case 4:
                    message.rune_type = reader.int32();
                    break;
                case 5:
                    message.entity_id = reader.int32();
                    break;
                case 6:
                    message.item_level = reader.int32();
                    break;
                case 7:
                    message.primary_charges = reader.int32();
                    break;
                case 8:
                    message.secondary_charges = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_EnemyItemAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_EnemyItemAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_EnemyItemAlert} CDOTAUserMsg_EnemyItemAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_EnemyItemAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_EnemyItemAlert message.
         * @function verify
         * @memberof CDOTAUserMsg_EnemyItemAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_EnemyItemAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.target_player_id != null && message.hasOwnProperty("target_player_id"))
                if (!$util.isInteger(message.target_player_id))
                    return "target_player_id: integer expected";
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                if (!$util.isInteger(message.item_ability_id))
                    return "item_ability_id: integer expected";
            if (message.rune_type != null && message.hasOwnProperty("rune_type"))
                if (!$util.isInteger(message.rune_type))
                    return "rune_type: integer expected";
            if (message.entity_id != null && message.hasOwnProperty("entity_id"))
                if (!$util.isInteger(message.entity_id))
                    return "entity_id: integer expected";
            if (message.item_level != null && message.hasOwnProperty("item_level"))
                if (!$util.isInteger(message.item_level))
                    return "item_level: integer expected";
            if (message.primary_charges != null && message.hasOwnProperty("primary_charges"))
                if (!$util.isInteger(message.primary_charges))
                    return "primary_charges: integer expected";
            if (message.secondary_charges != null && message.hasOwnProperty("secondary_charges"))
                if (!$util.isInteger(message.secondary_charges))
                    return "secondary_charges: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_EnemyItemAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_EnemyItemAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_EnemyItemAlert} CDOTAUserMsg_EnemyItemAlert
         */
        CDOTAUserMsg_EnemyItemAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_EnemyItemAlert)
                return object;
            var message = new $root.CDOTAUserMsg_EnemyItemAlert();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.target_player_id != null)
                message.target_player_id = object.target_player_id >>> 0;
            if (object.item_ability_id != null)
                message.item_ability_id = object.item_ability_id | 0;
            if (object.rune_type != null)
                message.rune_type = object.rune_type | 0;
            if (object.entity_id != null)
                message.entity_id = object.entity_id | 0;
            if (object.item_level != null)
                message.item_level = object.item_level | 0;
            if (object.primary_charges != null)
                message.primary_charges = object.primary_charges | 0;
            if (object.secondary_charges != null)
                message.secondary_charges = object.secondary_charges | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_EnemyItemAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_EnemyItemAlert
         * @static
         * @param {CDOTAUserMsg_EnemyItemAlert} message CDOTAUserMsg_EnemyItemAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_EnemyItemAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.target_player_id = 0;
                object.item_ability_id = 0;
                object.rune_type = -1;
                object.entity_id = 0;
                object.item_level = -1;
                object.primary_charges = -1;
                object.secondary_charges = -1;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.target_player_id != null && message.hasOwnProperty("target_player_id"))
                object.target_player_id = message.target_player_id;
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                object.item_ability_id = message.item_ability_id;
            if (message.rune_type != null && message.hasOwnProperty("rune_type"))
                object.rune_type = message.rune_type;
            if (message.entity_id != null && message.hasOwnProperty("entity_id"))
                object.entity_id = message.entity_id;
            if (message.item_level != null && message.hasOwnProperty("item_level"))
                object.item_level = message.item_level;
            if (message.primary_charges != null && message.hasOwnProperty("primary_charges"))
                object.primary_charges = message.primary_charges;
            if (message.secondary_charges != null && message.hasOwnProperty("secondary_charges"))
                object.secondary_charges = message.secondary_charges;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_EnemyItemAlert to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_EnemyItemAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_EnemyItemAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_EnemyItemAlert;
    })();
    
    $root.CDOTAUserMsg_ModifierAlert = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_ModifierAlert.
         * @exports ICDOTAUserMsg_ModifierAlert
         * @interface ICDOTAUserMsg_ModifierAlert
         * @property {number|null} [player_id] CDOTAUserMsg_ModifierAlert player_id
         * @property {string|null} [class_name] CDOTAUserMsg_ModifierAlert class_name
         * @property {number|null} [stack_count] CDOTAUserMsg_ModifierAlert stack_count
         * @property {boolean|null} [is_debuff] CDOTAUserMsg_ModifierAlert is_debuff
         * @property {number|null} [target_entindex] CDOTAUserMsg_ModifierAlert target_entindex
         * @property {number|null} [seconds_remaining] CDOTAUserMsg_ModifierAlert seconds_remaining
         */
    
        /**
         * Constructs a new CDOTAUserMsg_ModifierAlert.
         * @exports CDOTAUserMsg_ModifierAlert
         * @classdesc Represents a CDOTAUserMsg_ModifierAlert.
         * @implements ICDOTAUserMsg_ModifierAlert
         * @constructor
         * @param {ICDOTAUserMsg_ModifierAlert=} [properties] Properties to set
         */
        function CDOTAUserMsg_ModifierAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_ModifierAlert player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_ModifierAlert
         * @instance
         */
        CDOTAUserMsg_ModifierAlert.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_ModifierAlert class_name.
         * @member {string} class_name
         * @memberof CDOTAUserMsg_ModifierAlert
         * @instance
         */
        CDOTAUserMsg_ModifierAlert.prototype.class_name = "";
    
        /**
         * CDOTAUserMsg_ModifierAlert stack_count.
         * @member {number} stack_count
         * @memberof CDOTAUserMsg_ModifierAlert
         * @instance
         */
        CDOTAUserMsg_ModifierAlert.prototype.stack_count = 0;
    
        /**
         * CDOTAUserMsg_ModifierAlert is_debuff.
         * @member {boolean} is_debuff
         * @memberof CDOTAUserMsg_ModifierAlert
         * @instance
         */
        CDOTAUserMsg_ModifierAlert.prototype.is_debuff = false;
    
        /**
         * CDOTAUserMsg_ModifierAlert target_entindex.
         * @member {number} target_entindex
         * @memberof CDOTAUserMsg_ModifierAlert
         * @instance
         */
        CDOTAUserMsg_ModifierAlert.prototype.target_entindex = 0;
    
        /**
         * CDOTAUserMsg_ModifierAlert seconds_remaining.
         * @member {number} seconds_remaining
         * @memberof CDOTAUserMsg_ModifierAlert
         * @instance
         */
        CDOTAUserMsg_ModifierAlert.prototype.seconds_remaining = 0;
    
        /**
         * Creates a new CDOTAUserMsg_ModifierAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_ModifierAlert
         * @static
         * @param {ICDOTAUserMsg_ModifierAlert=} [properties] Properties to set
         * @returns {CDOTAUserMsg_ModifierAlert} CDOTAUserMsg_ModifierAlert instance
         */
        CDOTAUserMsg_ModifierAlert.create = function create(properties) {
            return new CDOTAUserMsg_ModifierAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ModifierAlert message. Does not implicitly {@link CDOTAUserMsg_ModifierAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_ModifierAlert
         * @static
         * @param {ICDOTAUserMsg_ModifierAlert} message CDOTAUserMsg_ModifierAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ModifierAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.class_name != null && Object.hasOwnProperty.call(message, "class_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.class_name);
            if (message.stack_count != null && Object.hasOwnProperty.call(message, "stack_count"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.stack_count);
            if (message.is_debuff != null && Object.hasOwnProperty.call(message, "is_debuff"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.is_debuff);
            if (message.target_entindex != null && Object.hasOwnProperty.call(message, "target_entindex"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.target_entindex);
            if (message.seconds_remaining != null && Object.hasOwnProperty.call(message, "seconds_remaining"))
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.seconds_remaining);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ModifierAlert message, length delimited. Does not implicitly {@link CDOTAUserMsg_ModifierAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_ModifierAlert
         * @static
         * @param {ICDOTAUserMsg_ModifierAlert} message CDOTAUserMsg_ModifierAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ModifierAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_ModifierAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_ModifierAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_ModifierAlert} CDOTAUserMsg_ModifierAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ModifierAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_ModifierAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.class_name = reader.string();
                    break;
                case 3:
                    message.stack_count = reader.uint32();
                    break;
                case 4:
                    message.is_debuff = reader.bool();
                    break;
                case 5:
                    message.target_entindex = reader.uint32();
                    break;
                case 6:
                    message.seconds_remaining = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_ModifierAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_ModifierAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_ModifierAlert} CDOTAUserMsg_ModifierAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ModifierAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_ModifierAlert message.
         * @function verify
         * @memberof CDOTAUserMsg_ModifierAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_ModifierAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.class_name != null && message.hasOwnProperty("class_name"))
                if (!$util.isString(message.class_name))
                    return "class_name: string expected";
            if (message.stack_count != null && message.hasOwnProperty("stack_count"))
                if (!$util.isInteger(message.stack_count))
                    return "stack_count: integer expected";
            if (message.is_debuff != null && message.hasOwnProperty("is_debuff"))
                if (typeof message.is_debuff !== "boolean")
                    return "is_debuff: boolean expected";
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                if (!$util.isInteger(message.target_entindex))
                    return "target_entindex: integer expected";
            if (message.seconds_remaining != null && message.hasOwnProperty("seconds_remaining"))
                if (typeof message.seconds_remaining !== "number")
                    return "seconds_remaining: number expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_ModifierAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_ModifierAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_ModifierAlert} CDOTAUserMsg_ModifierAlert
         */
        CDOTAUserMsg_ModifierAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_ModifierAlert)
                return object;
            var message = new $root.CDOTAUserMsg_ModifierAlert();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.class_name != null)
                message.class_name = String(object.class_name);
            if (object.stack_count != null)
                message.stack_count = object.stack_count >>> 0;
            if (object.is_debuff != null)
                message.is_debuff = Boolean(object.is_debuff);
            if (object.target_entindex != null)
                message.target_entindex = object.target_entindex >>> 0;
            if (object.seconds_remaining != null)
                message.seconds_remaining = Number(object.seconds_remaining);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_ModifierAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_ModifierAlert
         * @static
         * @param {CDOTAUserMsg_ModifierAlert} message CDOTAUserMsg_ModifierAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_ModifierAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.class_name = "";
                object.stack_count = 0;
                object.is_debuff = false;
                object.target_entindex = 0;
                object.seconds_remaining = 0;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.class_name != null && message.hasOwnProperty("class_name"))
                object.class_name = message.class_name;
            if (message.stack_count != null && message.hasOwnProperty("stack_count"))
                object.stack_count = message.stack_count;
            if (message.is_debuff != null && message.hasOwnProperty("is_debuff"))
                object.is_debuff = message.is_debuff;
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                object.target_entindex = message.target_entindex;
            if (message.seconds_remaining != null && message.hasOwnProperty("seconds_remaining"))
                object.seconds_remaining = options.json && !isFinite(message.seconds_remaining) ? String(message.seconds_remaining) : message.seconds_remaining;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_ModifierAlert to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_ModifierAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_ModifierAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_ModifierAlert;
    })();
    
    $root.CDOTAUserMsg_HPManaAlert = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_HPManaAlert.
         * @exports ICDOTAUserMsg_HPManaAlert
         * @interface ICDOTAUserMsg_HPManaAlert
         * @property {number|null} [player_id] CDOTAUserMsg_HPManaAlert player_id
         * @property {number|null} [target_entindex] CDOTAUserMsg_HPManaAlert target_entindex
         * @property {boolean|null} [show_raw_values] CDOTAUserMsg_HPManaAlert show_raw_values
         */
    
        /**
         * Constructs a new CDOTAUserMsg_HPManaAlert.
         * @exports CDOTAUserMsg_HPManaAlert
         * @classdesc Represents a CDOTAUserMsg_HPManaAlert.
         * @implements ICDOTAUserMsg_HPManaAlert
         * @constructor
         * @param {ICDOTAUserMsg_HPManaAlert=} [properties] Properties to set
         */
        function CDOTAUserMsg_HPManaAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_HPManaAlert player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_HPManaAlert
         * @instance
         */
        CDOTAUserMsg_HPManaAlert.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_HPManaAlert target_entindex.
         * @member {number} target_entindex
         * @memberof CDOTAUserMsg_HPManaAlert
         * @instance
         */
        CDOTAUserMsg_HPManaAlert.prototype.target_entindex = 0;
    
        /**
         * CDOTAUserMsg_HPManaAlert show_raw_values.
         * @member {boolean} show_raw_values
         * @memberof CDOTAUserMsg_HPManaAlert
         * @instance
         */
        CDOTAUserMsg_HPManaAlert.prototype.show_raw_values = false;
    
        /**
         * Creates a new CDOTAUserMsg_HPManaAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_HPManaAlert
         * @static
         * @param {ICDOTAUserMsg_HPManaAlert=} [properties] Properties to set
         * @returns {CDOTAUserMsg_HPManaAlert} CDOTAUserMsg_HPManaAlert instance
         */
        CDOTAUserMsg_HPManaAlert.create = function create(properties) {
            return new CDOTAUserMsg_HPManaAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_HPManaAlert message. Does not implicitly {@link CDOTAUserMsg_HPManaAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_HPManaAlert
         * @static
         * @param {ICDOTAUserMsg_HPManaAlert} message CDOTAUserMsg_HPManaAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_HPManaAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.target_entindex != null && Object.hasOwnProperty.call(message, "target_entindex"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.target_entindex);
            if (message.show_raw_values != null && Object.hasOwnProperty.call(message, "show_raw_values"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.show_raw_values);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_HPManaAlert message, length delimited. Does not implicitly {@link CDOTAUserMsg_HPManaAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_HPManaAlert
         * @static
         * @param {ICDOTAUserMsg_HPManaAlert} message CDOTAUserMsg_HPManaAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_HPManaAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_HPManaAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_HPManaAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_HPManaAlert} CDOTAUserMsg_HPManaAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_HPManaAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_HPManaAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.target_entindex = reader.uint32();
                    break;
                case 3:
                    message.show_raw_values = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_HPManaAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_HPManaAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_HPManaAlert} CDOTAUserMsg_HPManaAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_HPManaAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_HPManaAlert message.
         * @function verify
         * @memberof CDOTAUserMsg_HPManaAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_HPManaAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                if (!$util.isInteger(message.target_entindex))
                    return "target_entindex: integer expected";
            if (message.show_raw_values != null && message.hasOwnProperty("show_raw_values"))
                if (typeof message.show_raw_values !== "boolean")
                    return "show_raw_values: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_HPManaAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_HPManaAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_HPManaAlert} CDOTAUserMsg_HPManaAlert
         */
        CDOTAUserMsg_HPManaAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_HPManaAlert)
                return object;
            var message = new $root.CDOTAUserMsg_HPManaAlert();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.target_entindex != null)
                message.target_entindex = object.target_entindex >>> 0;
            if (object.show_raw_values != null)
                message.show_raw_values = Boolean(object.show_raw_values);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_HPManaAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_HPManaAlert
         * @static
         * @param {CDOTAUserMsg_HPManaAlert} message CDOTAUserMsg_HPManaAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_HPManaAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.target_entindex = 0;
                object.show_raw_values = false;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                object.target_entindex = message.target_entindex;
            if (message.show_raw_values != null && message.hasOwnProperty("show_raw_values"))
                object.show_raw_values = message.show_raw_values;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_HPManaAlert to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_HPManaAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_HPManaAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_HPManaAlert;
    })();
    
    $root.CDOTAUserMsg_GlyphAlert = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_GlyphAlert.
         * @exports ICDOTAUserMsg_GlyphAlert
         * @interface ICDOTAUserMsg_GlyphAlert
         * @property {number|null} [player_id] CDOTAUserMsg_GlyphAlert player_id
         * @property {boolean|null} [negative] CDOTAUserMsg_GlyphAlert negative
         */
    
        /**
         * Constructs a new CDOTAUserMsg_GlyphAlert.
         * @exports CDOTAUserMsg_GlyphAlert
         * @classdesc Represents a CDOTAUserMsg_GlyphAlert.
         * @implements ICDOTAUserMsg_GlyphAlert
         * @constructor
         * @param {ICDOTAUserMsg_GlyphAlert=} [properties] Properties to set
         */
        function CDOTAUserMsg_GlyphAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_GlyphAlert player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_GlyphAlert
         * @instance
         */
        CDOTAUserMsg_GlyphAlert.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_GlyphAlert negative.
         * @member {boolean} negative
         * @memberof CDOTAUserMsg_GlyphAlert
         * @instance
         */
        CDOTAUserMsg_GlyphAlert.prototype.negative = false;
    
        /**
         * Creates a new CDOTAUserMsg_GlyphAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_GlyphAlert
         * @static
         * @param {ICDOTAUserMsg_GlyphAlert=} [properties] Properties to set
         * @returns {CDOTAUserMsg_GlyphAlert} CDOTAUserMsg_GlyphAlert instance
         */
        CDOTAUserMsg_GlyphAlert.create = function create(properties) {
            return new CDOTAUserMsg_GlyphAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_GlyphAlert message. Does not implicitly {@link CDOTAUserMsg_GlyphAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_GlyphAlert
         * @static
         * @param {ICDOTAUserMsg_GlyphAlert} message CDOTAUserMsg_GlyphAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_GlyphAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.negative != null && Object.hasOwnProperty.call(message, "negative"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.negative);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_GlyphAlert message, length delimited. Does not implicitly {@link CDOTAUserMsg_GlyphAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_GlyphAlert
         * @static
         * @param {ICDOTAUserMsg_GlyphAlert} message CDOTAUserMsg_GlyphAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_GlyphAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_GlyphAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_GlyphAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_GlyphAlert} CDOTAUserMsg_GlyphAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_GlyphAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_GlyphAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.negative = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_GlyphAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_GlyphAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_GlyphAlert} CDOTAUserMsg_GlyphAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_GlyphAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_GlyphAlert message.
         * @function verify
         * @memberof CDOTAUserMsg_GlyphAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_GlyphAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.negative != null && message.hasOwnProperty("negative"))
                if (typeof message.negative !== "boolean")
                    return "negative: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_GlyphAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_GlyphAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_GlyphAlert} CDOTAUserMsg_GlyphAlert
         */
        CDOTAUserMsg_GlyphAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_GlyphAlert)
                return object;
            var message = new $root.CDOTAUserMsg_GlyphAlert();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.negative != null)
                message.negative = Boolean(object.negative);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_GlyphAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_GlyphAlert
         * @static
         * @param {CDOTAUserMsg_GlyphAlert} message CDOTAUserMsg_GlyphAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_GlyphAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.negative = false;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.negative != null && message.hasOwnProperty("negative"))
                object.negative = message.negative;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_GlyphAlert to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_GlyphAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_GlyphAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_GlyphAlert;
    })();
    
    $root.CDOTAUserMsg_RadarAlert = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_RadarAlert.
         * @exports ICDOTAUserMsg_RadarAlert
         * @interface ICDOTAUserMsg_RadarAlert
         * @property {number|null} [player_id] CDOTAUserMsg_RadarAlert player_id
         * @property {boolean|null} [negative] CDOTAUserMsg_RadarAlert negative
         */
    
        /**
         * Constructs a new CDOTAUserMsg_RadarAlert.
         * @exports CDOTAUserMsg_RadarAlert
         * @classdesc Represents a CDOTAUserMsg_RadarAlert.
         * @implements ICDOTAUserMsg_RadarAlert
         * @constructor
         * @param {ICDOTAUserMsg_RadarAlert=} [properties] Properties to set
         */
        function CDOTAUserMsg_RadarAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_RadarAlert player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_RadarAlert
         * @instance
         */
        CDOTAUserMsg_RadarAlert.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_RadarAlert negative.
         * @member {boolean} negative
         * @memberof CDOTAUserMsg_RadarAlert
         * @instance
         */
        CDOTAUserMsg_RadarAlert.prototype.negative = false;
    
        /**
         * Creates a new CDOTAUserMsg_RadarAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_RadarAlert
         * @static
         * @param {ICDOTAUserMsg_RadarAlert=} [properties] Properties to set
         * @returns {CDOTAUserMsg_RadarAlert} CDOTAUserMsg_RadarAlert instance
         */
        CDOTAUserMsg_RadarAlert.create = function create(properties) {
            return new CDOTAUserMsg_RadarAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_RadarAlert message. Does not implicitly {@link CDOTAUserMsg_RadarAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_RadarAlert
         * @static
         * @param {ICDOTAUserMsg_RadarAlert} message CDOTAUserMsg_RadarAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_RadarAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.negative != null && Object.hasOwnProperty.call(message, "negative"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.negative);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_RadarAlert message, length delimited. Does not implicitly {@link CDOTAUserMsg_RadarAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_RadarAlert
         * @static
         * @param {ICDOTAUserMsg_RadarAlert} message CDOTAUserMsg_RadarAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_RadarAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_RadarAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_RadarAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_RadarAlert} CDOTAUserMsg_RadarAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_RadarAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_RadarAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.negative = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_RadarAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_RadarAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_RadarAlert} CDOTAUserMsg_RadarAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_RadarAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_RadarAlert message.
         * @function verify
         * @memberof CDOTAUserMsg_RadarAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_RadarAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.negative != null && message.hasOwnProperty("negative"))
                if (typeof message.negative !== "boolean")
                    return "negative: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_RadarAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_RadarAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_RadarAlert} CDOTAUserMsg_RadarAlert
         */
        CDOTAUserMsg_RadarAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_RadarAlert)
                return object;
            var message = new $root.CDOTAUserMsg_RadarAlert();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.negative != null)
                message.negative = Boolean(object.negative);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_RadarAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_RadarAlert
         * @static
         * @param {CDOTAUserMsg_RadarAlert} message CDOTAUserMsg_RadarAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_RadarAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.negative = false;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.negative != null && message.hasOwnProperty("negative"))
                object.negative = message.negative;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_RadarAlert to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_RadarAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_RadarAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_RadarAlert;
    })();
    
    $root.CDOTAUserMsg_WillPurchaseAlert = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_WillPurchaseAlert.
         * @exports ICDOTAUserMsg_WillPurchaseAlert
         * @interface ICDOTAUserMsg_WillPurchaseAlert
         * @property {number|null} [item_ability_id] CDOTAUserMsg_WillPurchaseAlert item_ability_id
         * @property {number|null} [player_id] CDOTAUserMsg_WillPurchaseAlert player_id
         * @property {number|null} [gold_remaining] CDOTAUserMsg_WillPurchaseAlert gold_remaining
         * @property {number|null} [suggestion_player_id] CDOTAUserMsg_WillPurchaseAlert suggestion_player_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_WillPurchaseAlert.
         * @exports CDOTAUserMsg_WillPurchaseAlert
         * @classdesc Represents a CDOTAUserMsg_WillPurchaseAlert.
         * @implements ICDOTAUserMsg_WillPurchaseAlert
         * @constructor
         * @param {ICDOTAUserMsg_WillPurchaseAlert=} [properties] Properties to set
         */
        function CDOTAUserMsg_WillPurchaseAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_WillPurchaseAlert item_ability_id.
         * @member {number} item_ability_id
         * @memberof CDOTAUserMsg_WillPurchaseAlert
         * @instance
         */
        CDOTAUserMsg_WillPurchaseAlert.prototype.item_ability_id = 0;
    
        /**
         * CDOTAUserMsg_WillPurchaseAlert player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_WillPurchaseAlert
         * @instance
         */
        CDOTAUserMsg_WillPurchaseAlert.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_WillPurchaseAlert gold_remaining.
         * @member {number} gold_remaining
         * @memberof CDOTAUserMsg_WillPurchaseAlert
         * @instance
         */
        CDOTAUserMsg_WillPurchaseAlert.prototype.gold_remaining = 0;
    
        /**
         * CDOTAUserMsg_WillPurchaseAlert suggestion_player_id.
         * @member {number} suggestion_player_id
         * @memberof CDOTAUserMsg_WillPurchaseAlert
         * @instance
         */
        CDOTAUserMsg_WillPurchaseAlert.prototype.suggestion_player_id = 0;
    
        /**
         * Creates a new CDOTAUserMsg_WillPurchaseAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_WillPurchaseAlert
         * @static
         * @param {ICDOTAUserMsg_WillPurchaseAlert=} [properties] Properties to set
         * @returns {CDOTAUserMsg_WillPurchaseAlert} CDOTAUserMsg_WillPurchaseAlert instance
         */
        CDOTAUserMsg_WillPurchaseAlert.create = function create(properties) {
            return new CDOTAUserMsg_WillPurchaseAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_WillPurchaseAlert message. Does not implicitly {@link CDOTAUserMsg_WillPurchaseAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_WillPurchaseAlert
         * @static
         * @param {ICDOTAUserMsg_WillPurchaseAlert} message CDOTAUserMsg_WillPurchaseAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_WillPurchaseAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item_ability_id != null && Object.hasOwnProperty.call(message, "item_ability_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.item_ability_id);
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.player_id);
            if (message.gold_remaining != null && Object.hasOwnProperty.call(message, "gold_remaining"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.gold_remaining);
            if (message.suggestion_player_id != null && Object.hasOwnProperty.call(message, "suggestion_player_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.suggestion_player_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_WillPurchaseAlert message, length delimited. Does not implicitly {@link CDOTAUserMsg_WillPurchaseAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_WillPurchaseAlert
         * @static
         * @param {ICDOTAUserMsg_WillPurchaseAlert} message CDOTAUserMsg_WillPurchaseAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_WillPurchaseAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_WillPurchaseAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_WillPurchaseAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_WillPurchaseAlert} CDOTAUserMsg_WillPurchaseAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_WillPurchaseAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_WillPurchaseAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item_ability_id = reader.int32();
                    break;
                case 2:
                    message.player_id = reader.int32();
                    break;
                case 3:
                    message.gold_remaining = reader.uint32();
                    break;
                case 4:
                    message.suggestion_player_id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_WillPurchaseAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_WillPurchaseAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_WillPurchaseAlert} CDOTAUserMsg_WillPurchaseAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_WillPurchaseAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_WillPurchaseAlert message.
         * @function verify
         * @memberof CDOTAUserMsg_WillPurchaseAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_WillPurchaseAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                if (!$util.isInteger(message.item_ability_id))
                    return "item_ability_id: integer expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.gold_remaining != null && message.hasOwnProperty("gold_remaining"))
                if (!$util.isInteger(message.gold_remaining))
                    return "gold_remaining: integer expected";
            if (message.suggestion_player_id != null && message.hasOwnProperty("suggestion_player_id"))
                if (!$util.isInteger(message.suggestion_player_id))
                    return "suggestion_player_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_WillPurchaseAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_WillPurchaseAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_WillPurchaseAlert} CDOTAUserMsg_WillPurchaseAlert
         */
        CDOTAUserMsg_WillPurchaseAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_WillPurchaseAlert)
                return object;
            var message = new $root.CDOTAUserMsg_WillPurchaseAlert();
            if (object.item_ability_id != null)
                message.item_ability_id = object.item_ability_id | 0;
            if (object.player_id != null)
                message.player_id = object.player_id | 0;
            if (object.gold_remaining != null)
                message.gold_remaining = object.gold_remaining >>> 0;
            if (object.suggestion_player_id != null)
                message.suggestion_player_id = object.suggestion_player_id | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_WillPurchaseAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_WillPurchaseAlert
         * @static
         * @param {CDOTAUserMsg_WillPurchaseAlert} message CDOTAUserMsg_WillPurchaseAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_WillPurchaseAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.item_ability_id = 0;
                object.player_id = 0;
                object.gold_remaining = 0;
                object.suggestion_player_id = 0;
            }
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                object.item_ability_id = message.item_ability_id;
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.gold_remaining != null && message.hasOwnProperty("gold_remaining"))
                object.gold_remaining = message.gold_remaining;
            if (message.suggestion_player_id != null && message.hasOwnProperty("suggestion_player_id"))
                object.suggestion_player_id = message.suggestion_player_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_WillPurchaseAlert to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_WillPurchaseAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_WillPurchaseAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_WillPurchaseAlert;
    })();
    
    $root.CDOTAUserMsg_EmptyTeleportAlert = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_EmptyTeleportAlert.
         * @exports ICDOTAUserMsg_EmptyTeleportAlert
         * @interface ICDOTAUserMsg_EmptyTeleportAlert
         * @property {number|null} [source_player_id] CDOTAUserMsg_EmptyTeleportAlert source_player_id
         * @property {number|null} [target_player_id] CDOTAUserMsg_EmptyTeleportAlert target_player_id
         * @property {number|null} [cooldown_seconds] CDOTAUserMsg_EmptyTeleportAlert cooldown_seconds
         */
    
        /**
         * Constructs a new CDOTAUserMsg_EmptyTeleportAlert.
         * @exports CDOTAUserMsg_EmptyTeleportAlert
         * @classdesc Represents a CDOTAUserMsg_EmptyTeleportAlert.
         * @implements ICDOTAUserMsg_EmptyTeleportAlert
         * @constructor
         * @param {ICDOTAUserMsg_EmptyTeleportAlert=} [properties] Properties to set
         */
        function CDOTAUserMsg_EmptyTeleportAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_EmptyTeleportAlert source_player_id.
         * @member {number} source_player_id
         * @memberof CDOTAUserMsg_EmptyTeleportAlert
         * @instance
         */
        CDOTAUserMsg_EmptyTeleportAlert.prototype.source_player_id = 0;
    
        /**
         * CDOTAUserMsg_EmptyTeleportAlert target_player_id.
         * @member {number} target_player_id
         * @memberof CDOTAUserMsg_EmptyTeleportAlert
         * @instance
         */
        CDOTAUserMsg_EmptyTeleportAlert.prototype.target_player_id = 0;
    
        /**
         * CDOTAUserMsg_EmptyTeleportAlert cooldown_seconds.
         * @member {number} cooldown_seconds
         * @memberof CDOTAUserMsg_EmptyTeleportAlert
         * @instance
         */
        CDOTAUserMsg_EmptyTeleportAlert.prototype.cooldown_seconds = 0;
    
        /**
         * Creates a new CDOTAUserMsg_EmptyTeleportAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_EmptyTeleportAlert
         * @static
         * @param {ICDOTAUserMsg_EmptyTeleportAlert=} [properties] Properties to set
         * @returns {CDOTAUserMsg_EmptyTeleportAlert} CDOTAUserMsg_EmptyTeleportAlert instance
         */
        CDOTAUserMsg_EmptyTeleportAlert.create = function create(properties) {
            return new CDOTAUserMsg_EmptyTeleportAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_EmptyTeleportAlert message. Does not implicitly {@link CDOTAUserMsg_EmptyTeleportAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_EmptyTeleportAlert
         * @static
         * @param {ICDOTAUserMsg_EmptyTeleportAlert} message CDOTAUserMsg_EmptyTeleportAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_EmptyTeleportAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.source_player_id != null && Object.hasOwnProperty.call(message, "source_player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.source_player_id);
            if (message.target_player_id != null && Object.hasOwnProperty.call(message, "target_player_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.target_player_id);
            if (message.cooldown_seconds != null && Object.hasOwnProperty.call(message, "cooldown_seconds"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.cooldown_seconds);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_EmptyTeleportAlert message, length delimited. Does not implicitly {@link CDOTAUserMsg_EmptyTeleportAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_EmptyTeleportAlert
         * @static
         * @param {ICDOTAUserMsg_EmptyTeleportAlert} message CDOTAUserMsg_EmptyTeleportAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_EmptyTeleportAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_EmptyTeleportAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_EmptyTeleportAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_EmptyTeleportAlert} CDOTAUserMsg_EmptyTeleportAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_EmptyTeleportAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_EmptyTeleportAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.source_player_id = reader.int32();
                    break;
                case 2:
                    message.target_player_id = reader.int32();
                    break;
                case 3:
                    message.cooldown_seconds = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_EmptyTeleportAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_EmptyTeleportAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_EmptyTeleportAlert} CDOTAUserMsg_EmptyTeleportAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_EmptyTeleportAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_EmptyTeleportAlert message.
         * @function verify
         * @memberof CDOTAUserMsg_EmptyTeleportAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_EmptyTeleportAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.source_player_id != null && message.hasOwnProperty("source_player_id"))
                if (!$util.isInteger(message.source_player_id))
                    return "source_player_id: integer expected";
            if (message.target_player_id != null && message.hasOwnProperty("target_player_id"))
                if (!$util.isInteger(message.target_player_id))
                    return "target_player_id: integer expected";
            if (message.cooldown_seconds != null && message.hasOwnProperty("cooldown_seconds"))
                if (!$util.isInteger(message.cooldown_seconds))
                    return "cooldown_seconds: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_EmptyTeleportAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_EmptyTeleportAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_EmptyTeleportAlert} CDOTAUserMsg_EmptyTeleportAlert
         */
        CDOTAUserMsg_EmptyTeleportAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_EmptyTeleportAlert)
                return object;
            var message = new $root.CDOTAUserMsg_EmptyTeleportAlert();
            if (object.source_player_id != null)
                message.source_player_id = object.source_player_id | 0;
            if (object.target_player_id != null)
                message.target_player_id = object.target_player_id | 0;
            if (object.cooldown_seconds != null)
                message.cooldown_seconds = object.cooldown_seconds | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_EmptyTeleportAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_EmptyTeleportAlert
         * @static
         * @param {CDOTAUserMsg_EmptyTeleportAlert} message CDOTAUserMsg_EmptyTeleportAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_EmptyTeleportAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.source_player_id = 0;
                object.target_player_id = 0;
                object.cooldown_seconds = 0;
            }
            if (message.source_player_id != null && message.hasOwnProperty("source_player_id"))
                object.source_player_id = message.source_player_id;
            if (message.target_player_id != null && message.hasOwnProperty("target_player_id"))
                object.target_player_id = message.target_player_id;
            if (message.cooldown_seconds != null && message.hasOwnProperty("cooldown_seconds"))
                object.cooldown_seconds = message.cooldown_seconds;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_EmptyTeleportAlert to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_EmptyTeleportAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_EmptyTeleportAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_EmptyTeleportAlert;
    })();
    
    $root.CDOTAUserMsg_MarsArenaOfBloodAttack = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_MarsArenaOfBloodAttack.
         * @exports ICDOTAUserMsg_MarsArenaOfBloodAttack
         * @interface ICDOTAUserMsg_MarsArenaOfBloodAttack
         * @property {number|null} [source_ehandle] CDOTAUserMsg_MarsArenaOfBloodAttack source_ehandle
         * @property {number|null} [target_ehandle] CDOTAUserMsg_MarsArenaOfBloodAttack target_ehandle
         * @property {number|null} [warrior_index] CDOTAUserMsg_MarsArenaOfBloodAttack warrior_index
         */
    
        /**
         * Constructs a new CDOTAUserMsg_MarsArenaOfBloodAttack.
         * @exports CDOTAUserMsg_MarsArenaOfBloodAttack
         * @classdesc Represents a CDOTAUserMsg_MarsArenaOfBloodAttack.
         * @implements ICDOTAUserMsg_MarsArenaOfBloodAttack
         * @constructor
         * @param {ICDOTAUserMsg_MarsArenaOfBloodAttack=} [properties] Properties to set
         */
        function CDOTAUserMsg_MarsArenaOfBloodAttack(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_MarsArenaOfBloodAttack source_ehandle.
         * @member {number} source_ehandle
         * @memberof CDOTAUserMsg_MarsArenaOfBloodAttack
         * @instance
         */
        CDOTAUserMsg_MarsArenaOfBloodAttack.prototype.source_ehandle = 0;
    
        /**
         * CDOTAUserMsg_MarsArenaOfBloodAttack target_ehandle.
         * @member {number} target_ehandle
         * @memberof CDOTAUserMsg_MarsArenaOfBloodAttack
         * @instance
         */
        CDOTAUserMsg_MarsArenaOfBloodAttack.prototype.target_ehandle = 0;
    
        /**
         * CDOTAUserMsg_MarsArenaOfBloodAttack warrior_index.
         * @member {number} warrior_index
         * @memberof CDOTAUserMsg_MarsArenaOfBloodAttack
         * @instance
         */
        CDOTAUserMsg_MarsArenaOfBloodAttack.prototype.warrior_index = 0;
    
        /**
         * Creates a new CDOTAUserMsg_MarsArenaOfBloodAttack instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_MarsArenaOfBloodAttack
         * @static
         * @param {ICDOTAUserMsg_MarsArenaOfBloodAttack=} [properties] Properties to set
         * @returns {CDOTAUserMsg_MarsArenaOfBloodAttack} CDOTAUserMsg_MarsArenaOfBloodAttack instance
         */
        CDOTAUserMsg_MarsArenaOfBloodAttack.create = function create(properties) {
            return new CDOTAUserMsg_MarsArenaOfBloodAttack(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_MarsArenaOfBloodAttack message. Does not implicitly {@link CDOTAUserMsg_MarsArenaOfBloodAttack.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_MarsArenaOfBloodAttack
         * @static
         * @param {ICDOTAUserMsg_MarsArenaOfBloodAttack} message CDOTAUserMsg_MarsArenaOfBloodAttack message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_MarsArenaOfBloodAttack.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.source_ehandle != null && Object.hasOwnProperty.call(message, "source_ehandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.source_ehandle);
            if (message.target_ehandle != null && Object.hasOwnProperty.call(message, "target_ehandle"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.target_ehandle);
            if (message.warrior_index != null && Object.hasOwnProperty.call(message, "warrior_index"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.warrior_index);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_MarsArenaOfBloodAttack message, length delimited. Does not implicitly {@link CDOTAUserMsg_MarsArenaOfBloodAttack.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_MarsArenaOfBloodAttack
         * @static
         * @param {ICDOTAUserMsg_MarsArenaOfBloodAttack} message CDOTAUserMsg_MarsArenaOfBloodAttack message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_MarsArenaOfBloodAttack.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_MarsArenaOfBloodAttack message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_MarsArenaOfBloodAttack
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_MarsArenaOfBloodAttack} CDOTAUserMsg_MarsArenaOfBloodAttack
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_MarsArenaOfBloodAttack.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_MarsArenaOfBloodAttack();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.source_ehandle = reader.int32();
                    break;
                case 2:
                    message.target_ehandle = reader.int32();
                    break;
                case 3:
                    message.warrior_index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_MarsArenaOfBloodAttack message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_MarsArenaOfBloodAttack
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_MarsArenaOfBloodAttack} CDOTAUserMsg_MarsArenaOfBloodAttack
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_MarsArenaOfBloodAttack.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_MarsArenaOfBloodAttack message.
         * @function verify
         * @memberof CDOTAUserMsg_MarsArenaOfBloodAttack
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_MarsArenaOfBloodAttack.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.source_ehandle != null && message.hasOwnProperty("source_ehandle"))
                if (!$util.isInteger(message.source_ehandle))
                    return "source_ehandle: integer expected";
            if (message.target_ehandle != null && message.hasOwnProperty("target_ehandle"))
                if (!$util.isInteger(message.target_ehandle))
                    return "target_ehandle: integer expected";
            if (message.warrior_index != null && message.hasOwnProperty("warrior_index"))
                if (!$util.isInteger(message.warrior_index))
                    return "warrior_index: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_MarsArenaOfBloodAttack message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_MarsArenaOfBloodAttack
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_MarsArenaOfBloodAttack} CDOTAUserMsg_MarsArenaOfBloodAttack
         */
        CDOTAUserMsg_MarsArenaOfBloodAttack.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_MarsArenaOfBloodAttack)
                return object;
            var message = new $root.CDOTAUserMsg_MarsArenaOfBloodAttack();
            if (object.source_ehandle != null)
                message.source_ehandle = object.source_ehandle | 0;
            if (object.target_ehandle != null)
                message.target_ehandle = object.target_ehandle | 0;
            if (object.warrior_index != null)
                message.warrior_index = object.warrior_index | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_MarsArenaOfBloodAttack message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_MarsArenaOfBloodAttack
         * @static
         * @param {CDOTAUserMsg_MarsArenaOfBloodAttack} message CDOTAUserMsg_MarsArenaOfBloodAttack
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_MarsArenaOfBloodAttack.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.source_ehandle = 0;
                object.target_ehandle = 0;
                object.warrior_index = 0;
            }
            if (message.source_ehandle != null && message.hasOwnProperty("source_ehandle"))
                object.source_ehandle = message.source_ehandle;
            if (message.target_ehandle != null && message.hasOwnProperty("target_ehandle"))
                object.target_ehandle = message.target_ehandle;
            if (message.warrior_index != null && message.hasOwnProperty("warrior_index"))
                object.warrior_index = message.warrior_index;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_MarsArenaOfBloodAttack to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_MarsArenaOfBloodAttack
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_MarsArenaOfBloodAttack.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_MarsArenaOfBloodAttack;
    })();
    
    $root.CDOTAEntityMsg_InvokerSpellCast = (function() {
    
        /**
         * Properties of a CDOTAEntityMsg_InvokerSpellCast.
         * @exports ICDOTAEntityMsg_InvokerSpellCast
         * @interface ICDOTAEntityMsg_InvokerSpellCast
         * @property {ICEntityMsg|null} [entity_msg] CDOTAEntityMsg_InvokerSpellCast entity_msg
         * @property {number|null} [cast_activity] CDOTAEntityMsg_InvokerSpellCast cast_activity
         */
    
        /**
         * Constructs a new CDOTAEntityMsg_InvokerSpellCast.
         * @exports CDOTAEntityMsg_InvokerSpellCast
         * @classdesc Represents a CDOTAEntityMsg_InvokerSpellCast.
         * @implements ICDOTAEntityMsg_InvokerSpellCast
         * @constructor
         * @param {ICDOTAEntityMsg_InvokerSpellCast=} [properties] Properties to set
         */
        function CDOTAEntityMsg_InvokerSpellCast(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAEntityMsg_InvokerSpellCast entity_msg.
         * @member {ICEntityMsg|null|undefined} entity_msg
         * @memberof CDOTAEntityMsg_InvokerSpellCast
         * @instance
         */
        CDOTAEntityMsg_InvokerSpellCast.prototype.entity_msg = null;
    
        /**
         * CDOTAEntityMsg_InvokerSpellCast cast_activity.
         * @member {number} cast_activity
         * @memberof CDOTAEntityMsg_InvokerSpellCast
         * @instance
         */
        CDOTAEntityMsg_InvokerSpellCast.prototype.cast_activity = 0;
    
        /**
         * Creates a new CDOTAEntityMsg_InvokerSpellCast instance using the specified properties.
         * @function create
         * @memberof CDOTAEntityMsg_InvokerSpellCast
         * @static
         * @param {ICDOTAEntityMsg_InvokerSpellCast=} [properties] Properties to set
         * @returns {CDOTAEntityMsg_InvokerSpellCast} CDOTAEntityMsg_InvokerSpellCast instance
         */
        CDOTAEntityMsg_InvokerSpellCast.create = function create(properties) {
            return new CDOTAEntityMsg_InvokerSpellCast(properties);
        };
    
        /**
         * Encodes the specified CDOTAEntityMsg_InvokerSpellCast message. Does not implicitly {@link CDOTAEntityMsg_InvokerSpellCast.verify|verify} messages.
         * @function encode
         * @memberof CDOTAEntityMsg_InvokerSpellCast
         * @static
         * @param {ICDOTAEntityMsg_InvokerSpellCast} message CDOTAEntityMsg_InvokerSpellCast message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAEntityMsg_InvokerSpellCast.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entity_msg != null && Object.hasOwnProperty.call(message, "entity_msg"))
                $root.CEntityMsg.encode(message.entity_msg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.cast_activity != null && Object.hasOwnProperty.call(message, "cast_activity"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.cast_activity);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAEntityMsg_InvokerSpellCast message, length delimited. Does not implicitly {@link CDOTAEntityMsg_InvokerSpellCast.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAEntityMsg_InvokerSpellCast
         * @static
         * @param {ICDOTAEntityMsg_InvokerSpellCast} message CDOTAEntityMsg_InvokerSpellCast message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAEntityMsg_InvokerSpellCast.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAEntityMsg_InvokerSpellCast message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAEntityMsg_InvokerSpellCast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAEntityMsg_InvokerSpellCast} CDOTAEntityMsg_InvokerSpellCast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAEntityMsg_InvokerSpellCast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAEntityMsg_InvokerSpellCast();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.entity_msg = $root.CEntityMsg.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.cast_activity = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAEntityMsg_InvokerSpellCast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAEntityMsg_InvokerSpellCast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAEntityMsg_InvokerSpellCast} CDOTAEntityMsg_InvokerSpellCast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAEntityMsg_InvokerSpellCast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAEntityMsg_InvokerSpellCast message.
         * @function verify
         * @memberof CDOTAEntityMsg_InvokerSpellCast
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAEntityMsg_InvokerSpellCast.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entity_msg != null && message.hasOwnProperty("entity_msg")) {
                var error = $root.CEntityMsg.verify(message.entity_msg);
                if (error)
                    return "entity_msg." + error;
            }
            if (message.cast_activity != null && message.hasOwnProperty("cast_activity"))
                if (!$util.isInteger(message.cast_activity))
                    return "cast_activity: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAEntityMsg_InvokerSpellCast message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAEntityMsg_InvokerSpellCast
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAEntityMsg_InvokerSpellCast} CDOTAEntityMsg_InvokerSpellCast
         */
        CDOTAEntityMsg_InvokerSpellCast.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAEntityMsg_InvokerSpellCast)
                return object;
            var message = new $root.CDOTAEntityMsg_InvokerSpellCast();
            if (object.entity_msg != null) {
                if (typeof object.entity_msg !== "object")
                    throw TypeError(".CDOTAEntityMsg_InvokerSpellCast.entity_msg: object expected");
                message.entity_msg = $root.CEntityMsg.fromObject(object.entity_msg);
            }
            if (object.cast_activity != null)
                message.cast_activity = object.cast_activity | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAEntityMsg_InvokerSpellCast message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAEntityMsg_InvokerSpellCast
         * @static
         * @param {CDOTAEntityMsg_InvokerSpellCast} message CDOTAEntityMsg_InvokerSpellCast
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAEntityMsg_InvokerSpellCast.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.entity_msg = null;
                object.cast_activity = 0;
            }
            if (message.entity_msg != null && message.hasOwnProperty("entity_msg"))
                object.entity_msg = $root.CEntityMsg.toObject(message.entity_msg, options);
            if (message.cast_activity != null && message.hasOwnProperty("cast_activity"))
                object.cast_activity = message.cast_activity;
            return object;
        };
    
        /**
         * Converts this CDOTAEntityMsg_InvokerSpellCast to JSON.
         * @function toJSON
         * @memberof CDOTAEntityMsg_InvokerSpellCast
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAEntityMsg_InvokerSpellCast.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAEntityMsg_InvokerSpellCast;
    })();
    
    $root.CDOTAUserMsg_BuyBackStateAlert = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_BuyBackStateAlert.
         * @exports ICDOTAUserMsg_BuyBackStateAlert
         * @interface ICDOTAUserMsg_BuyBackStateAlert
         * @property {number|null} [player_id] CDOTAUserMsg_BuyBackStateAlert player_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_BuyBackStateAlert.
         * @exports CDOTAUserMsg_BuyBackStateAlert
         * @classdesc Represents a CDOTAUserMsg_BuyBackStateAlert.
         * @implements ICDOTAUserMsg_BuyBackStateAlert
         * @constructor
         * @param {ICDOTAUserMsg_BuyBackStateAlert=} [properties] Properties to set
         */
        function CDOTAUserMsg_BuyBackStateAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_BuyBackStateAlert player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_BuyBackStateAlert
         * @instance
         */
        CDOTAUserMsg_BuyBackStateAlert.prototype.player_id = 0;
    
        /**
         * Creates a new CDOTAUserMsg_BuyBackStateAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_BuyBackStateAlert
         * @static
         * @param {ICDOTAUserMsg_BuyBackStateAlert=} [properties] Properties to set
         * @returns {CDOTAUserMsg_BuyBackStateAlert} CDOTAUserMsg_BuyBackStateAlert instance
         */
        CDOTAUserMsg_BuyBackStateAlert.create = function create(properties) {
            return new CDOTAUserMsg_BuyBackStateAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_BuyBackStateAlert message. Does not implicitly {@link CDOTAUserMsg_BuyBackStateAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_BuyBackStateAlert
         * @static
         * @param {ICDOTAUserMsg_BuyBackStateAlert} message CDOTAUserMsg_BuyBackStateAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_BuyBackStateAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.player_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_BuyBackStateAlert message, length delimited. Does not implicitly {@link CDOTAUserMsg_BuyBackStateAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_BuyBackStateAlert
         * @static
         * @param {ICDOTAUserMsg_BuyBackStateAlert} message CDOTAUserMsg_BuyBackStateAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_BuyBackStateAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_BuyBackStateAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_BuyBackStateAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_BuyBackStateAlert} CDOTAUserMsg_BuyBackStateAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_BuyBackStateAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_BuyBackStateAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_BuyBackStateAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_BuyBackStateAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_BuyBackStateAlert} CDOTAUserMsg_BuyBackStateAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_BuyBackStateAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_BuyBackStateAlert message.
         * @function verify
         * @memberof CDOTAUserMsg_BuyBackStateAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_BuyBackStateAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_BuyBackStateAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_BuyBackStateAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_BuyBackStateAlert} CDOTAUserMsg_BuyBackStateAlert
         */
        CDOTAUserMsg_BuyBackStateAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_BuyBackStateAlert)
                return object;
            var message = new $root.CDOTAUserMsg_BuyBackStateAlert();
            if (object.player_id != null)
                message.player_id = object.player_id | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_BuyBackStateAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_BuyBackStateAlert
         * @static
         * @param {CDOTAUserMsg_BuyBackStateAlert} message CDOTAUserMsg_BuyBackStateAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_BuyBackStateAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.player_id = 0;
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_BuyBackStateAlert to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_BuyBackStateAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_BuyBackStateAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_BuyBackStateAlert;
    })();
    
    $root.CDOTAUserMsg_QuickBuyAlert = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_QuickBuyAlert.
         * @exports ICDOTAUserMsg_QuickBuyAlert
         * @interface ICDOTAUserMsg_QuickBuyAlert
         * @property {number|null} [player_id] CDOTAUserMsg_QuickBuyAlert player_id
         * @property {number|null} [item_ability_id] CDOTAUserMsg_QuickBuyAlert item_ability_id
         * @property {number|null} [gold_cost] CDOTAUserMsg_QuickBuyAlert gold_cost
         * @property {number|null} [item_cooldown_seconds] CDOTAUserMsg_QuickBuyAlert item_cooldown_seconds
         * @property {boolean|null} [show_buyback] CDOTAUserMsg_QuickBuyAlert show_buyback
         */
    
        /**
         * Constructs a new CDOTAUserMsg_QuickBuyAlert.
         * @exports CDOTAUserMsg_QuickBuyAlert
         * @classdesc Represents a CDOTAUserMsg_QuickBuyAlert.
         * @implements ICDOTAUserMsg_QuickBuyAlert
         * @constructor
         * @param {ICDOTAUserMsg_QuickBuyAlert=} [properties] Properties to set
         */
        function CDOTAUserMsg_QuickBuyAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_QuickBuyAlert player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_QuickBuyAlert
         * @instance
         */
        CDOTAUserMsg_QuickBuyAlert.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_QuickBuyAlert item_ability_id.
         * @member {number} item_ability_id
         * @memberof CDOTAUserMsg_QuickBuyAlert
         * @instance
         */
        CDOTAUserMsg_QuickBuyAlert.prototype.item_ability_id = 0;
    
        /**
         * CDOTAUserMsg_QuickBuyAlert gold_cost.
         * @member {number} gold_cost
         * @memberof CDOTAUserMsg_QuickBuyAlert
         * @instance
         */
        CDOTAUserMsg_QuickBuyAlert.prototype.gold_cost = 0;
    
        /**
         * CDOTAUserMsg_QuickBuyAlert item_cooldown_seconds.
         * @member {number} item_cooldown_seconds
         * @memberof CDOTAUserMsg_QuickBuyAlert
         * @instance
         */
        CDOTAUserMsg_QuickBuyAlert.prototype.item_cooldown_seconds = 0;
    
        /**
         * CDOTAUserMsg_QuickBuyAlert show_buyback.
         * @member {boolean} show_buyback
         * @memberof CDOTAUserMsg_QuickBuyAlert
         * @instance
         */
        CDOTAUserMsg_QuickBuyAlert.prototype.show_buyback = false;
    
        /**
         * Creates a new CDOTAUserMsg_QuickBuyAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_QuickBuyAlert
         * @static
         * @param {ICDOTAUserMsg_QuickBuyAlert=} [properties] Properties to set
         * @returns {CDOTAUserMsg_QuickBuyAlert} CDOTAUserMsg_QuickBuyAlert instance
         */
        CDOTAUserMsg_QuickBuyAlert.create = function create(properties) {
            return new CDOTAUserMsg_QuickBuyAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_QuickBuyAlert message. Does not implicitly {@link CDOTAUserMsg_QuickBuyAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_QuickBuyAlert
         * @static
         * @param {ICDOTAUserMsg_QuickBuyAlert} message CDOTAUserMsg_QuickBuyAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_QuickBuyAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.player_id);
            if (message.item_ability_id != null && Object.hasOwnProperty.call(message, "item_ability_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.item_ability_id);
            if (message.gold_cost != null && Object.hasOwnProperty.call(message, "gold_cost"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.gold_cost);
            if (message.item_cooldown_seconds != null && Object.hasOwnProperty.call(message, "item_cooldown_seconds"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.item_cooldown_seconds);
            if (message.show_buyback != null && Object.hasOwnProperty.call(message, "show_buyback"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.show_buyback);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_QuickBuyAlert message, length delimited. Does not implicitly {@link CDOTAUserMsg_QuickBuyAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_QuickBuyAlert
         * @static
         * @param {ICDOTAUserMsg_QuickBuyAlert} message CDOTAUserMsg_QuickBuyAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_QuickBuyAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_QuickBuyAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_QuickBuyAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_QuickBuyAlert} CDOTAUserMsg_QuickBuyAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_QuickBuyAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_QuickBuyAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.int32();
                    break;
                case 2:
                    message.item_ability_id = reader.int32();
                    break;
                case 3:
                    message.gold_cost = reader.int32();
                    break;
                case 4:
                    message.item_cooldown_seconds = reader.int32();
                    break;
                case 5:
                    message.show_buyback = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_QuickBuyAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_QuickBuyAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_QuickBuyAlert} CDOTAUserMsg_QuickBuyAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_QuickBuyAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_QuickBuyAlert message.
         * @function verify
         * @memberof CDOTAUserMsg_QuickBuyAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_QuickBuyAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                if (!$util.isInteger(message.item_ability_id))
                    return "item_ability_id: integer expected";
            if (message.gold_cost != null && message.hasOwnProperty("gold_cost"))
                if (!$util.isInteger(message.gold_cost))
                    return "gold_cost: integer expected";
            if (message.item_cooldown_seconds != null && message.hasOwnProperty("item_cooldown_seconds"))
                if (!$util.isInteger(message.item_cooldown_seconds))
                    return "item_cooldown_seconds: integer expected";
            if (message.show_buyback != null && message.hasOwnProperty("show_buyback"))
                if (typeof message.show_buyback !== "boolean")
                    return "show_buyback: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_QuickBuyAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_QuickBuyAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_QuickBuyAlert} CDOTAUserMsg_QuickBuyAlert
         */
        CDOTAUserMsg_QuickBuyAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_QuickBuyAlert)
                return object;
            var message = new $root.CDOTAUserMsg_QuickBuyAlert();
            if (object.player_id != null)
                message.player_id = object.player_id | 0;
            if (object.item_ability_id != null)
                message.item_ability_id = object.item_ability_id | 0;
            if (object.gold_cost != null)
                message.gold_cost = object.gold_cost | 0;
            if (object.item_cooldown_seconds != null)
                message.item_cooldown_seconds = object.item_cooldown_seconds | 0;
            if (object.show_buyback != null)
                message.show_buyback = Boolean(object.show_buyback);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_QuickBuyAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_QuickBuyAlert
         * @static
         * @param {CDOTAUserMsg_QuickBuyAlert} message CDOTAUserMsg_QuickBuyAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_QuickBuyAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.item_ability_id = 0;
                object.gold_cost = 0;
                object.item_cooldown_seconds = 0;
                object.show_buyback = false;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                object.item_ability_id = message.item_ability_id;
            if (message.gold_cost != null && message.hasOwnProperty("gold_cost"))
                object.gold_cost = message.gold_cost;
            if (message.item_cooldown_seconds != null && message.hasOwnProperty("item_cooldown_seconds"))
                object.item_cooldown_seconds = message.item_cooldown_seconds;
            if (message.show_buyback != null && message.hasOwnProperty("show_buyback"))
                object.show_buyback = message.show_buyback;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_QuickBuyAlert to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_QuickBuyAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_QuickBuyAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_QuickBuyAlert;
    })();
    
    $root.CDOTAUserMsg_CourierKilledAlert = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_CourierKilledAlert.
         * @exports ICDOTAUserMsg_CourierKilledAlert
         * @interface ICDOTAUserMsg_CourierKilledAlert
         * @property {number|null} [team] CDOTAUserMsg_CourierKilledAlert team
         * @property {number|null} [gold_value] CDOTAUserMsg_CourierKilledAlert gold_value
         * @property {number|null} [entity_handle] CDOTAUserMsg_CourierKilledAlert entity_handle
         * @property {number|null} [timestamp] CDOTAUserMsg_CourierKilledAlert timestamp
         * @property {Array.<CDOTAUserMsg_CourierKilledAlert.ILostItem>|null} [lost_items] CDOTAUserMsg_CourierKilledAlert lost_items
         * @property {number|null} [killer_player_id] CDOTAUserMsg_CourierKilledAlert killer_player_id
         * @property {number|null} [owning_player_id] CDOTAUserMsg_CourierKilledAlert owning_player_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_CourierKilledAlert.
         * @exports CDOTAUserMsg_CourierKilledAlert
         * @classdesc Represents a CDOTAUserMsg_CourierKilledAlert.
         * @implements ICDOTAUserMsg_CourierKilledAlert
         * @constructor
         * @param {ICDOTAUserMsg_CourierKilledAlert=} [properties] Properties to set
         */
        function CDOTAUserMsg_CourierKilledAlert(properties) {
            this.lost_items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_CourierKilledAlert team.
         * @member {number} team
         * @memberof CDOTAUserMsg_CourierKilledAlert
         * @instance
         */
        CDOTAUserMsg_CourierKilledAlert.prototype.team = 0;
    
        /**
         * CDOTAUserMsg_CourierKilledAlert gold_value.
         * @member {number} gold_value
         * @memberof CDOTAUserMsg_CourierKilledAlert
         * @instance
         */
        CDOTAUserMsg_CourierKilledAlert.prototype.gold_value = 0;
    
        /**
         * CDOTAUserMsg_CourierKilledAlert entity_handle.
         * @member {number} entity_handle
         * @memberof CDOTAUserMsg_CourierKilledAlert
         * @instance
         */
        CDOTAUserMsg_CourierKilledAlert.prototype.entity_handle = 0;
    
        /**
         * CDOTAUserMsg_CourierKilledAlert timestamp.
         * @member {number} timestamp
         * @memberof CDOTAUserMsg_CourierKilledAlert
         * @instance
         */
        CDOTAUserMsg_CourierKilledAlert.prototype.timestamp = 0;
    
        /**
         * CDOTAUserMsg_CourierKilledAlert lost_items.
         * @member {Array.<CDOTAUserMsg_CourierKilledAlert.ILostItem>} lost_items
         * @memberof CDOTAUserMsg_CourierKilledAlert
         * @instance
         */
        CDOTAUserMsg_CourierKilledAlert.prototype.lost_items = $util.emptyArray;
    
        /**
         * CDOTAUserMsg_CourierKilledAlert killer_player_id.
         * @member {number} killer_player_id
         * @memberof CDOTAUserMsg_CourierKilledAlert
         * @instance
         */
        CDOTAUserMsg_CourierKilledAlert.prototype.killer_player_id = 0;
    
        /**
         * CDOTAUserMsg_CourierKilledAlert owning_player_id.
         * @member {number} owning_player_id
         * @memberof CDOTAUserMsg_CourierKilledAlert
         * @instance
         */
        CDOTAUserMsg_CourierKilledAlert.prototype.owning_player_id = 0;
    
        /**
         * Creates a new CDOTAUserMsg_CourierKilledAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_CourierKilledAlert
         * @static
         * @param {ICDOTAUserMsg_CourierKilledAlert=} [properties] Properties to set
         * @returns {CDOTAUserMsg_CourierKilledAlert} CDOTAUserMsg_CourierKilledAlert instance
         */
        CDOTAUserMsg_CourierKilledAlert.create = function create(properties) {
            return new CDOTAUserMsg_CourierKilledAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CourierKilledAlert message. Does not implicitly {@link CDOTAUserMsg_CourierKilledAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_CourierKilledAlert
         * @static
         * @param {ICDOTAUserMsg_CourierKilledAlert} message CDOTAUserMsg_CourierKilledAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CourierKilledAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.team != null && Object.hasOwnProperty.call(message, "team"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.team);
            if (message.gold_value != null && Object.hasOwnProperty.call(message, "gold_value"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.gold_value);
            if (message.entity_handle != null && Object.hasOwnProperty.call(message, "entity_handle"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.entity_handle);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.timestamp);
            if (message.lost_items != null && message.lost_items.length)
                for (var i = 0; i < message.lost_items.length; ++i)
                    $root.CDOTAUserMsg_CourierKilledAlert.LostItem.encode(message.lost_items[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.killer_player_id != null && Object.hasOwnProperty.call(message, "killer_player_id"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.killer_player_id);
            if (message.owning_player_id != null && Object.hasOwnProperty.call(message, "owning_player_id"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.owning_player_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CourierKilledAlert message, length delimited. Does not implicitly {@link CDOTAUserMsg_CourierKilledAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_CourierKilledAlert
         * @static
         * @param {ICDOTAUserMsg_CourierKilledAlert} message CDOTAUserMsg_CourierKilledAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CourierKilledAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_CourierKilledAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_CourierKilledAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_CourierKilledAlert} CDOTAUserMsg_CourierKilledAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CourierKilledAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_CourierKilledAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.team = reader.uint32();
                    break;
                case 2:
                    message.gold_value = reader.uint32();
                    break;
                case 3:
                    message.entity_handle = reader.int32();
                    break;
                case 4:
                    message.timestamp = reader.int32();
                    break;
                case 5:
                    if (!(message.lost_items && message.lost_items.length))
                        message.lost_items = [];
                    message.lost_items.push($root.CDOTAUserMsg_CourierKilledAlert.LostItem.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.killer_player_id = reader.int32();
                    break;
                case 7:
                    message.owning_player_id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_CourierKilledAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_CourierKilledAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_CourierKilledAlert} CDOTAUserMsg_CourierKilledAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CourierKilledAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_CourierKilledAlert message.
         * @function verify
         * @memberof CDOTAUserMsg_CourierKilledAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_CourierKilledAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.team != null && message.hasOwnProperty("team"))
                if (!$util.isInteger(message.team))
                    return "team: integer expected";
            if (message.gold_value != null && message.hasOwnProperty("gold_value"))
                if (!$util.isInteger(message.gold_value))
                    return "gold_value: integer expected";
            if (message.entity_handle != null && message.hasOwnProperty("entity_handle"))
                if (!$util.isInteger(message.entity_handle))
                    return "entity_handle: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp))
                    return "timestamp: integer expected";
            if (message.lost_items != null && message.hasOwnProperty("lost_items")) {
                if (!Array.isArray(message.lost_items))
                    return "lost_items: array expected";
                for (var i = 0; i < message.lost_items.length; ++i) {
                    var error = $root.CDOTAUserMsg_CourierKilledAlert.LostItem.verify(message.lost_items[i]);
                    if (error)
                        return "lost_items." + error;
                }
            }
            if (message.killer_player_id != null && message.hasOwnProperty("killer_player_id"))
                if (!$util.isInteger(message.killer_player_id))
                    return "killer_player_id: integer expected";
            if (message.owning_player_id != null && message.hasOwnProperty("owning_player_id"))
                if (!$util.isInteger(message.owning_player_id))
                    return "owning_player_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_CourierKilledAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_CourierKilledAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_CourierKilledAlert} CDOTAUserMsg_CourierKilledAlert
         */
        CDOTAUserMsg_CourierKilledAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_CourierKilledAlert)
                return object;
            var message = new $root.CDOTAUserMsg_CourierKilledAlert();
            if (object.team != null)
                message.team = object.team >>> 0;
            if (object.gold_value != null)
                message.gold_value = object.gold_value >>> 0;
            if (object.entity_handle != null)
                message.entity_handle = object.entity_handle | 0;
            if (object.timestamp != null)
                message.timestamp = object.timestamp | 0;
            if (object.lost_items) {
                if (!Array.isArray(object.lost_items))
                    throw TypeError(".CDOTAUserMsg_CourierKilledAlert.lost_items: array expected");
                message.lost_items = [];
                for (var i = 0; i < object.lost_items.length; ++i) {
                    if (typeof object.lost_items[i] !== "object")
                        throw TypeError(".CDOTAUserMsg_CourierKilledAlert.lost_items: object expected");
                    message.lost_items[i] = $root.CDOTAUserMsg_CourierKilledAlert.LostItem.fromObject(object.lost_items[i]);
                }
            }
            if (object.killer_player_id != null)
                message.killer_player_id = object.killer_player_id | 0;
            if (object.owning_player_id != null)
                message.owning_player_id = object.owning_player_id | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_CourierKilledAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_CourierKilledAlert
         * @static
         * @param {CDOTAUserMsg_CourierKilledAlert} message CDOTAUserMsg_CourierKilledAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_CourierKilledAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.lost_items = [];
            if (options.defaults) {
                object.team = 0;
                object.gold_value = 0;
                object.entity_handle = 0;
                object.timestamp = 0;
                object.killer_player_id = 0;
                object.owning_player_id = 0;
            }
            if (message.team != null && message.hasOwnProperty("team"))
                object.team = message.team;
            if (message.gold_value != null && message.hasOwnProperty("gold_value"))
                object.gold_value = message.gold_value;
            if (message.entity_handle != null && message.hasOwnProperty("entity_handle"))
                object.entity_handle = message.entity_handle;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            if (message.lost_items && message.lost_items.length) {
                object.lost_items = [];
                for (var j = 0; j < message.lost_items.length; ++j)
                    object.lost_items[j] = $root.CDOTAUserMsg_CourierKilledAlert.LostItem.toObject(message.lost_items[j], options);
            }
            if (message.killer_player_id != null && message.hasOwnProperty("killer_player_id"))
                object.killer_player_id = message.killer_player_id;
            if (message.owning_player_id != null && message.hasOwnProperty("owning_player_id"))
                object.owning_player_id = message.owning_player_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_CourierKilledAlert to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_CourierKilledAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_CourierKilledAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CDOTAUserMsg_CourierKilledAlert.LostItem = (function() {
    
            /**
             * Properties of a LostItem.
             * @memberof CDOTAUserMsg_CourierKilledAlert
             * @interface ILostItem
             * @property {number|null} [item_ability_id] LostItem item_ability_id
             * @property {number|null} [quantity] LostItem quantity
             */
    
            /**
             * Constructs a new LostItem.
             * @memberof CDOTAUserMsg_CourierKilledAlert
             * @classdesc Represents a LostItem.
             * @implements ILostItem
             * @constructor
             * @param {CDOTAUserMsg_CourierKilledAlert.ILostItem=} [properties] Properties to set
             */
            function LostItem(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LostItem item_ability_id.
             * @member {number} item_ability_id
             * @memberof CDOTAUserMsg_CourierKilledAlert.LostItem
             * @instance
             */
            LostItem.prototype.item_ability_id = 0;
    
            /**
             * LostItem quantity.
             * @member {number} quantity
             * @memberof CDOTAUserMsg_CourierKilledAlert.LostItem
             * @instance
             */
            LostItem.prototype.quantity = 0;
    
            /**
             * Creates a new LostItem instance using the specified properties.
             * @function create
             * @memberof CDOTAUserMsg_CourierKilledAlert.LostItem
             * @static
             * @param {CDOTAUserMsg_CourierKilledAlert.ILostItem=} [properties] Properties to set
             * @returns {CDOTAUserMsg_CourierKilledAlert.LostItem} LostItem instance
             */
            LostItem.create = function create(properties) {
                return new LostItem(properties);
            };
    
            /**
             * Encodes the specified LostItem message. Does not implicitly {@link CDOTAUserMsg_CourierKilledAlert.LostItem.verify|verify} messages.
             * @function encode
             * @memberof CDOTAUserMsg_CourierKilledAlert.LostItem
             * @static
             * @param {CDOTAUserMsg_CourierKilledAlert.ILostItem} message LostItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LostItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.item_ability_id != null && Object.hasOwnProperty.call(message, "item_ability_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.item_ability_id);
                if (message.quantity != null && Object.hasOwnProperty.call(message, "quantity"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.quantity);
                return writer;
            };
    
            /**
             * Encodes the specified LostItem message, length delimited. Does not implicitly {@link CDOTAUserMsg_CourierKilledAlert.LostItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTAUserMsg_CourierKilledAlert.LostItem
             * @static
             * @param {CDOTAUserMsg_CourierKilledAlert.ILostItem} message LostItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LostItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a LostItem message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTAUserMsg_CourierKilledAlert.LostItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTAUserMsg_CourierKilledAlert.LostItem} LostItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LostItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_CourierKilledAlert.LostItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.item_ability_id = reader.int32();
                        break;
                    case 2:
                        message.quantity = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a LostItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTAUserMsg_CourierKilledAlert.LostItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTAUserMsg_CourierKilledAlert.LostItem} LostItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LostItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a LostItem message.
             * @function verify
             * @memberof CDOTAUserMsg_CourierKilledAlert.LostItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LostItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                    if (!$util.isInteger(message.item_ability_id))
                        return "item_ability_id: integer expected";
                if (message.quantity != null && message.hasOwnProperty("quantity"))
                    if (!$util.isInteger(message.quantity))
                        return "quantity: integer expected";
                return null;
            };
    
            /**
             * Creates a LostItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTAUserMsg_CourierKilledAlert.LostItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTAUserMsg_CourierKilledAlert.LostItem} LostItem
             */
            LostItem.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTAUserMsg_CourierKilledAlert.LostItem)
                    return object;
                var message = new $root.CDOTAUserMsg_CourierKilledAlert.LostItem();
                if (object.item_ability_id != null)
                    message.item_ability_id = object.item_ability_id | 0;
                if (object.quantity != null)
                    message.quantity = object.quantity >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a LostItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTAUserMsg_CourierKilledAlert.LostItem
             * @static
             * @param {CDOTAUserMsg_CourierKilledAlert.LostItem} message LostItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LostItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.item_ability_id = 0;
                    object.quantity = 0;
                }
                if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                    object.item_ability_id = message.item_ability_id;
                if (message.quantity != null && message.hasOwnProperty("quantity"))
                    object.quantity = message.quantity;
                return object;
            };
    
            /**
             * Converts this LostItem to JSON.
             * @function toJSON
             * @memberof CDOTAUserMsg_CourierKilledAlert.LostItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LostItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return LostItem;
        })();
    
        return CDOTAUserMsg_CourierKilledAlert;
    })();
    
    $root.CDOTAUserMsg_MinimapEvent = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_MinimapEvent.
         * @exports ICDOTAUserMsg_MinimapEvent
         * @interface ICDOTAUserMsg_MinimapEvent
         * @property {number|null} [event_type] CDOTAUserMsg_MinimapEvent event_type
         * @property {number|null} [entity_handle] CDOTAUserMsg_MinimapEvent entity_handle
         * @property {number|null} [x] CDOTAUserMsg_MinimapEvent x
         * @property {number|null} [y] CDOTAUserMsg_MinimapEvent y
         * @property {number|null} [duration] CDOTAUserMsg_MinimapEvent duration
         * @property {number|null} [target_entity_handle] CDOTAUserMsg_MinimapEvent target_entity_handle
         */
    
        /**
         * Constructs a new CDOTAUserMsg_MinimapEvent.
         * @exports CDOTAUserMsg_MinimapEvent
         * @classdesc Represents a CDOTAUserMsg_MinimapEvent.
         * @implements ICDOTAUserMsg_MinimapEvent
         * @constructor
         * @param {ICDOTAUserMsg_MinimapEvent=} [properties] Properties to set
         */
        function CDOTAUserMsg_MinimapEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_MinimapEvent event_type.
         * @member {number} event_type
         * @memberof CDOTAUserMsg_MinimapEvent
         * @instance
         */
        CDOTAUserMsg_MinimapEvent.prototype.event_type = 0;
    
        /**
         * CDOTAUserMsg_MinimapEvent entity_handle.
         * @member {number} entity_handle
         * @memberof CDOTAUserMsg_MinimapEvent
         * @instance
         */
        CDOTAUserMsg_MinimapEvent.prototype.entity_handle = 0;
    
        /**
         * CDOTAUserMsg_MinimapEvent x.
         * @member {number} x
         * @memberof CDOTAUserMsg_MinimapEvent
         * @instance
         */
        CDOTAUserMsg_MinimapEvent.prototype.x = 0;
    
        /**
         * CDOTAUserMsg_MinimapEvent y.
         * @member {number} y
         * @memberof CDOTAUserMsg_MinimapEvent
         * @instance
         */
        CDOTAUserMsg_MinimapEvent.prototype.y = 0;
    
        /**
         * CDOTAUserMsg_MinimapEvent duration.
         * @member {number} duration
         * @memberof CDOTAUserMsg_MinimapEvent
         * @instance
         */
        CDOTAUserMsg_MinimapEvent.prototype.duration = 0;
    
        /**
         * CDOTAUserMsg_MinimapEvent target_entity_handle.
         * @member {number} target_entity_handle
         * @memberof CDOTAUserMsg_MinimapEvent
         * @instance
         */
        CDOTAUserMsg_MinimapEvent.prototype.target_entity_handle = 0;
    
        /**
         * Creates a new CDOTAUserMsg_MinimapEvent instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_MinimapEvent
         * @static
         * @param {ICDOTAUserMsg_MinimapEvent=} [properties] Properties to set
         * @returns {CDOTAUserMsg_MinimapEvent} CDOTAUserMsg_MinimapEvent instance
         */
        CDOTAUserMsg_MinimapEvent.create = function create(properties) {
            return new CDOTAUserMsg_MinimapEvent(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_MinimapEvent message. Does not implicitly {@link CDOTAUserMsg_MinimapEvent.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_MinimapEvent
         * @static
         * @param {ICDOTAUserMsg_MinimapEvent} message CDOTAUserMsg_MinimapEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_MinimapEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event_type != null && Object.hasOwnProperty.call(message, "event_type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.event_type);
            if (message.entity_handle != null && Object.hasOwnProperty.call(message, "entity_handle"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.entity_handle);
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.y);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.duration);
            if (message.target_entity_handle != null && Object.hasOwnProperty.call(message, "target_entity_handle"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.target_entity_handle);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_MinimapEvent message, length delimited. Does not implicitly {@link CDOTAUserMsg_MinimapEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_MinimapEvent
         * @static
         * @param {ICDOTAUserMsg_MinimapEvent} message CDOTAUserMsg_MinimapEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_MinimapEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_MinimapEvent message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_MinimapEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_MinimapEvent} CDOTAUserMsg_MinimapEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_MinimapEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_MinimapEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.event_type = reader.int32();
                    break;
                case 2:
                    message.entity_handle = reader.int32();
                    break;
                case 3:
                    message.x = reader.int32();
                    break;
                case 4:
                    message.y = reader.int32();
                    break;
                case 5:
                    message.duration = reader.int32();
                    break;
                case 6:
                    message.target_entity_handle = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_MinimapEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_MinimapEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_MinimapEvent} CDOTAUserMsg_MinimapEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_MinimapEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_MinimapEvent message.
         * @function verify
         * @memberof CDOTAUserMsg_MinimapEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_MinimapEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event_type != null && message.hasOwnProperty("event_type"))
                if (!$util.isInteger(message.event_type))
                    return "event_type: integer expected";
            if (message.entity_handle != null && message.hasOwnProperty("entity_handle"))
                if (!$util.isInteger(message.entity_handle))
                    return "entity_handle: integer expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (!$util.isInteger(message.duration))
                    return "duration: integer expected";
            if (message.target_entity_handle != null && message.hasOwnProperty("target_entity_handle"))
                if (!$util.isInteger(message.target_entity_handle))
                    return "target_entity_handle: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_MinimapEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_MinimapEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_MinimapEvent} CDOTAUserMsg_MinimapEvent
         */
        CDOTAUserMsg_MinimapEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_MinimapEvent)
                return object;
            var message = new $root.CDOTAUserMsg_MinimapEvent();
            if (object.event_type != null)
                message.event_type = object.event_type | 0;
            if (object.entity_handle != null)
                message.entity_handle = object.entity_handle | 0;
            if (object.x != null)
                message.x = object.x | 0;
            if (object.y != null)
                message.y = object.y | 0;
            if (object.duration != null)
                message.duration = object.duration | 0;
            if (object.target_entity_handle != null)
                message.target_entity_handle = object.target_entity_handle | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_MinimapEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_MinimapEvent
         * @static
         * @param {CDOTAUserMsg_MinimapEvent} message CDOTAUserMsg_MinimapEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_MinimapEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.event_type = 0;
                object.entity_handle = 0;
                object.x = 0;
                object.y = 0;
                object.duration = 0;
                object.target_entity_handle = 0;
            }
            if (message.event_type != null && message.hasOwnProperty("event_type"))
                object.event_type = message.event_type;
            if (message.entity_handle != null && message.hasOwnProperty("entity_handle"))
                object.entity_handle = message.entity_handle;
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = message.duration;
            if (message.target_entity_handle != null && message.hasOwnProperty("target_entity_handle"))
                object.target_entity_handle = message.target_entity_handle;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_MinimapEvent to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_MinimapEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_MinimapEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_MinimapEvent;
    })();
    
    $root.CDOTAUserMsg_MapLine = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_MapLine.
         * @exports ICDOTAUserMsg_MapLine
         * @interface ICDOTAUserMsg_MapLine
         * @property {number|null} [player_id] CDOTAUserMsg_MapLine player_id
         * @property {ICDOTAMsg_MapLine|null} [mapline] CDOTAUserMsg_MapLine mapline
         */
    
        /**
         * Constructs a new CDOTAUserMsg_MapLine.
         * @exports CDOTAUserMsg_MapLine
         * @classdesc Represents a CDOTAUserMsg_MapLine.
         * @implements ICDOTAUserMsg_MapLine
         * @constructor
         * @param {ICDOTAUserMsg_MapLine=} [properties] Properties to set
         */
        function CDOTAUserMsg_MapLine(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_MapLine player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_MapLine
         * @instance
         */
        CDOTAUserMsg_MapLine.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_MapLine mapline.
         * @member {ICDOTAMsg_MapLine|null|undefined} mapline
         * @memberof CDOTAUserMsg_MapLine
         * @instance
         */
        CDOTAUserMsg_MapLine.prototype.mapline = null;
    
        /**
         * Creates a new CDOTAUserMsg_MapLine instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_MapLine
         * @static
         * @param {ICDOTAUserMsg_MapLine=} [properties] Properties to set
         * @returns {CDOTAUserMsg_MapLine} CDOTAUserMsg_MapLine instance
         */
        CDOTAUserMsg_MapLine.create = function create(properties) {
            return new CDOTAUserMsg_MapLine(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_MapLine message. Does not implicitly {@link CDOTAUserMsg_MapLine.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_MapLine
         * @static
         * @param {ICDOTAUserMsg_MapLine} message CDOTAUserMsg_MapLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_MapLine.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.player_id);
            if (message.mapline != null && Object.hasOwnProperty.call(message, "mapline"))
                $root.CDOTAMsg_MapLine.encode(message.mapline, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_MapLine message, length delimited. Does not implicitly {@link CDOTAUserMsg_MapLine.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_MapLine
         * @static
         * @param {ICDOTAUserMsg_MapLine} message CDOTAUserMsg_MapLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_MapLine.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_MapLine message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_MapLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_MapLine} CDOTAUserMsg_MapLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_MapLine.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_MapLine();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.int32();
                    break;
                case 2:
                    message.mapline = $root.CDOTAMsg_MapLine.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_MapLine message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_MapLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_MapLine} CDOTAUserMsg_MapLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_MapLine.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_MapLine message.
         * @function verify
         * @memberof CDOTAUserMsg_MapLine
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_MapLine.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.mapline != null && message.hasOwnProperty("mapline")) {
                var error = $root.CDOTAMsg_MapLine.verify(message.mapline);
                if (error)
                    return "mapline." + error;
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_MapLine message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_MapLine
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_MapLine} CDOTAUserMsg_MapLine
         */
        CDOTAUserMsg_MapLine.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_MapLine)
                return object;
            var message = new $root.CDOTAUserMsg_MapLine();
            if (object.player_id != null)
                message.player_id = object.player_id | 0;
            if (object.mapline != null) {
                if (typeof object.mapline !== "object")
                    throw TypeError(".CDOTAUserMsg_MapLine.mapline: object expected");
                message.mapline = $root.CDOTAMsg_MapLine.fromObject(object.mapline);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_MapLine message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_MapLine
         * @static
         * @param {CDOTAUserMsg_MapLine} message CDOTAUserMsg_MapLine
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_MapLine.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.mapline = null;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.mapline != null && message.hasOwnProperty("mapline"))
                object.mapline = $root.CDOTAMsg_MapLine.toObject(message.mapline, options);
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_MapLine to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_MapLine
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_MapLine.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_MapLine;
    })();
    
    $root.CDOTAUserMsg_MinimapDebugPoint = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_MinimapDebugPoint.
         * @exports ICDOTAUserMsg_MinimapDebugPoint
         * @interface ICDOTAUserMsg_MinimapDebugPoint
         * @property {ICMsgVector|null} [location] CDOTAUserMsg_MinimapDebugPoint location
         * @property {number|null} [color] CDOTAUserMsg_MinimapDebugPoint color
         * @property {number|null} [size] CDOTAUserMsg_MinimapDebugPoint size
         * @property {number|null} [duration] CDOTAUserMsg_MinimapDebugPoint duration
         * @property {number|null} [index] CDOTAUserMsg_MinimapDebugPoint index
         */
    
        /**
         * Constructs a new CDOTAUserMsg_MinimapDebugPoint.
         * @exports CDOTAUserMsg_MinimapDebugPoint
         * @classdesc Represents a CDOTAUserMsg_MinimapDebugPoint.
         * @implements ICDOTAUserMsg_MinimapDebugPoint
         * @constructor
         * @param {ICDOTAUserMsg_MinimapDebugPoint=} [properties] Properties to set
         */
        function CDOTAUserMsg_MinimapDebugPoint(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_MinimapDebugPoint location.
         * @member {ICMsgVector|null|undefined} location
         * @memberof CDOTAUserMsg_MinimapDebugPoint
         * @instance
         */
        CDOTAUserMsg_MinimapDebugPoint.prototype.location = null;
    
        /**
         * CDOTAUserMsg_MinimapDebugPoint color.
         * @member {number} color
         * @memberof CDOTAUserMsg_MinimapDebugPoint
         * @instance
         */
        CDOTAUserMsg_MinimapDebugPoint.prototype.color = 0;
    
        /**
         * CDOTAUserMsg_MinimapDebugPoint size.
         * @member {number} size
         * @memberof CDOTAUserMsg_MinimapDebugPoint
         * @instance
         */
        CDOTAUserMsg_MinimapDebugPoint.prototype.size = 0;
    
        /**
         * CDOTAUserMsg_MinimapDebugPoint duration.
         * @member {number} duration
         * @memberof CDOTAUserMsg_MinimapDebugPoint
         * @instance
         */
        CDOTAUserMsg_MinimapDebugPoint.prototype.duration = 0;
    
        /**
         * CDOTAUserMsg_MinimapDebugPoint index.
         * @member {number} index
         * @memberof CDOTAUserMsg_MinimapDebugPoint
         * @instance
         */
        CDOTAUserMsg_MinimapDebugPoint.prototype.index = 0;
    
        /**
         * Creates a new CDOTAUserMsg_MinimapDebugPoint instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_MinimapDebugPoint
         * @static
         * @param {ICDOTAUserMsg_MinimapDebugPoint=} [properties] Properties to set
         * @returns {CDOTAUserMsg_MinimapDebugPoint} CDOTAUserMsg_MinimapDebugPoint instance
         */
        CDOTAUserMsg_MinimapDebugPoint.create = function create(properties) {
            return new CDOTAUserMsg_MinimapDebugPoint(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_MinimapDebugPoint message. Does not implicitly {@link CDOTAUserMsg_MinimapDebugPoint.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_MinimapDebugPoint
         * @static
         * @param {ICDOTAUserMsg_MinimapDebugPoint} message CDOTAUserMsg_MinimapDebugPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_MinimapDebugPoint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                $root.CMsgVector.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.color);
            if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.size);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.duration);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.index);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_MinimapDebugPoint message, length delimited. Does not implicitly {@link CDOTAUserMsg_MinimapDebugPoint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_MinimapDebugPoint
         * @static
         * @param {ICDOTAUserMsg_MinimapDebugPoint} message CDOTAUserMsg_MinimapDebugPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_MinimapDebugPoint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_MinimapDebugPoint message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_MinimapDebugPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_MinimapDebugPoint} CDOTAUserMsg_MinimapDebugPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_MinimapDebugPoint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_MinimapDebugPoint();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.location = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.color = reader.uint32();
                    break;
                case 3:
                    message.size = reader.int32();
                    break;
                case 4:
                    message.duration = reader.float();
                    break;
                case 5:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_MinimapDebugPoint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_MinimapDebugPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_MinimapDebugPoint} CDOTAUserMsg_MinimapDebugPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_MinimapDebugPoint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_MinimapDebugPoint message.
         * @function verify
         * @memberof CDOTAUserMsg_MinimapDebugPoint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_MinimapDebugPoint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.location != null && message.hasOwnProperty("location")) {
                var error = $root.CMsgVector.verify(message.location);
                if (error)
                    return "location." + error;
            }
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isInteger(message.color))
                    return "color: integer expected";
            if (message.size != null && message.hasOwnProperty("size"))
                if (!$util.isInteger(message.size))
                    return "size: integer expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_MinimapDebugPoint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_MinimapDebugPoint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_MinimapDebugPoint} CDOTAUserMsg_MinimapDebugPoint
         */
        CDOTAUserMsg_MinimapDebugPoint.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_MinimapDebugPoint)
                return object;
            var message = new $root.CDOTAUserMsg_MinimapDebugPoint();
            if (object.location != null) {
                if (typeof object.location !== "object")
                    throw TypeError(".CDOTAUserMsg_MinimapDebugPoint.location: object expected");
                message.location = $root.CMsgVector.fromObject(object.location);
            }
            if (object.color != null)
                message.color = object.color >>> 0;
            if (object.size != null)
                message.size = object.size | 0;
            if (object.duration != null)
                message.duration = Number(object.duration);
            if (object.index != null)
                message.index = object.index | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_MinimapDebugPoint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_MinimapDebugPoint
         * @static
         * @param {CDOTAUserMsg_MinimapDebugPoint} message CDOTAUserMsg_MinimapDebugPoint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_MinimapDebugPoint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.location = null;
                object.color = 0;
                object.size = 0;
                object.duration = 0;
                object.index = 0;
            }
            if (message.location != null && message.hasOwnProperty("location"))
                object.location = $root.CMsgVector.toObject(message.location, options);
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.size != null && message.hasOwnProperty("size"))
                object.size = message.size;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_MinimapDebugPoint to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_MinimapDebugPoint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_MinimapDebugPoint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_MinimapDebugPoint;
    })();
    
    $root.CDOTAUserMsg_CreateLinearProjectile = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_CreateLinearProjectile.
         * @exports ICDOTAUserMsg_CreateLinearProjectile
         * @interface ICDOTAUserMsg_CreateLinearProjectile
         * @property {ICMsgVector|null} [origin] CDOTAUserMsg_CreateLinearProjectile origin
         * @property {ICMsgVector2D|null} [velocity] CDOTAUserMsg_CreateLinearProjectile velocity
         * @property {number|null} [entindex] CDOTAUserMsg_CreateLinearProjectile entindex
         * @property {number|Long|null} [particle_index] CDOTAUserMsg_CreateLinearProjectile particle_index
         * @property {number|null} [handle] CDOTAUserMsg_CreateLinearProjectile handle
         * @property {ICMsgVector2D|null} [acceleration] CDOTAUserMsg_CreateLinearProjectile acceleration
         * @property {number|null} [max_speed] CDOTAUserMsg_CreateLinearProjectile max_speed
         * @property {number|null} [fow_radius] CDOTAUserMsg_CreateLinearProjectile fow_radius
         * @property {boolean|null} [sticky_fow_reveal] CDOTAUserMsg_CreateLinearProjectile sticky_fow_reveal
         * @property {number|null} [distance] CDOTAUserMsg_CreateLinearProjectile distance
         * @property {number|null} [colorgemcolor] CDOTAUserMsg_CreateLinearProjectile colorgemcolor
         */
    
        /**
         * Constructs a new CDOTAUserMsg_CreateLinearProjectile.
         * @exports CDOTAUserMsg_CreateLinearProjectile
         * @classdesc Represents a CDOTAUserMsg_CreateLinearProjectile.
         * @implements ICDOTAUserMsg_CreateLinearProjectile
         * @constructor
         * @param {ICDOTAUserMsg_CreateLinearProjectile=} [properties] Properties to set
         */
        function CDOTAUserMsg_CreateLinearProjectile(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_CreateLinearProjectile origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CDOTAUserMsg_CreateLinearProjectile
         * @instance
         */
        CDOTAUserMsg_CreateLinearProjectile.prototype.origin = null;
    
        /**
         * CDOTAUserMsg_CreateLinearProjectile velocity.
         * @member {ICMsgVector2D|null|undefined} velocity
         * @memberof CDOTAUserMsg_CreateLinearProjectile
         * @instance
         */
        CDOTAUserMsg_CreateLinearProjectile.prototype.velocity = null;
    
        /**
         * CDOTAUserMsg_CreateLinearProjectile entindex.
         * @member {number} entindex
         * @memberof CDOTAUserMsg_CreateLinearProjectile
         * @instance
         */
        CDOTAUserMsg_CreateLinearProjectile.prototype.entindex = 0;
    
        /**
         * CDOTAUserMsg_CreateLinearProjectile particle_index.
         * @member {number|Long} particle_index
         * @memberof CDOTAUserMsg_CreateLinearProjectile
         * @instance
         */
        CDOTAUserMsg_CreateLinearProjectile.prototype.particle_index = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CDOTAUserMsg_CreateLinearProjectile handle.
         * @member {number} handle
         * @memberof CDOTAUserMsg_CreateLinearProjectile
         * @instance
         */
        CDOTAUserMsg_CreateLinearProjectile.prototype.handle = 0;
    
        /**
         * CDOTAUserMsg_CreateLinearProjectile acceleration.
         * @member {ICMsgVector2D|null|undefined} acceleration
         * @memberof CDOTAUserMsg_CreateLinearProjectile
         * @instance
         */
        CDOTAUserMsg_CreateLinearProjectile.prototype.acceleration = null;
    
        /**
         * CDOTAUserMsg_CreateLinearProjectile max_speed.
         * @member {number} max_speed
         * @memberof CDOTAUserMsg_CreateLinearProjectile
         * @instance
         */
        CDOTAUserMsg_CreateLinearProjectile.prototype.max_speed = 0;
    
        /**
         * CDOTAUserMsg_CreateLinearProjectile fow_radius.
         * @member {number} fow_radius
         * @memberof CDOTAUserMsg_CreateLinearProjectile
         * @instance
         */
        CDOTAUserMsg_CreateLinearProjectile.prototype.fow_radius = 0;
    
        /**
         * CDOTAUserMsg_CreateLinearProjectile sticky_fow_reveal.
         * @member {boolean} sticky_fow_reveal
         * @memberof CDOTAUserMsg_CreateLinearProjectile
         * @instance
         */
        CDOTAUserMsg_CreateLinearProjectile.prototype.sticky_fow_reveal = false;
    
        /**
         * CDOTAUserMsg_CreateLinearProjectile distance.
         * @member {number} distance
         * @memberof CDOTAUserMsg_CreateLinearProjectile
         * @instance
         */
        CDOTAUserMsg_CreateLinearProjectile.prototype.distance = 0;
    
        /**
         * CDOTAUserMsg_CreateLinearProjectile colorgemcolor.
         * @member {number} colorgemcolor
         * @memberof CDOTAUserMsg_CreateLinearProjectile
         * @instance
         */
        CDOTAUserMsg_CreateLinearProjectile.prototype.colorgemcolor = 0;
    
        /**
         * Creates a new CDOTAUserMsg_CreateLinearProjectile instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_CreateLinearProjectile
         * @static
         * @param {ICDOTAUserMsg_CreateLinearProjectile=} [properties] Properties to set
         * @returns {CDOTAUserMsg_CreateLinearProjectile} CDOTAUserMsg_CreateLinearProjectile instance
         */
        CDOTAUserMsg_CreateLinearProjectile.create = function create(properties) {
            return new CDOTAUserMsg_CreateLinearProjectile(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CreateLinearProjectile message. Does not implicitly {@link CDOTAUserMsg_CreateLinearProjectile.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_CreateLinearProjectile
         * @static
         * @param {ICDOTAUserMsg_CreateLinearProjectile} message CDOTAUserMsg_CreateLinearProjectile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CreateLinearProjectile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.velocity != null && Object.hasOwnProperty.call(message, "velocity"))
                $root.CMsgVector2D.encode(message.velocity, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.entindex != null && Object.hasOwnProperty.call(message, "entindex"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.entindex);
            if (message.particle_index != null && Object.hasOwnProperty.call(message, "particle_index"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.particle_index);
            if (message.handle != null && Object.hasOwnProperty.call(message, "handle"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.handle);
            if (message.acceleration != null && Object.hasOwnProperty.call(message, "acceleration"))
                $root.CMsgVector2D.encode(message.acceleration, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.max_speed != null && Object.hasOwnProperty.call(message, "max_speed"))
                writer.uint32(/* id 8, wireType 5 =*/69).float(message.max_speed);
            if (message.fow_radius != null && Object.hasOwnProperty.call(message, "fow_radius"))
                writer.uint32(/* id 9, wireType 5 =*/77).float(message.fow_radius);
            if (message.sticky_fow_reveal != null && Object.hasOwnProperty.call(message, "sticky_fow_reveal"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.sticky_fow_reveal);
            if (message.distance != null && Object.hasOwnProperty.call(message, "distance"))
                writer.uint32(/* id 11, wireType 5 =*/93).float(message.distance);
            if (message.colorgemcolor != null && Object.hasOwnProperty.call(message, "colorgemcolor"))
                writer.uint32(/* id 12, wireType 5 =*/101).fixed32(message.colorgemcolor);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CreateLinearProjectile message, length delimited. Does not implicitly {@link CDOTAUserMsg_CreateLinearProjectile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_CreateLinearProjectile
         * @static
         * @param {ICDOTAUserMsg_CreateLinearProjectile} message CDOTAUserMsg_CreateLinearProjectile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CreateLinearProjectile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_CreateLinearProjectile message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_CreateLinearProjectile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_CreateLinearProjectile} CDOTAUserMsg_CreateLinearProjectile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CreateLinearProjectile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_CreateLinearProjectile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.velocity = $root.CMsgVector2D.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.entindex = reader.int32();
                    break;
                case 5:
                    message.particle_index = reader.uint64();
                    break;
                case 6:
                    message.handle = reader.int32();
                    break;
                case 7:
                    message.acceleration = $root.CMsgVector2D.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.max_speed = reader.float();
                    break;
                case 9:
                    message.fow_radius = reader.float();
                    break;
                case 10:
                    message.sticky_fow_reveal = reader.bool();
                    break;
                case 11:
                    message.distance = reader.float();
                    break;
                case 12:
                    message.colorgemcolor = reader.fixed32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_CreateLinearProjectile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_CreateLinearProjectile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_CreateLinearProjectile} CDOTAUserMsg_CreateLinearProjectile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CreateLinearProjectile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_CreateLinearProjectile message.
         * @function verify
         * @memberof CDOTAUserMsg_CreateLinearProjectile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_CreateLinearProjectile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.velocity != null && message.hasOwnProperty("velocity")) {
                var error = $root.CMsgVector2D.verify(message.velocity);
                if (error)
                    return "velocity." + error;
            }
            if (message.entindex != null && message.hasOwnProperty("entindex"))
                if (!$util.isInteger(message.entindex))
                    return "entindex: integer expected";
            if (message.particle_index != null && message.hasOwnProperty("particle_index"))
                if (!$util.isInteger(message.particle_index) && !(message.particle_index && $util.isInteger(message.particle_index.low) && $util.isInteger(message.particle_index.high)))
                    return "particle_index: integer|Long expected";
            if (message.handle != null && message.hasOwnProperty("handle"))
                if (!$util.isInteger(message.handle))
                    return "handle: integer expected";
            if (message.acceleration != null && message.hasOwnProperty("acceleration")) {
                var error = $root.CMsgVector2D.verify(message.acceleration);
                if (error)
                    return "acceleration." + error;
            }
            if (message.max_speed != null && message.hasOwnProperty("max_speed"))
                if (typeof message.max_speed !== "number")
                    return "max_speed: number expected";
            if (message.fow_radius != null && message.hasOwnProperty("fow_radius"))
                if (typeof message.fow_radius !== "number")
                    return "fow_radius: number expected";
            if (message.sticky_fow_reveal != null && message.hasOwnProperty("sticky_fow_reveal"))
                if (typeof message.sticky_fow_reveal !== "boolean")
                    return "sticky_fow_reveal: boolean expected";
            if (message.distance != null && message.hasOwnProperty("distance"))
                if (typeof message.distance !== "number")
                    return "distance: number expected";
            if (message.colorgemcolor != null && message.hasOwnProperty("colorgemcolor"))
                if (!$util.isInteger(message.colorgemcolor))
                    return "colorgemcolor: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_CreateLinearProjectile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_CreateLinearProjectile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_CreateLinearProjectile} CDOTAUserMsg_CreateLinearProjectile
         */
        CDOTAUserMsg_CreateLinearProjectile.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_CreateLinearProjectile)
                return object;
            var message = new $root.CDOTAUserMsg_CreateLinearProjectile();
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CDOTAUserMsg_CreateLinearProjectile.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.velocity != null) {
                if (typeof object.velocity !== "object")
                    throw TypeError(".CDOTAUserMsg_CreateLinearProjectile.velocity: object expected");
                message.velocity = $root.CMsgVector2D.fromObject(object.velocity);
            }
            if (object.entindex != null)
                message.entindex = object.entindex | 0;
            if (object.particle_index != null)
                if ($util.Long)
                    (message.particle_index = $util.Long.fromValue(object.particle_index)).unsigned = true;
                else if (typeof object.particle_index === "string")
                    message.particle_index = parseInt(object.particle_index, 10);
                else if (typeof object.particle_index === "number")
                    message.particle_index = object.particle_index;
                else if (typeof object.particle_index === "object")
                    message.particle_index = new $util.LongBits(object.particle_index.low >>> 0, object.particle_index.high >>> 0).toNumber(true);
            if (object.handle != null)
                message.handle = object.handle | 0;
            if (object.acceleration != null) {
                if (typeof object.acceleration !== "object")
                    throw TypeError(".CDOTAUserMsg_CreateLinearProjectile.acceleration: object expected");
                message.acceleration = $root.CMsgVector2D.fromObject(object.acceleration);
            }
            if (object.max_speed != null)
                message.max_speed = Number(object.max_speed);
            if (object.fow_radius != null)
                message.fow_radius = Number(object.fow_radius);
            if (object.sticky_fow_reveal != null)
                message.sticky_fow_reveal = Boolean(object.sticky_fow_reveal);
            if (object.distance != null)
                message.distance = Number(object.distance);
            if (object.colorgemcolor != null)
                message.colorgemcolor = object.colorgemcolor >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_CreateLinearProjectile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_CreateLinearProjectile
         * @static
         * @param {CDOTAUserMsg_CreateLinearProjectile} message CDOTAUserMsg_CreateLinearProjectile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_CreateLinearProjectile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.origin = null;
                object.velocity = null;
                object.entindex = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.particle_index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.particle_index = options.longs === String ? "0" : 0;
                object.handle = 0;
                object.acceleration = null;
                object.max_speed = 0;
                object.fow_radius = 0;
                object.sticky_fow_reveal = false;
                object.distance = 0;
                object.colorgemcolor = 0;
            }
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.velocity != null && message.hasOwnProperty("velocity"))
                object.velocity = $root.CMsgVector2D.toObject(message.velocity, options);
            if (message.entindex != null && message.hasOwnProperty("entindex"))
                object.entindex = message.entindex;
            if (message.particle_index != null && message.hasOwnProperty("particle_index"))
                if (typeof message.particle_index === "number")
                    object.particle_index = options.longs === String ? String(message.particle_index) : message.particle_index;
                else
                    object.particle_index = options.longs === String ? $util.Long.prototype.toString.call(message.particle_index) : options.longs === Number ? new $util.LongBits(message.particle_index.low >>> 0, message.particle_index.high >>> 0).toNumber(true) : message.particle_index;
            if (message.handle != null && message.hasOwnProperty("handle"))
                object.handle = message.handle;
            if (message.acceleration != null && message.hasOwnProperty("acceleration"))
                object.acceleration = $root.CMsgVector2D.toObject(message.acceleration, options);
            if (message.max_speed != null && message.hasOwnProperty("max_speed"))
                object.max_speed = options.json && !isFinite(message.max_speed) ? String(message.max_speed) : message.max_speed;
            if (message.fow_radius != null && message.hasOwnProperty("fow_radius"))
                object.fow_radius = options.json && !isFinite(message.fow_radius) ? String(message.fow_radius) : message.fow_radius;
            if (message.sticky_fow_reveal != null && message.hasOwnProperty("sticky_fow_reveal"))
                object.sticky_fow_reveal = message.sticky_fow_reveal;
            if (message.distance != null && message.hasOwnProperty("distance"))
                object.distance = options.json && !isFinite(message.distance) ? String(message.distance) : message.distance;
            if (message.colorgemcolor != null && message.hasOwnProperty("colorgemcolor"))
                object.colorgemcolor = message.colorgemcolor;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_CreateLinearProjectile to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_CreateLinearProjectile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_CreateLinearProjectile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_CreateLinearProjectile;
    })();
    
    $root.CDOTAUserMsg_DestroyLinearProjectile = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_DestroyLinearProjectile.
         * @exports ICDOTAUserMsg_DestroyLinearProjectile
         * @interface ICDOTAUserMsg_DestroyLinearProjectile
         * @property {number|null} [handle] CDOTAUserMsg_DestroyLinearProjectile handle
         */
    
        /**
         * Constructs a new CDOTAUserMsg_DestroyLinearProjectile.
         * @exports CDOTAUserMsg_DestroyLinearProjectile
         * @classdesc Represents a CDOTAUserMsg_DestroyLinearProjectile.
         * @implements ICDOTAUserMsg_DestroyLinearProjectile
         * @constructor
         * @param {ICDOTAUserMsg_DestroyLinearProjectile=} [properties] Properties to set
         */
        function CDOTAUserMsg_DestroyLinearProjectile(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_DestroyLinearProjectile handle.
         * @member {number} handle
         * @memberof CDOTAUserMsg_DestroyLinearProjectile
         * @instance
         */
        CDOTAUserMsg_DestroyLinearProjectile.prototype.handle = 0;
    
        /**
         * Creates a new CDOTAUserMsg_DestroyLinearProjectile instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_DestroyLinearProjectile
         * @static
         * @param {ICDOTAUserMsg_DestroyLinearProjectile=} [properties] Properties to set
         * @returns {CDOTAUserMsg_DestroyLinearProjectile} CDOTAUserMsg_DestroyLinearProjectile instance
         */
        CDOTAUserMsg_DestroyLinearProjectile.create = function create(properties) {
            return new CDOTAUserMsg_DestroyLinearProjectile(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_DestroyLinearProjectile message. Does not implicitly {@link CDOTAUserMsg_DestroyLinearProjectile.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_DestroyLinearProjectile
         * @static
         * @param {ICDOTAUserMsg_DestroyLinearProjectile} message CDOTAUserMsg_DestroyLinearProjectile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_DestroyLinearProjectile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.handle != null && Object.hasOwnProperty.call(message, "handle"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.handle);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_DestroyLinearProjectile message, length delimited. Does not implicitly {@link CDOTAUserMsg_DestroyLinearProjectile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_DestroyLinearProjectile
         * @static
         * @param {ICDOTAUserMsg_DestroyLinearProjectile} message CDOTAUserMsg_DestroyLinearProjectile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_DestroyLinearProjectile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_DestroyLinearProjectile message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_DestroyLinearProjectile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_DestroyLinearProjectile} CDOTAUserMsg_DestroyLinearProjectile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_DestroyLinearProjectile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_DestroyLinearProjectile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.handle = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_DestroyLinearProjectile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_DestroyLinearProjectile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_DestroyLinearProjectile} CDOTAUserMsg_DestroyLinearProjectile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_DestroyLinearProjectile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_DestroyLinearProjectile message.
         * @function verify
         * @memberof CDOTAUserMsg_DestroyLinearProjectile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_DestroyLinearProjectile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.handle != null && message.hasOwnProperty("handle"))
                if (!$util.isInteger(message.handle))
                    return "handle: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_DestroyLinearProjectile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_DestroyLinearProjectile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_DestroyLinearProjectile} CDOTAUserMsg_DestroyLinearProjectile
         */
        CDOTAUserMsg_DestroyLinearProjectile.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_DestroyLinearProjectile)
                return object;
            var message = new $root.CDOTAUserMsg_DestroyLinearProjectile();
            if (object.handle != null)
                message.handle = object.handle | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_DestroyLinearProjectile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_DestroyLinearProjectile
         * @static
         * @param {CDOTAUserMsg_DestroyLinearProjectile} message CDOTAUserMsg_DestroyLinearProjectile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_DestroyLinearProjectile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.handle = 0;
            if (message.handle != null && message.hasOwnProperty("handle"))
                object.handle = message.handle;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_DestroyLinearProjectile to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_DestroyLinearProjectile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_DestroyLinearProjectile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_DestroyLinearProjectile;
    })();
    
    $root.CDOTAUserMsg_DodgeTrackingProjectiles = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_DodgeTrackingProjectiles.
         * @exports ICDOTAUserMsg_DodgeTrackingProjectiles
         * @interface ICDOTAUserMsg_DodgeTrackingProjectiles
         * @property {number} entindex CDOTAUserMsg_DodgeTrackingProjectiles entindex
         * @property {boolean|null} [attacks_only] CDOTAUserMsg_DodgeTrackingProjectiles attacks_only
         */
    
        /**
         * Constructs a new CDOTAUserMsg_DodgeTrackingProjectiles.
         * @exports CDOTAUserMsg_DodgeTrackingProjectiles
         * @classdesc Represents a CDOTAUserMsg_DodgeTrackingProjectiles.
         * @implements ICDOTAUserMsg_DodgeTrackingProjectiles
         * @constructor
         * @param {ICDOTAUserMsg_DodgeTrackingProjectiles=} [properties] Properties to set
         */
        function CDOTAUserMsg_DodgeTrackingProjectiles(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_DodgeTrackingProjectiles entindex.
         * @member {number} entindex
         * @memberof CDOTAUserMsg_DodgeTrackingProjectiles
         * @instance
         */
        CDOTAUserMsg_DodgeTrackingProjectiles.prototype.entindex = 0;
    
        /**
         * CDOTAUserMsg_DodgeTrackingProjectiles attacks_only.
         * @member {boolean} attacks_only
         * @memberof CDOTAUserMsg_DodgeTrackingProjectiles
         * @instance
         */
        CDOTAUserMsg_DodgeTrackingProjectiles.prototype.attacks_only = false;
    
        /**
         * Creates a new CDOTAUserMsg_DodgeTrackingProjectiles instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_DodgeTrackingProjectiles
         * @static
         * @param {ICDOTAUserMsg_DodgeTrackingProjectiles=} [properties] Properties to set
         * @returns {CDOTAUserMsg_DodgeTrackingProjectiles} CDOTAUserMsg_DodgeTrackingProjectiles instance
         */
        CDOTAUserMsg_DodgeTrackingProjectiles.create = function create(properties) {
            return new CDOTAUserMsg_DodgeTrackingProjectiles(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_DodgeTrackingProjectiles message. Does not implicitly {@link CDOTAUserMsg_DodgeTrackingProjectiles.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_DodgeTrackingProjectiles
         * @static
         * @param {ICDOTAUserMsg_DodgeTrackingProjectiles} message CDOTAUserMsg_DodgeTrackingProjectiles message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_DodgeTrackingProjectiles.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.entindex);
            if (message.attacks_only != null && Object.hasOwnProperty.call(message, "attacks_only"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.attacks_only);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_DodgeTrackingProjectiles message, length delimited. Does not implicitly {@link CDOTAUserMsg_DodgeTrackingProjectiles.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_DodgeTrackingProjectiles
         * @static
         * @param {ICDOTAUserMsg_DodgeTrackingProjectiles} message CDOTAUserMsg_DodgeTrackingProjectiles message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_DodgeTrackingProjectiles.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_DodgeTrackingProjectiles message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_DodgeTrackingProjectiles
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_DodgeTrackingProjectiles} CDOTAUserMsg_DodgeTrackingProjectiles
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_DodgeTrackingProjectiles.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_DodgeTrackingProjectiles();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.entindex = reader.int32();
                    break;
                case 2:
                    message.attacks_only = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("entindex"))
                throw $util.ProtocolError("missing required 'entindex'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_DodgeTrackingProjectiles message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_DodgeTrackingProjectiles
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_DodgeTrackingProjectiles} CDOTAUserMsg_DodgeTrackingProjectiles
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_DodgeTrackingProjectiles.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_DodgeTrackingProjectiles message.
         * @function verify
         * @memberof CDOTAUserMsg_DodgeTrackingProjectiles
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_DodgeTrackingProjectiles.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.entindex))
                return "entindex: integer expected";
            if (message.attacks_only != null && message.hasOwnProperty("attacks_only"))
                if (typeof message.attacks_only !== "boolean")
                    return "attacks_only: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_DodgeTrackingProjectiles message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_DodgeTrackingProjectiles
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_DodgeTrackingProjectiles} CDOTAUserMsg_DodgeTrackingProjectiles
         */
        CDOTAUserMsg_DodgeTrackingProjectiles.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_DodgeTrackingProjectiles)
                return object;
            var message = new $root.CDOTAUserMsg_DodgeTrackingProjectiles();
            if (object.entindex != null)
                message.entindex = object.entindex | 0;
            if (object.attacks_only != null)
                message.attacks_only = Boolean(object.attacks_only);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_DodgeTrackingProjectiles message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_DodgeTrackingProjectiles
         * @static
         * @param {CDOTAUserMsg_DodgeTrackingProjectiles} message CDOTAUserMsg_DodgeTrackingProjectiles
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_DodgeTrackingProjectiles.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.entindex = 0;
                object.attacks_only = false;
            }
            if (message.entindex != null && message.hasOwnProperty("entindex"))
                object.entindex = message.entindex;
            if (message.attacks_only != null && message.hasOwnProperty("attacks_only"))
                object.attacks_only = message.attacks_only;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_DodgeTrackingProjectiles to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_DodgeTrackingProjectiles
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_DodgeTrackingProjectiles.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_DodgeTrackingProjectiles;
    })();
    
    $root.CDOTAUserMsg_SpectatorPlayerClick = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_SpectatorPlayerClick.
         * @exports ICDOTAUserMsg_SpectatorPlayerClick
         * @interface ICDOTAUserMsg_SpectatorPlayerClick
         * @property {number} entindex CDOTAUserMsg_SpectatorPlayerClick entindex
         * @property {number|null} [order_type] CDOTAUserMsg_SpectatorPlayerClick order_type
         * @property {number|null} [target_index] CDOTAUserMsg_SpectatorPlayerClick target_index
         */
    
        /**
         * Constructs a new CDOTAUserMsg_SpectatorPlayerClick.
         * @exports CDOTAUserMsg_SpectatorPlayerClick
         * @classdesc Represents a CDOTAUserMsg_SpectatorPlayerClick.
         * @implements ICDOTAUserMsg_SpectatorPlayerClick
         * @constructor
         * @param {ICDOTAUserMsg_SpectatorPlayerClick=} [properties] Properties to set
         */
        function CDOTAUserMsg_SpectatorPlayerClick(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_SpectatorPlayerClick entindex.
         * @member {number} entindex
         * @memberof CDOTAUserMsg_SpectatorPlayerClick
         * @instance
         */
        CDOTAUserMsg_SpectatorPlayerClick.prototype.entindex = 0;
    
        /**
         * CDOTAUserMsg_SpectatorPlayerClick order_type.
         * @member {number} order_type
         * @memberof CDOTAUserMsg_SpectatorPlayerClick
         * @instance
         */
        CDOTAUserMsg_SpectatorPlayerClick.prototype.order_type = 0;
    
        /**
         * CDOTAUserMsg_SpectatorPlayerClick target_index.
         * @member {number} target_index
         * @memberof CDOTAUserMsg_SpectatorPlayerClick
         * @instance
         */
        CDOTAUserMsg_SpectatorPlayerClick.prototype.target_index = 0;
    
        /**
         * Creates a new CDOTAUserMsg_SpectatorPlayerClick instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_SpectatorPlayerClick
         * @static
         * @param {ICDOTAUserMsg_SpectatorPlayerClick=} [properties] Properties to set
         * @returns {CDOTAUserMsg_SpectatorPlayerClick} CDOTAUserMsg_SpectatorPlayerClick instance
         */
        CDOTAUserMsg_SpectatorPlayerClick.create = function create(properties) {
            return new CDOTAUserMsg_SpectatorPlayerClick(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SpectatorPlayerClick message. Does not implicitly {@link CDOTAUserMsg_SpectatorPlayerClick.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_SpectatorPlayerClick
         * @static
         * @param {ICDOTAUserMsg_SpectatorPlayerClick} message CDOTAUserMsg_SpectatorPlayerClick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SpectatorPlayerClick.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.entindex);
            if (message.order_type != null && Object.hasOwnProperty.call(message, "order_type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.order_type);
            if (message.target_index != null && Object.hasOwnProperty.call(message, "target_index"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.target_index);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SpectatorPlayerClick message, length delimited. Does not implicitly {@link CDOTAUserMsg_SpectatorPlayerClick.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_SpectatorPlayerClick
         * @static
         * @param {ICDOTAUserMsg_SpectatorPlayerClick} message CDOTAUserMsg_SpectatorPlayerClick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SpectatorPlayerClick.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_SpectatorPlayerClick message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_SpectatorPlayerClick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_SpectatorPlayerClick} CDOTAUserMsg_SpectatorPlayerClick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SpectatorPlayerClick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_SpectatorPlayerClick();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.entindex = reader.int32();
                    break;
                case 2:
                    message.order_type = reader.int32();
                    break;
                case 3:
                    message.target_index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("entindex"))
                throw $util.ProtocolError("missing required 'entindex'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_SpectatorPlayerClick message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_SpectatorPlayerClick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_SpectatorPlayerClick} CDOTAUserMsg_SpectatorPlayerClick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SpectatorPlayerClick.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_SpectatorPlayerClick message.
         * @function verify
         * @memberof CDOTAUserMsg_SpectatorPlayerClick
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_SpectatorPlayerClick.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.entindex))
                return "entindex: integer expected";
            if (message.order_type != null && message.hasOwnProperty("order_type"))
                if (!$util.isInteger(message.order_type))
                    return "order_type: integer expected";
            if (message.target_index != null && message.hasOwnProperty("target_index"))
                if (!$util.isInteger(message.target_index))
                    return "target_index: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_SpectatorPlayerClick message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_SpectatorPlayerClick
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_SpectatorPlayerClick} CDOTAUserMsg_SpectatorPlayerClick
         */
        CDOTAUserMsg_SpectatorPlayerClick.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_SpectatorPlayerClick)
                return object;
            var message = new $root.CDOTAUserMsg_SpectatorPlayerClick();
            if (object.entindex != null)
                message.entindex = object.entindex | 0;
            if (object.order_type != null)
                message.order_type = object.order_type | 0;
            if (object.target_index != null)
                message.target_index = object.target_index | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_SpectatorPlayerClick message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_SpectatorPlayerClick
         * @static
         * @param {CDOTAUserMsg_SpectatorPlayerClick} message CDOTAUserMsg_SpectatorPlayerClick
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_SpectatorPlayerClick.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.entindex = 0;
                object.order_type = 0;
                object.target_index = 0;
            }
            if (message.entindex != null && message.hasOwnProperty("entindex"))
                object.entindex = message.entindex;
            if (message.order_type != null && message.hasOwnProperty("order_type"))
                object.order_type = message.order_type;
            if (message.target_index != null && message.hasOwnProperty("target_index"))
                object.target_index = message.target_index;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_SpectatorPlayerClick to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_SpectatorPlayerClick
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_SpectatorPlayerClick.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_SpectatorPlayerClick;
    })();
    
    $root.CDOTAUserMsg_SpectatorPlayerUnitOrders = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_SpectatorPlayerUnitOrders.
         * @exports ICDOTAUserMsg_SpectatorPlayerUnitOrders
         * @interface ICDOTAUserMsg_SpectatorPlayerUnitOrders
         * @property {number|null} [entindex] CDOTAUserMsg_SpectatorPlayerUnitOrders entindex
         * @property {number|null} [order_type] CDOTAUserMsg_SpectatorPlayerUnitOrders order_type
         * @property {Array.<number>|null} [units] CDOTAUserMsg_SpectatorPlayerUnitOrders units
         * @property {number|null} [target_index] CDOTAUserMsg_SpectatorPlayerUnitOrders target_index
         * @property {number|null} [ability_id] CDOTAUserMsg_SpectatorPlayerUnitOrders ability_id
         * @property {ICMsgVector|null} [position] CDOTAUserMsg_SpectatorPlayerUnitOrders position
         * @property {boolean|null} [queue] CDOTAUserMsg_SpectatorPlayerUnitOrders queue
         * @property {number|null} [sequence_number] CDOTAUserMsg_SpectatorPlayerUnitOrders sequence_number
         * @property {number|null} [flags] CDOTAUserMsg_SpectatorPlayerUnitOrders flags
         */
    
        /**
         * Constructs a new CDOTAUserMsg_SpectatorPlayerUnitOrders.
         * @exports CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @classdesc Represents a CDOTAUserMsg_SpectatorPlayerUnitOrders.
         * @implements ICDOTAUserMsg_SpectatorPlayerUnitOrders
         * @constructor
         * @param {ICDOTAUserMsg_SpectatorPlayerUnitOrders=} [properties] Properties to set
         */
        function CDOTAUserMsg_SpectatorPlayerUnitOrders(properties) {
            this.units = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_SpectatorPlayerUnitOrders entindex.
         * @member {number} entindex
         * @memberof CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @instance
         */
        CDOTAUserMsg_SpectatorPlayerUnitOrders.prototype.entindex = 0;
    
        /**
         * CDOTAUserMsg_SpectatorPlayerUnitOrders order_type.
         * @member {number} order_type
         * @memberof CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @instance
         */
        CDOTAUserMsg_SpectatorPlayerUnitOrders.prototype.order_type = 0;
    
        /**
         * CDOTAUserMsg_SpectatorPlayerUnitOrders units.
         * @member {Array.<number>} units
         * @memberof CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @instance
         */
        CDOTAUserMsg_SpectatorPlayerUnitOrders.prototype.units = $util.emptyArray;
    
        /**
         * CDOTAUserMsg_SpectatorPlayerUnitOrders target_index.
         * @member {number} target_index
         * @memberof CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @instance
         */
        CDOTAUserMsg_SpectatorPlayerUnitOrders.prototype.target_index = 0;
    
        /**
         * CDOTAUserMsg_SpectatorPlayerUnitOrders ability_id.
         * @member {number} ability_id
         * @memberof CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @instance
         */
        CDOTAUserMsg_SpectatorPlayerUnitOrders.prototype.ability_id = 0;
    
        /**
         * CDOTAUserMsg_SpectatorPlayerUnitOrders position.
         * @member {ICMsgVector|null|undefined} position
         * @memberof CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @instance
         */
        CDOTAUserMsg_SpectatorPlayerUnitOrders.prototype.position = null;
    
        /**
         * CDOTAUserMsg_SpectatorPlayerUnitOrders queue.
         * @member {boolean} queue
         * @memberof CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @instance
         */
        CDOTAUserMsg_SpectatorPlayerUnitOrders.prototype.queue = false;
    
        /**
         * CDOTAUserMsg_SpectatorPlayerUnitOrders sequence_number.
         * @member {number} sequence_number
         * @memberof CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @instance
         */
        CDOTAUserMsg_SpectatorPlayerUnitOrders.prototype.sequence_number = 0;
    
        /**
         * CDOTAUserMsg_SpectatorPlayerUnitOrders flags.
         * @member {number} flags
         * @memberof CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @instance
         */
        CDOTAUserMsg_SpectatorPlayerUnitOrders.prototype.flags = 0;
    
        /**
         * Creates a new CDOTAUserMsg_SpectatorPlayerUnitOrders instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @static
         * @param {ICDOTAUserMsg_SpectatorPlayerUnitOrders=} [properties] Properties to set
         * @returns {CDOTAUserMsg_SpectatorPlayerUnitOrders} CDOTAUserMsg_SpectatorPlayerUnitOrders instance
         */
        CDOTAUserMsg_SpectatorPlayerUnitOrders.create = function create(properties) {
            return new CDOTAUserMsg_SpectatorPlayerUnitOrders(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SpectatorPlayerUnitOrders message. Does not implicitly {@link CDOTAUserMsg_SpectatorPlayerUnitOrders.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @static
         * @param {ICDOTAUserMsg_SpectatorPlayerUnitOrders} message CDOTAUserMsg_SpectatorPlayerUnitOrders message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SpectatorPlayerUnitOrders.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entindex != null && Object.hasOwnProperty.call(message, "entindex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.entindex);
            if (message.order_type != null && Object.hasOwnProperty.call(message, "order_type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.order_type);
            if (message.units != null && message.units.length)
                for (var i = 0; i < message.units.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.units[i]);
            if (message.target_index != null && Object.hasOwnProperty.call(message, "target_index"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.target_index);
            if (message.ability_id != null && Object.hasOwnProperty.call(message, "ability_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.ability_id);
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                $root.CMsgVector.encode(message.position, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.queue != null && Object.hasOwnProperty.call(message, "queue"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.queue);
            if (message.sequence_number != null && Object.hasOwnProperty.call(message, "sequence_number"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.sequence_number);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.flags);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SpectatorPlayerUnitOrders message, length delimited. Does not implicitly {@link CDOTAUserMsg_SpectatorPlayerUnitOrders.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @static
         * @param {ICDOTAUserMsg_SpectatorPlayerUnitOrders} message CDOTAUserMsg_SpectatorPlayerUnitOrders message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SpectatorPlayerUnitOrders.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_SpectatorPlayerUnitOrders message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_SpectatorPlayerUnitOrders} CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SpectatorPlayerUnitOrders.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_SpectatorPlayerUnitOrders();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.entindex = reader.int32();
                    break;
                case 2:
                    message.order_type = reader.int32();
                    break;
                case 3:
                    if (!(message.units && message.units.length))
                        message.units = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.units.push(reader.int32());
                    } else
                        message.units.push(reader.int32());
                    break;
                case 4:
                    message.target_index = reader.int32();
                    break;
                case 5:
                    message.ability_id = reader.int32();
                    break;
                case 6:
                    message.position = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.queue = reader.bool();
                    break;
                case 8:
                    message.sequence_number = reader.int32();
                    break;
                case 9:
                    message.flags = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_SpectatorPlayerUnitOrders message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_SpectatorPlayerUnitOrders} CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SpectatorPlayerUnitOrders.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_SpectatorPlayerUnitOrders message.
         * @function verify
         * @memberof CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_SpectatorPlayerUnitOrders.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entindex != null && message.hasOwnProperty("entindex"))
                if (!$util.isInteger(message.entindex))
                    return "entindex: integer expected";
            if (message.order_type != null && message.hasOwnProperty("order_type"))
                if (!$util.isInteger(message.order_type))
                    return "order_type: integer expected";
            if (message.units != null && message.hasOwnProperty("units")) {
                if (!Array.isArray(message.units))
                    return "units: array expected";
                for (var i = 0; i < message.units.length; ++i)
                    if (!$util.isInteger(message.units[i]))
                        return "units: integer[] expected";
            }
            if (message.target_index != null && message.hasOwnProperty("target_index"))
                if (!$util.isInteger(message.target_index))
                    return "target_index: integer expected";
            if (message.ability_id != null && message.hasOwnProperty("ability_id"))
                if (!$util.isInteger(message.ability_id))
                    return "ability_id: integer expected";
            if (message.position != null && message.hasOwnProperty("position")) {
                var error = $root.CMsgVector.verify(message.position);
                if (error)
                    return "position." + error;
            }
            if (message.queue != null && message.hasOwnProperty("queue"))
                if (typeof message.queue !== "boolean")
                    return "queue: boolean expected";
            if (message.sequence_number != null && message.hasOwnProperty("sequence_number"))
                if (!$util.isInteger(message.sequence_number))
                    return "sequence_number: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_SpectatorPlayerUnitOrders message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_SpectatorPlayerUnitOrders} CDOTAUserMsg_SpectatorPlayerUnitOrders
         */
        CDOTAUserMsg_SpectatorPlayerUnitOrders.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_SpectatorPlayerUnitOrders)
                return object;
            var message = new $root.CDOTAUserMsg_SpectatorPlayerUnitOrders();
            if (object.entindex != null)
                message.entindex = object.entindex | 0;
            if (object.order_type != null)
                message.order_type = object.order_type | 0;
            if (object.units) {
                if (!Array.isArray(object.units))
                    throw TypeError(".CDOTAUserMsg_SpectatorPlayerUnitOrders.units: array expected");
                message.units = [];
                for (var i = 0; i < object.units.length; ++i)
                    message.units[i] = object.units[i] | 0;
            }
            if (object.target_index != null)
                message.target_index = object.target_index | 0;
            if (object.ability_id != null)
                message.ability_id = object.ability_id | 0;
            if (object.position != null) {
                if (typeof object.position !== "object")
                    throw TypeError(".CDOTAUserMsg_SpectatorPlayerUnitOrders.position: object expected");
                message.position = $root.CMsgVector.fromObject(object.position);
            }
            if (object.queue != null)
                message.queue = Boolean(object.queue);
            if (object.sequence_number != null)
                message.sequence_number = object.sequence_number | 0;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_SpectatorPlayerUnitOrders message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @static
         * @param {CDOTAUserMsg_SpectatorPlayerUnitOrders} message CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_SpectatorPlayerUnitOrders.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.units = [];
            if (options.defaults) {
                object.entindex = 0;
                object.order_type = 0;
                object.target_index = 0;
                object.ability_id = 0;
                object.position = null;
                object.queue = false;
                object.sequence_number = 0;
                object.flags = 0;
            }
            if (message.entindex != null && message.hasOwnProperty("entindex"))
                object.entindex = message.entindex;
            if (message.order_type != null && message.hasOwnProperty("order_type"))
                object.order_type = message.order_type;
            if (message.units && message.units.length) {
                object.units = [];
                for (var j = 0; j < message.units.length; ++j)
                    object.units[j] = message.units[j];
            }
            if (message.target_index != null && message.hasOwnProperty("target_index"))
                object.target_index = message.target_index;
            if (message.ability_id != null && message.hasOwnProperty("ability_id"))
                object.ability_id = message.ability_id;
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = $root.CMsgVector.toObject(message.position, options);
            if (message.queue != null && message.hasOwnProperty("queue"))
                object.queue = message.queue;
            if (message.sequence_number != null && message.hasOwnProperty("sequence_number"))
                object.sequence_number = message.sequence_number;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_SpectatorPlayerUnitOrders to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_SpectatorPlayerUnitOrders
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_SpectatorPlayerUnitOrders.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_SpectatorPlayerUnitOrders;
    })();
    
    $root.CDOTAUserMsg_NevermoreRequiem = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_NevermoreRequiem.
         * @exports ICDOTAUserMsg_NevermoreRequiem
         * @interface ICDOTAUserMsg_NevermoreRequiem
         * @property {number|null} [entity_handle] CDOTAUserMsg_NevermoreRequiem entity_handle
         * @property {number|null} [lines] CDOTAUserMsg_NevermoreRequiem lines
         * @property {ICMsgVector|null} [origin] CDOTAUserMsg_NevermoreRequiem origin
         * @property {boolean|null} [reverse] CDOTAUserMsg_NevermoreRequiem reverse
         */
    
        /**
         * Constructs a new CDOTAUserMsg_NevermoreRequiem.
         * @exports CDOTAUserMsg_NevermoreRequiem
         * @classdesc Represents a CDOTAUserMsg_NevermoreRequiem.
         * @implements ICDOTAUserMsg_NevermoreRequiem
         * @constructor
         * @param {ICDOTAUserMsg_NevermoreRequiem=} [properties] Properties to set
         */
        function CDOTAUserMsg_NevermoreRequiem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_NevermoreRequiem entity_handle.
         * @member {number} entity_handle
         * @memberof CDOTAUserMsg_NevermoreRequiem
         * @instance
         */
        CDOTAUserMsg_NevermoreRequiem.prototype.entity_handle = 0;
    
        /**
         * CDOTAUserMsg_NevermoreRequiem lines.
         * @member {number} lines
         * @memberof CDOTAUserMsg_NevermoreRequiem
         * @instance
         */
        CDOTAUserMsg_NevermoreRequiem.prototype.lines = 0;
    
        /**
         * CDOTAUserMsg_NevermoreRequiem origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CDOTAUserMsg_NevermoreRequiem
         * @instance
         */
        CDOTAUserMsg_NevermoreRequiem.prototype.origin = null;
    
        /**
         * CDOTAUserMsg_NevermoreRequiem reverse.
         * @member {boolean} reverse
         * @memberof CDOTAUserMsg_NevermoreRequiem
         * @instance
         */
        CDOTAUserMsg_NevermoreRequiem.prototype.reverse = false;
    
        /**
         * Creates a new CDOTAUserMsg_NevermoreRequiem instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_NevermoreRequiem
         * @static
         * @param {ICDOTAUserMsg_NevermoreRequiem=} [properties] Properties to set
         * @returns {CDOTAUserMsg_NevermoreRequiem} CDOTAUserMsg_NevermoreRequiem instance
         */
        CDOTAUserMsg_NevermoreRequiem.create = function create(properties) {
            return new CDOTAUserMsg_NevermoreRequiem(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_NevermoreRequiem message. Does not implicitly {@link CDOTAUserMsg_NevermoreRequiem.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_NevermoreRequiem
         * @static
         * @param {ICDOTAUserMsg_NevermoreRequiem} message CDOTAUserMsg_NevermoreRequiem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_NevermoreRequiem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entity_handle != null && Object.hasOwnProperty.call(message, "entity_handle"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.entity_handle);
            if (message.lines != null && Object.hasOwnProperty.call(message, "lines"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.lines);
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.reverse != null && Object.hasOwnProperty.call(message, "reverse"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.reverse);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_NevermoreRequiem message, length delimited. Does not implicitly {@link CDOTAUserMsg_NevermoreRequiem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_NevermoreRequiem
         * @static
         * @param {ICDOTAUserMsg_NevermoreRequiem} message CDOTAUserMsg_NevermoreRequiem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_NevermoreRequiem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_NevermoreRequiem message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_NevermoreRequiem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_NevermoreRequiem} CDOTAUserMsg_NevermoreRequiem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_NevermoreRequiem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_NevermoreRequiem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.entity_handle = reader.int32();
                    break;
                case 2:
                    message.lines = reader.int32();
                    break;
                case 3:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.reverse = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_NevermoreRequiem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_NevermoreRequiem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_NevermoreRequiem} CDOTAUserMsg_NevermoreRequiem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_NevermoreRequiem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_NevermoreRequiem message.
         * @function verify
         * @memberof CDOTAUserMsg_NevermoreRequiem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_NevermoreRequiem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entity_handle != null && message.hasOwnProperty("entity_handle"))
                if (!$util.isInteger(message.entity_handle))
                    return "entity_handle: integer expected";
            if (message.lines != null && message.hasOwnProperty("lines"))
                if (!$util.isInteger(message.lines))
                    return "lines: integer expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.reverse != null && message.hasOwnProperty("reverse"))
                if (typeof message.reverse !== "boolean")
                    return "reverse: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_NevermoreRequiem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_NevermoreRequiem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_NevermoreRequiem} CDOTAUserMsg_NevermoreRequiem
         */
        CDOTAUserMsg_NevermoreRequiem.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_NevermoreRequiem)
                return object;
            var message = new $root.CDOTAUserMsg_NevermoreRequiem();
            if (object.entity_handle != null)
                message.entity_handle = object.entity_handle | 0;
            if (object.lines != null)
                message.lines = object.lines | 0;
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CDOTAUserMsg_NevermoreRequiem.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.reverse != null)
                message.reverse = Boolean(object.reverse);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_NevermoreRequiem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_NevermoreRequiem
         * @static
         * @param {CDOTAUserMsg_NevermoreRequiem} message CDOTAUserMsg_NevermoreRequiem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_NevermoreRequiem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.entity_handle = 0;
                object.lines = 0;
                object.origin = null;
                object.reverse = false;
            }
            if (message.entity_handle != null && message.hasOwnProperty("entity_handle"))
                object.entity_handle = message.entity_handle;
            if (message.lines != null && message.hasOwnProperty("lines"))
                object.lines = message.lines;
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.reverse != null && message.hasOwnProperty("reverse"))
                object.reverse = message.reverse;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_NevermoreRequiem to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_NevermoreRequiem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_NevermoreRequiem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_NevermoreRequiem;
    })();
    
    $root.CDOTAUserMsg_InvalidCommand = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_InvalidCommand.
         * @exports ICDOTAUserMsg_InvalidCommand
         * @interface ICDOTAUserMsg_InvalidCommand
         * @property {string|null} [message] CDOTAUserMsg_InvalidCommand message
         */
    
        /**
         * Constructs a new CDOTAUserMsg_InvalidCommand.
         * @exports CDOTAUserMsg_InvalidCommand
         * @classdesc Represents a CDOTAUserMsg_InvalidCommand.
         * @implements ICDOTAUserMsg_InvalidCommand
         * @constructor
         * @param {ICDOTAUserMsg_InvalidCommand=} [properties] Properties to set
         */
        function CDOTAUserMsg_InvalidCommand(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_InvalidCommand message.
         * @member {string} message
         * @memberof CDOTAUserMsg_InvalidCommand
         * @instance
         */
        CDOTAUserMsg_InvalidCommand.prototype.message = "";
    
        /**
         * Creates a new CDOTAUserMsg_InvalidCommand instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_InvalidCommand
         * @static
         * @param {ICDOTAUserMsg_InvalidCommand=} [properties] Properties to set
         * @returns {CDOTAUserMsg_InvalidCommand} CDOTAUserMsg_InvalidCommand instance
         */
        CDOTAUserMsg_InvalidCommand.create = function create(properties) {
            return new CDOTAUserMsg_InvalidCommand(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_InvalidCommand message. Does not implicitly {@link CDOTAUserMsg_InvalidCommand.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_InvalidCommand
         * @static
         * @param {ICDOTAUserMsg_InvalidCommand} message CDOTAUserMsg_InvalidCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_InvalidCommand.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_InvalidCommand message, length delimited. Does not implicitly {@link CDOTAUserMsg_InvalidCommand.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_InvalidCommand
         * @static
         * @param {ICDOTAUserMsg_InvalidCommand} message CDOTAUserMsg_InvalidCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_InvalidCommand.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_InvalidCommand message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_InvalidCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_InvalidCommand} CDOTAUserMsg_InvalidCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_InvalidCommand.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_InvalidCommand();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_InvalidCommand message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_InvalidCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_InvalidCommand} CDOTAUserMsg_InvalidCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_InvalidCommand.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_InvalidCommand message.
         * @function verify
         * @memberof CDOTAUserMsg_InvalidCommand
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_InvalidCommand.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_InvalidCommand message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_InvalidCommand
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_InvalidCommand} CDOTAUserMsg_InvalidCommand
         */
        CDOTAUserMsg_InvalidCommand.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_InvalidCommand)
                return object;
            var message = new $root.CDOTAUserMsg_InvalidCommand();
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_InvalidCommand message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_InvalidCommand
         * @static
         * @param {CDOTAUserMsg_InvalidCommand} message CDOTAUserMsg_InvalidCommand
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_InvalidCommand.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.message = "";
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_InvalidCommand to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_InvalidCommand
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_InvalidCommand.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_InvalidCommand;
    })();
    
    $root.CDOTAUserMsg_HudError = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_HudError.
         * @exports ICDOTAUserMsg_HudError
         * @interface ICDOTAUserMsg_HudError
         * @property {number|null} [order_id] CDOTAUserMsg_HudError order_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_HudError.
         * @exports CDOTAUserMsg_HudError
         * @classdesc Represents a CDOTAUserMsg_HudError.
         * @implements ICDOTAUserMsg_HudError
         * @constructor
         * @param {ICDOTAUserMsg_HudError=} [properties] Properties to set
         */
        function CDOTAUserMsg_HudError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_HudError order_id.
         * @member {number} order_id
         * @memberof CDOTAUserMsg_HudError
         * @instance
         */
        CDOTAUserMsg_HudError.prototype.order_id = 0;
    
        /**
         * Creates a new CDOTAUserMsg_HudError instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_HudError
         * @static
         * @param {ICDOTAUserMsg_HudError=} [properties] Properties to set
         * @returns {CDOTAUserMsg_HudError} CDOTAUserMsg_HudError instance
         */
        CDOTAUserMsg_HudError.create = function create(properties) {
            return new CDOTAUserMsg_HudError(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_HudError message. Does not implicitly {@link CDOTAUserMsg_HudError.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_HudError
         * @static
         * @param {ICDOTAUserMsg_HudError} message CDOTAUserMsg_HudError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_HudError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.order_id != null && Object.hasOwnProperty.call(message, "order_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.order_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_HudError message, length delimited. Does not implicitly {@link CDOTAUserMsg_HudError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_HudError
         * @static
         * @param {ICDOTAUserMsg_HudError} message CDOTAUserMsg_HudError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_HudError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_HudError message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_HudError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_HudError} CDOTAUserMsg_HudError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_HudError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_HudError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.order_id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_HudError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_HudError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_HudError} CDOTAUserMsg_HudError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_HudError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_HudError message.
         * @function verify
         * @memberof CDOTAUserMsg_HudError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_HudError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.order_id != null && message.hasOwnProperty("order_id"))
                if (!$util.isInteger(message.order_id))
                    return "order_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_HudError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_HudError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_HudError} CDOTAUserMsg_HudError
         */
        CDOTAUserMsg_HudError.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_HudError)
                return object;
            var message = new $root.CDOTAUserMsg_HudError();
            if (object.order_id != null)
                message.order_id = object.order_id | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_HudError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_HudError
         * @static
         * @param {CDOTAUserMsg_HudError} message CDOTAUserMsg_HudError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_HudError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.order_id = 0;
            if (message.order_id != null && message.hasOwnProperty("order_id"))
                object.order_id = message.order_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_HudError to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_HudError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_HudError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_HudError;
    })();
    
    $root.CDOTAUserMsg_SharedCooldown = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_SharedCooldown.
         * @exports ICDOTAUserMsg_SharedCooldown
         * @interface ICDOTAUserMsg_SharedCooldown
         * @property {number|null} [entindex] CDOTAUserMsg_SharedCooldown entindex
         * @property {string|null} [name] CDOTAUserMsg_SharedCooldown name
         * @property {number|null} [cooldown] CDOTAUserMsg_SharedCooldown cooldown
         * @property {number|null} [name_index] CDOTAUserMsg_SharedCooldown name_index
         */
    
        /**
         * Constructs a new CDOTAUserMsg_SharedCooldown.
         * @exports CDOTAUserMsg_SharedCooldown
         * @classdesc Represents a CDOTAUserMsg_SharedCooldown.
         * @implements ICDOTAUserMsg_SharedCooldown
         * @constructor
         * @param {ICDOTAUserMsg_SharedCooldown=} [properties] Properties to set
         */
        function CDOTAUserMsg_SharedCooldown(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_SharedCooldown entindex.
         * @member {number} entindex
         * @memberof CDOTAUserMsg_SharedCooldown
         * @instance
         */
        CDOTAUserMsg_SharedCooldown.prototype.entindex = 0;
    
        /**
         * CDOTAUserMsg_SharedCooldown name.
         * @member {string} name
         * @memberof CDOTAUserMsg_SharedCooldown
         * @instance
         */
        CDOTAUserMsg_SharedCooldown.prototype.name = "";
    
        /**
         * CDOTAUserMsg_SharedCooldown cooldown.
         * @member {number} cooldown
         * @memberof CDOTAUserMsg_SharedCooldown
         * @instance
         */
        CDOTAUserMsg_SharedCooldown.prototype.cooldown = 0;
    
        /**
         * CDOTAUserMsg_SharedCooldown name_index.
         * @member {number} name_index
         * @memberof CDOTAUserMsg_SharedCooldown
         * @instance
         */
        CDOTAUserMsg_SharedCooldown.prototype.name_index = 0;
    
        /**
         * Creates a new CDOTAUserMsg_SharedCooldown instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_SharedCooldown
         * @static
         * @param {ICDOTAUserMsg_SharedCooldown=} [properties] Properties to set
         * @returns {CDOTAUserMsg_SharedCooldown} CDOTAUserMsg_SharedCooldown instance
         */
        CDOTAUserMsg_SharedCooldown.create = function create(properties) {
            return new CDOTAUserMsg_SharedCooldown(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SharedCooldown message. Does not implicitly {@link CDOTAUserMsg_SharedCooldown.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_SharedCooldown
         * @static
         * @param {ICDOTAUserMsg_SharedCooldown} message CDOTAUserMsg_SharedCooldown message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SharedCooldown.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entindex != null && Object.hasOwnProperty.call(message, "entindex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.entindex);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.cooldown != null && Object.hasOwnProperty.call(message, "cooldown"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.cooldown);
            if (message.name_index != null && Object.hasOwnProperty.call(message, "name_index"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.name_index);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SharedCooldown message, length delimited. Does not implicitly {@link CDOTAUserMsg_SharedCooldown.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_SharedCooldown
         * @static
         * @param {ICDOTAUserMsg_SharedCooldown} message CDOTAUserMsg_SharedCooldown message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SharedCooldown.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_SharedCooldown message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_SharedCooldown
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_SharedCooldown} CDOTAUserMsg_SharedCooldown
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SharedCooldown.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_SharedCooldown();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.entindex = reader.int32();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.cooldown = reader.float();
                    break;
                case 4:
                    message.name_index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_SharedCooldown message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_SharedCooldown
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_SharedCooldown} CDOTAUserMsg_SharedCooldown
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SharedCooldown.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_SharedCooldown message.
         * @function verify
         * @memberof CDOTAUserMsg_SharedCooldown
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_SharedCooldown.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entindex != null && message.hasOwnProperty("entindex"))
                if (!$util.isInteger(message.entindex))
                    return "entindex: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.cooldown != null && message.hasOwnProperty("cooldown"))
                if (typeof message.cooldown !== "number")
                    return "cooldown: number expected";
            if (message.name_index != null && message.hasOwnProperty("name_index"))
                if (!$util.isInteger(message.name_index))
                    return "name_index: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_SharedCooldown message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_SharedCooldown
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_SharedCooldown} CDOTAUserMsg_SharedCooldown
         */
        CDOTAUserMsg_SharedCooldown.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_SharedCooldown)
                return object;
            var message = new $root.CDOTAUserMsg_SharedCooldown();
            if (object.entindex != null)
                message.entindex = object.entindex | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.cooldown != null)
                message.cooldown = Number(object.cooldown);
            if (object.name_index != null)
                message.name_index = object.name_index | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_SharedCooldown message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_SharedCooldown
         * @static
         * @param {CDOTAUserMsg_SharedCooldown} message CDOTAUserMsg_SharedCooldown
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_SharedCooldown.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.entindex = 0;
                object.name = "";
                object.cooldown = 0;
                object.name_index = 0;
            }
            if (message.entindex != null && message.hasOwnProperty("entindex"))
                object.entindex = message.entindex;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.cooldown != null && message.hasOwnProperty("cooldown"))
                object.cooldown = options.json && !isFinite(message.cooldown) ? String(message.cooldown) : message.cooldown;
            if (message.name_index != null && message.hasOwnProperty("name_index"))
                object.name_index = message.name_index;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_SharedCooldown to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_SharedCooldown
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_SharedCooldown.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_SharedCooldown;
    })();
    
    $root.CDOTAUserMsg_SetNextAutobuyItem = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_SetNextAutobuyItem.
         * @exports ICDOTAUserMsg_SetNextAutobuyItem
         * @interface ICDOTAUserMsg_SetNextAutobuyItem
         * @property {string|null} [name] CDOTAUserMsg_SetNextAutobuyItem name
         */
    
        /**
         * Constructs a new CDOTAUserMsg_SetNextAutobuyItem.
         * @exports CDOTAUserMsg_SetNextAutobuyItem
         * @classdesc Represents a CDOTAUserMsg_SetNextAutobuyItem.
         * @implements ICDOTAUserMsg_SetNextAutobuyItem
         * @constructor
         * @param {ICDOTAUserMsg_SetNextAutobuyItem=} [properties] Properties to set
         */
        function CDOTAUserMsg_SetNextAutobuyItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_SetNextAutobuyItem name.
         * @member {string} name
         * @memberof CDOTAUserMsg_SetNextAutobuyItem
         * @instance
         */
        CDOTAUserMsg_SetNextAutobuyItem.prototype.name = "";
    
        /**
         * Creates a new CDOTAUserMsg_SetNextAutobuyItem instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_SetNextAutobuyItem
         * @static
         * @param {ICDOTAUserMsg_SetNextAutobuyItem=} [properties] Properties to set
         * @returns {CDOTAUserMsg_SetNextAutobuyItem} CDOTAUserMsg_SetNextAutobuyItem instance
         */
        CDOTAUserMsg_SetNextAutobuyItem.create = function create(properties) {
            return new CDOTAUserMsg_SetNextAutobuyItem(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SetNextAutobuyItem message. Does not implicitly {@link CDOTAUserMsg_SetNextAutobuyItem.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_SetNextAutobuyItem
         * @static
         * @param {ICDOTAUserMsg_SetNextAutobuyItem} message CDOTAUserMsg_SetNextAutobuyItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SetNextAutobuyItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SetNextAutobuyItem message, length delimited. Does not implicitly {@link CDOTAUserMsg_SetNextAutobuyItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_SetNextAutobuyItem
         * @static
         * @param {ICDOTAUserMsg_SetNextAutobuyItem} message CDOTAUserMsg_SetNextAutobuyItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SetNextAutobuyItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_SetNextAutobuyItem message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_SetNextAutobuyItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_SetNextAutobuyItem} CDOTAUserMsg_SetNextAutobuyItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SetNextAutobuyItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_SetNextAutobuyItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_SetNextAutobuyItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_SetNextAutobuyItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_SetNextAutobuyItem} CDOTAUserMsg_SetNextAutobuyItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SetNextAutobuyItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_SetNextAutobuyItem message.
         * @function verify
         * @memberof CDOTAUserMsg_SetNextAutobuyItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_SetNextAutobuyItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_SetNextAutobuyItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_SetNextAutobuyItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_SetNextAutobuyItem} CDOTAUserMsg_SetNextAutobuyItem
         */
        CDOTAUserMsg_SetNextAutobuyItem.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_SetNextAutobuyItem)
                return object;
            var message = new $root.CDOTAUserMsg_SetNextAutobuyItem();
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_SetNextAutobuyItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_SetNextAutobuyItem
         * @static
         * @param {CDOTAUserMsg_SetNextAutobuyItem} message CDOTAUserMsg_SetNextAutobuyItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_SetNextAutobuyItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.name = "";
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_SetNextAutobuyItem to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_SetNextAutobuyItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_SetNextAutobuyItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_SetNextAutobuyItem;
    })();
    
    $root.CDOTAUserMsg_HalloweenDrops = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_HalloweenDrops.
         * @exports ICDOTAUserMsg_HalloweenDrops
         * @interface ICDOTAUserMsg_HalloweenDrops
         * @property {Array.<number>|null} [item_defs] CDOTAUserMsg_HalloweenDrops item_defs
         * @property {Array.<number>|null} [player_ids] CDOTAUserMsg_HalloweenDrops player_ids
         * @property {number|null} [prize_list] CDOTAUserMsg_HalloweenDrops prize_list
         */
    
        /**
         * Constructs a new CDOTAUserMsg_HalloweenDrops.
         * @exports CDOTAUserMsg_HalloweenDrops
         * @classdesc Represents a CDOTAUserMsg_HalloweenDrops.
         * @implements ICDOTAUserMsg_HalloweenDrops
         * @constructor
         * @param {ICDOTAUserMsg_HalloweenDrops=} [properties] Properties to set
         */
        function CDOTAUserMsg_HalloweenDrops(properties) {
            this.item_defs = [];
            this.player_ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_HalloweenDrops item_defs.
         * @member {Array.<number>} item_defs
         * @memberof CDOTAUserMsg_HalloweenDrops
         * @instance
         */
        CDOTAUserMsg_HalloweenDrops.prototype.item_defs = $util.emptyArray;
    
        /**
         * CDOTAUserMsg_HalloweenDrops player_ids.
         * @member {Array.<number>} player_ids
         * @memberof CDOTAUserMsg_HalloweenDrops
         * @instance
         */
        CDOTAUserMsg_HalloweenDrops.prototype.player_ids = $util.emptyArray;
    
        /**
         * CDOTAUserMsg_HalloweenDrops prize_list.
         * @member {number} prize_list
         * @memberof CDOTAUserMsg_HalloweenDrops
         * @instance
         */
        CDOTAUserMsg_HalloweenDrops.prototype.prize_list = 0;
    
        /**
         * Creates a new CDOTAUserMsg_HalloweenDrops instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_HalloweenDrops
         * @static
         * @param {ICDOTAUserMsg_HalloweenDrops=} [properties] Properties to set
         * @returns {CDOTAUserMsg_HalloweenDrops} CDOTAUserMsg_HalloweenDrops instance
         */
        CDOTAUserMsg_HalloweenDrops.create = function create(properties) {
            return new CDOTAUserMsg_HalloweenDrops(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_HalloweenDrops message. Does not implicitly {@link CDOTAUserMsg_HalloweenDrops.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_HalloweenDrops
         * @static
         * @param {ICDOTAUserMsg_HalloweenDrops} message CDOTAUserMsg_HalloweenDrops message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_HalloweenDrops.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item_defs != null && message.item_defs.length)
                for (var i = 0; i < message.item_defs.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.item_defs[i]);
            if (message.player_ids != null && message.player_ids.length)
                for (var i = 0; i < message.player_ids.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.player_ids[i]);
            if (message.prize_list != null && Object.hasOwnProperty.call(message, "prize_list"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.prize_list);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_HalloweenDrops message, length delimited. Does not implicitly {@link CDOTAUserMsg_HalloweenDrops.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_HalloweenDrops
         * @static
         * @param {ICDOTAUserMsg_HalloweenDrops} message CDOTAUserMsg_HalloweenDrops message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_HalloweenDrops.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_HalloweenDrops message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_HalloweenDrops
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_HalloweenDrops} CDOTAUserMsg_HalloweenDrops
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_HalloweenDrops.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_HalloweenDrops();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.item_defs && message.item_defs.length))
                        message.item_defs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.item_defs.push(reader.uint32());
                    } else
                        message.item_defs.push(reader.uint32());
                    break;
                case 2:
                    if (!(message.player_ids && message.player_ids.length))
                        message.player_ids = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.player_ids.push(reader.uint32());
                    } else
                        message.player_ids.push(reader.uint32());
                    break;
                case 3:
                    message.prize_list = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_HalloweenDrops message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_HalloweenDrops
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_HalloweenDrops} CDOTAUserMsg_HalloweenDrops
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_HalloweenDrops.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_HalloweenDrops message.
         * @function verify
         * @memberof CDOTAUserMsg_HalloweenDrops
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_HalloweenDrops.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item_defs != null && message.hasOwnProperty("item_defs")) {
                if (!Array.isArray(message.item_defs))
                    return "item_defs: array expected";
                for (var i = 0; i < message.item_defs.length; ++i)
                    if (!$util.isInteger(message.item_defs[i]))
                        return "item_defs: integer[] expected";
            }
            if (message.player_ids != null && message.hasOwnProperty("player_ids")) {
                if (!Array.isArray(message.player_ids))
                    return "player_ids: array expected";
                for (var i = 0; i < message.player_ids.length; ++i)
                    if (!$util.isInteger(message.player_ids[i]))
                        return "player_ids: integer[] expected";
            }
            if (message.prize_list != null && message.hasOwnProperty("prize_list"))
                if (!$util.isInteger(message.prize_list))
                    return "prize_list: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_HalloweenDrops message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_HalloweenDrops
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_HalloweenDrops} CDOTAUserMsg_HalloweenDrops
         */
        CDOTAUserMsg_HalloweenDrops.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_HalloweenDrops)
                return object;
            var message = new $root.CDOTAUserMsg_HalloweenDrops();
            if (object.item_defs) {
                if (!Array.isArray(object.item_defs))
                    throw TypeError(".CDOTAUserMsg_HalloweenDrops.item_defs: array expected");
                message.item_defs = [];
                for (var i = 0; i < object.item_defs.length; ++i)
                    message.item_defs[i] = object.item_defs[i] >>> 0;
            }
            if (object.player_ids) {
                if (!Array.isArray(object.player_ids))
                    throw TypeError(".CDOTAUserMsg_HalloweenDrops.player_ids: array expected");
                message.player_ids = [];
                for (var i = 0; i < object.player_ids.length; ++i)
                    message.player_ids[i] = object.player_ids[i] >>> 0;
            }
            if (object.prize_list != null)
                message.prize_list = object.prize_list >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_HalloweenDrops message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_HalloweenDrops
         * @static
         * @param {CDOTAUserMsg_HalloweenDrops} message CDOTAUserMsg_HalloweenDrops
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_HalloweenDrops.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.item_defs = [];
                object.player_ids = [];
            }
            if (options.defaults)
                object.prize_list = 0;
            if (message.item_defs && message.item_defs.length) {
                object.item_defs = [];
                for (var j = 0; j < message.item_defs.length; ++j)
                    object.item_defs[j] = message.item_defs[j];
            }
            if (message.player_ids && message.player_ids.length) {
                object.player_ids = [];
                for (var j = 0; j < message.player_ids.length; ++j)
                    object.player_ids[j] = message.player_ids[j];
            }
            if (message.prize_list != null && message.hasOwnProperty("prize_list"))
                object.prize_list = message.prize_list;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_HalloweenDrops to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_HalloweenDrops
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_HalloweenDrops.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_HalloweenDrops;
    })();
    
    $root.CDOTAUserMsg_PredictionResult = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_PredictionResult.
         * @exports ICDOTAUserMsg_PredictionResult
         * @interface ICDOTAUserMsg_PredictionResult
         * @property {number|null} [account_id] CDOTAUserMsg_PredictionResult account_id
         * @property {number|Long|null} [match_id] CDOTAUserMsg_PredictionResult match_id
         * @property {boolean|null} [correct] CDOTAUserMsg_PredictionResult correct
         * @property {Array.<CDOTAUserMsg_PredictionResult.IPrediction>|null} [predictions] CDOTAUserMsg_PredictionResult predictions
         */
    
        /**
         * Constructs a new CDOTAUserMsg_PredictionResult.
         * @exports CDOTAUserMsg_PredictionResult
         * @classdesc Represents a CDOTAUserMsg_PredictionResult.
         * @implements ICDOTAUserMsg_PredictionResult
         * @constructor
         * @param {ICDOTAUserMsg_PredictionResult=} [properties] Properties to set
         */
        function CDOTAUserMsg_PredictionResult(properties) {
            this.predictions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_PredictionResult account_id.
         * @member {number} account_id
         * @memberof CDOTAUserMsg_PredictionResult
         * @instance
         */
        CDOTAUserMsg_PredictionResult.prototype.account_id = 0;
    
        /**
         * CDOTAUserMsg_PredictionResult match_id.
         * @member {number|Long} match_id
         * @memberof CDOTAUserMsg_PredictionResult
         * @instance
         */
        CDOTAUserMsg_PredictionResult.prototype.match_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CDOTAUserMsg_PredictionResult correct.
         * @member {boolean} correct
         * @memberof CDOTAUserMsg_PredictionResult
         * @instance
         */
        CDOTAUserMsg_PredictionResult.prototype.correct = false;
    
        /**
         * CDOTAUserMsg_PredictionResult predictions.
         * @member {Array.<CDOTAUserMsg_PredictionResult.IPrediction>} predictions
         * @memberof CDOTAUserMsg_PredictionResult
         * @instance
         */
        CDOTAUserMsg_PredictionResult.prototype.predictions = $util.emptyArray;
    
        /**
         * Creates a new CDOTAUserMsg_PredictionResult instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_PredictionResult
         * @static
         * @param {ICDOTAUserMsg_PredictionResult=} [properties] Properties to set
         * @returns {CDOTAUserMsg_PredictionResult} CDOTAUserMsg_PredictionResult instance
         */
        CDOTAUserMsg_PredictionResult.create = function create(properties) {
            return new CDOTAUserMsg_PredictionResult(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_PredictionResult message. Does not implicitly {@link CDOTAUserMsg_PredictionResult.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_PredictionResult
         * @static
         * @param {ICDOTAUserMsg_PredictionResult} message CDOTAUserMsg_PredictionResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_PredictionResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account_id != null && Object.hasOwnProperty.call(message, "account_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.account_id);
            if (message.match_id != null && Object.hasOwnProperty.call(message, "match_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.match_id);
            if (message.correct != null && Object.hasOwnProperty.call(message, "correct"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.correct);
            if (message.predictions != null && message.predictions.length)
                for (var i = 0; i < message.predictions.length; ++i)
                    $root.CDOTAUserMsg_PredictionResult.Prediction.encode(message.predictions[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_PredictionResult message, length delimited. Does not implicitly {@link CDOTAUserMsg_PredictionResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_PredictionResult
         * @static
         * @param {ICDOTAUserMsg_PredictionResult} message CDOTAUserMsg_PredictionResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_PredictionResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_PredictionResult message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_PredictionResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_PredictionResult} CDOTAUserMsg_PredictionResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_PredictionResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_PredictionResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.account_id = reader.uint32();
                    break;
                case 2:
                    message.match_id = reader.uint64();
                    break;
                case 3:
                    message.correct = reader.bool();
                    break;
                case 4:
                    if (!(message.predictions && message.predictions.length))
                        message.predictions = [];
                    message.predictions.push($root.CDOTAUserMsg_PredictionResult.Prediction.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_PredictionResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_PredictionResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_PredictionResult} CDOTAUserMsg_PredictionResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_PredictionResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_PredictionResult message.
         * @function verify
         * @memberof CDOTAUserMsg_PredictionResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_PredictionResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account_id != null && message.hasOwnProperty("account_id"))
                if (!$util.isInteger(message.account_id))
                    return "account_id: integer expected";
            if (message.match_id != null && message.hasOwnProperty("match_id"))
                if (!$util.isInteger(message.match_id) && !(message.match_id && $util.isInteger(message.match_id.low) && $util.isInteger(message.match_id.high)))
                    return "match_id: integer|Long expected";
            if (message.correct != null && message.hasOwnProperty("correct"))
                if (typeof message.correct !== "boolean")
                    return "correct: boolean expected";
            if (message.predictions != null && message.hasOwnProperty("predictions")) {
                if (!Array.isArray(message.predictions))
                    return "predictions: array expected";
                for (var i = 0; i < message.predictions.length; ++i) {
                    var error = $root.CDOTAUserMsg_PredictionResult.Prediction.verify(message.predictions[i]);
                    if (error)
                        return "predictions." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_PredictionResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_PredictionResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_PredictionResult} CDOTAUserMsg_PredictionResult
         */
        CDOTAUserMsg_PredictionResult.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_PredictionResult)
                return object;
            var message = new $root.CDOTAUserMsg_PredictionResult();
            if (object.account_id != null)
                message.account_id = object.account_id >>> 0;
            if (object.match_id != null)
                if ($util.Long)
                    (message.match_id = $util.Long.fromValue(object.match_id)).unsigned = true;
                else if (typeof object.match_id === "string")
                    message.match_id = parseInt(object.match_id, 10);
                else if (typeof object.match_id === "number")
                    message.match_id = object.match_id;
                else if (typeof object.match_id === "object")
                    message.match_id = new $util.LongBits(object.match_id.low >>> 0, object.match_id.high >>> 0).toNumber(true);
            if (object.correct != null)
                message.correct = Boolean(object.correct);
            if (object.predictions) {
                if (!Array.isArray(object.predictions))
                    throw TypeError(".CDOTAUserMsg_PredictionResult.predictions: array expected");
                message.predictions = [];
                for (var i = 0; i < object.predictions.length; ++i) {
                    if (typeof object.predictions[i] !== "object")
                        throw TypeError(".CDOTAUserMsg_PredictionResult.predictions: object expected");
                    message.predictions[i] = $root.CDOTAUserMsg_PredictionResult.Prediction.fromObject(object.predictions[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_PredictionResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_PredictionResult
         * @static
         * @param {CDOTAUserMsg_PredictionResult} message CDOTAUserMsg_PredictionResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_PredictionResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.predictions = [];
            if (options.defaults) {
                object.account_id = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.match_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.match_id = options.longs === String ? "0" : 0;
                object.correct = false;
            }
            if (message.account_id != null && message.hasOwnProperty("account_id"))
                object.account_id = message.account_id;
            if (message.match_id != null && message.hasOwnProperty("match_id"))
                if (typeof message.match_id === "number")
                    object.match_id = options.longs === String ? String(message.match_id) : message.match_id;
                else
                    object.match_id = options.longs === String ? $util.Long.prototype.toString.call(message.match_id) : options.longs === Number ? new $util.LongBits(message.match_id.low >>> 0, message.match_id.high >>> 0).toNumber(true) : message.match_id;
            if (message.correct != null && message.hasOwnProperty("correct"))
                object.correct = message.correct;
            if (message.predictions && message.predictions.length) {
                object.predictions = [];
                for (var j = 0; j < message.predictions.length; ++j)
                    object.predictions[j] = $root.CDOTAUserMsg_PredictionResult.Prediction.toObject(message.predictions[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_PredictionResult to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_PredictionResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_PredictionResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CDOTAUserMsg_PredictionResult.Prediction = (function() {
    
            /**
             * Properties of a Prediction.
             * @memberof CDOTAUserMsg_PredictionResult
             * @interface IPrediction
             * @property {number|null} [item_def] Prediction item_def
             * @property {number|null} [num_correct] Prediction num_correct
             * @property {number|null} [num_fails] Prediction num_fails
             * @property {CDOTAUserMsg_PredictionResult.Prediction.EResult|null} [result] Prediction result
             * @property {Array.<number>|null} [granted_item_defs] Prediction granted_item_defs
             */
    
            /**
             * Constructs a new Prediction.
             * @memberof CDOTAUserMsg_PredictionResult
             * @classdesc Represents a Prediction.
             * @implements IPrediction
             * @constructor
             * @param {CDOTAUserMsg_PredictionResult.IPrediction=} [properties] Properties to set
             */
            function Prediction(properties) {
                this.granted_item_defs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Prediction item_def.
             * @member {number} item_def
             * @memberof CDOTAUserMsg_PredictionResult.Prediction
             * @instance
             */
            Prediction.prototype.item_def = 0;
    
            /**
             * Prediction num_correct.
             * @member {number} num_correct
             * @memberof CDOTAUserMsg_PredictionResult.Prediction
             * @instance
             */
            Prediction.prototype.num_correct = 0;
    
            /**
             * Prediction num_fails.
             * @member {number} num_fails
             * @memberof CDOTAUserMsg_PredictionResult.Prediction
             * @instance
             */
            Prediction.prototype.num_fails = 0;
    
            /**
             * Prediction result.
             * @member {CDOTAUserMsg_PredictionResult.Prediction.EResult} result
             * @memberof CDOTAUserMsg_PredictionResult.Prediction
             * @instance
             */
            Prediction.prototype.result = 1;
    
            /**
             * Prediction granted_item_defs.
             * @member {Array.<number>} granted_item_defs
             * @memberof CDOTAUserMsg_PredictionResult.Prediction
             * @instance
             */
            Prediction.prototype.granted_item_defs = $util.emptyArray;
    
            /**
             * Creates a new Prediction instance using the specified properties.
             * @function create
             * @memberof CDOTAUserMsg_PredictionResult.Prediction
             * @static
             * @param {CDOTAUserMsg_PredictionResult.IPrediction=} [properties] Properties to set
             * @returns {CDOTAUserMsg_PredictionResult.Prediction} Prediction instance
             */
            Prediction.create = function create(properties) {
                return new Prediction(properties);
            };
    
            /**
             * Encodes the specified Prediction message. Does not implicitly {@link CDOTAUserMsg_PredictionResult.Prediction.verify|verify} messages.
             * @function encode
             * @memberof CDOTAUserMsg_PredictionResult.Prediction
             * @static
             * @param {CDOTAUserMsg_PredictionResult.IPrediction} message Prediction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Prediction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.item_def != null && Object.hasOwnProperty.call(message, "item_def"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.item_def);
                if (message.num_correct != null && Object.hasOwnProperty.call(message, "num_correct"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.num_correct);
                if (message.num_fails != null && Object.hasOwnProperty.call(message, "num_fails"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.num_fails);
                if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.result);
                if (message.granted_item_defs != null && message.granted_item_defs.length)
                    for (var i = 0; i < message.granted_item_defs.length; ++i)
                        writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.granted_item_defs[i]);
                return writer;
            };
    
            /**
             * Encodes the specified Prediction message, length delimited. Does not implicitly {@link CDOTAUserMsg_PredictionResult.Prediction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTAUserMsg_PredictionResult.Prediction
             * @static
             * @param {CDOTAUserMsg_PredictionResult.IPrediction} message Prediction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Prediction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Prediction message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTAUserMsg_PredictionResult.Prediction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTAUserMsg_PredictionResult.Prediction} Prediction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Prediction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_PredictionResult.Prediction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.item_def = reader.uint32();
                        break;
                    case 2:
                        message.num_correct = reader.uint32();
                        break;
                    case 3:
                        message.num_fails = reader.uint32();
                        break;
                    case 4:
                        message.result = reader.int32();
                        break;
                    case 6:
                        if (!(message.granted_item_defs && message.granted_item_defs.length))
                            message.granted_item_defs = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.granted_item_defs.push(reader.uint32());
                        } else
                            message.granted_item_defs.push(reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Prediction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTAUserMsg_PredictionResult.Prediction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTAUserMsg_PredictionResult.Prediction} Prediction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Prediction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Prediction message.
             * @function verify
             * @memberof CDOTAUserMsg_PredictionResult.Prediction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Prediction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.item_def != null && message.hasOwnProperty("item_def"))
                    if (!$util.isInteger(message.item_def))
                        return "item_def: integer expected";
                if (message.num_correct != null && message.hasOwnProperty("num_correct"))
                    if (!$util.isInteger(message.num_correct))
                        return "num_correct: integer expected";
                if (message.num_fails != null && message.hasOwnProperty("num_fails"))
                    if (!$util.isInteger(message.num_fails))
                        return "num_fails: integer expected";
                if (message.result != null && message.hasOwnProperty("result"))
                    switch (message.result) {
                    default:
                        return "result: enum value expected";
                    case 1:
                    case 2:
                        break;
                    }
                if (message.granted_item_defs != null && message.hasOwnProperty("granted_item_defs")) {
                    if (!Array.isArray(message.granted_item_defs))
                        return "granted_item_defs: array expected";
                    for (var i = 0; i < message.granted_item_defs.length; ++i)
                        if (!$util.isInteger(message.granted_item_defs[i]))
                            return "granted_item_defs: integer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a Prediction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTAUserMsg_PredictionResult.Prediction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTAUserMsg_PredictionResult.Prediction} Prediction
             */
            Prediction.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTAUserMsg_PredictionResult.Prediction)
                    return object;
                var message = new $root.CDOTAUserMsg_PredictionResult.Prediction();
                if (object.item_def != null)
                    message.item_def = object.item_def >>> 0;
                if (object.num_correct != null)
                    message.num_correct = object.num_correct >>> 0;
                if (object.num_fails != null)
                    message.num_fails = object.num_fails >>> 0;
                switch (object.result) {
                case "k_eResult_ItemGranted":
                case 1:
                    message.result = 1;
                    break;
                case "k_eResult_Destroyed":
                case 2:
                    message.result = 2;
                    break;
                }
                if (object.granted_item_defs) {
                    if (!Array.isArray(object.granted_item_defs))
                        throw TypeError(".CDOTAUserMsg_PredictionResult.Prediction.granted_item_defs: array expected");
                    message.granted_item_defs = [];
                    for (var i = 0; i < object.granted_item_defs.length; ++i)
                        message.granted_item_defs[i] = object.granted_item_defs[i] >>> 0;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Prediction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTAUserMsg_PredictionResult.Prediction
             * @static
             * @param {CDOTAUserMsg_PredictionResult.Prediction} message Prediction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Prediction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.granted_item_defs = [];
                if (options.defaults) {
                    object.item_def = 0;
                    object.num_correct = 0;
                    object.num_fails = 0;
                    object.result = options.enums === String ? "k_eResult_ItemGranted" : 1;
                }
                if (message.item_def != null && message.hasOwnProperty("item_def"))
                    object.item_def = message.item_def;
                if (message.num_correct != null && message.hasOwnProperty("num_correct"))
                    object.num_correct = message.num_correct;
                if (message.num_fails != null && message.hasOwnProperty("num_fails"))
                    object.num_fails = message.num_fails;
                if (message.result != null && message.hasOwnProperty("result"))
                    object.result = options.enums === String ? $root.CDOTAUserMsg_PredictionResult.Prediction.EResult[message.result] : message.result;
                if (message.granted_item_defs && message.granted_item_defs.length) {
                    object.granted_item_defs = [];
                    for (var j = 0; j < message.granted_item_defs.length; ++j)
                        object.granted_item_defs[j] = message.granted_item_defs[j];
                }
                return object;
            };
    
            /**
             * Converts this Prediction to JSON.
             * @function toJSON
             * @memberof CDOTAUserMsg_PredictionResult.Prediction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Prediction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * EResult enum.
             * @name CDOTAUserMsg_PredictionResult.Prediction.EResult
             * @enum {number}
             * @property {number} k_eResult_ItemGranted=1 k_eResult_ItemGranted value
             * @property {number} k_eResult_Destroyed=2 k_eResult_Destroyed value
             */
            Prediction.EResult = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "k_eResult_ItemGranted"] = 1;
                values[valuesById[2] = "k_eResult_Destroyed"] = 2;
                return values;
            })();
    
            return Prediction;
        })();
    
        return CDOTAUserMsg_PredictionResult;
    })();
    
    $root.CDOTAResponseQuerySerialized = (function() {
    
        /**
         * Properties of a CDOTAResponseQuerySerialized.
         * @exports ICDOTAResponseQuerySerialized
         * @interface ICDOTAResponseQuerySerialized
         * @property {Array.<CDOTAResponseQuerySerialized.IFact>|null} [facts] CDOTAResponseQuerySerialized facts
         */
    
        /**
         * Constructs a new CDOTAResponseQuerySerialized.
         * @exports CDOTAResponseQuerySerialized
         * @classdesc Represents a CDOTAResponseQuerySerialized.
         * @implements ICDOTAResponseQuerySerialized
         * @constructor
         * @param {ICDOTAResponseQuerySerialized=} [properties] Properties to set
         */
        function CDOTAResponseQuerySerialized(properties) {
            this.facts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAResponseQuerySerialized facts.
         * @member {Array.<CDOTAResponseQuerySerialized.IFact>} facts
         * @memberof CDOTAResponseQuerySerialized
         * @instance
         */
        CDOTAResponseQuerySerialized.prototype.facts = $util.emptyArray;
    
        /**
         * Creates a new CDOTAResponseQuerySerialized instance using the specified properties.
         * @function create
         * @memberof CDOTAResponseQuerySerialized
         * @static
         * @param {ICDOTAResponseQuerySerialized=} [properties] Properties to set
         * @returns {CDOTAResponseQuerySerialized} CDOTAResponseQuerySerialized instance
         */
        CDOTAResponseQuerySerialized.create = function create(properties) {
            return new CDOTAResponseQuerySerialized(properties);
        };
    
        /**
         * Encodes the specified CDOTAResponseQuerySerialized message. Does not implicitly {@link CDOTAResponseQuerySerialized.verify|verify} messages.
         * @function encode
         * @memberof CDOTAResponseQuerySerialized
         * @static
         * @param {ICDOTAResponseQuerySerialized} message CDOTAResponseQuerySerialized message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAResponseQuerySerialized.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.facts != null && message.facts.length)
                for (var i = 0; i < message.facts.length; ++i)
                    $root.CDOTAResponseQuerySerialized.Fact.encode(message.facts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAResponseQuerySerialized message, length delimited. Does not implicitly {@link CDOTAResponseQuerySerialized.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAResponseQuerySerialized
         * @static
         * @param {ICDOTAResponseQuerySerialized} message CDOTAResponseQuerySerialized message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAResponseQuerySerialized.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAResponseQuerySerialized message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAResponseQuerySerialized
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAResponseQuerySerialized} CDOTAResponseQuerySerialized
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAResponseQuerySerialized.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAResponseQuerySerialized();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.facts && message.facts.length))
                        message.facts = [];
                    message.facts.push($root.CDOTAResponseQuerySerialized.Fact.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAResponseQuerySerialized message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAResponseQuerySerialized
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAResponseQuerySerialized} CDOTAResponseQuerySerialized
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAResponseQuerySerialized.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAResponseQuerySerialized message.
         * @function verify
         * @memberof CDOTAResponseQuerySerialized
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAResponseQuerySerialized.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.facts != null && message.hasOwnProperty("facts")) {
                if (!Array.isArray(message.facts))
                    return "facts: array expected";
                for (var i = 0; i < message.facts.length; ++i) {
                    var error = $root.CDOTAResponseQuerySerialized.Fact.verify(message.facts[i]);
                    if (error)
                        return "facts." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CDOTAResponseQuerySerialized message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAResponseQuerySerialized
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAResponseQuerySerialized} CDOTAResponseQuerySerialized
         */
        CDOTAResponseQuerySerialized.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAResponseQuerySerialized)
                return object;
            var message = new $root.CDOTAResponseQuerySerialized();
            if (object.facts) {
                if (!Array.isArray(object.facts))
                    throw TypeError(".CDOTAResponseQuerySerialized.facts: array expected");
                message.facts = [];
                for (var i = 0; i < object.facts.length; ++i) {
                    if (typeof object.facts[i] !== "object")
                        throw TypeError(".CDOTAResponseQuerySerialized.facts: object expected");
                    message.facts[i] = $root.CDOTAResponseQuerySerialized.Fact.fromObject(object.facts[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAResponseQuerySerialized message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAResponseQuerySerialized
         * @static
         * @param {CDOTAResponseQuerySerialized} message CDOTAResponseQuerySerialized
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAResponseQuerySerialized.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.facts = [];
            if (message.facts && message.facts.length) {
                object.facts = [];
                for (var j = 0; j < message.facts.length; ++j)
                    object.facts[j] = $root.CDOTAResponseQuerySerialized.Fact.toObject(message.facts[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CDOTAResponseQuerySerialized to JSON.
         * @function toJSON
         * @memberof CDOTAResponseQuerySerialized
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAResponseQuerySerialized.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CDOTAResponseQuerySerialized.Fact = (function() {
    
            /**
             * Properties of a Fact.
             * @memberof CDOTAResponseQuerySerialized
             * @interface IFact
             * @property {number} key Fact key
             * @property {CDOTAResponseQuerySerialized.Fact.ValueType} valtype Fact valtype
             * @property {number|null} [val_numeric] Fact val_numeric
             * @property {string|null} [val_string] Fact val_string
             * @property {number|null} [val_stringtable_index] Fact val_stringtable_index
             * @property {number|null} [val_int_numeric] Fact val_int_numeric
             */
    
            /**
             * Constructs a new Fact.
             * @memberof CDOTAResponseQuerySerialized
             * @classdesc Represents a Fact.
             * @implements IFact
             * @constructor
             * @param {CDOTAResponseQuerySerialized.IFact=} [properties] Properties to set
             */
            function Fact(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Fact key.
             * @member {number} key
             * @memberof CDOTAResponseQuerySerialized.Fact
             * @instance
             */
            Fact.prototype.key = 0;
    
            /**
             * Fact valtype.
             * @member {CDOTAResponseQuerySerialized.Fact.ValueType} valtype
             * @memberof CDOTAResponseQuerySerialized.Fact
             * @instance
             */
            Fact.prototype.valtype = 1;
    
            /**
             * Fact val_numeric.
             * @member {number} val_numeric
             * @memberof CDOTAResponseQuerySerialized.Fact
             * @instance
             */
            Fact.prototype.val_numeric = 0;
    
            /**
             * Fact val_string.
             * @member {string} val_string
             * @memberof CDOTAResponseQuerySerialized.Fact
             * @instance
             */
            Fact.prototype.val_string = "";
    
            /**
             * Fact val_stringtable_index.
             * @member {number} val_stringtable_index
             * @memberof CDOTAResponseQuerySerialized.Fact
             * @instance
             */
            Fact.prototype.val_stringtable_index = 0;
    
            /**
             * Fact val_int_numeric.
             * @member {number} val_int_numeric
             * @memberof CDOTAResponseQuerySerialized.Fact
             * @instance
             */
            Fact.prototype.val_int_numeric = 0;
    
            /**
             * Creates a new Fact instance using the specified properties.
             * @function create
             * @memberof CDOTAResponseQuerySerialized.Fact
             * @static
             * @param {CDOTAResponseQuerySerialized.IFact=} [properties] Properties to set
             * @returns {CDOTAResponseQuerySerialized.Fact} Fact instance
             */
            Fact.create = function create(properties) {
                return new Fact(properties);
            };
    
            /**
             * Encodes the specified Fact message. Does not implicitly {@link CDOTAResponseQuerySerialized.Fact.verify|verify} messages.
             * @function encode
             * @memberof CDOTAResponseQuerySerialized.Fact
             * @static
             * @param {CDOTAResponseQuerySerialized.IFact} message Fact message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Fact.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.key);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.valtype);
                if (message.val_numeric != null && Object.hasOwnProperty.call(message, "val_numeric"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.val_numeric);
                if (message.val_string != null && Object.hasOwnProperty.call(message, "val_string"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.val_string);
                if (message.val_stringtable_index != null && Object.hasOwnProperty.call(message, "val_stringtable_index"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.val_stringtable_index);
                if (message.val_int_numeric != null && Object.hasOwnProperty.call(message, "val_int_numeric"))
                    writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.val_int_numeric);
                return writer;
            };
    
            /**
             * Encodes the specified Fact message, length delimited. Does not implicitly {@link CDOTAResponseQuerySerialized.Fact.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTAResponseQuerySerialized.Fact
             * @static
             * @param {CDOTAResponseQuerySerialized.IFact} message Fact message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Fact.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Fact message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTAResponseQuerySerialized.Fact
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTAResponseQuerySerialized.Fact} Fact
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Fact.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAResponseQuerySerialized.Fact();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.int32();
                        break;
                    case 2:
                        message.valtype = reader.int32();
                        break;
                    case 3:
                        message.val_numeric = reader.float();
                        break;
                    case 4:
                        message.val_string = reader.string();
                        break;
                    case 5:
                        message.val_stringtable_index = reader.int32();
                        break;
                    case 6:
                        message.val_int_numeric = reader.sint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("key"))
                    throw $util.ProtocolError("missing required 'key'", { instance: message });
                if (!message.hasOwnProperty("valtype"))
                    throw $util.ProtocolError("missing required 'valtype'", { instance: message });
                return message;
            };
    
            /**
             * Decodes a Fact message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTAResponseQuerySerialized.Fact
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTAResponseQuerySerialized.Fact} Fact
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Fact.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Fact message.
             * @function verify
             * @memberof CDOTAResponseQuerySerialized.Fact
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Fact.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.key))
                    return "key: integer expected";
                switch (message.valtype) {
                default:
                    return "valtype: enum value expected";
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
                if (message.val_numeric != null && message.hasOwnProperty("val_numeric"))
                    if (typeof message.val_numeric !== "number")
                        return "val_numeric: number expected";
                if (message.val_string != null && message.hasOwnProperty("val_string"))
                    if (!$util.isString(message.val_string))
                        return "val_string: string expected";
                if (message.val_stringtable_index != null && message.hasOwnProperty("val_stringtable_index"))
                    if (!$util.isInteger(message.val_stringtable_index))
                        return "val_stringtable_index: integer expected";
                if (message.val_int_numeric != null && message.hasOwnProperty("val_int_numeric"))
                    if (!$util.isInteger(message.val_int_numeric))
                        return "val_int_numeric: integer expected";
                return null;
            };
    
            /**
             * Creates a Fact message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTAResponseQuerySerialized.Fact
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTAResponseQuerySerialized.Fact} Fact
             */
            Fact.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTAResponseQuerySerialized.Fact)
                    return object;
                var message = new $root.CDOTAResponseQuerySerialized.Fact();
                if (object.key != null)
                    message.key = object.key | 0;
                switch (object.valtype) {
                case "NUMERIC":
                case 1:
                    message.valtype = 1;
                    break;
                case "STRING":
                case 2:
                    message.valtype = 2;
                    break;
                case "STRINGTABLE_INDEX":
                case 3:
                    message.valtype = 3;
                    break;
                case "INT_NUMERIC":
                case 4:
                    message.valtype = 4;
                    break;
                }
                if (object.val_numeric != null)
                    message.val_numeric = Number(object.val_numeric);
                if (object.val_string != null)
                    message.val_string = String(object.val_string);
                if (object.val_stringtable_index != null)
                    message.val_stringtable_index = object.val_stringtable_index | 0;
                if (object.val_int_numeric != null)
                    message.val_int_numeric = object.val_int_numeric | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a Fact message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTAResponseQuerySerialized.Fact
             * @static
             * @param {CDOTAResponseQuerySerialized.Fact} message Fact
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Fact.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = 0;
                    object.valtype = options.enums === String ? "NUMERIC" : 1;
                    object.val_numeric = 0;
                    object.val_string = "";
                    object.val_stringtable_index = 0;
                    object.val_int_numeric = 0;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.valtype != null && message.hasOwnProperty("valtype"))
                    object.valtype = options.enums === String ? $root.CDOTAResponseQuerySerialized.Fact.ValueType[message.valtype] : message.valtype;
                if (message.val_numeric != null && message.hasOwnProperty("val_numeric"))
                    object.val_numeric = options.json && !isFinite(message.val_numeric) ? String(message.val_numeric) : message.val_numeric;
                if (message.val_string != null && message.hasOwnProperty("val_string"))
                    object.val_string = message.val_string;
                if (message.val_stringtable_index != null && message.hasOwnProperty("val_stringtable_index"))
                    object.val_stringtable_index = message.val_stringtable_index;
                if (message.val_int_numeric != null && message.hasOwnProperty("val_int_numeric"))
                    object.val_int_numeric = message.val_int_numeric;
                return object;
            };
    
            /**
             * Converts this Fact to JSON.
             * @function toJSON
             * @memberof CDOTAResponseQuerySerialized.Fact
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Fact.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * ValueType enum.
             * @name CDOTAResponseQuerySerialized.Fact.ValueType
             * @enum {number}
             * @property {number} NUMERIC=1 NUMERIC value
             * @property {number} STRING=2 STRING value
             * @property {number} STRINGTABLE_INDEX=3 STRINGTABLE_INDEX value
             * @property {number} INT_NUMERIC=4 INT_NUMERIC value
             */
            Fact.ValueType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "NUMERIC"] = 1;
                values[valuesById[2] = "STRING"] = 2;
                values[valuesById[3] = "STRINGTABLE_INDEX"] = 3;
                values[valuesById[4] = "INT_NUMERIC"] = 4;
                return values;
            })();
    
            return Fact;
        })();
    
        return CDOTAResponseQuerySerialized;
    })();
    
    $root.CDOTASpeechMatchOnClient = (function() {
    
        /**
         * Properties of a CDOTASpeechMatchOnClient.
         * @exports ICDOTASpeechMatchOnClient
         * @interface ICDOTASpeechMatchOnClient
         * @property {number|null} [concept] CDOTASpeechMatchOnClient concept
         * @property {number|null} [recipient_type] CDOTASpeechMatchOnClient recipient_type
         * @property {ICDOTAResponseQuerySerialized|null} [responsequery] CDOTASpeechMatchOnClient responsequery
         * @property {number|null} [randomseed] CDOTASpeechMatchOnClient randomseed
         */
    
        /**
         * Constructs a new CDOTASpeechMatchOnClient.
         * @exports CDOTASpeechMatchOnClient
         * @classdesc Represents a CDOTASpeechMatchOnClient.
         * @implements ICDOTASpeechMatchOnClient
         * @constructor
         * @param {ICDOTASpeechMatchOnClient=} [properties] Properties to set
         */
        function CDOTASpeechMatchOnClient(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTASpeechMatchOnClient concept.
         * @member {number} concept
         * @memberof CDOTASpeechMatchOnClient
         * @instance
         */
        CDOTASpeechMatchOnClient.prototype.concept = 0;
    
        /**
         * CDOTASpeechMatchOnClient recipient_type.
         * @member {number} recipient_type
         * @memberof CDOTASpeechMatchOnClient
         * @instance
         */
        CDOTASpeechMatchOnClient.prototype.recipient_type = 0;
    
        /**
         * CDOTASpeechMatchOnClient responsequery.
         * @member {ICDOTAResponseQuerySerialized|null|undefined} responsequery
         * @memberof CDOTASpeechMatchOnClient
         * @instance
         */
        CDOTASpeechMatchOnClient.prototype.responsequery = null;
    
        /**
         * CDOTASpeechMatchOnClient randomseed.
         * @member {number} randomseed
         * @memberof CDOTASpeechMatchOnClient
         * @instance
         */
        CDOTASpeechMatchOnClient.prototype.randomseed = 0;
    
        /**
         * Creates a new CDOTASpeechMatchOnClient instance using the specified properties.
         * @function create
         * @memberof CDOTASpeechMatchOnClient
         * @static
         * @param {ICDOTASpeechMatchOnClient=} [properties] Properties to set
         * @returns {CDOTASpeechMatchOnClient} CDOTASpeechMatchOnClient instance
         */
        CDOTASpeechMatchOnClient.create = function create(properties) {
            return new CDOTASpeechMatchOnClient(properties);
        };
    
        /**
         * Encodes the specified CDOTASpeechMatchOnClient message. Does not implicitly {@link CDOTASpeechMatchOnClient.verify|verify} messages.
         * @function encode
         * @memberof CDOTASpeechMatchOnClient
         * @static
         * @param {ICDOTASpeechMatchOnClient} message CDOTASpeechMatchOnClient message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTASpeechMatchOnClient.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.concept != null && Object.hasOwnProperty.call(message, "concept"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.concept);
            if (message.recipient_type != null && Object.hasOwnProperty.call(message, "recipient_type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.recipient_type);
            if (message.responsequery != null && Object.hasOwnProperty.call(message, "responsequery"))
                $root.CDOTAResponseQuerySerialized.encode(message.responsequery, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.randomseed != null && Object.hasOwnProperty.call(message, "randomseed"))
                writer.uint32(/* id 4, wireType 5 =*/37).sfixed32(message.randomseed);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTASpeechMatchOnClient message, length delimited. Does not implicitly {@link CDOTASpeechMatchOnClient.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTASpeechMatchOnClient
         * @static
         * @param {ICDOTASpeechMatchOnClient} message CDOTASpeechMatchOnClient message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTASpeechMatchOnClient.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTASpeechMatchOnClient message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTASpeechMatchOnClient
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTASpeechMatchOnClient} CDOTASpeechMatchOnClient
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTASpeechMatchOnClient.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTASpeechMatchOnClient();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.concept = reader.int32();
                    break;
                case 2:
                    message.recipient_type = reader.int32();
                    break;
                case 3:
                    message.responsequery = $root.CDOTAResponseQuerySerialized.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.randomseed = reader.sfixed32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTASpeechMatchOnClient message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTASpeechMatchOnClient
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTASpeechMatchOnClient} CDOTASpeechMatchOnClient
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTASpeechMatchOnClient.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTASpeechMatchOnClient message.
         * @function verify
         * @memberof CDOTASpeechMatchOnClient
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTASpeechMatchOnClient.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.concept != null && message.hasOwnProperty("concept"))
                if (!$util.isInteger(message.concept))
                    return "concept: integer expected";
            if (message.recipient_type != null && message.hasOwnProperty("recipient_type"))
                if (!$util.isInteger(message.recipient_type))
                    return "recipient_type: integer expected";
            if (message.responsequery != null && message.hasOwnProperty("responsequery")) {
                var error = $root.CDOTAResponseQuerySerialized.verify(message.responsequery);
                if (error)
                    return "responsequery." + error;
            }
            if (message.randomseed != null && message.hasOwnProperty("randomseed"))
                if (!$util.isInteger(message.randomseed))
                    return "randomseed: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTASpeechMatchOnClient message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTASpeechMatchOnClient
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTASpeechMatchOnClient} CDOTASpeechMatchOnClient
         */
        CDOTASpeechMatchOnClient.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTASpeechMatchOnClient)
                return object;
            var message = new $root.CDOTASpeechMatchOnClient();
            if (object.concept != null)
                message.concept = object.concept | 0;
            if (object.recipient_type != null)
                message.recipient_type = object.recipient_type | 0;
            if (object.responsequery != null) {
                if (typeof object.responsequery !== "object")
                    throw TypeError(".CDOTASpeechMatchOnClient.responsequery: object expected");
                message.responsequery = $root.CDOTAResponseQuerySerialized.fromObject(object.responsequery);
            }
            if (object.randomseed != null)
                message.randomseed = object.randomseed | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTASpeechMatchOnClient message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTASpeechMatchOnClient
         * @static
         * @param {CDOTASpeechMatchOnClient} message CDOTASpeechMatchOnClient
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTASpeechMatchOnClient.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.concept = 0;
                object.recipient_type = 0;
                object.responsequery = null;
                object.randomseed = 0;
            }
            if (message.concept != null && message.hasOwnProperty("concept"))
                object.concept = message.concept;
            if (message.recipient_type != null && message.hasOwnProperty("recipient_type"))
                object.recipient_type = message.recipient_type;
            if (message.responsequery != null && message.hasOwnProperty("responsequery"))
                object.responsequery = $root.CDOTAResponseQuerySerialized.toObject(message.responsequery, options);
            if (message.randomseed != null && message.hasOwnProperty("randomseed"))
                object.randomseed = message.randomseed;
            return object;
        };
    
        /**
         * Converts this CDOTASpeechMatchOnClient to JSON.
         * @function toJSON
         * @memberof CDOTASpeechMatchOnClient
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTASpeechMatchOnClient.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTASpeechMatchOnClient;
    })();
    
    $root.CDOTAUserMsg_UnitEvent = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_UnitEvent.
         * @exports ICDOTAUserMsg_UnitEvent
         * @interface ICDOTAUserMsg_UnitEvent
         * @property {EDotaEntityMessages} msg_type CDOTAUserMsg_UnitEvent msg_type
         * @property {number} entity_index CDOTAUserMsg_UnitEvent entity_index
         * @property {CDOTAUserMsg_UnitEvent.ISpeech|null} [speech] CDOTAUserMsg_UnitEvent speech
         * @property {CDOTAUserMsg_UnitEvent.ISpeechMute|null} [speech_mute] CDOTAUserMsg_UnitEvent speech_mute
         * @property {CDOTAUserMsg_UnitEvent.IAddGesture|null} [add_gesture] CDOTAUserMsg_UnitEvent add_gesture
         * @property {CDOTAUserMsg_UnitEvent.IRemoveGesture|null} [remove_gesture] CDOTAUserMsg_UnitEvent remove_gesture
         * @property {CDOTAUserMsg_UnitEvent.IBloodImpact|null} [blood_impact] CDOTAUserMsg_UnitEvent blood_impact
         * @property {CDOTAUserMsg_UnitEvent.IFadeGesture|null} [fade_gesture] CDOTAUserMsg_UnitEvent fade_gesture
         * @property {ICDOTASpeechMatchOnClient|null} [speech_match_on_client] CDOTAUserMsg_UnitEvent speech_match_on_client
         */
    
        /**
         * Constructs a new CDOTAUserMsg_UnitEvent.
         * @exports CDOTAUserMsg_UnitEvent
         * @classdesc Represents a CDOTAUserMsg_UnitEvent.
         * @implements ICDOTAUserMsg_UnitEvent
         * @constructor
         * @param {ICDOTAUserMsg_UnitEvent=} [properties] Properties to set
         */
        function CDOTAUserMsg_UnitEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_UnitEvent msg_type.
         * @member {EDotaEntityMessages} msg_type
         * @memberof CDOTAUserMsg_UnitEvent
         * @instance
         */
        CDOTAUserMsg_UnitEvent.prototype.msg_type = 0;
    
        /**
         * CDOTAUserMsg_UnitEvent entity_index.
         * @member {number} entity_index
         * @memberof CDOTAUserMsg_UnitEvent
         * @instance
         */
        CDOTAUserMsg_UnitEvent.prototype.entity_index = 0;
    
        /**
         * CDOTAUserMsg_UnitEvent speech.
         * @member {CDOTAUserMsg_UnitEvent.ISpeech|null|undefined} speech
         * @memberof CDOTAUserMsg_UnitEvent
         * @instance
         */
        CDOTAUserMsg_UnitEvent.prototype.speech = null;
    
        /**
         * CDOTAUserMsg_UnitEvent speech_mute.
         * @member {CDOTAUserMsg_UnitEvent.ISpeechMute|null|undefined} speech_mute
         * @memberof CDOTAUserMsg_UnitEvent
         * @instance
         */
        CDOTAUserMsg_UnitEvent.prototype.speech_mute = null;
    
        /**
         * CDOTAUserMsg_UnitEvent add_gesture.
         * @member {CDOTAUserMsg_UnitEvent.IAddGesture|null|undefined} add_gesture
         * @memberof CDOTAUserMsg_UnitEvent
         * @instance
         */
        CDOTAUserMsg_UnitEvent.prototype.add_gesture = null;
    
        /**
         * CDOTAUserMsg_UnitEvent remove_gesture.
         * @member {CDOTAUserMsg_UnitEvent.IRemoveGesture|null|undefined} remove_gesture
         * @memberof CDOTAUserMsg_UnitEvent
         * @instance
         */
        CDOTAUserMsg_UnitEvent.prototype.remove_gesture = null;
    
        /**
         * CDOTAUserMsg_UnitEvent blood_impact.
         * @member {CDOTAUserMsg_UnitEvent.IBloodImpact|null|undefined} blood_impact
         * @memberof CDOTAUserMsg_UnitEvent
         * @instance
         */
        CDOTAUserMsg_UnitEvent.prototype.blood_impact = null;
    
        /**
         * CDOTAUserMsg_UnitEvent fade_gesture.
         * @member {CDOTAUserMsg_UnitEvent.IFadeGesture|null|undefined} fade_gesture
         * @memberof CDOTAUserMsg_UnitEvent
         * @instance
         */
        CDOTAUserMsg_UnitEvent.prototype.fade_gesture = null;
    
        /**
         * CDOTAUserMsg_UnitEvent speech_match_on_client.
         * @member {ICDOTASpeechMatchOnClient|null|undefined} speech_match_on_client
         * @memberof CDOTAUserMsg_UnitEvent
         * @instance
         */
        CDOTAUserMsg_UnitEvent.prototype.speech_match_on_client = null;
    
        /**
         * Creates a new CDOTAUserMsg_UnitEvent instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_UnitEvent
         * @static
         * @param {ICDOTAUserMsg_UnitEvent=} [properties] Properties to set
         * @returns {CDOTAUserMsg_UnitEvent} CDOTAUserMsg_UnitEvent instance
         */
        CDOTAUserMsg_UnitEvent.create = function create(properties) {
            return new CDOTAUserMsg_UnitEvent(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_UnitEvent message. Does not implicitly {@link CDOTAUserMsg_UnitEvent.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_UnitEvent
         * @static
         * @param {ICDOTAUserMsg_UnitEvent} message CDOTAUserMsg_UnitEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_UnitEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.msg_type);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.entity_index);
            if (message.speech != null && Object.hasOwnProperty.call(message, "speech"))
                $root.CDOTAUserMsg_UnitEvent.Speech.encode(message.speech, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.speech_mute != null && Object.hasOwnProperty.call(message, "speech_mute"))
                $root.CDOTAUserMsg_UnitEvent.SpeechMute.encode(message.speech_mute, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.add_gesture != null && Object.hasOwnProperty.call(message, "add_gesture"))
                $root.CDOTAUserMsg_UnitEvent.AddGesture.encode(message.add_gesture, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.remove_gesture != null && Object.hasOwnProperty.call(message, "remove_gesture"))
                $root.CDOTAUserMsg_UnitEvent.RemoveGesture.encode(message.remove_gesture, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.blood_impact != null && Object.hasOwnProperty.call(message, "blood_impact"))
                $root.CDOTAUserMsg_UnitEvent.BloodImpact.encode(message.blood_impact, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.fade_gesture != null && Object.hasOwnProperty.call(message, "fade_gesture"))
                $root.CDOTAUserMsg_UnitEvent.FadeGesture.encode(message.fade_gesture, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.speech_match_on_client != null && Object.hasOwnProperty.call(message, "speech_match_on_client"))
                $root.CDOTASpeechMatchOnClient.encode(message.speech_match_on_client, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_UnitEvent message, length delimited. Does not implicitly {@link CDOTAUserMsg_UnitEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_UnitEvent
         * @static
         * @param {ICDOTAUserMsg_UnitEvent} message CDOTAUserMsg_UnitEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_UnitEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_UnitEvent message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_UnitEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_UnitEvent} CDOTAUserMsg_UnitEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_UnitEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_UnitEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg_type = reader.int32();
                    break;
                case 2:
                    message.entity_index = reader.int32();
                    break;
                case 3:
                    message.speech = $root.CDOTAUserMsg_UnitEvent.Speech.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.speech_mute = $root.CDOTAUserMsg_UnitEvent.SpeechMute.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.add_gesture = $root.CDOTAUserMsg_UnitEvent.AddGesture.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.remove_gesture = $root.CDOTAUserMsg_UnitEvent.RemoveGesture.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.blood_impact = $root.CDOTAUserMsg_UnitEvent.BloodImpact.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.fade_gesture = $root.CDOTAUserMsg_UnitEvent.FadeGesture.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.speech_match_on_client = $root.CDOTASpeechMatchOnClient.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("msg_type"))
                throw $util.ProtocolError("missing required 'msg_type'", { instance: message });
            if (!message.hasOwnProperty("entity_index"))
                throw $util.ProtocolError("missing required 'entity_index'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_UnitEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_UnitEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_UnitEvent} CDOTAUserMsg_UnitEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_UnitEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_UnitEvent message.
         * @function verify
         * @memberof CDOTAUserMsg_UnitEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_UnitEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.msg_type) {
            default:
                return "msg_type: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 6:
            case 7:
                break;
            }
            if (!$util.isInteger(message.entity_index))
                return "entity_index: integer expected";
            if (message.speech != null && message.hasOwnProperty("speech")) {
                var error = $root.CDOTAUserMsg_UnitEvent.Speech.verify(message.speech);
                if (error)
                    return "speech." + error;
            }
            if (message.speech_mute != null && message.hasOwnProperty("speech_mute")) {
                var error = $root.CDOTAUserMsg_UnitEvent.SpeechMute.verify(message.speech_mute);
                if (error)
                    return "speech_mute." + error;
            }
            if (message.add_gesture != null && message.hasOwnProperty("add_gesture")) {
                var error = $root.CDOTAUserMsg_UnitEvent.AddGesture.verify(message.add_gesture);
                if (error)
                    return "add_gesture." + error;
            }
            if (message.remove_gesture != null && message.hasOwnProperty("remove_gesture")) {
                var error = $root.CDOTAUserMsg_UnitEvent.RemoveGesture.verify(message.remove_gesture);
                if (error)
                    return "remove_gesture." + error;
            }
            if (message.blood_impact != null && message.hasOwnProperty("blood_impact")) {
                var error = $root.CDOTAUserMsg_UnitEvent.BloodImpact.verify(message.blood_impact);
                if (error)
                    return "blood_impact." + error;
            }
            if (message.fade_gesture != null && message.hasOwnProperty("fade_gesture")) {
                var error = $root.CDOTAUserMsg_UnitEvent.FadeGesture.verify(message.fade_gesture);
                if (error)
                    return "fade_gesture." + error;
            }
            if (message.speech_match_on_client != null && message.hasOwnProperty("speech_match_on_client")) {
                var error = $root.CDOTASpeechMatchOnClient.verify(message.speech_match_on_client);
                if (error)
                    return "speech_match_on_client." + error;
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_UnitEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_UnitEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_UnitEvent} CDOTAUserMsg_UnitEvent
         */
        CDOTAUserMsg_UnitEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_UnitEvent)
                return object;
            var message = new $root.CDOTAUserMsg_UnitEvent();
            switch (object.msg_type) {
            case "DOTA_UNIT_SPEECH":
            case 0:
                message.msg_type = 0;
                break;
            case "DOTA_UNIT_SPEECH_MUTE":
            case 1:
                message.msg_type = 1;
                break;
            case "DOTA_UNIT_ADD_GESTURE":
            case 2:
                message.msg_type = 2;
                break;
            case "DOTA_UNIT_REMOVE_GESTURE":
            case 3:
                message.msg_type = 3;
                break;
            case "DOTA_UNIT_REMOVE_ALL_GESTURES":
            case 4:
                message.msg_type = 4;
                break;
            case "DOTA_UNIT_FADE_GESTURE":
            case 6:
                message.msg_type = 6;
                break;
            case "DOTA_UNIT_SPEECH_CLIENTSIDE_RULES":
            case 7:
                message.msg_type = 7;
                break;
            }
            if (object.entity_index != null)
                message.entity_index = object.entity_index | 0;
            if (object.speech != null) {
                if (typeof object.speech !== "object")
                    throw TypeError(".CDOTAUserMsg_UnitEvent.speech: object expected");
                message.speech = $root.CDOTAUserMsg_UnitEvent.Speech.fromObject(object.speech);
            }
            if (object.speech_mute != null) {
                if (typeof object.speech_mute !== "object")
                    throw TypeError(".CDOTAUserMsg_UnitEvent.speech_mute: object expected");
                message.speech_mute = $root.CDOTAUserMsg_UnitEvent.SpeechMute.fromObject(object.speech_mute);
            }
            if (object.add_gesture != null) {
                if (typeof object.add_gesture !== "object")
                    throw TypeError(".CDOTAUserMsg_UnitEvent.add_gesture: object expected");
                message.add_gesture = $root.CDOTAUserMsg_UnitEvent.AddGesture.fromObject(object.add_gesture);
            }
            if (object.remove_gesture != null) {
                if (typeof object.remove_gesture !== "object")
                    throw TypeError(".CDOTAUserMsg_UnitEvent.remove_gesture: object expected");
                message.remove_gesture = $root.CDOTAUserMsg_UnitEvent.RemoveGesture.fromObject(object.remove_gesture);
            }
            if (object.blood_impact != null) {
                if (typeof object.blood_impact !== "object")
                    throw TypeError(".CDOTAUserMsg_UnitEvent.blood_impact: object expected");
                message.blood_impact = $root.CDOTAUserMsg_UnitEvent.BloodImpact.fromObject(object.blood_impact);
            }
            if (object.fade_gesture != null) {
                if (typeof object.fade_gesture !== "object")
                    throw TypeError(".CDOTAUserMsg_UnitEvent.fade_gesture: object expected");
                message.fade_gesture = $root.CDOTAUserMsg_UnitEvent.FadeGesture.fromObject(object.fade_gesture);
            }
            if (object.speech_match_on_client != null) {
                if (typeof object.speech_match_on_client !== "object")
                    throw TypeError(".CDOTAUserMsg_UnitEvent.speech_match_on_client: object expected");
                message.speech_match_on_client = $root.CDOTASpeechMatchOnClient.fromObject(object.speech_match_on_client);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_UnitEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_UnitEvent
         * @static
         * @param {CDOTAUserMsg_UnitEvent} message CDOTAUserMsg_UnitEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_UnitEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.msg_type = options.enums === String ? "DOTA_UNIT_SPEECH" : 0;
                object.entity_index = 0;
                object.speech = null;
                object.speech_mute = null;
                object.add_gesture = null;
                object.remove_gesture = null;
                object.blood_impact = null;
                object.fade_gesture = null;
                object.speech_match_on_client = null;
            }
            if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                object.msg_type = options.enums === String ? $root.EDotaEntityMessages[message.msg_type] : message.msg_type;
            if (message.entity_index != null && message.hasOwnProperty("entity_index"))
                object.entity_index = message.entity_index;
            if (message.speech != null && message.hasOwnProperty("speech"))
                object.speech = $root.CDOTAUserMsg_UnitEvent.Speech.toObject(message.speech, options);
            if (message.speech_mute != null && message.hasOwnProperty("speech_mute"))
                object.speech_mute = $root.CDOTAUserMsg_UnitEvent.SpeechMute.toObject(message.speech_mute, options);
            if (message.add_gesture != null && message.hasOwnProperty("add_gesture"))
                object.add_gesture = $root.CDOTAUserMsg_UnitEvent.AddGesture.toObject(message.add_gesture, options);
            if (message.remove_gesture != null && message.hasOwnProperty("remove_gesture"))
                object.remove_gesture = $root.CDOTAUserMsg_UnitEvent.RemoveGesture.toObject(message.remove_gesture, options);
            if (message.blood_impact != null && message.hasOwnProperty("blood_impact"))
                object.blood_impact = $root.CDOTAUserMsg_UnitEvent.BloodImpact.toObject(message.blood_impact, options);
            if (message.fade_gesture != null && message.hasOwnProperty("fade_gesture"))
                object.fade_gesture = $root.CDOTAUserMsg_UnitEvent.FadeGesture.toObject(message.fade_gesture, options);
            if (message.speech_match_on_client != null && message.hasOwnProperty("speech_match_on_client"))
                object.speech_match_on_client = $root.CDOTASpeechMatchOnClient.toObject(message.speech_match_on_client, options);
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_UnitEvent to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_UnitEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_UnitEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CDOTAUserMsg_UnitEvent.Interval = (function() {
    
            /**
             * Properties of an Interval.
             * @memberof CDOTAUserMsg_UnitEvent
             * @interface IInterval
             * @property {number|null} [start] Interval start
             * @property {number|null} [range] Interval range
             */
    
            /**
             * Constructs a new Interval.
             * @memberof CDOTAUserMsg_UnitEvent
             * @classdesc Represents an Interval.
             * @implements IInterval
             * @constructor
             * @param {CDOTAUserMsg_UnitEvent.IInterval=} [properties] Properties to set
             */
            function Interval(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Interval start.
             * @member {number} start
             * @memberof CDOTAUserMsg_UnitEvent.Interval
             * @instance
             */
            Interval.prototype.start = 0;
    
            /**
             * Interval range.
             * @member {number} range
             * @memberof CDOTAUserMsg_UnitEvent.Interval
             * @instance
             */
            Interval.prototype.range = 0;
    
            /**
             * Creates a new Interval instance using the specified properties.
             * @function create
             * @memberof CDOTAUserMsg_UnitEvent.Interval
             * @static
             * @param {CDOTAUserMsg_UnitEvent.IInterval=} [properties] Properties to set
             * @returns {CDOTAUserMsg_UnitEvent.Interval} Interval instance
             */
            Interval.create = function create(properties) {
                return new Interval(properties);
            };
    
            /**
             * Encodes the specified Interval message. Does not implicitly {@link CDOTAUserMsg_UnitEvent.Interval.verify|verify} messages.
             * @function encode
             * @memberof CDOTAUserMsg_UnitEvent.Interval
             * @static
             * @param {CDOTAUserMsg_UnitEvent.IInterval} message Interval message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Interval.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.start);
                if (message.range != null && Object.hasOwnProperty.call(message, "range"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.range);
                return writer;
            };
    
            /**
             * Encodes the specified Interval message, length delimited. Does not implicitly {@link CDOTAUserMsg_UnitEvent.Interval.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTAUserMsg_UnitEvent.Interval
             * @static
             * @param {CDOTAUserMsg_UnitEvent.IInterval} message Interval message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Interval.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Interval message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTAUserMsg_UnitEvent.Interval
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTAUserMsg_UnitEvent.Interval} Interval
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Interval.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_UnitEvent.Interval();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.start = reader.float();
                        break;
                    case 2:
                        message.range = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Interval message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTAUserMsg_UnitEvent.Interval
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTAUserMsg_UnitEvent.Interval} Interval
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Interval.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Interval message.
             * @function verify
             * @memberof CDOTAUserMsg_UnitEvent.Interval
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Interval.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.start != null && message.hasOwnProperty("start"))
                    if (typeof message.start !== "number")
                        return "start: number expected";
                if (message.range != null && message.hasOwnProperty("range"))
                    if (typeof message.range !== "number")
                        return "range: number expected";
                return null;
            };
    
            /**
             * Creates an Interval message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTAUserMsg_UnitEvent.Interval
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTAUserMsg_UnitEvent.Interval} Interval
             */
            Interval.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTAUserMsg_UnitEvent.Interval)
                    return object;
                var message = new $root.CDOTAUserMsg_UnitEvent.Interval();
                if (object.start != null)
                    message.start = Number(object.start);
                if (object.range != null)
                    message.range = Number(object.range);
                return message;
            };
    
            /**
             * Creates a plain object from an Interval message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTAUserMsg_UnitEvent.Interval
             * @static
             * @param {CDOTAUserMsg_UnitEvent.Interval} message Interval
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Interval.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.start = 0;
                    object.range = 0;
                }
                if (message.start != null && message.hasOwnProperty("start"))
                    object.start = options.json && !isFinite(message.start) ? String(message.start) : message.start;
                if (message.range != null && message.hasOwnProperty("range"))
                    object.range = options.json && !isFinite(message.range) ? String(message.range) : message.range;
                return object;
            };
    
            /**
             * Converts this Interval to JSON.
             * @function toJSON
             * @memberof CDOTAUserMsg_UnitEvent.Interval
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Interval.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Interval;
        })();
    
        CDOTAUserMsg_UnitEvent.Speech = (function() {
    
            /**
             * Properties of a Speech.
             * @memberof CDOTAUserMsg_UnitEvent
             * @interface ISpeech
             * @property {number|null} [concept] Speech concept
             * @property {string|null} [response] Speech response
             * @property {number|null} [recipient_type] Speech recipient_type
             * @property {number|null} [level] Speech level
             * @property {boolean|null} [muteable] Speech muteable
             * @property {CDOTAUserMsg_UnitEvent.IInterval|null} [predelay] Speech predelay
             * @property {number|null} [flags] Speech flags
             */
    
            /**
             * Constructs a new Speech.
             * @memberof CDOTAUserMsg_UnitEvent
             * @classdesc Represents a Speech.
             * @implements ISpeech
             * @constructor
             * @param {CDOTAUserMsg_UnitEvent.ISpeech=} [properties] Properties to set
             */
            function Speech(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Speech concept.
             * @member {number} concept
             * @memberof CDOTAUserMsg_UnitEvent.Speech
             * @instance
             */
            Speech.prototype.concept = 0;
    
            /**
             * Speech response.
             * @member {string} response
             * @memberof CDOTAUserMsg_UnitEvent.Speech
             * @instance
             */
            Speech.prototype.response = "";
    
            /**
             * Speech recipient_type.
             * @member {number} recipient_type
             * @memberof CDOTAUserMsg_UnitEvent.Speech
             * @instance
             */
            Speech.prototype.recipient_type = 0;
    
            /**
             * Speech level.
             * @member {number} level
             * @memberof CDOTAUserMsg_UnitEvent.Speech
             * @instance
             */
            Speech.prototype.level = 0;
    
            /**
             * Speech muteable.
             * @member {boolean} muteable
             * @memberof CDOTAUserMsg_UnitEvent.Speech
             * @instance
             */
            Speech.prototype.muteable = false;
    
            /**
             * Speech predelay.
             * @member {CDOTAUserMsg_UnitEvent.IInterval|null|undefined} predelay
             * @memberof CDOTAUserMsg_UnitEvent.Speech
             * @instance
             */
            Speech.prototype.predelay = null;
    
            /**
             * Speech flags.
             * @member {number} flags
             * @memberof CDOTAUserMsg_UnitEvent.Speech
             * @instance
             */
            Speech.prototype.flags = 0;
    
            /**
             * Creates a new Speech instance using the specified properties.
             * @function create
             * @memberof CDOTAUserMsg_UnitEvent.Speech
             * @static
             * @param {CDOTAUserMsg_UnitEvent.ISpeech=} [properties] Properties to set
             * @returns {CDOTAUserMsg_UnitEvent.Speech} Speech instance
             */
            Speech.create = function create(properties) {
                return new Speech(properties);
            };
    
            /**
             * Encodes the specified Speech message. Does not implicitly {@link CDOTAUserMsg_UnitEvent.Speech.verify|verify} messages.
             * @function encode
             * @memberof CDOTAUserMsg_UnitEvent.Speech
             * @static
             * @param {CDOTAUserMsg_UnitEvent.ISpeech} message Speech message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Speech.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.concept != null && Object.hasOwnProperty.call(message, "concept"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.concept);
                if (message.response != null && Object.hasOwnProperty.call(message, "response"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.response);
                if (message.recipient_type != null && Object.hasOwnProperty.call(message, "recipient_type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.recipient_type);
                if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.level);
                if (message.muteable != null && Object.hasOwnProperty.call(message, "muteable"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.muteable);
                if (message.predelay != null && Object.hasOwnProperty.call(message, "predelay"))
                    $root.CDOTAUserMsg_UnitEvent.Interval.encode(message.predelay, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.flags);
                return writer;
            };
    
            /**
             * Encodes the specified Speech message, length delimited. Does not implicitly {@link CDOTAUserMsg_UnitEvent.Speech.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTAUserMsg_UnitEvent.Speech
             * @static
             * @param {CDOTAUserMsg_UnitEvent.ISpeech} message Speech message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Speech.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Speech message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTAUserMsg_UnitEvent.Speech
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTAUserMsg_UnitEvent.Speech} Speech
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Speech.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_UnitEvent.Speech();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.concept = reader.int32();
                        break;
                    case 2:
                        message.response = reader.string();
                        break;
                    case 3:
                        message.recipient_type = reader.int32();
                        break;
                    case 4:
                        message.level = reader.int32();
                        break;
                    case 5:
                        message.muteable = reader.bool();
                        break;
                    case 6:
                        message.predelay = $root.CDOTAUserMsg_UnitEvent.Interval.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.flags = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Speech message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTAUserMsg_UnitEvent.Speech
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTAUserMsg_UnitEvent.Speech} Speech
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Speech.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Speech message.
             * @function verify
             * @memberof CDOTAUserMsg_UnitEvent.Speech
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Speech.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.concept != null && message.hasOwnProperty("concept"))
                    if (!$util.isInteger(message.concept))
                        return "concept: integer expected";
                if (message.response != null && message.hasOwnProperty("response"))
                    if (!$util.isString(message.response))
                        return "response: string expected";
                if (message.recipient_type != null && message.hasOwnProperty("recipient_type"))
                    if (!$util.isInteger(message.recipient_type))
                        return "recipient_type: integer expected";
                if (message.level != null && message.hasOwnProperty("level"))
                    if (!$util.isInteger(message.level))
                        return "level: integer expected";
                if (message.muteable != null && message.hasOwnProperty("muteable"))
                    if (typeof message.muteable !== "boolean")
                        return "muteable: boolean expected";
                if (message.predelay != null && message.hasOwnProperty("predelay")) {
                    var error = $root.CDOTAUserMsg_UnitEvent.Interval.verify(message.predelay);
                    if (error)
                        return "predelay." + error;
                }
                if (message.flags != null && message.hasOwnProperty("flags"))
                    if (!$util.isInteger(message.flags))
                        return "flags: integer expected";
                return null;
            };
    
            /**
             * Creates a Speech message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTAUserMsg_UnitEvent.Speech
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTAUserMsg_UnitEvent.Speech} Speech
             */
            Speech.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTAUserMsg_UnitEvent.Speech)
                    return object;
                var message = new $root.CDOTAUserMsg_UnitEvent.Speech();
                if (object.concept != null)
                    message.concept = object.concept | 0;
                if (object.response != null)
                    message.response = String(object.response);
                if (object.recipient_type != null)
                    message.recipient_type = object.recipient_type | 0;
                if (object.level != null)
                    message.level = object.level | 0;
                if (object.muteable != null)
                    message.muteable = Boolean(object.muteable);
                if (object.predelay != null) {
                    if (typeof object.predelay !== "object")
                        throw TypeError(".CDOTAUserMsg_UnitEvent.Speech.predelay: object expected");
                    message.predelay = $root.CDOTAUserMsg_UnitEvent.Interval.fromObject(object.predelay);
                }
                if (object.flags != null)
                    message.flags = object.flags >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a Speech message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTAUserMsg_UnitEvent.Speech
             * @static
             * @param {CDOTAUserMsg_UnitEvent.Speech} message Speech
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Speech.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.concept = 0;
                    object.response = "";
                    object.recipient_type = 0;
                    object.level = 0;
                    object.muteable = false;
                    object.predelay = null;
                    object.flags = 0;
                }
                if (message.concept != null && message.hasOwnProperty("concept"))
                    object.concept = message.concept;
                if (message.response != null && message.hasOwnProperty("response"))
                    object.response = message.response;
                if (message.recipient_type != null && message.hasOwnProperty("recipient_type"))
                    object.recipient_type = message.recipient_type;
                if (message.level != null && message.hasOwnProperty("level"))
                    object.level = message.level;
                if (message.muteable != null && message.hasOwnProperty("muteable"))
                    object.muteable = message.muteable;
                if (message.predelay != null && message.hasOwnProperty("predelay"))
                    object.predelay = $root.CDOTAUserMsg_UnitEvent.Interval.toObject(message.predelay, options);
                if (message.flags != null && message.hasOwnProperty("flags"))
                    object.flags = message.flags;
                return object;
            };
    
            /**
             * Converts this Speech to JSON.
             * @function toJSON
             * @memberof CDOTAUserMsg_UnitEvent.Speech
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Speech.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Speech;
        })();
    
        CDOTAUserMsg_UnitEvent.SpeechMute = (function() {
    
            /**
             * Properties of a SpeechMute.
             * @memberof CDOTAUserMsg_UnitEvent
             * @interface ISpeechMute
             * @property {number|null} [delay] SpeechMute delay
             */
    
            /**
             * Constructs a new SpeechMute.
             * @memberof CDOTAUserMsg_UnitEvent
             * @classdesc Represents a SpeechMute.
             * @implements ISpeechMute
             * @constructor
             * @param {CDOTAUserMsg_UnitEvent.ISpeechMute=} [properties] Properties to set
             */
            function SpeechMute(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SpeechMute delay.
             * @member {number} delay
             * @memberof CDOTAUserMsg_UnitEvent.SpeechMute
             * @instance
             */
            SpeechMute.prototype.delay = 0.5;
    
            /**
             * Creates a new SpeechMute instance using the specified properties.
             * @function create
             * @memberof CDOTAUserMsg_UnitEvent.SpeechMute
             * @static
             * @param {CDOTAUserMsg_UnitEvent.ISpeechMute=} [properties] Properties to set
             * @returns {CDOTAUserMsg_UnitEvent.SpeechMute} SpeechMute instance
             */
            SpeechMute.create = function create(properties) {
                return new SpeechMute(properties);
            };
    
            /**
             * Encodes the specified SpeechMute message. Does not implicitly {@link CDOTAUserMsg_UnitEvent.SpeechMute.verify|verify} messages.
             * @function encode
             * @memberof CDOTAUserMsg_UnitEvent.SpeechMute
             * @static
             * @param {CDOTAUserMsg_UnitEvent.ISpeechMute} message SpeechMute message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpeechMute.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.delay != null && Object.hasOwnProperty.call(message, "delay"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.delay);
                return writer;
            };
    
            /**
             * Encodes the specified SpeechMute message, length delimited. Does not implicitly {@link CDOTAUserMsg_UnitEvent.SpeechMute.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTAUserMsg_UnitEvent.SpeechMute
             * @static
             * @param {CDOTAUserMsg_UnitEvent.ISpeechMute} message SpeechMute message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpeechMute.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SpeechMute message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTAUserMsg_UnitEvent.SpeechMute
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTAUserMsg_UnitEvent.SpeechMute} SpeechMute
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpeechMute.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_UnitEvent.SpeechMute();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.delay = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SpeechMute message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTAUserMsg_UnitEvent.SpeechMute
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTAUserMsg_UnitEvent.SpeechMute} SpeechMute
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpeechMute.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SpeechMute message.
             * @function verify
             * @memberof CDOTAUserMsg_UnitEvent.SpeechMute
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SpeechMute.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.delay != null && message.hasOwnProperty("delay"))
                    if (typeof message.delay !== "number")
                        return "delay: number expected";
                return null;
            };
    
            /**
             * Creates a SpeechMute message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTAUserMsg_UnitEvent.SpeechMute
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTAUserMsg_UnitEvent.SpeechMute} SpeechMute
             */
            SpeechMute.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTAUserMsg_UnitEvent.SpeechMute)
                    return object;
                var message = new $root.CDOTAUserMsg_UnitEvent.SpeechMute();
                if (object.delay != null)
                    message.delay = Number(object.delay);
                return message;
            };
    
            /**
             * Creates a plain object from a SpeechMute message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTAUserMsg_UnitEvent.SpeechMute
             * @static
             * @param {CDOTAUserMsg_UnitEvent.SpeechMute} message SpeechMute
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SpeechMute.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.delay = 0.5;
                if (message.delay != null && message.hasOwnProperty("delay"))
                    object.delay = options.json && !isFinite(message.delay) ? String(message.delay) : message.delay;
                return object;
            };
    
            /**
             * Converts this SpeechMute to JSON.
             * @function toJSON
             * @memberof CDOTAUserMsg_UnitEvent.SpeechMute
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SpeechMute.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SpeechMute;
        })();
    
        CDOTAUserMsg_UnitEvent.AddGesture = (function() {
    
            /**
             * Properties of an AddGesture.
             * @memberof CDOTAUserMsg_UnitEvent
             * @interface IAddGesture
             * @property {number|null} [activity] AddGesture activity
             * @property {number|null} [slot] AddGesture slot
             * @property {number|null} [fade_in] AddGesture fade_in
             * @property {number|null} [fade_out] AddGesture fade_out
             * @property {number|null} [playback_rate] AddGesture playback_rate
             * @property {number|null} [sequence_variant] AddGesture sequence_variant
             */
    
            /**
             * Constructs a new AddGesture.
             * @memberof CDOTAUserMsg_UnitEvent
             * @classdesc Represents an AddGesture.
             * @implements IAddGesture
             * @constructor
             * @param {CDOTAUserMsg_UnitEvent.IAddGesture=} [properties] Properties to set
             */
            function AddGesture(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AddGesture activity.
             * @member {number} activity
             * @memberof CDOTAUserMsg_UnitEvent.AddGesture
             * @instance
             */
            AddGesture.prototype.activity = 0;
    
            /**
             * AddGesture slot.
             * @member {number} slot
             * @memberof CDOTAUserMsg_UnitEvent.AddGesture
             * @instance
             */
            AddGesture.prototype.slot = 0;
    
            /**
             * AddGesture fade_in.
             * @member {number} fade_in
             * @memberof CDOTAUserMsg_UnitEvent.AddGesture
             * @instance
             */
            AddGesture.prototype.fade_in = 0;
    
            /**
             * AddGesture fade_out.
             * @member {number} fade_out
             * @memberof CDOTAUserMsg_UnitEvent.AddGesture
             * @instance
             */
            AddGesture.prototype.fade_out = 0.1;
    
            /**
             * AddGesture playback_rate.
             * @member {number} playback_rate
             * @memberof CDOTAUserMsg_UnitEvent.AddGesture
             * @instance
             */
            AddGesture.prototype.playback_rate = 1;
    
            /**
             * AddGesture sequence_variant.
             * @member {number} sequence_variant
             * @memberof CDOTAUserMsg_UnitEvent.AddGesture
             * @instance
             */
            AddGesture.prototype.sequence_variant = 0;
    
            /**
             * Creates a new AddGesture instance using the specified properties.
             * @function create
             * @memberof CDOTAUserMsg_UnitEvent.AddGesture
             * @static
             * @param {CDOTAUserMsg_UnitEvent.IAddGesture=} [properties] Properties to set
             * @returns {CDOTAUserMsg_UnitEvent.AddGesture} AddGesture instance
             */
            AddGesture.create = function create(properties) {
                return new AddGesture(properties);
            };
    
            /**
             * Encodes the specified AddGesture message. Does not implicitly {@link CDOTAUserMsg_UnitEvent.AddGesture.verify|verify} messages.
             * @function encode
             * @memberof CDOTAUserMsg_UnitEvent.AddGesture
             * @static
             * @param {CDOTAUserMsg_UnitEvent.IAddGesture} message AddGesture message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddGesture.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.activity != null && Object.hasOwnProperty.call(message, "activity"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.activity);
                if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.slot);
                if (message.fade_in != null && Object.hasOwnProperty.call(message, "fade_in"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.fade_in);
                if (message.fade_out != null && Object.hasOwnProperty.call(message, "fade_out"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.fade_out);
                if (message.playback_rate != null && Object.hasOwnProperty.call(message, "playback_rate"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.playback_rate);
                if (message.sequence_variant != null && Object.hasOwnProperty.call(message, "sequence_variant"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.sequence_variant);
                return writer;
            };
    
            /**
             * Encodes the specified AddGesture message, length delimited. Does not implicitly {@link CDOTAUserMsg_UnitEvent.AddGesture.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTAUserMsg_UnitEvent.AddGesture
             * @static
             * @param {CDOTAUserMsg_UnitEvent.IAddGesture} message AddGesture message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddGesture.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an AddGesture message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTAUserMsg_UnitEvent.AddGesture
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTAUserMsg_UnitEvent.AddGesture} AddGesture
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddGesture.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_UnitEvent.AddGesture();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.activity = reader.int32();
                        break;
                    case 2:
                        message.slot = reader.int32();
                        break;
                    case 3:
                        message.fade_in = reader.float();
                        break;
                    case 4:
                        message.fade_out = reader.float();
                        break;
                    case 5:
                        message.playback_rate = reader.float();
                        break;
                    case 6:
                        message.sequence_variant = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an AddGesture message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTAUserMsg_UnitEvent.AddGesture
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTAUserMsg_UnitEvent.AddGesture} AddGesture
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddGesture.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an AddGesture message.
             * @function verify
             * @memberof CDOTAUserMsg_UnitEvent.AddGesture
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddGesture.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.activity != null && message.hasOwnProperty("activity"))
                    if (!$util.isInteger(message.activity))
                        return "activity: integer expected";
                if (message.slot != null && message.hasOwnProperty("slot"))
                    if (!$util.isInteger(message.slot))
                        return "slot: integer expected";
                if (message.fade_in != null && message.hasOwnProperty("fade_in"))
                    if (typeof message.fade_in !== "number")
                        return "fade_in: number expected";
                if (message.fade_out != null && message.hasOwnProperty("fade_out"))
                    if (typeof message.fade_out !== "number")
                        return "fade_out: number expected";
                if (message.playback_rate != null && message.hasOwnProperty("playback_rate"))
                    if (typeof message.playback_rate !== "number")
                        return "playback_rate: number expected";
                if (message.sequence_variant != null && message.hasOwnProperty("sequence_variant"))
                    if (!$util.isInteger(message.sequence_variant))
                        return "sequence_variant: integer expected";
                return null;
            };
    
            /**
             * Creates an AddGesture message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTAUserMsg_UnitEvent.AddGesture
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTAUserMsg_UnitEvent.AddGesture} AddGesture
             */
            AddGesture.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTAUserMsg_UnitEvent.AddGesture)
                    return object;
                var message = new $root.CDOTAUserMsg_UnitEvent.AddGesture();
                if (object.activity != null)
                    message.activity = object.activity | 0;
                if (object.slot != null)
                    message.slot = object.slot | 0;
                if (object.fade_in != null)
                    message.fade_in = Number(object.fade_in);
                if (object.fade_out != null)
                    message.fade_out = Number(object.fade_out);
                if (object.playback_rate != null)
                    message.playback_rate = Number(object.playback_rate);
                if (object.sequence_variant != null)
                    message.sequence_variant = object.sequence_variant | 0;
                return message;
            };
    
            /**
             * Creates a plain object from an AddGesture message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTAUserMsg_UnitEvent.AddGesture
             * @static
             * @param {CDOTAUserMsg_UnitEvent.AddGesture} message AddGesture
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddGesture.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.activity = 0;
                    object.slot = 0;
                    object.fade_in = 0;
                    object.fade_out = 0.1;
                    object.playback_rate = 1;
                    object.sequence_variant = 0;
                }
                if (message.activity != null && message.hasOwnProperty("activity"))
                    object.activity = message.activity;
                if (message.slot != null && message.hasOwnProperty("slot"))
                    object.slot = message.slot;
                if (message.fade_in != null && message.hasOwnProperty("fade_in"))
                    object.fade_in = options.json && !isFinite(message.fade_in) ? String(message.fade_in) : message.fade_in;
                if (message.fade_out != null && message.hasOwnProperty("fade_out"))
                    object.fade_out = options.json && !isFinite(message.fade_out) ? String(message.fade_out) : message.fade_out;
                if (message.playback_rate != null && message.hasOwnProperty("playback_rate"))
                    object.playback_rate = options.json && !isFinite(message.playback_rate) ? String(message.playback_rate) : message.playback_rate;
                if (message.sequence_variant != null && message.hasOwnProperty("sequence_variant"))
                    object.sequence_variant = message.sequence_variant;
                return object;
            };
    
            /**
             * Converts this AddGesture to JSON.
             * @function toJSON
             * @memberof CDOTAUserMsg_UnitEvent.AddGesture
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddGesture.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return AddGesture;
        })();
    
        CDOTAUserMsg_UnitEvent.RemoveGesture = (function() {
    
            /**
             * Properties of a RemoveGesture.
             * @memberof CDOTAUserMsg_UnitEvent
             * @interface IRemoveGesture
             * @property {number|null} [activity] RemoveGesture activity
             */
    
            /**
             * Constructs a new RemoveGesture.
             * @memberof CDOTAUserMsg_UnitEvent
             * @classdesc Represents a RemoveGesture.
             * @implements IRemoveGesture
             * @constructor
             * @param {CDOTAUserMsg_UnitEvent.IRemoveGesture=} [properties] Properties to set
             */
            function RemoveGesture(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RemoveGesture activity.
             * @member {number} activity
             * @memberof CDOTAUserMsg_UnitEvent.RemoveGesture
             * @instance
             */
            RemoveGesture.prototype.activity = 0;
    
            /**
             * Creates a new RemoveGesture instance using the specified properties.
             * @function create
             * @memberof CDOTAUserMsg_UnitEvent.RemoveGesture
             * @static
             * @param {CDOTAUserMsg_UnitEvent.IRemoveGesture=} [properties] Properties to set
             * @returns {CDOTAUserMsg_UnitEvent.RemoveGesture} RemoveGesture instance
             */
            RemoveGesture.create = function create(properties) {
                return new RemoveGesture(properties);
            };
    
            /**
             * Encodes the specified RemoveGesture message. Does not implicitly {@link CDOTAUserMsg_UnitEvent.RemoveGesture.verify|verify} messages.
             * @function encode
             * @memberof CDOTAUserMsg_UnitEvent.RemoveGesture
             * @static
             * @param {CDOTAUserMsg_UnitEvent.IRemoveGesture} message RemoveGesture message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoveGesture.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.activity != null && Object.hasOwnProperty.call(message, "activity"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.activity);
                return writer;
            };
    
            /**
             * Encodes the specified RemoveGesture message, length delimited. Does not implicitly {@link CDOTAUserMsg_UnitEvent.RemoveGesture.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTAUserMsg_UnitEvent.RemoveGesture
             * @static
             * @param {CDOTAUserMsg_UnitEvent.IRemoveGesture} message RemoveGesture message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoveGesture.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a RemoveGesture message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTAUserMsg_UnitEvent.RemoveGesture
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTAUserMsg_UnitEvent.RemoveGesture} RemoveGesture
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoveGesture.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_UnitEvent.RemoveGesture();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.activity = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a RemoveGesture message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTAUserMsg_UnitEvent.RemoveGesture
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTAUserMsg_UnitEvent.RemoveGesture} RemoveGesture
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoveGesture.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a RemoveGesture message.
             * @function verify
             * @memberof CDOTAUserMsg_UnitEvent.RemoveGesture
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RemoveGesture.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.activity != null && message.hasOwnProperty("activity"))
                    if (!$util.isInteger(message.activity))
                        return "activity: integer expected";
                return null;
            };
    
            /**
             * Creates a RemoveGesture message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTAUserMsg_UnitEvent.RemoveGesture
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTAUserMsg_UnitEvent.RemoveGesture} RemoveGesture
             */
            RemoveGesture.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTAUserMsg_UnitEvent.RemoveGesture)
                    return object;
                var message = new $root.CDOTAUserMsg_UnitEvent.RemoveGesture();
                if (object.activity != null)
                    message.activity = object.activity | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a RemoveGesture message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTAUserMsg_UnitEvent.RemoveGesture
             * @static
             * @param {CDOTAUserMsg_UnitEvent.RemoveGesture} message RemoveGesture
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RemoveGesture.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.activity = 0;
                if (message.activity != null && message.hasOwnProperty("activity"))
                    object.activity = message.activity;
                return object;
            };
    
            /**
             * Converts this RemoveGesture to JSON.
             * @function toJSON
             * @memberof CDOTAUserMsg_UnitEvent.RemoveGesture
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RemoveGesture.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return RemoveGesture;
        })();
    
        CDOTAUserMsg_UnitEvent.BloodImpact = (function() {
    
            /**
             * Properties of a BloodImpact.
             * @memberof CDOTAUserMsg_UnitEvent
             * @interface IBloodImpact
             * @property {number|null} [scale] BloodImpact scale
             * @property {number|null} [x_normal] BloodImpact x_normal
             * @property {number|null} [y_normal] BloodImpact y_normal
             */
    
            /**
             * Constructs a new BloodImpact.
             * @memberof CDOTAUserMsg_UnitEvent
             * @classdesc Represents a BloodImpact.
             * @implements IBloodImpact
             * @constructor
             * @param {CDOTAUserMsg_UnitEvent.IBloodImpact=} [properties] Properties to set
             */
            function BloodImpact(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BloodImpact scale.
             * @member {number} scale
             * @memberof CDOTAUserMsg_UnitEvent.BloodImpact
             * @instance
             */
            BloodImpact.prototype.scale = 0;
    
            /**
             * BloodImpact x_normal.
             * @member {number} x_normal
             * @memberof CDOTAUserMsg_UnitEvent.BloodImpact
             * @instance
             */
            BloodImpact.prototype.x_normal = 0;
    
            /**
             * BloodImpact y_normal.
             * @member {number} y_normal
             * @memberof CDOTAUserMsg_UnitEvent.BloodImpact
             * @instance
             */
            BloodImpact.prototype.y_normal = 0;
    
            /**
             * Creates a new BloodImpact instance using the specified properties.
             * @function create
             * @memberof CDOTAUserMsg_UnitEvent.BloodImpact
             * @static
             * @param {CDOTAUserMsg_UnitEvent.IBloodImpact=} [properties] Properties to set
             * @returns {CDOTAUserMsg_UnitEvent.BloodImpact} BloodImpact instance
             */
            BloodImpact.create = function create(properties) {
                return new BloodImpact(properties);
            };
    
            /**
             * Encodes the specified BloodImpact message. Does not implicitly {@link CDOTAUserMsg_UnitEvent.BloodImpact.verify|verify} messages.
             * @function encode
             * @memberof CDOTAUserMsg_UnitEvent.BloodImpact
             * @static
             * @param {CDOTAUserMsg_UnitEvent.IBloodImpact} message BloodImpact message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BloodImpact.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.scale);
                if (message.x_normal != null && Object.hasOwnProperty.call(message, "x_normal"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.x_normal);
                if (message.y_normal != null && Object.hasOwnProperty.call(message, "y_normal"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.y_normal);
                return writer;
            };
    
            /**
             * Encodes the specified BloodImpact message, length delimited. Does not implicitly {@link CDOTAUserMsg_UnitEvent.BloodImpact.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTAUserMsg_UnitEvent.BloodImpact
             * @static
             * @param {CDOTAUserMsg_UnitEvent.IBloodImpact} message BloodImpact message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BloodImpact.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BloodImpact message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTAUserMsg_UnitEvent.BloodImpact
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTAUserMsg_UnitEvent.BloodImpact} BloodImpact
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BloodImpact.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_UnitEvent.BloodImpact();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.scale = reader.int32();
                        break;
                    case 2:
                        message.x_normal = reader.int32();
                        break;
                    case 3:
                        message.y_normal = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BloodImpact message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTAUserMsg_UnitEvent.BloodImpact
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTAUserMsg_UnitEvent.BloodImpact} BloodImpact
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BloodImpact.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BloodImpact message.
             * @function verify
             * @memberof CDOTAUserMsg_UnitEvent.BloodImpact
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BloodImpact.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.scale != null && message.hasOwnProperty("scale"))
                    if (!$util.isInteger(message.scale))
                        return "scale: integer expected";
                if (message.x_normal != null && message.hasOwnProperty("x_normal"))
                    if (!$util.isInteger(message.x_normal))
                        return "x_normal: integer expected";
                if (message.y_normal != null && message.hasOwnProperty("y_normal"))
                    if (!$util.isInteger(message.y_normal))
                        return "y_normal: integer expected";
                return null;
            };
    
            /**
             * Creates a BloodImpact message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTAUserMsg_UnitEvent.BloodImpact
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTAUserMsg_UnitEvent.BloodImpact} BloodImpact
             */
            BloodImpact.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTAUserMsg_UnitEvent.BloodImpact)
                    return object;
                var message = new $root.CDOTAUserMsg_UnitEvent.BloodImpact();
                if (object.scale != null)
                    message.scale = object.scale | 0;
                if (object.x_normal != null)
                    message.x_normal = object.x_normal | 0;
                if (object.y_normal != null)
                    message.y_normal = object.y_normal | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a BloodImpact message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTAUserMsg_UnitEvent.BloodImpact
             * @static
             * @param {CDOTAUserMsg_UnitEvent.BloodImpact} message BloodImpact
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BloodImpact.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.scale = 0;
                    object.x_normal = 0;
                    object.y_normal = 0;
                }
                if (message.scale != null && message.hasOwnProperty("scale"))
                    object.scale = message.scale;
                if (message.x_normal != null && message.hasOwnProperty("x_normal"))
                    object.x_normal = message.x_normal;
                if (message.y_normal != null && message.hasOwnProperty("y_normal"))
                    object.y_normal = message.y_normal;
                return object;
            };
    
            /**
             * Converts this BloodImpact to JSON.
             * @function toJSON
             * @memberof CDOTAUserMsg_UnitEvent.BloodImpact
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BloodImpact.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BloodImpact;
        })();
    
        CDOTAUserMsg_UnitEvent.FadeGesture = (function() {
    
            /**
             * Properties of a FadeGesture.
             * @memberof CDOTAUserMsg_UnitEvent
             * @interface IFadeGesture
             * @property {number|null} [activity] FadeGesture activity
             */
    
            /**
             * Constructs a new FadeGesture.
             * @memberof CDOTAUserMsg_UnitEvent
             * @classdesc Represents a FadeGesture.
             * @implements IFadeGesture
             * @constructor
             * @param {CDOTAUserMsg_UnitEvent.IFadeGesture=} [properties] Properties to set
             */
            function FadeGesture(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FadeGesture activity.
             * @member {number} activity
             * @memberof CDOTAUserMsg_UnitEvent.FadeGesture
             * @instance
             */
            FadeGesture.prototype.activity = 0;
    
            /**
             * Creates a new FadeGesture instance using the specified properties.
             * @function create
             * @memberof CDOTAUserMsg_UnitEvent.FadeGesture
             * @static
             * @param {CDOTAUserMsg_UnitEvent.IFadeGesture=} [properties] Properties to set
             * @returns {CDOTAUserMsg_UnitEvent.FadeGesture} FadeGesture instance
             */
            FadeGesture.create = function create(properties) {
                return new FadeGesture(properties);
            };
    
            /**
             * Encodes the specified FadeGesture message. Does not implicitly {@link CDOTAUserMsg_UnitEvent.FadeGesture.verify|verify} messages.
             * @function encode
             * @memberof CDOTAUserMsg_UnitEvent.FadeGesture
             * @static
             * @param {CDOTAUserMsg_UnitEvent.IFadeGesture} message FadeGesture message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FadeGesture.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.activity != null && Object.hasOwnProperty.call(message, "activity"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.activity);
                return writer;
            };
    
            /**
             * Encodes the specified FadeGesture message, length delimited. Does not implicitly {@link CDOTAUserMsg_UnitEvent.FadeGesture.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTAUserMsg_UnitEvent.FadeGesture
             * @static
             * @param {CDOTAUserMsg_UnitEvent.IFadeGesture} message FadeGesture message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FadeGesture.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FadeGesture message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTAUserMsg_UnitEvent.FadeGesture
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTAUserMsg_UnitEvent.FadeGesture} FadeGesture
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FadeGesture.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_UnitEvent.FadeGesture();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.activity = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FadeGesture message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTAUserMsg_UnitEvent.FadeGesture
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTAUserMsg_UnitEvent.FadeGesture} FadeGesture
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FadeGesture.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FadeGesture message.
             * @function verify
             * @memberof CDOTAUserMsg_UnitEvent.FadeGesture
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FadeGesture.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.activity != null && message.hasOwnProperty("activity"))
                    if (!$util.isInteger(message.activity))
                        return "activity: integer expected";
                return null;
            };
    
            /**
             * Creates a FadeGesture message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTAUserMsg_UnitEvent.FadeGesture
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTAUserMsg_UnitEvent.FadeGesture} FadeGesture
             */
            FadeGesture.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTAUserMsg_UnitEvent.FadeGesture)
                    return object;
                var message = new $root.CDOTAUserMsg_UnitEvent.FadeGesture();
                if (object.activity != null)
                    message.activity = object.activity | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a FadeGesture message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTAUserMsg_UnitEvent.FadeGesture
             * @static
             * @param {CDOTAUserMsg_UnitEvent.FadeGesture} message FadeGesture
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FadeGesture.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.activity = 0;
                if (message.activity != null && message.hasOwnProperty("activity"))
                    object.activity = message.activity;
                return object;
            };
    
            /**
             * Converts this FadeGesture to JSON.
             * @function toJSON
             * @memberof CDOTAUserMsg_UnitEvent.FadeGesture
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FadeGesture.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FadeGesture;
        })();
    
        return CDOTAUserMsg_UnitEvent;
    })();
    
    $root.CDOTAUserMsg_ItemPurchased = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_ItemPurchased.
         * @exports ICDOTAUserMsg_ItemPurchased
         * @interface ICDOTAUserMsg_ItemPurchased
         * @property {number|null} [item_ability_id] CDOTAUserMsg_ItemPurchased item_ability_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_ItemPurchased.
         * @exports CDOTAUserMsg_ItemPurchased
         * @classdesc Represents a CDOTAUserMsg_ItemPurchased.
         * @implements ICDOTAUserMsg_ItemPurchased
         * @constructor
         * @param {ICDOTAUserMsg_ItemPurchased=} [properties] Properties to set
         */
        function CDOTAUserMsg_ItemPurchased(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_ItemPurchased item_ability_id.
         * @member {number} item_ability_id
         * @memberof CDOTAUserMsg_ItemPurchased
         * @instance
         */
        CDOTAUserMsg_ItemPurchased.prototype.item_ability_id = 0;
    
        /**
         * Creates a new CDOTAUserMsg_ItemPurchased instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_ItemPurchased
         * @static
         * @param {ICDOTAUserMsg_ItemPurchased=} [properties] Properties to set
         * @returns {CDOTAUserMsg_ItemPurchased} CDOTAUserMsg_ItemPurchased instance
         */
        CDOTAUserMsg_ItemPurchased.create = function create(properties) {
            return new CDOTAUserMsg_ItemPurchased(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ItemPurchased message. Does not implicitly {@link CDOTAUserMsg_ItemPurchased.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_ItemPurchased
         * @static
         * @param {ICDOTAUserMsg_ItemPurchased} message CDOTAUserMsg_ItemPurchased message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ItemPurchased.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item_ability_id != null && Object.hasOwnProperty.call(message, "item_ability_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.item_ability_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ItemPurchased message, length delimited. Does not implicitly {@link CDOTAUserMsg_ItemPurchased.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_ItemPurchased
         * @static
         * @param {ICDOTAUserMsg_ItemPurchased} message CDOTAUserMsg_ItemPurchased message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ItemPurchased.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_ItemPurchased message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_ItemPurchased
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_ItemPurchased} CDOTAUserMsg_ItemPurchased
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ItemPurchased.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_ItemPurchased();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item_ability_id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_ItemPurchased message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_ItemPurchased
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_ItemPurchased} CDOTAUserMsg_ItemPurchased
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ItemPurchased.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_ItemPurchased message.
         * @function verify
         * @memberof CDOTAUserMsg_ItemPurchased
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_ItemPurchased.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                if (!$util.isInteger(message.item_ability_id))
                    return "item_ability_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_ItemPurchased message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_ItemPurchased
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_ItemPurchased} CDOTAUserMsg_ItemPurchased
         */
        CDOTAUserMsg_ItemPurchased.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_ItemPurchased)
                return object;
            var message = new $root.CDOTAUserMsg_ItemPurchased();
            if (object.item_ability_id != null)
                message.item_ability_id = object.item_ability_id | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_ItemPurchased message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_ItemPurchased
         * @static
         * @param {CDOTAUserMsg_ItemPurchased} message CDOTAUserMsg_ItemPurchased
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_ItemPurchased.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.item_ability_id = 0;
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                object.item_ability_id = message.item_ability_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_ItemPurchased to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_ItemPurchased
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_ItemPurchased.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_ItemPurchased;
    })();
    
    $root.CDOTAUserMsg_ItemSold = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_ItemSold.
         * @exports ICDOTAUserMsg_ItemSold
         * @interface ICDOTAUserMsg_ItemSold
         * @property {number|null} [item_ability_id] CDOTAUserMsg_ItemSold item_ability_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_ItemSold.
         * @exports CDOTAUserMsg_ItemSold
         * @classdesc Represents a CDOTAUserMsg_ItemSold.
         * @implements ICDOTAUserMsg_ItemSold
         * @constructor
         * @param {ICDOTAUserMsg_ItemSold=} [properties] Properties to set
         */
        function CDOTAUserMsg_ItemSold(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_ItemSold item_ability_id.
         * @member {number} item_ability_id
         * @memberof CDOTAUserMsg_ItemSold
         * @instance
         */
        CDOTAUserMsg_ItemSold.prototype.item_ability_id = 0;
    
        /**
         * Creates a new CDOTAUserMsg_ItemSold instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_ItemSold
         * @static
         * @param {ICDOTAUserMsg_ItemSold=} [properties] Properties to set
         * @returns {CDOTAUserMsg_ItemSold} CDOTAUserMsg_ItemSold instance
         */
        CDOTAUserMsg_ItemSold.create = function create(properties) {
            return new CDOTAUserMsg_ItemSold(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ItemSold message. Does not implicitly {@link CDOTAUserMsg_ItemSold.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_ItemSold
         * @static
         * @param {ICDOTAUserMsg_ItemSold} message CDOTAUserMsg_ItemSold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ItemSold.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item_ability_id != null && Object.hasOwnProperty.call(message, "item_ability_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.item_ability_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ItemSold message, length delimited. Does not implicitly {@link CDOTAUserMsg_ItemSold.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_ItemSold
         * @static
         * @param {ICDOTAUserMsg_ItemSold} message CDOTAUserMsg_ItemSold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ItemSold.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_ItemSold message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_ItemSold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_ItemSold} CDOTAUserMsg_ItemSold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ItemSold.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_ItemSold();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item_ability_id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_ItemSold message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_ItemSold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_ItemSold} CDOTAUserMsg_ItemSold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ItemSold.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_ItemSold message.
         * @function verify
         * @memberof CDOTAUserMsg_ItemSold
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_ItemSold.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                if (!$util.isInteger(message.item_ability_id))
                    return "item_ability_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_ItemSold message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_ItemSold
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_ItemSold} CDOTAUserMsg_ItemSold
         */
        CDOTAUserMsg_ItemSold.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_ItemSold)
                return object;
            var message = new $root.CDOTAUserMsg_ItemSold();
            if (object.item_ability_id != null)
                message.item_ability_id = object.item_ability_id | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_ItemSold message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_ItemSold
         * @static
         * @param {CDOTAUserMsg_ItemSold} message CDOTAUserMsg_ItemSold
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_ItemSold.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.item_ability_id = 0;
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                object.item_ability_id = message.item_ability_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_ItemSold to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_ItemSold
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_ItemSold.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_ItemSold;
    })();
    
    $root.CDOTAUserMsg_ItemFound = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_ItemFound.
         * @exports ICDOTAUserMsg_ItemFound
         * @interface ICDOTAUserMsg_ItemFound
         * @property {number|null} [player] CDOTAUserMsg_ItemFound player
         * @property {number|null} [quality] CDOTAUserMsg_ItemFound quality
         * @property {number|null} [rarity] CDOTAUserMsg_ItemFound rarity
         * @property {number|null} [method] CDOTAUserMsg_ItemFound method
         * @property {number|null} [itemdef] CDOTAUserMsg_ItemFound itemdef
         */
    
        /**
         * Constructs a new CDOTAUserMsg_ItemFound.
         * @exports CDOTAUserMsg_ItemFound
         * @classdesc Represents a CDOTAUserMsg_ItemFound.
         * @implements ICDOTAUserMsg_ItemFound
         * @constructor
         * @param {ICDOTAUserMsg_ItemFound=} [properties] Properties to set
         */
        function CDOTAUserMsg_ItemFound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_ItemFound player.
         * @member {number} player
         * @memberof CDOTAUserMsg_ItemFound
         * @instance
         */
        CDOTAUserMsg_ItemFound.prototype.player = 0;
    
        /**
         * CDOTAUserMsg_ItemFound quality.
         * @member {number} quality
         * @memberof CDOTAUserMsg_ItemFound
         * @instance
         */
        CDOTAUserMsg_ItemFound.prototype.quality = 0;
    
        /**
         * CDOTAUserMsg_ItemFound rarity.
         * @member {number} rarity
         * @memberof CDOTAUserMsg_ItemFound
         * @instance
         */
        CDOTAUserMsg_ItemFound.prototype.rarity = 0;
    
        /**
         * CDOTAUserMsg_ItemFound method.
         * @member {number} method
         * @memberof CDOTAUserMsg_ItemFound
         * @instance
         */
        CDOTAUserMsg_ItemFound.prototype.method = 0;
    
        /**
         * CDOTAUserMsg_ItemFound itemdef.
         * @member {number} itemdef
         * @memberof CDOTAUserMsg_ItemFound
         * @instance
         */
        CDOTAUserMsg_ItemFound.prototype.itemdef = 0;
    
        /**
         * Creates a new CDOTAUserMsg_ItemFound instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_ItemFound
         * @static
         * @param {ICDOTAUserMsg_ItemFound=} [properties] Properties to set
         * @returns {CDOTAUserMsg_ItemFound} CDOTAUserMsg_ItemFound instance
         */
        CDOTAUserMsg_ItemFound.create = function create(properties) {
            return new CDOTAUserMsg_ItemFound(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ItemFound message. Does not implicitly {@link CDOTAUserMsg_ItemFound.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_ItemFound
         * @static
         * @param {ICDOTAUserMsg_ItemFound} message CDOTAUserMsg_ItemFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ItemFound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player != null && Object.hasOwnProperty.call(message, "player"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.player);
            if (message.quality != null && Object.hasOwnProperty.call(message, "quality"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.quality);
            if (message.rarity != null && Object.hasOwnProperty.call(message, "rarity"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.rarity);
            if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.method);
            if (message.itemdef != null && Object.hasOwnProperty.call(message, "itemdef"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.itemdef);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ItemFound message, length delimited. Does not implicitly {@link CDOTAUserMsg_ItemFound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_ItemFound
         * @static
         * @param {ICDOTAUserMsg_ItemFound} message CDOTAUserMsg_ItemFound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ItemFound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_ItemFound message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_ItemFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_ItemFound} CDOTAUserMsg_ItemFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ItemFound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_ItemFound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player = reader.int32();
                    break;
                case 2:
                    message.quality = reader.int32();
                    break;
                case 3:
                    message.rarity = reader.int32();
                    break;
                case 4:
                    message.method = reader.int32();
                    break;
                case 5:
                    message.itemdef = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_ItemFound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_ItemFound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_ItemFound} CDOTAUserMsg_ItemFound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ItemFound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_ItemFound message.
         * @function verify
         * @memberof CDOTAUserMsg_ItemFound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_ItemFound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player != null && message.hasOwnProperty("player"))
                if (!$util.isInteger(message.player))
                    return "player: integer expected";
            if (message.quality != null && message.hasOwnProperty("quality"))
                if (!$util.isInteger(message.quality))
                    return "quality: integer expected";
            if (message.rarity != null && message.hasOwnProperty("rarity"))
                if (!$util.isInteger(message.rarity))
                    return "rarity: integer expected";
            if (message.method != null && message.hasOwnProperty("method"))
                if (!$util.isInteger(message.method))
                    return "method: integer expected";
            if (message.itemdef != null && message.hasOwnProperty("itemdef"))
                if (!$util.isInteger(message.itemdef))
                    return "itemdef: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_ItemFound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_ItemFound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_ItemFound} CDOTAUserMsg_ItemFound
         */
        CDOTAUserMsg_ItemFound.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_ItemFound)
                return object;
            var message = new $root.CDOTAUserMsg_ItemFound();
            if (object.player != null)
                message.player = object.player | 0;
            if (object.quality != null)
                message.quality = object.quality | 0;
            if (object.rarity != null)
                message.rarity = object.rarity | 0;
            if (object.method != null)
                message.method = object.method | 0;
            if (object.itemdef != null)
                message.itemdef = object.itemdef | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_ItemFound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_ItemFound
         * @static
         * @param {CDOTAUserMsg_ItemFound} message CDOTAUserMsg_ItemFound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_ItemFound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player = 0;
                object.quality = 0;
                object.rarity = 0;
                object.method = 0;
                object.itemdef = 0;
            }
            if (message.player != null && message.hasOwnProperty("player"))
                object.player = message.player;
            if (message.quality != null && message.hasOwnProperty("quality"))
                object.quality = message.quality;
            if (message.rarity != null && message.hasOwnProperty("rarity"))
                object.rarity = message.rarity;
            if (message.method != null && message.hasOwnProperty("method"))
                object.method = message.method;
            if (message.itemdef != null && message.hasOwnProperty("itemdef"))
                object.itemdef = message.itemdef;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_ItemFound to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_ItemFound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_ItemFound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_ItemFound;
    })();
    
    $root.CDOTAUserMsg_OverheadEvent = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_OverheadEvent.
         * @exports ICDOTAUserMsg_OverheadEvent
         * @interface ICDOTAUserMsg_OverheadEvent
         * @property {DOTA_OVERHEAD_ALERT} message_type CDOTAUserMsg_OverheadEvent message_type
         * @property {number|null} [value] CDOTAUserMsg_OverheadEvent value
         * @property {number|null} [target_player_entindex] CDOTAUserMsg_OverheadEvent target_player_entindex
         * @property {number|null} [target_entindex] CDOTAUserMsg_OverheadEvent target_entindex
         * @property {number|null} [source_player_entindex] CDOTAUserMsg_OverheadEvent source_player_entindex
         */
    
        /**
         * Constructs a new CDOTAUserMsg_OverheadEvent.
         * @exports CDOTAUserMsg_OverheadEvent
         * @classdesc Represents a CDOTAUserMsg_OverheadEvent.
         * @implements ICDOTAUserMsg_OverheadEvent
         * @constructor
         * @param {ICDOTAUserMsg_OverheadEvent=} [properties] Properties to set
         */
        function CDOTAUserMsg_OverheadEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_OverheadEvent message_type.
         * @member {DOTA_OVERHEAD_ALERT} message_type
         * @memberof CDOTAUserMsg_OverheadEvent
         * @instance
         */
        CDOTAUserMsg_OverheadEvent.prototype.message_type = 0;
    
        /**
         * CDOTAUserMsg_OverheadEvent value.
         * @member {number} value
         * @memberof CDOTAUserMsg_OverheadEvent
         * @instance
         */
        CDOTAUserMsg_OverheadEvent.prototype.value = 0;
    
        /**
         * CDOTAUserMsg_OverheadEvent target_player_entindex.
         * @member {number} target_player_entindex
         * @memberof CDOTAUserMsg_OverheadEvent
         * @instance
         */
        CDOTAUserMsg_OverheadEvent.prototype.target_player_entindex = 0;
    
        /**
         * CDOTAUserMsg_OverheadEvent target_entindex.
         * @member {number} target_entindex
         * @memberof CDOTAUserMsg_OverheadEvent
         * @instance
         */
        CDOTAUserMsg_OverheadEvent.prototype.target_entindex = 0;
    
        /**
         * CDOTAUserMsg_OverheadEvent source_player_entindex.
         * @member {number} source_player_entindex
         * @memberof CDOTAUserMsg_OverheadEvent
         * @instance
         */
        CDOTAUserMsg_OverheadEvent.prototype.source_player_entindex = 0;
    
        /**
         * Creates a new CDOTAUserMsg_OverheadEvent instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_OverheadEvent
         * @static
         * @param {ICDOTAUserMsg_OverheadEvent=} [properties] Properties to set
         * @returns {CDOTAUserMsg_OverheadEvent} CDOTAUserMsg_OverheadEvent instance
         */
        CDOTAUserMsg_OverheadEvent.create = function create(properties) {
            return new CDOTAUserMsg_OverheadEvent(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_OverheadEvent message. Does not implicitly {@link CDOTAUserMsg_OverheadEvent.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_OverheadEvent
         * @static
         * @param {ICDOTAUserMsg_OverheadEvent} message CDOTAUserMsg_OverheadEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_OverheadEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.message_type);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.value);
            if (message.target_player_entindex != null && Object.hasOwnProperty.call(message, "target_player_entindex"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.target_player_entindex);
            if (message.target_entindex != null && Object.hasOwnProperty.call(message, "target_entindex"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.target_entindex);
            if (message.source_player_entindex != null && Object.hasOwnProperty.call(message, "source_player_entindex"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.source_player_entindex);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_OverheadEvent message, length delimited. Does not implicitly {@link CDOTAUserMsg_OverheadEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_OverheadEvent
         * @static
         * @param {ICDOTAUserMsg_OverheadEvent} message CDOTAUserMsg_OverheadEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_OverheadEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_OverheadEvent message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_OverheadEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_OverheadEvent} CDOTAUserMsg_OverheadEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_OverheadEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_OverheadEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.message_type = reader.int32();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                case 3:
                    message.target_player_entindex = reader.int32();
                    break;
                case 4:
                    message.target_entindex = reader.int32();
                    break;
                case 5:
                    message.source_player_entindex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("message_type"))
                throw $util.ProtocolError("missing required 'message_type'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_OverheadEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_OverheadEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_OverheadEvent} CDOTAUserMsg_OverheadEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_OverheadEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_OverheadEvent message.
         * @function verify
         * @memberof CDOTAUserMsg_OverheadEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_OverheadEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.message_type) {
            default:
                return "message_type: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
                break;
            }
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value))
                    return "value: integer expected";
            if (message.target_player_entindex != null && message.hasOwnProperty("target_player_entindex"))
                if (!$util.isInteger(message.target_player_entindex))
                    return "target_player_entindex: integer expected";
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                if (!$util.isInteger(message.target_entindex))
                    return "target_entindex: integer expected";
            if (message.source_player_entindex != null && message.hasOwnProperty("source_player_entindex"))
                if (!$util.isInteger(message.source_player_entindex))
                    return "source_player_entindex: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_OverheadEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_OverheadEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_OverheadEvent} CDOTAUserMsg_OverheadEvent
         */
        CDOTAUserMsg_OverheadEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_OverheadEvent)
                return object;
            var message = new $root.CDOTAUserMsg_OverheadEvent();
            switch (object.message_type) {
            case "OVERHEAD_ALERT_GOLD":
            case 0:
                message.message_type = 0;
                break;
            case "OVERHEAD_ALERT_DENY":
            case 1:
                message.message_type = 1;
                break;
            case "OVERHEAD_ALERT_CRITICAL":
            case 2:
                message.message_type = 2;
                break;
            case "OVERHEAD_ALERT_XP":
            case 3:
                message.message_type = 3;
                break;
            case "OVERHEAD_ALERT_BONUS_SPELL_DAMAGE":
            case 4:
                message.message_type = 4;
                break;
            case "OVERHEAD_ALERT_MISS":
            case 5:
                message.message_type = 5;
                break;
            case "OVERHEAD_ALERT_DAMAGE":
            case 6:
                message.message_type = 6;
                break;
            case "OVERHEAD_ALERT_EVADE":
            case 7:
                message.message_type = 7;
                break;
            case "OVERHEAD_ALERT_BLOCK":
            case 8:
                message.message_type = 8;
                break;
            case "OVERHEAD_ALERT_BONUS_POISON_DAMAGE":
            case 9:
                message.message_type = 9;
                break;
            case "OVERHEAD_ALERT_HEAL":
            case 10:
                message.message_type = 10;
                break;
            case "OVERHEAD_ALERT_MANA_ADD":
            case 11:
                message.message_type = 11;
                break;
            case "OVERHEAD_ALERT_MANA_LOSS":
            case 12:
                message.message_type = 12;
                break;
            case "OVERHEAD_ALERT_LAST_HIT_EARLY":
            case 13:
                message.message_type = 13;
                break;
            case "OVERHEAD_ALERT_LAST_HIT_CLOSE":
            case 14:
                message.message_type = 14;
                break;
            case "OVERHEAD_ALERT_LAST_HIT_MISS":
            case 15:
                message.message_type = 15;
                break;
            case "OVERHEAD_ALERT_MAGICAL_BLOCK":
            case 16:
                message.message_type = 16;
                break;
            case "OVERHEAD_ALERT_INCOMING_DAMAGE":
            case 17:
                message.message_type = 17;
                break;
            case "OVERHEAD_ALERT_OUTGOING_DAMAGE":
            case 18:
                message.message_type = 18;
                break;
            case "OVERHEAD_ALERT_DISABLE_RESIST":
            case 19:
                message.message_type = 19;
                break;
            case "OVERHEAD_ALERT_DEATH":
            case 20:
                message.message_type = 20;
                break;
            case "OVERHEAD_ALERT_BLOCKED":
            case 21:
                message.message_type = 21;
                break;
            case "OVERHEAD_ALERT_ITEM_RECEIVED":
            case 22:
                message.message_type = 22;
                break;
            }
            if (object.value != null)
                message.value = object.value | 0;
            if (object.target_player_entindex != null)
                message.target_player_entindex = object.target_player_entindex | 0;
            if (object.target_entindex != null)
                message.target_entindex = object.target_entindex | 0;
            if (object.source_player_entindex != null)
                message.source_player_entindex = object.source_player_entindex | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_OverheadEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_OverheadEvent
         * @static
         * @param {CDOTAUserMsg_OverheadEvent} message CDOTAUserMsg_OverheadEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_OverheadEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.message_type = options.enums === String ? "OVERHEAD_ALERT_GOLD" : 0;
                object.value = 0;
                object.target_player_entindex = 0;
                object.target_entindex = 0;
                object.source_player_entindex = 0;
            }
            if (message.message_type != null && message.hasOwnProperty("message_type"))
                object.message_type = options.enums === String ? $root.DOTA_OVERHEAD_ALERT[message.message_type] : message.message_type;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.target_player_entindex != null && message.hasOwnProperty("target_player_entindex"))
                object.target_player_entindex = message.target_player_entindex;
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                object.target_entindex = message.target_entindex;
            if (message.source_player_entindex != null && message.hasOwnProperty("source_player_entindex"))
                object.source_player_entindex = message.source_player_entindex;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_OverheadEvent to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_OverheadEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_OverheadEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_OverheadEvent;
    })();
    
    $root.CDOTAUserMsg_TutorialTipInfo = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_TutorialTipInfo.
         * @exports ICDOTAUserMsg_TutorialTipInfo
         * @interface ICDOTAUserMsg_TutorialTipInfo
         * @property {string|null} [name] CDOTAUserMsg_TutorialTipInfo name
         * @property {number|null} [progress] CDOTAUserMsg_TutorialTipInfo progress
         */
    
        /**
         * Constructs a new CDOTAUserMsg_TutorialTipInfo.
         * @exports CDOTAUserMsg_TutorialTipInfo
         * @classdesc Represents a CDOTAUserMsg_TutorialTipInfo.
         * @implements ICDOTAUserMsg_TutorialTipInfo
         * @constructor
         * @param {ICDOTAUserMsg_TutorialTipInfo=} [properties] Properties to set
         */
        function CDOTAUserMsg_TutorialTipInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_TutorialTipInfo name.
         * @member {string} name
         * @memberof CDOTAUserMsg_TutorialTipInfo
         * @instance
         */
        CDOTAUserMsg_TutorialTipInfo.prototype.name = "";
    
        /**
         * CDOTAUserMsg_TutorialTipInfo progress.
         * @member {number} progress
         * @memberof CDOTAUserMsg_TutorialTipInfo
         * @instance
         */
        CDOTAUserMsg_TutorialTipInfo.prototype.progress = 0;
    
        /**
         * Creates a new CDOTAUserMsg_TutorialTipInfo instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_TutorialTipInfo
         * @static
         * @param {ICDOTAUserMsg_TutorialTipInfo=} [properties] Properties to set
         * @returns {CDOTAUserMsg_TutorialTipInfo} CDOTAUserMsg_TutorialTipInfo instance
         */
        CDOTAUserMsg_TutorialTipInfo.create = function create(properties) {
            return new CDOTAUserMsg_TutorialTipInfo(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TutorialTipInfo message. Does not implicitly {@link CDOTAUserMsg_TutorialTipInfo.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_TutorialTipInfo
         * @static
         * @param {ICDOTAUserMsg_TutorialTipInfo} message CDOTAUserMsg_TutorialTipInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TutorialTipInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.progress != null && Object.hasOwnProperty.call(message, "progress"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.progress);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TutorialTipInfo message, length delimited. Does not implicitly {@link CDOTAUserMsg_TutorialTipInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_TutorialTipInfo
         * @static
         * @param {ICDOTAUserMsg_TutorialTipInfo} message CDOTAUserMsg_TutorialTipInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TutorialTipInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_TutorialTipInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_TutorialTipInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_TutorialTipInfo} CDOTAUserMsg_TutorialTipInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TutorialTipInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_TutorialTipInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.progress = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_TutorialTipInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_TutorialTipInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_TutorialTipInfo} CDOTAUserMsg_TutorialTipInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TutorialTipInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_TutorialTipInfo message.
         * @function verify
         * @memberof CDOTAUserMsg_TutorialTipInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_TutorialTipInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.progress != null && message.hasOwnProperty("progress"))
                if (!$util.isInteger(message.progress))
                    return "progress: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_TutorialTipInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_TutorialTipInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_TutorialTipInfo} CDOTAUserMsg_TutorialTipInfo
         */
        CDOTAUserMsg_TutorialTipInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_TutorialTipInfo)
                return object;
            var message = new $root.CDOTAUserMsg_TutorialTipInfo();
            if (object.name != null)
                message.name = String(object.name);
            if (object.progress != null)
                message.progress = object.progress | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_TutorialTipInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_TutorialTipInfo
         * @static
         * @param {CDOTAUserMsg_TutorialTipInfo} message CDOTAUserMsg_TutorialTipInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_TutorialTipInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.progress = 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.progress != null && message.hasOwnProperty("progress"))
                object.progress = message.progress;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_TutorialTipInfo to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_TutorialTipInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_TutorialTipInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_TutorialTipInfo;
    })();
    
    $root.CDOTAUserMsg_TutorialFinish = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_TutorialFinish.
         * @exports ICDOTAUserMsg_TutorialFinish
         * @interface ICDOTAUserMsg_TutorialFinish
         * @property {string|null} [heading] CDOTAUserMsg_TutorialFinish heading
         * @property {string|null} [emblem] CDOTAUserMsg_TutorialFinish emblem
         * @property {string|null} [body] CDOTAUserMsg_TutorialFinish body
         * @property {boolean|null} [success] CDOTAUserMsg_TutorialFinish success
         */
    
        /**
         * Constructs a new CDOTAUserMsg_TutorialFinish.
         * @exports CDOTAUserMsg_TutorialFinish
         * @classdesc Represents a CDOTAUserMsg_TutorialFinish.
         * @implements ICDOTAUserMsg_TutorialFinish
         * @constructor
         * @param {ICDOTAUserMsg_TutorialFinish=} [properties] Properties to set
         */
        function CDOTAUserMsg_TutorialFinish(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_TutorialFinish heading.
         * @member {string} heading
         * @memberof CDOTAUserMsg_TutorialFinish
         * @instance
         */
        CDOTAUserMsg_TutorialFinish.prototype.heading = "";
    
        /**
         * CDOTAUserMsg_TutorialFinish emblem.
         * @member {string} emblem
         * @memberof CDOTAUserMsg_TutorialFinish
         * @instance
         */
        CDOTAUserMsg_TutorialFinish.prototype.emblem = "";
    
        /**
         * CDOTAUserMsg_TutorialFinish body.
         * @member {string} body
         * @memberof CDOTAUserMsg_TutorialFinish
         * @instance
         */
        CDOTAUserMsg_TutorialFinish.prototype.body = "";
    
        /**
         * CDOTAUserMsg_TutorialFinish success.
         * @member {boolean} success
         * @memberof CDOTAUserMsg_TutorialFinish
         * @instance
         */
        CDOTAUserMsg_TutorialFinish.prototype.success = false;
    
        /**
         * Creates a new CDOTAUserMsg_TutorialFinish instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_TutorialFinish
         * @static
         * @param {ICDOTAUserMsg_TutorialFinish=} [properties] Properties to set
         * @returns {CDOTAUserMsg_TutorialFinish} CDOTAUserMsg_TutorialFinish instance
         */
        CDOTAUserMsg_TutorialFinish.create = function create(properties) {
            return new CDOTAUserMsg_TutorialFinish(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TutorialFinish message. Does not implicitly {@link CDOTAUserMsg_TutorialFinish.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_TutorialFinish
         * @static
         * @param {ICDOTAUserMsg_TutorialFinish} message CDOTAUserMsg_TutorialFinish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TutorialFinish.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heading != null && Object.hasOwnProperty.call(message, "heading"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.heading);
            if (message.emblem != null && Object.hasOwnProperty.call(message, "emblem"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.emblem);
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.body);
            if (message.success != null && Object.hasOwnProperty.call(message, "success"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.success);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TutorialFinish message, length delimited. Does not implicitly {@link CDOTAUserMsg_TutorialFinish.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_TutorialFinish
         * @static
         * @param {ICDOTAUserMsg_TutorialFinish} message CDOTAUserMsg_TutorialFinish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TutorialFinish.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_TutorialFinish message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_TutorialFinish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_TutorialFinish} CDOTAUserMsg_TutorialFinish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TutorialFinish.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_TutorialFinish();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.heading = reader.string();
                    break;
                case 2:
                    message.emblem = reader.string();
                    break;
                case 3:
                    message.body = reader.string();
                    break;
                case 4:
                    message.success = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_TutorialFinish message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_TutorialFinish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_TutorialFinish} CDOTAUserMsg_TutorialFinish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TutorialFinish.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_TutorialFinish message.
         * @function verify
         * @memberof CDOTAUserMsg_TutorialFinish
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_TutorialFinish.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heading != null && message.hasOwnProperty("heading"))
                if (!$util.isString(message.heading))
                    return "heading: string expected";
            if (message.emblem != null && message.hasOwnProperty("emblem"))
                if (!$util.isString(message.emblem))
                    return "emblem: string expected";
            if (message.body != null && message.hasOwnProperty("body"))
                if (!$util.isString(message.body))
                    return "body: string expected";
            if (message.success != null && message.hasOwnProperty("success"))
                if (typeof message.success !== "boolean")
                    return "success: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_TutorialFinish message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_TutorialFinish
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_TutorialFinish} CDOTAUserMsg_TutorialFinish
         */
        CDOTAUserMsg_TutorialFinish.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_TutorialFinish)
                return object;
            var message = new $root.CDOTAUserMsg_TutorialFinish();
            if (object.heading != null)
                message.heading = String(object.heading);
            if (object.emblem != null)
                message.emblem = String(object.emblem);
            if (object.body != null)
                message.body = String(object.body);
            if (object.success != null)
                message.success = Boolean(object.success);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_TutorialFinish message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_TutorialFinish
         * @static
         * @param {CDOTAUserMsg_TutorialFinish} message CDOTAUserMsg_TutorialFinish
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_TutorialFinish.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.heading = "";
                object.emblem = "";
                object.body = "";
                object.success = false;
            }
            if (message.heading != null && message.hasOwnProperty("heading"))
                object.heading = message.heading;
            if (message.emblem != null && message.hasOwnProperty("emblem"))
                object.emblem = message.emblem;
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = message.body;
            if (message.success != null && message.hasOwnProperty("success"))
                object.success = message.success;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_TutorialFinish to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_TutorialFinish
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_TutorialFinish.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_TutorialFinish;
    })();
    
    $root.CDOTAUserMsg_TutorialMinimapPosition = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_TutorialMinimapPosition.
         * @exports ICDOTAUserMsg_TutorialMinimapPosition
         * @interface ICDOTAUserMsg_TutorialMinimapPosition
         */
    
        /**
         * Constructs a new CDOTAUserMsg_TutorialMinimapPosition.
         * @exports CDOTAUserMsg_TutorialMinimapPosition
         * @classdesc Represents a CDOTAUserMsg_TutorialMinimapPosition.
         * @implements ICDOTAUserMsg_TutorialMinimapPosition
         * @constructor
         * @param {ICDOTAUserMsg_TutorialMinimapPosition=} [properties] Properties to set
         */
        function CDOTAUserMsg_TutorialMinimapPosition(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CDOTAUserMsg_TutorialMinimapPosition instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_TutorialMinimapPosition
         * @static
         * @param {ICDOTAUserMsg_TutorialMinimapPosition=} [properties] Properties to set
         * @returns {CDOTAUserMsg_TutorialMinimapPosition} CDOTAUserMsg_TutorialMinimapPosition instance
         */
        CDOTAUserMsg_TutorialMinimapPosition.create = function create(properties) {
            return new CDOTAUserMsg_TutorialMinimapPosition(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TutorialMinimapPosition message. Does not implicitly {@link CDOTAUserMsg_TutorialMinimapPosition.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_TutorialMinimapPosition
         * @static
         * @param {ICDOTAUserMsg_TutorialMinimapPosition} message CDOTAUserMsg_TutorialMinimapPosition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TutorialMinimapPosition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TutorialMinimapPosition message, length delimited. Does not implicitly {@link CDOTAUserMsg_TutorialMinimapPosition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_TutorialMinimapPosition
         * @static
         * @param {ICDOTAUserMsg_TutorialMinimapPosition} message CDOTAUserMsg_TutorialMinimapPosition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TutorialMinimapPosition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_TutorialMinimapPosition message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_TutorialMinimapPosition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_TutorialMinimapPosition} CDOTAUserMsg_TutorialMinimapPosition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TutorialMinimapPosition.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_TutorialMinimapPosition();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_TutorialMinimapPosition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_TutorialMinimapPosition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_TutorialMinimapPosition} CDOTAUserMsg_TutorialMinimapPosition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TutorialMinimapPosition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_TutorialMinimapPosition message.
         * @function verify
         * @memberof CDOTAUserMsg_TutorialMinimapPosition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_TutorialMinimapPosition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_TutorialMinimapPosition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_TutorialMinimapPosition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_TutorialMinimapPosition} CDOTAUserMsg_TutorialMinimapPosition
         */
        CDOTAUserMsg_TutorialMinimapPosition.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_TutorialMinimapPosition)
                return object;
            return new $root.CDOTAUserMsg_TutorialMinimapPosition();
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_TutorialMinimapPosition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_TutorialMinimapPosition
         * @static
         * @param {CDOTAUserMsg_TutorialMinimapPosition} message CDOTAUserMsg_TutorialMinimapPosition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_TutorialMinimapPosition.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CDOTAUserMsg_TutorialMinimapPosition to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_TutorialMinimapPosition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_TutorialMinimapPosition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_TutorialMinimapPosition;
    })();
    
    $root.CDOTAUserMsg_SendGenericToolTip = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_SendGenericToolTip.
         * @exports ICDOTAUserMsg_SendGenericToolTip
         * @interface ICDOTAUserMsg_SendGenericToolTip
         * @property {string|null} [title] CDOTAUserMsg_SendGenericToolTip title
         * @property {string|null} [text] CDOTAUserMsg_SendGenericToolTip text
         * @property {number|null} [entindex] CDOTAUserMsg_SendGenericToolTip entindex
         * @property {boolean|null} [close] CDOTAUserMsg_SendGenericToolTip close
         */
    
        /**
         * Constructs a new CDOTAUserMsg_SendGenericToolTip.
         * @exports CDOTAUserMsg_SendGenericToolTip
         * @classdesc Represents a CDOTAUserMsg_SendGenericToolTip.
         * @implements ICDOTAUserMsg_SendGenericToolTip
         * @constructor
         * @param {ICDOTAUserMsg_SendGenericToolTip=} [properties] Properties to set
         */
        function CDOTAUserMsg_SendGenericToolTip(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_SendGenericToolTip title.
         * @member {string} title
         * @memberof CDOTAUserMsg_SendGenericToolTip
         * @instance
         */
        CDOTAUserMsg_SendGenericToolTip.prototype.title = "";
    
        /**
         * CDOTAUserMsg_SendGenericToolTip text.
         * @member {string} text
         * @memberof CDOTAUserMsg_SendGenericToolTip
         * @instance
         */
        CDOTAUserMsg_SendGenericToolTip.prototype.text = "";
    
        /**
         * CDOTAUserMsg_SendGenericToolTip entindex.
         * @member {number} entindex
         * @memberof CDOTAUserMsg_SendGenericToolTip
         * @instance
         */
        CDOTAUserMsg_SendGenericToolTip.prototype.entindex = 0;
    
        /**
         * CDOTAUserMsg_SendGenericToolTip close.
         * @member {boolean} close
         * @memberof CDOTAUserMsg_SendGenericToolTip
         * @instance
         */
        CDOTAUserMsg_SendGenericToolTip.prototype.close = false;
    
        /**
         * Creates a new CDOTAUserMsg_SendGenericToolTip instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_SendGenericToolTip
         * @static
         * @param {ICDOTAUserMsg_SendGenericToolTip=} [properties] Properties to set
         * @returns {CDOTAUserMsg_SendGenericToolTip} CDOTAUserMsg_SendGenericToolTip instance
         */
        CDOTAUserMsg_SendGenericToolTip.create = function create(properties) {
            return new CDOTAUserMsg_SendGenericToolTip(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SendGenericToolTip message. Does not implicitly {@link CDOTAUserMsg_SendGenericToolTip.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_SendGenericToolTip
         * @static
         * @param {ICDOTAUserMsg_SendGenericToolTip} message CDOTAUserMsg_SendGenericToolTip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SendGenericToolTip.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
            if (message.entindex != null && Object.hasOwnProperty.call(message, "entindex"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.entindex);
            if (message.close != null && Object.hasOwnProperty.call(message, "close"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.close);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SendGenericToolTip message, length delimited. Does not implicitly {@link CDOTAUserMsg_SendGenericToolTip.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_SendGenericToolTip
         * @static
         * @param {ICDOTAUserMsg_SendGenericToolTip} message CDOTAUserMsg_SendGenericToolTip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SendGenericToolTip.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_SendGenericToolTip message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_SendGenericToolTip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_SendGenericToolTip} CDOTAUserMsg_SendGenericToolTip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SendGenericToolTip.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_SendGenericToolTip();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.title = reader.string();
                    break;
                case 2:
                    message.text = reader.string();
                    break;
                case 3:
                    message.entindex = reader.int32();
                    break;
                case 4:
                    message.close = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_SendGenericToolTip message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_SendGenericToolTip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_SendGenericToolTip} CDOTAUserMsg_SendGenericToolTip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SendGenericToolTip.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_SendGenericToolTip message.
         * @function verify
         * @memberof CDOTAUserMsg_SendGenericToolTip
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_SendGenericToolTip.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.entindex != null && message.hasOwnProperty("entindex"))
                if (!$util.isInteger(message.entindex))
                    return "entindex: integer expected";
            if (message.close != null && message.hasOwnProperty("close"))
                if (typeof message.close !== "boolean")
                    return "close: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_SendGenericToolTip message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_SendGenericToolTip
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_SendGenericToolTip} CDOTAUserMsg_SendGenericToolTip
         */
        CDOTAUserMsg_SendGenericToolTip.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_SendGenericToolTip)
                return object;
            var message = new $root.CDOTAUserMsg_SendGenericToolTip();
            if (object.title != null)
                message.title = String(object.title);
            if (object.text != null)
                message.text = String(object.text);
            if (object.entindex != null)
                message.entindex = object.entindex | 0;
            if (object.close != null)
                message.close = Boolean(object.close);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_SendGenericToolTip message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_SendGenericToolTip
         * @static
         * @param {CDOTAUserMsg_SendGenericToolTip} message CDOTAUserMsg_SendGenericToolTip
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_SendGenericToolTip.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.title = "";
                object.text = "";
                object.entindex = 0;
                object.close = false;
            }
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.entindex != null && message.hasOwnProperty("entindex"))
                object.entindex = message.entindex;
            if (message.close != null && message.hasOwnProperty("close"))
                object.close = message.close;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_SendGenericToolTip to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_SendGenericToolTip
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_SendGenericToolTip.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_SendGenericToolTip;
    })();
    
    $root.CDOTAUserMsg_WorldLine = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_WorldLine.
         * @exports ICDOTAUserMsg_WorldLine
         * @interface ICDOTAUserMsg_WorldLine
         * @property {number|null} [player_id] CDOTAUserMsg_WorldLine player_id
         * @property {ICDOTAMsg_WorldLine|null} [worldline] CDOTAUserMsg_WorldLine worldline
         */
    
        /**
         * Constructs a new CDOTAUserMsg_WorldLine.
         * @exports CDOTAUserMsg_WorldLine
         * @classdesc Represents a CDOTAUserMsg_WorldLine.
         * @implements ICDOTAUserMsg_WorldLine
         * @constructor
         * @param {ICDOTAUserMsg_WorldLine=} [properties] Properties to set
         */
        function CDOTAUserMsg_WorldLine(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_WorldLine player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_WorldLine
         * @instance
         */
        CDOTAUserMsg_WorldLine.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_WorldLine worldline.
         * @member {ICDOTAMsg_WorldLine|null|undefined} worldline
         * @memberof CDOTAUserMsg_WorldLine
         * @instance
         */
        CDOTAUserMsg_WorldLine.prototype.worldline = null;
    
        /**
         * Creates a new CDOTAUserMsg_WorldLine instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_WorldLine
         * @static
         * @param {ICDOTAUserMsg_WorldLine=} [properties] Properties to set
         * @returns {CDOTAUserMsg_WorldLine} CDOTAUserMsg_WorldLine instance
         */
        CDOTAUserMsg_WorldLine.create = function create(properties) {
            return new CDOTAUserMsg_WorldLine(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_WorldLine message. Does not implicitly {@link CDOTAUserMsg_WorldLine.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_WorldLine
         * @static
         * @param {ICDOTAUserMsg_WorldLine} message CDOTAUserMsg_WorldLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_WorldLine.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.player_id);
            if (message.worldline != null && Object.hasOwnProperty.call(message, "worldline"))
                $root.CDOTAMsg_WorldLine.encode(message.worldline, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_WorldLine message, length delimited. Does not implicitly {@link CDOTAUserMsg_WorldLine.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_WorldLine
         * @static
         * @param {ICDOTAUserMsg_WorldLine} message CDOTAUserMsg_WorldLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_WorldLine.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_WorldLine message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_WorldLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_WorldLine} CDOTAUserMsg_WorldLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_WorldLine.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_WorldLine();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.int32();
                    break;
                case 2:
                    message.worldline = $root.CDOTAMsg_WorldLine.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_WorldLine message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_WorldLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_WorldLine} CDOTAUserMsg_WorldLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_WorldLine.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_WorldLine message.
         * @function verify
         * @memberof CDOTAUserMsg_WorldLine
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_WorldLine.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.worldline != null && message.hasOwnProperty("worldline")) {
                var error = $root.CDOTAMsg_WorldLine.verify(message.worldline);
                if (error)
                    return "worldline." + error;
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_WorldLine message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_WorldLine
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_WorldLine} CDOTAUserMsg_WorldLine
         */
        CDOTAUserMsg_WorldLine.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_WorldLine)
                return object;
            var message = new $root.CDOTAUserMsg_WorldLine();
            if (object.player_id != null)
                message.player_id = object.player_id | 0;
            if (object.worldline != null) {
                if (typeof object.worldline !== "object")
                    throw TypeError(".CDOTAUserMsg_WorldLine.worldline: object expected");
                message.worldline = $root.CDOTAMsg_WorldLine.fromObject(object.worldline);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_WorldLine message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_WorldLine
         * @static
         * @param {CDOTAUserMsg_WorldLine} message CDOTAUserMsg_WorldLine
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_WorldLine.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.worldline = null;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.worldline != null && message.hasOwnProperty("worldline"))
                object.worldline = $root.CDOTAMsg_WorldLine.toObject(message.worldline, options);
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_WorldLine to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_WorldLine
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_WorldLine.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_WorldLine;
    })();
    
    $root.CDOTAUserMsg_ChatWheel = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_ChatWheel.
         * @exports ICDOTAUserMsg_ChatWheel
         * @interface ICDOTAUserMsg_ChatWheel
         * @property {number|null} [chat_message_id] CDOTAUserMsg_ChatWheel chat_message_id
         * @property {number|null} [player_id] CDOTAUserMsg_ChatWheel player_id
         * @property {number|null} [account_id] CDOTAUserMsg_ChatWheel account_id
         * @property {number|null} [param_hero_id] CDOTAUserMsg_ChatWheel param_hero_id
         * @property {number|null} [emoticon_id] CDOTAUserMsg_ChatWheel emoticon_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_ChatWheel.
         * @exports CDOTAUserMsg_ChatWheel
         * @classdesc Represents a CDOTAUserMsg_ChatWheel.
         * @implements ICDOTAUserMsg_ChatWheel
         * @constructor
         * @param {ICDOTAUserMsg_ChatWheel=} [properties] Properties to set
         */
        function CDOTAUserMsg_ChatWheel(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_ChatWheel chat_message_id.
         * @member {number} chat_message_id
         * @memberof CDOTAUserMsg_ChatWheel
         * @instance
         */
        CDOTAUserMsg_ChatWheel.prototype.chat_message_id = 0;
    
        /**
         * CDOTAUserMsg_ChatWheel player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_ChatWheel
         * @instance
         */
        CDOTAUserMsg_ChatWheel.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_ChatWheel account_id.
         * @member {number} account_id
         * @memberof CDOTAUserMsg_ChatWheel
         * @instance
         */
        CDOTAUserMsg_ChatWheel.prototype.account_id = 0;
    
        /**
         * CDOTAUserMsg_ChatWheel param_hero_id.
         * @member {number} param_hero_id
         * @memberof CDOTAUserMsg_ChatWheel
         * @instance
         */
        CDOTAUserMsg_ChatWheel.prototype.param_hero_id = 0;
    
        /**
         * CDOTAUserMsg_ChatWheel emoticon_id.
         * @member {number} emoticon_id
         * @memberof CDOTAUserMsg_ChatWheel
         * @instance
         */
        CDOTAUserMsg_ChatWheel.prototype.emoticon_id = 0;
    
        /**
         * Creates a new CDOTAUserMsg_ChatWheel instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_ChatWheel
         * @static
         * @param {ICDOTAUserMsg_ChatWheel=} [properties] Properties to set
         * @returns {CDOTAUserMsg_ChatWheel} CDOTAUserMsg_ChatWheel instance
         */
        CDOTAUserMsg_ChatWheel.create = function create(properties) {
            return new CDOTAUserMsg_ChatWheel(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ChatWheel message. Does not implicitly {@link CDOTAUserMsg_ChatWheel.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_ChatWheel
         * @static
         * @param {ICDOTAUserMsg_ChatWheel} message CDOTAUserMsg_ChatWheel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ChatWheel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chat_message_id != null && Object.hasOwnProperty.call(message, "chat_message_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.chat_message_id);
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.player_id);
            if (message.account_id != null && Object.hasOwnProperty.call(message, "account_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.account_id);
            if (message.param_hero_id != null && Object.hasOwnProperty.call(message, "param_hero_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.param_hero_id);
            if (message.emoticon_id != null && Object.hasOwnProperty.call(message, "emoticon_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.emoticon_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ChatWheel message, length delimited. Does not implicitly {@link CDOTAUserMsg_ChatWheel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_ChatWheel
         * @static
         * @param {ICDOTAUserMsg_ChatWheel} message CDOTAUserMsg_ChatWheel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ChatWheel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_ChatWheel message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_ChatWheel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_ChatWheel} CDOTAUserMsg_ChatWheel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ChatWheel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_ChatWheel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chat_message_id = reader.uint32();
                    break;
                case 2:
                    message.player_id = reader.uint32();
                    break;
                case 3:
                    message.account_id = reader.uint32();
                    break;
                case 4:
                    message.param_hero_id = reader.uint32();
                    break;
                case 5:
                    message.emoticon_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_ChatWheel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_ChatWheel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_ChatWheel} CDOTAUserMsg_ChatWheel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ChatWheel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_ChatWheel message.
         * @function verify
         * @memberof CDOTAUserMsg_ChatWheel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_ChatWheel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chat_message_id != null && message.hasOwnProperty("chat_message_id"))
                if (!$util.isInteger(message.chat_message_id))
                    return "chat_message_id: integer expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.account_id != null && message.hasOwnProperty("account_id"))
                if (!$util.isInteger(message.account_id))
                    return "account_id: integer expected";
            if (message.param_hero_id != null && message.hasOwnProperty("param_hero_id"))
                if (!$util.isInteger(message.param_hero_id))
                    return "param_hero_id: integer expected";
            if (message.emoticon_id != null && message.hasOwnProperty("emoticon_id"))
                if (!$util.isInteger(message.emoticon_id))
                    return "emoticon_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_ChatWheel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_ChatWheel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_ChatWheel} CDOTAUserMsg_ChatWheel
         */
        CDOTAUserMsg_ChatWheel.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_ChatWheel)
                return object;
            var message = new $root.CDOTAUserMsg_ChatWheel();
            if (object.chat_message_id != null)
                message.chat_message_id = object.chat_message_id >>> 0;
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.account_id != null)
                message.account_id = object.account_id >>> 0;
            if (object.param_hero_id != null)
                message.param_hero_id = object.param_hero_id >>> 0;
            if (object.emoticon_id != null)
                message.emoticon_id = object.emoticon_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_ChatWheel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_ChatWheel
         * @static
         * @param {CDOTAUserMsg_ChatWheel} message CDOTAUserMsg_ChatWheel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_ChatWheel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.chat_message_id = 0;
                object.player_id = 0;
                object.account_id = 0;
                object.param_hero_id = 0;
                object.emoticon_id = 0;
            }
            if (message.chat_message_id != null && message.hasOwnProperty("chat_message_id"))
                object.chat_message_id = message.chat_message_id;
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.account_id != null && message.hasOwnProperty("account_id"))
                object.account_id = message.account_id;
            if (message.param_hero_id != null && message.hasOwnProperty("param_hero_id"))
                object.param_hero_id = message.param_hero_id;
            if (message.emoticon_id != null && message.hasOwnProperty("emoticon_id"))
                object.emoticon_id = message.emoticon_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_ChatWheel to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_ChatWheel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_ChatWheel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_ChatWheel;
    })();
    
    $root.CDOTAUserMsg_ReceivedXmasGift = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_ReceivedXmasGift.
         * @exports ICDOTAUserMsg_ReceivedXmasGift
         * @interface ICDOTAUserMsg_ReceivedXmasGift
         * @property {number|null} [player_id] CDOTAUserMsg_ReceivedXmasGift player_id
         * @property {string|null} [item_name] CDOTAUserMsg_ReceivedXmasGift item_name
         * @property {number|null} [inventory_slot] CDOTAUserMsg_ReceivedXmasGift inventory_slot
         */
    
        /**
         * Constructs a new CDOTAUserMsg_ReceivedXmasGift.
         * @exports CDOTAUserMsg_ReceivedXmasGift
         * @classdesc Represents a CDOTAUserMsg_ReceivedXmasGift.
         * @implements ICDOTAUserMsg_ReceivedXmasGift
         * @constructor
         * @param {ICDOTAUserMsg_ReceivedXmasGift=} [properties] Properties to set
         */
        function CDOTAUserMsg_ReceivedXmasGift(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_ReceivedXmasGift player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_ReceivedXmasGift
         * @instance
         */
        CDOTAUserMsg_ReceivedXmasGift.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_ReceivedXmasGift item_name.
         * @member {string} item_name
         * @memberof CDOTAUserMsg_ReceivedXmasGift
         * @instance
         */
        CDOTAUserMsg_ReceivedXmasGift.prototype.item_name = "";
    
        /**
         * CDOTAUserMsg_ReceivedXmasGift inventory_slot.
         * @member {number} inventory_slot
         * @memberof CDOTAUserMsg_ReceivedXmasGift
         * @instance
         */
        CDOTAUserMsg_ReceivedXmasGift.prototype.inventory_slot = 0;
    
        /**
         * Creates a new CDOTAUserMsg_ReceivedXmasGift instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_ReceivedXmasGift
         * @static
         * @param {ICDOTAUserMsg_ReceivedXmasGift=} [properties] Properties to set
         * @returns {CDOTAUserMsg_ReceivedXmasGift} CDOTAUserMsg_ReceivedXmasGift instance
         */
        CDOTAUserMsg_ReceivedXmasGift.create = function create(properties) {
            return new CDOTAUserMsg_ReceivedXmasGift(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ReceivedXmasGift message. Does not implicitly {@link CDOTAUserMsg_ReceivedXmasGift.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_ReceivedXmasGift
         * @static
         * @param {ICDOTAUserMsg_ReceivedXmasGift} message CDOTAUserMsg_ReceivedXmasGift message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ReceivedXmasGift.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.player_id);
            if (message.item_name != null && Object.hasOwnProperty.call(message, "item_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.item_name);
            if (message.inventory_slot != null && Object.hasOwnProperty.call(message, "inventory_slot"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.inventory_slot);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ReceivedXmasGift message, length delimited. Does not implicitly {@link CDOTAUserMsg_ReceivedXmasGift.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_ReceivedXmasGift
         * @static
         * @param {ICDOTAUserMsg_ReceivedXmasGift} message CDOTAUserMsg_ReceivedXmasGift message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ReceivedXmasGift.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_ReceivedXmasGift message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_ReceivedXmasGift
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_ReceivedXmasGift} CDOTAUserMsg_ReceivedXmasGift
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ReceivedXmasGift.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_ReceivedXmasGift();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.int32();
                    break;
                case 2:
                    message.item_name = reader.string();
                    break;
                case 3:
                    message.inventory_slot = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_ReceivedXmasGift message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_ReceivedXmasGift
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_ReceivedXmasGift} CDOTAUserMsg_ReceivedXmasGift
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ReceivedXmasGift.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_ReceivedXmasGift message.
         * @function verify
         * @memberof CDOTAUserMsg_ReceivedXmasGift
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_ReceivedXmasGift.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.item_name != null && message.hasOwnProperty("item_name"))
                if (!$util.isString(message.item_name))
                    return "item_name: string expected";
            if (message.inventory_slot != null && message.hasOwnProperty("inventory_slot"))
                if (!$util.isInteger(message.inventory_slot))
                    return "inventory_slot: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_ReceivedXmasGift message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_ReceivedXmasGift
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_ReceivedXmasGift} CDOTAUserMsg_ReceivedXmasGift
         */
        CDOTAUserMsg_ReceivedXmasGift.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_ReceivedXmasGift)
                return object;
            var message = new $root.CDOTAUserMsg_ReceivedXmasGift();
            if (object.player_id != null)
                message.player_id = object.player_id | 0;
            if (object.item_name != null)
                message.item_name = String(object.item_name);
            if (object.inventory_slot != null)
                message.inventory_slot = object.inventory_slot | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_ReceivedXmasGift message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_ReceivedXmasGift
         * @static
         * @param {CDOTAUserMsg_ReceivedXmasGift} message CDOTAUserMsg_ReceivedXmasGift
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_ReceivedXmasGift.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.item_name = "";
                object.inventory_slot = 0;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.item_name != null && message.hasOwnProperty("item_name"))
                object.item_name = message.item_name;
            if (message.inventory_slot != null && message.hasOwnProperty("inventory_slot"))
                object.inventory_slot = message.inventory_slot;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_ReceivedXmasGift to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_ReceivedXmasGift
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_ReceivedXmasGift.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_ReceivedXmasGift;
    })();
    
    $root.CDOTAUserMsg_ShowSurvey = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_ShowSurvey.
         * @exports ICDOTAUserMsg_ShowSurvey
         * @interface ICDOTAUserMsg_ShowSurvey
         * @property {number|null} [survey_id] CDOTAUserMsg_ShowSurvey survey_id
         * @property {number|Long|null} [match_id] CDOTAUserMsg_ShowSurvey match_id
         * @property {string|null} [response_style] CDOTAUserMsg_ShowSurvey response_style
         * @property {number|null} [teammate_hero_id] CDOTAUserMsg_ShowSurvey teammate_hero_id
         * @property {string|null} [teammate_name] CDOTAUserMsg_ShowSurvey teammate_name
         * @property {number|null} [teammate_account_id] CDOTAUserMsg_ShowSurvey teammate_account_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_ShowSurvey.
         * @exports CDOTAUserMsg_ShowSurvey
         * @classdesc Represents a CDOTAUserMsg_ShowSurvey.
         * @implements ICDOTAUserMsg_ShowSurvey
         * @constructor
         * @param {ICDOTAUserMsg_ShowSurvey=} [properties] Properties to set
         */
        function CDOTAUserMsg_ShowSurvey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_ShowSurvey survey_id.
         * @member {number} survey_id
         * @memberof CDOTAUserMsg_ShowSurvey
         * @instance
         */
        CDOTAUserMsg_ShowSurvey.prototype.survey_id = 0;
    
        /**
         * CDOTAUserMsg_ShowSurvey match_id.
         * @member {number|Long} match_id
         * @memberof CDOTAUserMsg_ShowSurvey
         * @instance
         */
        CDOTAUserMsg_ShowSurvey.prototype.match_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CDOTAUserMsg_ShowSurvey response_style.
         * @member {string} response_style
         * @memberof CDOTAUserMsg_ShowSurvey
         * @instance
         */
        CDOTAUserMsg_ShowSurvey.prototype.response_style = "";
    
        /**
         * CDOTAUserMsg_ShowSurvey teammate_hero_id.
         * @member {number} teammate_hero_id
         * @memberof CDOTAUserMsg_ShowSurvey
         * @instance
         */
        CDOTAUserMsg_ShowSurvey.prototype.teammate_hero_id = 0;
    
        /**
         * CDOTAUserMsg_ShowSurvey teammate_name.
         * @member {string} teammate_name
         * @memberof CDOTAUserMsg_ShowSurvey
         * @instance
         */
        CDOTAUserMsg_ShowSurvey.prototype.teammate_name = "";
    
        /**
         * CDOTAUserMsg_ShowSurvey teammate_account_id.
         * @member {number} teammate_account_id
         * @memberof CDOTAUserMsg_ShowSurvey
         * @instance
         */
        CDOTAUserMsg_ShowSurvey.prototype.teammate_account_id = 0;
    
        /**
         * Creates a new CDOTAUserMsg_ShowSurvey instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_ShowSurvey
         * @static
         * @param {ICDOTAUserMsg_ShowSurvey=} [properties] Properties to set
         * @returns {CDOTAUserMsg_ShowSurvey} CDOTAUserMsg_ShowSurvey instance
         */
        CDOTAUserMsg_ShowSurvey.create = function create(properties) {
            return new CDOTAUserMsg_ShowSurvey(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ShowSurvey message. Does not implicitly {@link CDOTAUserMsg_ShowSurvey.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_ShowSurvey
         * @static
         * @param {ICDOTAUserMsg_ShowSurvey} message CDOTAUserMsg_ShowSurvey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ShowSurvey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.survey_id != null && Object.hasOwnProperty.call(message, "survey_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.survey_id);
            if (message.match_id != null && Object.hasOwnProperty.call(message, "match_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.match_id);
            if (message.response_style != null && Object.hasOwnProperty.call(message, "response_style"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.response_style);
            if (message.teammate_hero_id != null && Object.hasOwnProperty.call(message, "teammate_hero_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.teammate_hero_id);
            if (message.teammate_name != null && Object.hasOwnProperty.call(message, "teammate_name"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.teammate_name);
            if (message.teammate_account_id != null && Object.hasOwnProperty.call(message, "teammate_account_id"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.teammate_account_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ShowSurvey message, length delimited. Does not implicitly {@link CDOTAUserMsg_ShowSurvey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_ShowSurvey
         * @static
         * @param {ICDOTAUserMsg_ShowSurvey} message CDOTAUserMsg_ShowSurvey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ShowSurvey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_ShowSurvey message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_ShowSurvey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_ShowSurvey} CDOTAUserMsg_ShowSurvey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ShowSurvey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_ShowSurvey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.survey_id = reader.int32();
                    break;
                case 2:
                    message.match_id = reader.uint64();
                    break;
                case 3:
                    message.response_style = reader.string();
                    break;
                case 4:
                    message.teammate_hero_id = reader.uint32();
                    break;
                case 5:
                    message.teammate_name = reader.string();
                    break;
                case 6:
                    message.teammate_account_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_ShowSurvey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_ShowSurvey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_ShowSurvey} CDOTAUserMsg_ShowSurvey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ShowSurvey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_ShowSurvey message.
         * @function verify
         * @memberof CDOTAUserMsg_ShowSurvey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_ShowSurvey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.survey_id != null && message.hasOwnProperty("survey_id"))
                if (!$util.isInteger(message.survey_id))
                    return "survey_id: integer expected";
            if (message.match_id != null && message.hasOwnProperty("match_id"))
                if (!$util.isInteger(message.match_id) && !(message.match_id && $util.isInteger(message.match_id.low) && $util.isInteger(message.match_id.high)))
                    return "match_id: integer|Long expected";
            if (message.response_style != null && message.hasOwnProperty("response_style"))
                if (!$util.isString(message.response_style))
                    return "response_style: string expected";
            if (message.teammate_hero_id != null && message.hasOwnProperty("teammate_hero_id"))
                if (!$util.isInteger(message.teammate_hero_id))
                    return "teammate_hero_id: integer expected";
            if (message.teammate_name != null && message.hasOwnProperty("teammate_name"))
                if (!$util.isString(message.teammate_name))
                    return "teammate_name: string expected";
            if (message.teammate_account_id != null && message.hasOwnProperty("teammate_account_id"))
                if (!$util.isInteger(message.teammate_account_id))
                    return "teammate_account_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_ShowSurvey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_ShowSurvey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_ShowSurvey} CDOTAUserMsg_ShowSurvey
         */
        CDOTAUserMsg_ShowSurvey.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_ShowSurvey)
                return object;
            var message = new $root.CDOTAUserMsg_ShowSurvey();
            if (object.survey_id != null)
                message.survey_id = object.survey_id | 0;
            if (object.match_id != null)
                if ($util.Long)
                    (message.match_id = $util.Long.fromValue(object.match_id)).unsigned = true;
                else if (typeof object.match_id === "string")
                    message.match_id = parseInt(object.match_id, 10);
                else if (typeof object.match_id === "number")
                    message.match_id = object.match_id;
                else if (typeof object.match_id === "object")
                    message.match_id = new $util.LongBits(object.match_id.low >>> 0, object.match_id.high >>> 0).toNumber(true);
            if (object.response_style != null)
                message.response_style = String(object.response_style);
            if (object.teammate_hero_id != null)
                message.teammate_hero_id = object.teammate_hero_id >>> 0;
            if (object.teammate_name != null)
                message.teammate_name = String(object.teammate_name);
            if (object.teammate_account_id != null)
                message.teammate_account_id = object.teammate_account_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_ShowSurvey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_ShowSurvey
         * @static
         * @param {CDOTAUserMsg_ShowSurvey} message CDOTAUserMsg_ShowSurvey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_ShowSurvey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.survey_id = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.match_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.match_id = options.longs === String ? "0" : 0;
                object.response_style = "";
                object.teammate_hero_id = 0;
                object.teammate_name = "";
                object.teammate_account_id = 0;
            }
            if (message.survey_id != null && message.hasOwnProperty("survey_id"))
                object.survey_id = message.survey_id;
            if (message.match_id != null && message.hasOwnProperty("match_id"))
                if (typeof message.match_id === "number")
                    object.match_id = options.longs === String ? String(message.match_id) : message.match_id;
                else
                    object.match_id = options.longs === String ? $util.Long.prototype.toString.call(message.match_id) : options.longs === Number ? new $util.LongBits(message.match_id.low >>> 0, message.match_id.high >>> 0).toNumber(true) : message.match_id;
            if (message.response_style != null && message.hasOwnProperty("response_style"))
                object.response_style = message.response_style;
            if (message.teammate_hero_id != null && message.hasOwnProperty("teammate_hero_id"))
                object.teammate_hero_id = message.teammate_hero_id;
            if (message.teammate_name != null && message.hasOwnProperty("teammate_name"))
                object.teammate_name = message.teammate_name;
            if (message.teammate_account_id != null && message.hasOwnProperty("teammate_account_id"))
                object.teammate_account_id = message.teammate_account_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_ShowSurvey to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_ShowSurvey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_ShowSurvey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_ShowSurvey;
    })();
    
    $root.CDOTAUserMsg_UpdateSharedContent = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_UpdateSharedContent.
         * @exports ICDOTAUserMsg_UpdateSharedContent
         * @interface ICDOTAUserMsg_UpdateSharedContent
         * @property {number|null} [slot_type] CDOTAUserMsg_UpdateSharedContent slot_type
         */
    
        /**
         * Constructs a new CDOTAUserMsg_UpdateSharedContent.
         * @exports CDOTAUserMsg_UpdateSharedContent
         * @classdesc Represents a CDOTAUserMsg_UpdateSharedContent.
         * @implements ICDOTAUserMsg_UpdateSharedContent
         * @constructor
         * @param {ICDOTAUserMsg_UpdateSharedContent=} [properties] Properties to set
         */
        function CDOTAUserMsg_UpdateSharedContent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_UpdateSharedContent slot_type.
         * @member {number} slot_type
         * @memberof CDOTAUserMsg_UpdateSharedContent
         * @instance
         */
        CDOTAUserMsg_UpdateSharedContent.prototype.slot_type = 0;
    
        /**
         * Creates a new CDOTAUserMsg_UpdateSharedContent instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_UpdateSharedContent
         * @static
         * @param {ICDOTAUserMsg_UpdateSharedContent=} [properties] Properties to set
         * @returns {CDOTAUserMsg_UpdateSharedContent} CDOTAUserMsg_UpdateSharedContent instance
         */
        CDOTAUserMsg_UpdateSharedContent.create = function create(properties) {
            return new CDOTAUserMsg_UpdateSharedContent(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_UpdateSharedContent message. Does not implicitly {@link CDOTAUserMsg_UpdateSharedContent.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_UpdateSharedContent
         * @static
         * @param {ICDOTAUserMsg_UpdateSharedContent} message CDOTAUserMsg_UpdateSharedContent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_UpdateSharedContent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot_type != null && Object.hasOwnProperty.call(message, "slot_type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.slot_type);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_UpdateSharedContent message, length delimited. Does not implicitly {@link CDOTAUserMsg_UpdateSharedContent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_UpdateSharedContent
         * @static
         * @param {ICDOTAUserMsg_UpdateSharedContent} message CDOTAUserMsg_UpdateSharedContent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_UpdateSharedContent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_UpdateSharedContent message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_UpdateSharedContent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_UpdateSharedContent} CDOTAUserMsg_UpdateSharedContent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_UpdateSharedContent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_UpdateSharedContent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.slot_type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_UpdateSharedContent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_UpdateSharedContent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_UpdateSharedContent} CDOTAUserMsg_UpdateSharedContent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_UpdateSharedContent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_UpdateSharedContent message.
         * @function verify
         * @memberof CDOTAUserMsg_UpdateSharedContent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_UpdateSharedContent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.slot_type != null && message.hasOwnProperty("slot_type"))
                if (!$util.isInteger(message.slot_type))
                    return "slot_type: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_UpdateSharedContent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_UpdateSharedContent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_UpdateSharedContent} CDOTAUserMsg_UpdateSharedContent
         */
        CDOTAUserMsg_UpdateSharedContent.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_UpdateSharedContent)
                return object;
            var message = new $root.CDOTAUserMsg_UpdateSharedContent();
            if (object.slot_type != null)
                message.slot_type = object.slot_type | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_UpdateSharedContent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_UpdateSharedContent
         * @static
         * @param {CDOTAUserMsg_UpdateSharedContent} message CDOTAUserMsg_UpdateSharedContent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_UpdateSharedContent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.slot_type = 0;
            if (message.slot_type != null && message.hasOwnProperty("slot_type"))
                object.slot_type = message.slot_type;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_UpdateSharedContent to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_UpdateSharedContent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_UpdateSharedContent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_UpdateSharedContent;
    })();
    
    $root.CDOTAUserMsg_TutorialRequestExp = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_TutorialRequestExp.
         * @exports ICDOTAUserMsg_TutorialRequestExp
         * @interface ICDOTAUserMsg_TutorialRequestExp
         */
    
        /**
         * Constructs a new CDOTAUserMsg_TutorialRequestExp.
         * @exports CDOTAUserMsg_TutorialRequestExp
         * @classdesc Represents a CDOTAUserMsg_TutorialRequestExp.
         * @implements ICDOTAUserMsg_TutorialRequestExp
         * @constructor
         * @param {ICDOTAUserMsg_TutorialRequestExp=} [properties] Properties to set
         */
        function CDOTAUserMsg_TutorialRequestExp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CDOTAUserMsg_TutorialRequestExp instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_TutorialRequestExp
         * @static
         * @param {ICDOTAUserMsg_TutorialRequestExp=} [properties] Properties to set
         * @returns {CDOTAUserMsg_TutorialRequestExp} CDOTAUserMsg_TutorialRequestExp instance
         */
        CDOTAUserMsg_TutorialRequestExp.create = function create(properties) {
            return new CDOTAUserMsg_TutorialRequestExp(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TutorialRequestExp message. Does not implicitly {@link CDOTAUserMsg_TutorialRequestExp.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_TutorialRequestExp
         * @static
         * @param {ICDOTAUserMsg_TutorialRequestExp} message CDOTAUserMsg_TutorialRequestExp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TutorialRequestExp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TutorialRequestExp message, length delimited. Does not implicitly {@link CDOTAUserMsg_TutorialRequestExp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_TutorialRequestExp
         * @static
         * @param {ICDOTAUserMsg_TutorialRequestExp} message CDOTAUserMsg_TutorialRequestExp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TutorialRequestExp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_TutorialRequestExp message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_TutorialRequestExp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_TutorialRequestExp} CDOTAUserMsg_TutorialRequestExp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TutorialRequestExp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_TutorialRequestExp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_TutorialRequestExp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_TutorialRequestExp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_TutorialRequestExp} CDOTAUserMsg_TutorialRequestExp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TutorialRequestExp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_TutorialRequestExp message.
         * @function verify
         * @memberof CDOTAUserMsg_TutorialRequestExp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_TutorialRequestExp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_TutorialRequestExp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_TutorialRequestExp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_TutorialRequestExp} CDOTAUserMsg_TutorialRequestExp
         */
        CDOTAUserMsg_TutorialRequestExp.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_TutorialRequestExp)
                return object;
            return new $root.CDOTAUserMsg_TutorialRequestExp();
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_TutorialRequestExp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_TutorialRequestExp
         * @static
         * @param {CDOTAUserMsg_TutorialRequestExp} message CDOTAUserMsg_TutorialRequestExp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_TutorialRequestExp.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CDOTAUserMsg_TutorialRequestExp to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_TutorialRequestExp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_TutorialRequestExp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_TutorialRequestExp;
    })();
    
    $root.CDOTAUserMsg_TutorialFade = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_TutorialFade.
         * @exports ICDOTAUserMsg_TutorialFade
         * @interface ICDOTAUserMsg_TutorialFade
         * @property {number|null} [tgt_alpha] CDOTAUserMsg_TutorialFade tgt_alpha
         */
    
        /**
         * Constructs a new CDOTAUserMsg_TutorialFade.
         * @exports CDOTAUserMsg_TutorialFade
         * @classdesc Represents a CDOTAUserMsg_TutorialFade.
         * @implements ICDOTAUserMsg_TutorialFade
         * @constructor
         * @param {ICDOTAUserMsg_TutorialFade=} [properties] Properties to set
         */
        function CDOTAUserMsg_TutorialFade(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_TutorialFade tgt_alpha.
         * @member {number} tgt_alpha
         * @memberof CDOTAUserMsg_TutorialFade
         * @instance
         */
        CDOTAUserMsg_TutorialFade.prototype.tgt_alpha = 0;
    
        /**
         * Creates a new CDOTAUserMsg_TutorialFade instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_TutorialFade
         * @static
         * @param {ICDOTAUserMsg_TutorialFade=} [properties] Properties to set
         * @returns {CDOTAUserMsg_TutorialFade} CDOTAUserMsg_TutorialFade instance
         */
        CDOTAUserMsg_TutorialFade.create = function create(properties) {
            return new CDOTAUserMsg_TutorialFade(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TutorialFade message. Does not implicitly {@link CDOTAUserMsg_TutorialFade.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_TutorialFade
         * @static
         * @param {ICDOTAUserMsg_TutorialFade} message CDOTAUserMsg_TutorialFade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TutorialFade.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tgt_alpha != null && Object.hasOwnProperty.call(message, "tgt_alpha"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tgt_alpha);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TutorialFade message, length delimited. Does not implicitly {@link CDOTAUserMsg_TutorialFade.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_TutorialFade
         * @static
         * @param {ICDOTAUserMsg_TutorialFade} message CDOTAUserMsg_TutorialFade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TutorialFade.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_TutorialFade message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_TutorialFade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_TutorialFade} CDOTAUserMsg_TutorialFade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TutorialFade.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_TutorialFade();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tgt_alpha = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_TutorialFade message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_TutorialFade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_TutorialFade} CDOTAUserMsg_TutorialFade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TutorialFade.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_TutorialFade message.
         * @function verify
         * @memberof CDOTAUserMsg_TutorialFade
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_TutorialFade.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tgt_alpha != null && message.hasOwnProperty("tgt_alpha"))
                if (!$util.isInteger(message.tgt_alpha))
                    return "tgt_alpha: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_TutorialFade message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_TutorialFade
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_TutorialFade} CDOTAUserMsg_TutorialFade
         */
        CDOTAUserMsg_TutorialFade.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_TutorialFade)
                return object;
            var message = new $root.CDOTAUserMsg_TutorialFade();
            if (object.tgt_alpha != null)
                message.tgt_alpha = object.tgt_alpha | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_TutorialFade message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_TutorialFade
         * @static
         * @param {CDOTAUserMsg_TutorialFade} message CDOTAUserMsg_TutorialFade
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_TutorialFade.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.tgt_alpha = 0;
            if (message.tgt_alpha != null && message.hasOwnProperty("tgt_alpha"))
                object.tgt_alpha = message.tgt_alpha;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_TutorialFade to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_TutorialFade
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_TutorialFade.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_TutorialFade;
    })();
    
    $root.CDOTAUserMsg_TutorialPingMinimap = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_TutorialPingMinimap.
         * @exports ICDOTAUserMsg_TutorialPingMinimap
         * @interface ICDOTAUserMsg_TutorialPingMinimap
         * @property {number|null} [player_id] CDOTAUserMsg_TutorialPingMinimap player_id
         * @property {number|null} [pos_x] CDOTAUserMsg_TutorialPingMinimap pos_x
         * @property {number|null} [pos_y] CDOTAUserMsg_TutorialPingMinimap pos_y
         * @property {number|null} [pos_z] CDOTAUserMsg_TutorialPingMinimap pos_z
         * @property {number|null} [entity_index] CDOTAUserMsg_TutorialPingMinimap entity_index
         */
    
        /**
         * Constructs a new CDOTAUserMsg_TutorialPingMinimap.
         * @exports CDOTAUserMsg_TutorialPingMinimap
         * @classdesc Represents a CDOTAUserMsg_TutorialPingMinimap.
         * @implements ICDOTAUserMsg_TutorialPingMinimap
         * @constructor
         * @param {ICDOTAUserMsg_TutorialPingMinimap=} [properties] Properties to set
         */
        function CDOTAUserMsg_TutorialPingMinimap(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_TutorialPingMinimap player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_TutorialPingMinimap
         * @instance
         */
        CDOTAUserMsg_TutorialPingMinimap.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_TutorialPingMinimap pos_x.
         * @member {number} pos_x
         * @memberof CDOTAUserMsg_TutorialPingMinimap
         * @instance
         */
        CDOTAUserMsg_TutorialPingMinimap.prototype.pos_x = 0;
    
        /**
         * CDOTAUserMsg_TutorialPingMinimap pos_y.
         * @member {number} pos_y
         * @memberof CDOTAUserMsg_TutorialPingMinimap
         * @instance
         */
        CDOTAUserMsg_TutorialPingMinimap.prototype.pos_y = 0;
    
        /**
         * CDOTAUserMsg_TutorialPingMinimap pos_z.
         * @member {number} pos_z
         * @memberof CDOTAUserMsg_TutorialPingMinimap
         * @instance
         */
        CDOTAUserMsg_TutorialPingMinimap.prototype.pos_z = 0;
    
        /**
         * CDOTAUserMsg_TutorialPingMinimap entity_index.
         * @member {number} entity_index
         * @memberof CDOTAUserMsg_TutorialPingMinimap
         * @instance
         */
        CDOTAUserMsg_TutorialPingMinimap.prototype.entity_index = 0;
    
        /**
         * Creates a new CDOTAUserMsg_TutorialPingMinimap instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_TutorialPingMinimap
         * @static
         * @param {ICDOTAUserMsg_TutorialPingMinimap=} [properties] Properties to set
         * @returns {CDOTAUserMsg_TutorialPingMinimap} CDOTAUserMsg_TutorialPingMinimap instance
         */
        CDOTAUserMsg_TutorialPingMinimap.create = function create(properties) {
            return new CDOTAUserMsg_TutorialPingMinimap(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TutorialPingMinimap message. Does not implicitly {@link CDOTAUserMsg_TutorialPingMinimap.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_TutorialPingMinimap
         * @static
         * @param {ICDOTAUserMsg_TutorialPingMinimap} message CDOTAUserMsg_TutorialPingMinimap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TutorialPingMinimap.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.pos_x != null && Object.hasOwnProperty.call(message, "pos_x"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.pos_x);
            if (message.pos_y != null && Object.hasOwnProperty.call(message, "pos_y"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.pos_y);
            if (message.pos_z != null && Object.hasOwnProperty.call(message, "pos_z"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.pos_z);
            if (message.entity_index != null && Object.hasOwnProperty.call(message, "entity_index"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.entity_index);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TutorialPingMinimap message, length delimited. Does not implicitly {@link CDOTAUserMsg_TutorialPingMinimap.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_TutorialPingMinimap
         * @static
         * @param {ICDOTAUserMsg_TutorialPingMinimap} message CDOTAUserMsg_TutorialPingMinimap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TutorialPingMinimap.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_TutorialPingMinimap message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_TutorialPingMinimap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_TutorialPingMinimap} CDOTAUserMsg_TutorialPingMinimap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TutorialPingMinimap.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_TutorialPingMinimap();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.pos_x = reader.float();
                    break;
                case 3:
                    message.pos_y = reader.float();
                    break;
                case 4:
                    message.pos_z = reader.float();
                    break;
                case 5:
                    message.entity_index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_TutorialPingMinimap message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_TutorialPingMinimap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_TutorialPingMinimap} CDOTAUserMsg_TutorialPingMinimap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TutorialPingMinimap.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_TutorialPingMinimap message.
         * @function verify
         * @memberof CDOTAUserMsg_TutorialPingMinimap
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_TutorialPingMinimap.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.pos_x != null && message.hasOwnProperty("pos_x"))
                if (typeof message.pos_x !== "number")
                    return "pos_x: number expected";
            if (message.pos_y != null && message.hasOwnProperty("pos_y"))
                if (typeof message.pos_y !== "number")
                    return "pos_y: number expected";
            if (message.pos_z != null && message.hasOwnProperty("pos_z"))
                if (typeof message.pos_z !== "number")
                    return "pos_z: number expected";
            if (message.entity_index != null && message.hasOwnProperty("entity_index"))
                if (!$util.isInteger(message.entity_index))
                    return "entity_index: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_TutorialPingMinimap message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_TutorialPingMinimap
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_TutorialPingMinimap} CDOTAUserMsg_TutorialPingMinimap
         */
        CDOTAUserMsg_TutorialPingMinimap.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_TutorialPingMinimap)
                return object;
            var message = new $root.CDOTAUserMsg_TutorialPingMinimap();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.pos_x != null)
                message.pos_x = Number(object.pos_x);
            if (object.pos_y != null)
                message.pos_y = Number(object.pos_y);
            if (object.pos_z != null)
                message.pos_z = Number(object.pos_z);
            if (object.entity_index != null)
                message.entity_index = object.entity_index | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_TutorialPingMinimap message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_TutorialPingMinimap
         * @static
         * @param {CDOTAUserMsg_TutorialPingMinimap} message CDOTAUserMsg_TutorialPingMinimap
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_TutorialPingMinimap.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.pos_x = 0;
                object.pos_y = 0;
                object.pos_z = 0;
                object.entity_index = 0;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.pos_x != null && message.hasOwnProperty("pos_x"))
                object.pos_x = options.json && !isFinite(message.pos_x) ? String(message.pos_x) : message.pos_x;
            if (message.pos_y != null && message.hasOwnProperty("pos_y"))
                object.pos_y = options.json && !isFinite(message.pos_y) ? String(message.pos_y) : message.pos_y;
            if (message.pos_z != null && message.hasOwnProperty("pos_z"))
                object.pos_z = options.json && !isFinite(message.pos_z) ? String(message.pos_z) : message.pos_z;
            if (message.entity_index != null && message.hasOwnProperty("entity_index"))
                object.entity_index = message.entity_index;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_TutorialPingMinimap to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_TutorialPingMinimap
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_TutorialPingMinimap.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_TutorialPingMinimap;
    })();
    
    $root.CDOTAUserMsg_GamerulesStateChanged = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_GamerulesStateChanged.
         * @exports ICDOTAUserMsg_GamerulesStateChanged
         * @interface ICDOTAUserMsg_GamerulesStateChanged
         * @property {number|null} [state] CDOTAUserMsg_GamerulesStateChanged state
         */
    
        /**
         * Constructs a new CDOTAUserMsg_GamerulesStateChanged.
         * @exports CDOTAUserMsg_GamerulesStateChanged
         * @classdesc Represents a CDOTAUserMsg_GamerulesStateChanged.
         * @implements ICDOTAUserMsg_GamerulesStateChanged
         * @constructor
         * @param {ICDOTAUserMsg_GamerulesStateChanged=} [properties] Properties to set
         */
        function CDOTAUserMsg_GamerulesStateChanged(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_GamerulesStateChanged state.
         * @member {number} state
         * @memberof CDOTAUserMsg_GamerulesStateChanged
         * @instance
         */
        CDOTAUserMsg_GamerulesStateChanged.prototype.state = 0;
    
        /**
         * Creates a new CDOTAUserMsg_GamerulesStateChanged instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_GamerulesStateChanged
         * @static
         * @param {ICDOTAUserMsg_GamerulesStateChanged=} [properties] Properties to set
         * @returns {CDOTAUserMsg_GamerulesStateChanged} CDOTAUserMsg_GamerulesStateChanged instance
         */
        CDOTAUserMsg_GamerulesStateChanged.create = function create(properties) {
            return new CDOTAUserMsg_GamerulesStateChanged(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_GamerulesStateChanged message. Does not implicitly {@link CDOTAUserMsg_GamerulesStateChanged.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_GamerulesStateChanged
         * @static
         * @param {ICDOTAUserMsg_GamerulesStateChanged} message CDOTAUserMsg_GamerulesStateChanged message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_GamerulesStateChanged.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.state);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_GamerulesStateChanged message, length delimited. Does not implicitly {@link CDOTAUserMsg_GamerulesStateChanged.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_GamerulesStateChanged
         * @static
         * @param {ICDOTAUserMsg_GamerulesStateChanged} message CDOTAUserMsg_GamerulesStateChanged message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_GamerulesStateChanged.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_GamerulesStateChanged message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_GamerulesStateChanged
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_GamerulesStateChanged} CDOTAUserMsg_GamerulesStateChanged
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_GamerulesStateChanged.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_GamerulesStateChanged();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.state = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_GamerulesStateChanged message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_GamerulesStateChanged
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_GamerulesStateChanged} CDOTAUserMsg_GamerulesStateChanged
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_GamerulesStateChanged.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_GamerulesStateChanged message.
         * @function verify
         * @memberof CDOTAUserMsg_GamerulesStateChanged
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_GamerulesStateChanged.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (!$util.isInteger(message.state))
                    return "state: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_GamerulesStateChanged message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_GamerulesStateChanged
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_GamerulesStateChanged} CDOTAUserMsg_GamerulesStateChanged
         */
        CDOTAUserMsg_GamerulesStateChanged.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_GamerulesStateChanged)
                return object;
            var message = new $root.CDOTAUserMsg_GamerulesStateChanged();
            if (object.state != null)
                message.state = object.state >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_GamerulesStateChanged message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_GamerulesStateChanged
         * @static
         * @param {CDOTAUserMsg_GamerulesStateChanged} message CDOTAUserMsg_GamerulesStateChanged
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_GamerulesStateChanged.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.state = 0;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_GamerulesStateChanged to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_GamerulesStateChanged
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_GamerulesStateChanged.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_GamerulesStateChanged;
    })();
    
    $root.CDOTAUserMsg_AddQuestLogEntry = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_AddQuestLogEntry.
         * @exports ICDOTAUserMsg_AddQuestLogEntry
         * @interface ICDOTAUserMsg_AddQuestLogEntry
         * @property {string|null} [npc_name] CDOTAUserMsg_AddQuestLogEntry npc_name
         * @property {string|null} [npc_dialog] CDOTAUserMsg_AddQuestLogEntry npc_dialog
         */
    
        /**
         * Constructs a new CDOTAUserMsg_AddQuestLogEntry.
         * @exports CDOTAUserMsg_AddQuestLogEntry
         * @classdesc Represents a CDOTAUserMsg_AddQuestLogEntry.
         * @implements ICDOTAUserMsg_AddQuestLogEntry
         * @constructor
         * @param {ICDOTAUserMsg_AddQuestLogEntry=} [properties] Properties to set
         */
        function CDOTAUserMsg_AddQuestLogEntry(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_AddQuestLogEntry npc_name.
         * @member {string} npc_name
         * @memberof CDOTAUserMsg_AddQuestLogEntry
         * @instance
         */
        CDOTAUserMsg_AddQuestLogEntry.prototype.npc_name = "";
    
        /**
         * CDOTAUserMsg_AddQuestLogEntry npc_dialog.
         * @member {string} npc_dialog
         * @memberof CDOTAUserMsg_AddQuestLogEntry
         * @instance
         */
        CDOTAUserMsg_AddQuestLogEntry.prototype.npc_dialog = "";
    
        /**
         * Creates a new CDOTAUserMsg_AddQuestLogEntry instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_AddQuestLogEntry
         * @static
         * @param {ICDOTAUserMsg_AddQuestLogEntry=} [properties] Properties to set
         * @returns {CDOTAUserMsg_AddQuestLogEntry} CDOTAUserMsg_AddQuestLogEntry instance
         */
        CDOTAUserMsg_AddQuestLogEntry.create = function create(properties) {
            return new CDOTAUserMsg_AddQuestLogEntry(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_AddQuestLogEntry message. Does not implicitly {@link CDOTAUserMsg_AddQuestLogEntry.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_AddQuestLogEntry
         * @static
         * @param {ICDOTAUserMsg_AddQuestLogEntry} message CDOTAUserMsg_AddQuestLogEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_AddQuestLogEntry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.npc_name != null && Object.hasOwnProperty.call(message, "npc_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.npc_name);
            if (message.npc_dialog != null && Object.hasOwnProperty.call(message, "npc_dialog"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.npc_dialog);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_AddQuestLogEntry message, length delimited. Does not implicitly {@link CDOTAUserMsg_AddQuestLogEntry.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_AddQuestLogEntry
         * @static
         * @param {ICDOTAUserMsg_AddQuestLogEntry} message CDOTAUserMsg_AddQuestLogEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_AddQuestLogEntry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_AddQuestLogEntry message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_AddQuestLogEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_AddQuestLogEntry} CDOTAUserMsg_AddQuestLogEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_AddQuestLogEntry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_AddQuestLogEntry();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.npc_name = reader.string();
                    break;
                case 2:
                    message.npc_dialog = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_AddQuestLogEntry message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_AddQuestLogEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_AddQuestLogEntry} CDOTAUserMsg_AddQuestLogEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_AddQuestLogEntry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_AddQuestLogEntry message.
         * @function verify
         * @memberof CDOTAUserMsg_AddQuestLogEntry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_AddQuestLogEntry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.npc_name != null && message.hasOwnProperty("npc_name"))
                if (!$util.isString(message.npc_name))
                    return "npc_name: string expected";
            if (message.npc_dialog != null && message.hasOwnProperty("npc_dialog"))
                if (!$util.isString(message.npc_dialog))
                    return "npc_dialog: string expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_AddQuestLogEntry message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_AddQuestLogEntry
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_AddQuestLogEntry} CDOTAUserMsg_AddQuestLogEntry
         */
        CDOTAUserMsg_AddQuestLogEntry.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_AddQuestLogEntry)
                return object;
            var message = new $root.CDOTAUserMsg_AddQuestLogEntry();
            if (object.npc_name != null)
                message.npc_name = String(object.npc_name);
            if (object.npc_dialog != null)
                message.npc_dialog = String(object.npc_dialog);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_AddQuestLogEntry message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_AddQuestLogEntry
         * @static
         * @param {CDOTAUserMsg_AddQuestLogEntry} message CDOTAUserMsg_AddQuestLogEntry
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_AddQuestLogEntry.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.npc_name = "";
                object.npc_dialog = "";
            }
            if (message.npc_name != null && message.hasOwnProperty("npc_name"))
                object.npc_name = message.npc_name;
            if (message.npc_dialog != null && message.hasOwnProperty("npc_dialog"))
                object.npc_dialog = message.npc_dialog;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_AddQuestLogEntry to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_AddQuestLogEntry
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_AddQuestLogEntry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_AddQuestLogEntry;
    })();
    
    $root.CDOTAUserMsg_SendStatPopup = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_SendStatPopup.
         * @exports ICDOTAUserMsg_SendStatPopup
         * @interface ICDOTAUserMsg_SendStatPopup
         * @property {number|null} [player_id] CDOTAUserMsg_SendStatPopup player_id
         * @property {ICDOTAMsg_SendStatPopup|null} [statpopup] CDOTAUserMsg_SendStatPopup statpopup
         */
    
        /**
         * Constructs a new CDOTAUserMsg_SendStatPopup.
         * @exports CDOTAUserMsg_SendStatPopup
         * @classdesc Represents a CDOTAUserMsg_SendStatPopup.
         * @implements ICDOTAUserMsg_SendStatPopup
         * @constructor
         * @param {ICDOTAUserMsg_SendStatPopup=} [properties] Properties to set
         */
        function CDOTAUserMsg_SendStatPopup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_SendStatPopup player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_SendStatPopup
         * @instance
         */
        CDOTAUserMsg_SendStatPopup.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_SendStatPopup statpopup.
         * @member {ICDOTAMsg_SendStatPopup|null|undefined} statpopup
         * @memberof CDOTAUserMsg_SendStatPopup
         * @instance
         */
        CDOTAUserMsg_SendStatPopup.prototype.statpopup = null;
    
        /**
         * Creates a new CDOTAUserMsg_SendStatPopup instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_SendStatPopup
         * @static
         * @param {ICDOTAUserMsg_SendStatPopup=} [properties] Properties to set
         * @returns {CDOTAUserMsg_SendStatPopup} CDOTAUserMsg_SendStatPopup instance
         */
        CDOTAUserMsg_SendStatPopup.create = function create(properties) {
            return new CDOTAUserMsg_SendStatPopup(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SendStatPopup message. Does not implicitly {@link CDOTAUserMsg_SendStatPopup.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_SendStatPopup
         * @static
         * @param {ICDOTAUserMsg_SendStatPopup} message CDOTAUserMsg_SendStatPopup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SendStatPopup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.player_id);
            if (message.statpopup != null && Object.hasOwnProperty.call(message, "statpopup"))
                $root.CDOTAMsg_SendStatPopup.encode(message.statpopup, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SendStatPopup message, length delimited. Does not implicitly {@link CDOTAUserMsg_SendStatPopup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_SendStatPopup
         * @static
         * @param {ICDOTAUserMsg_SendStatPopup} message CDOTAUserMsg_SendStatPopup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SendStatPopup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_SendStatPopup message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_SendStatPopup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_SendStatPopup} CDOTAUserMsg_SendStatPopup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SendStatPopup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_SendStatPopup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.int32();
                    break;
                case 2:
                    message.statpopup = $root.CDOTAMsg_SendStatPopup.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_SendStatPopup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_SendStatPopup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_SendStatPopup} CDOTAUserMsg_SendStatPopup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SendStatPopup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_SendStatPopup message.
         * @function verify
         * @memberof CDOTAUserMsg_SendStatPopup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_SendStatPopup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.statpopup != null && message.hasOwnProperty("statpopup")) {
                var error = $root.CDOTAMsg_SendStatPopup.verify(message.statpopup);
                if (error)
                    return "statpopup." + error;
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_SendStatPopup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_SendStatPopup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_SendStatPopup} CDOTAUserMsg_SendStatPopup
         */
        CDOTAUserMsg_SendStatPopup.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_SendStatPopup)
                return object;
            var message = new $root.CDOTAUserMsg_SendStatPopup();
            if (object.player_id != null)
                message.player_id = object.player_id | 0;
            if (object.statpopup != null) {
                if (typeof object.statpopup !== "object")
                    throw TypeError(".CDOTAUserMsg_SendStatPopup.statpopup: object expected");
                message.statpopup = $root.CDOTAMsg_SendStatPopup.fromObject(object.statpopup);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_SendStatPopup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_SendStatPopup
         * @static
         * @param {CDOTAUserMsg_SendStatPopup} message CDOTAUserMsg_SendStatPopup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_SendStatPopup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.statpopup = null;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.statpopup != null && message.hasOwnProperty("statpopup"))
                object.statpopup = $root.CDOTAMsg_SendStatPopup.toObject(message.statpopup, options);
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_SendStatPopup to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_SendStatPopup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_SendStatPopup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_SendStatPopup;
    })();
    
    $root.CDOTAUserMsg_DismissAllStatPopups = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_DismissAllStatPopups.
         * @exports ICDOTAUserMsg_DismissAllStatPopups
         * @interface ICDOTAUserMsg_DismissAllStatPopups
         * @property {ICDOTAMsg_DismissAllStatPopups|null} [dismissallmsg] CDOTAUserMsg_DismissAllStatPopups dismissallmsg
         */
    
        /**
         * Constructs a new CDOTAUserMsg_DismissAllStatPopups.
         * @exports CDOTAUserMsg_DismissAllStatPopups
         * @classdesc Represents a CDOTAUserMsg_DismissAllStatPopups.
         * @implements ICDOTAUserMsg_DismissAllStatPopups
         * @constructor
         * @param {ICDOTAUserMsg_DismissAllStatPopups=} [properties] Properties to set
         */
        function CDOTAUserMsg_DismissAllStatPopups(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_DismissAllStatPopups dismissallmsg.
         * @member {ICDOTAMsg_DismissAllStatPopups|null|undefined} dismissallmsg
         * @memberof CDOTAUserMsg_DismissAllStatPopups
         * @instance
         */
        CDOTAUserMsg_DismissAllStatPopups.prototype.dismissallmsg = null;
    
        /**
         * Creates a new CDOTAUserMsg_DismissAllStatPopups instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_DismissAllStatPopups
         * @static
         * @param {ICDOTAUserMsg_DismissAllStatPopups=} [properties] Properties to set
         * @returns {CDOTAUserMsg_DismissAllStatPopups} CDOTAUserMsg_DismissAllStatPopups instance
         */
        CDOTAUserMsg_DismissAllStatPopups.create = function create(properties) {
            return new CDOTAUserMsg_DismissAllStatPopups(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_DismissAllStatPopups message. Does not implicitly {@link CDOTAUserMsg_DismissAllStatPopups.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_DismissAllStatPopups
         * @static
         * @param {ICDOTAUserMsg_DismissAllStatPopups} message CDOTAUserMsg_DismissAllStatPopups message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_DismissAllStatPopups.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dismissallmsg != null && Object.hasOwnProperty.call(message, "dismissallmsg"))
                $root.CDOTAMsg_DismissAllStatPopups.encode(message.dismissallmsg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_DismissAllStatPopups message, length delimited. Does not implicitly {@link CDOTAUserMsg_DismissAllStatPopups.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_DismissAllStatPopups
         * @static
         * @param {ICDOTAUserMsg_DismissAllStatPopups} message CDOTAUserMsg_DismissAllStatPopups message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_DismissAllStatPopups.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_DismissAllStatPopups message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_DismissAllStatPopups
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_DismissAllStatPopups} CDOTAUserMsg_DismissAllStatPopups
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_DismissAllStatPopups.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_DismissAllStatPopups();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dismissallmsg = $root.CDOTAMsg_DismissAllStatPopups.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_DismissAllStatPopups message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_DismissAllStatPopups
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_DismissAllStatPopups} CDOTAUserMsg_DismissAllStatPopups
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_DismissAllStatPopups.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_DismissAllStatPopups message.
         * @function verify
         * @memberof CDOTAUserMsg_DismissAllStatPopups
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_DismissAllStatPopups.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dismissallmsg != null && message.hasOwnProperty("dismissallmsg")) {
                var error = $root.CDOTAMsg_DismissAllStatPopups.verify(message.dismissallmsg);
                if (error)
                    return "dismissallmsg." + error;
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_DismissAllStatPopups message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_DismissAllStatPopups
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_DismissAllStatPopups} CDOTAUserMsg_DismissAllStatPopups
         */
        CDOTAUserMsg_DismissAllStatPopups.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_DismissAllStatPopups)
                return object;
            var message = new $root.CDOTAUserMsg_DismissAllStatPopups();
            if (object.dismissallmsg != null) {
                if (typeof object.dismissallmsg !== "object")
                    throw TypeError(".CDOTAUserMsg_DismissAllStatPopups.dismissallmsg: object expected");
                message.dismissallmsg = $root.CDOTAMsg_DismissAllStatPopups.fromObject(object.dismissallmsg);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_DismissAllStatPopups message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_DismissAllStatPopups
         * @static
         * @param {CDOTAUserMsg_DismissAllStatPopups} message CDOTAUserMsg_DismissAllStatPopups
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_DismissAllStatPopups.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.dismissallmsg = null;
            if (message.dismissallmsg != null && message.hasOwnProperty("dismissallmsg"))
                object.dismissallmsg = $root.CDOTAMsg_DismissAllStatPopups.toObject(message.dismissallmsg, options);
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_DismissAllStatPopups to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_DismissAllStatPopups
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_DismissAllStatPopups.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_DismissAllStatPopups;
    })();
    
    $root.CDOTAUserMsg_SendRoshanSpectatorPhase = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_SendRoshanSpectatorPhase.
         * @exports ICDOTAUserMsg_SendRoshanSpectatorPhase
         * @interface ICDOTAUserMsg_SendRoshanSpectatorPhase
         * @property {DOTA_ROSHAN_PHASE|null} [phase] CDOTAUserMsg_SendRoshanSpectatorPhase phase
         * @property {number|null} [phase_start_time] CDOTAUserMsg_SendRoshanSpectatorPhase phase_start_time
         * @property {number|null} [phase_length] CDOTAUserMsg_SendRoshanSpectatorPhase phase_length
         */
    
        /**
         * Constructs a new CDOTAUserMsg_SendRoshanSpectatorPhase.
         * @exports CDOTAUserMsg_SendRoshanSpectatorPhase
         * @classdesc Represents a CDOTAUserMsg_SendRoshanSpectatorPhase.
         * @implements ICDOTAUserMsg_SendRoshanSpectatorPhase
         * @constructor
         * @param {ICDOTAUserMsg_SendRoshanSpectatorPhase=} [properties] Properties to set
         */
        function CDOTAUserMsg_SendRoshanSpectatorPhase(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_SendRoshanSpectatorPhase phase.
         * @member {DOTA_ROSHAN_PHASE} phase
         * @memberof CDOTAUserMsg_SendRoshanSpectatorPhase
         * @instance
         */
        CDOTAUserMsg_SendRoshanSpectatorPhase.prototype.phase = 0;
    
        /**
         * CDOTAUserMsg_SendRoshanSpectatorPhase phase_start_time.
         * @member {number} phase_start_time
         * @memberof CDOTAUserMsg_SendRoshanSpectatorPhase
         * @instance
         */
        CDOTAUserMsg_SendRoshanSpectatorPhase.prototype.phase_start_time = 0;
    
        /**
         * CDOTAUserMsg_SendRoshanSpectatorPhase phase_length.
         * @member {number} phase_length
         * @memberof CDOTAUserMsg_SendRoshanSpectatorPhase
         * @instance
         */
        CDOTAUserMsg_SendRoshanSpectatorPhase.prototype.phase_length = 0;
    
        /**
         * Creates a new CDOTAUserMsg_SendRoshanSpectatorPhase instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_SendRoshanSpectatorPhase
         * @static
         * @param {ICDOTAUserMsg_SendRoshanSpectatorPhase=} [properties] Properties to set
         * @returns {CDOTAUserMsg_SendRoshanSpectatorPhase} CDOTAUserMsg_SendRoshanSpectatorPhase instance
         */
        CDOTAUserMsg_SendRoshanSpectatorPhase.create = function create(properties) {
            return new CDOTAUserMsg_SendRoshanSpectatorPhase(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SendRoshanSpectatorPhase message. Does not implicitly {@link CDOTAUserMsg_SendRoshanSpectatorPhase.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_SendRoshanSpectatorPhase
         * @static
         * @param {ICDOTAUserMsg_SendRoshanSpectatorPhase} message CDOTAUserMsg_SendRoshanSpectatorPhase message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SendRoshanSpectatorPhase.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.phase != null && Object.hasOwnProperty.call(message, "phase"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.phase);
            if (message.phase_start_time != null && Object.hasOwnProperty.call(message, "phase_start_time"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.phase_start_time);
            if (message.phase_length != null && Object.hasOwnProperty.call(message, "phase_length"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.phase_length);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SendRoshanSpectatorPhase message, length delimited. Does not implicitly {@link CDOTAUserMsg_SendRoshanSpectatorPhase.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_SendRoshanSpectatorPhase
         * @static
         * @param {ICDOTAUserMsg_SendRoshanSpectatorPhase} message CDOTAUserMsg_SendRoshanSpectatorPhase message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SendRoshanSpectatorPhase.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_SendRoshanSpectatorPhase message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_SendRoshanSpectatorPhase
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_SendRoshanSpectatorPhase} CDOTAUserMsg_SendRoshanSpectatorPhase
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SendRoshanSpectatorPhase.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_SendRoshanSpectatorPhase();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.phase = reader.int32();
                    break;
                case 2:
                    message.phase_start_time = reader.int32();
                    break;
                case 3:
                    message.phase_length = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_SendRoshanSpectatorPhase message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_SendRoshanSpectatorPhase
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_SendRoshanSpectatorPhase} CDOTAUserMsg_SendRoshanSpectatorPhase
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SendRoshanSpectatorPhase.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_SendRoshanSpectatorPhase message.
         * @function verify
         * @memberof CDOTAUserMsg_SendRoshanSpectatorPhase
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_SendRoshanSpectatorPhase.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.phase != null && message.hasOwnProperty("phase"))
                switch (message.phase) {
                default:
                    return "phase: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.phase_start_time != null && message.hasOwnProperty("phase_start_time"))
                if (!$util.isInteger(message.phase_start_time))
                    return "phase_start_time: integer expected";
            if (message.phase_length != null && message.hasOwnProperty("phase_length"))
                if (!$util.isInteger(message.phase_length))
                    return "phase_length: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_SendRoshanSpectatorPhase message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_SendRoshanSpectatorPhase
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_SendRoshanSpectatorPhase} CDOTAUserMsg_SendRoshanSpectatorPhase
         */
        CDOTAUserMsg_SendRoshanSpectatorPhase.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_SendRoshanSpectatorPhase)
                return object;
            var message = new $root.CDOTAUserMsg_SendRoshanSpectatorPhase();
            switch (object.phase) {
            case "k_SRSP_ROSHAN_ALIVE":
            case 0:
                message.phase = 0;
                break;
            case "k_SRSP_ROSHAN_BASE_TIMER":
            case 1:
                message.phase = 1;
                break;
            case "k_SRSP_ROSHAN_VISIBLE_TIMER":
            case 2:
                message.phase = 2;
                break;
            }
            if (object.phase_start_time != null)
                message.phase_start_time = object.phase_start_time | 0;
            if (object.phase_length != null)
                message.phase_length = object.phase_length | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_SendRoshanSpectatorPhase message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_SendRoshanSpectatorPhase
         * @static
         * @param {CDOTAUserMsg_SendRoshanSpectatorPhase} message CDOTAUserMsg_SendRoshanSpectatorPhase
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_SendRoshanSpectatorPhase.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.phase = options.enums === String ? "k_SRSP_ROSHAN_ALIVE" : 0;
                object.phase_start_time = 0;
                object.phase_length = 0;
            }
            if (message.phase != null && message.hasOwnProperty("phase"))
                object.phase = options.enums === String ? $root.DOTA_ROSHAN_PHASE[message.phase] : message.phase;
            if (message.phase_start_time != null && message.hasOwnProperty("phase_start_time"))
                object.phase_start_time = message.phase_start_time;
            if (message.phase_length != null && message.hasOwnProperty("phase_length"))
                object.phase_length = message.phase_length;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_SendRoshanSpectatorPhase to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_SendRoshanSpectatorPhase
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_SendRoshanSpectatorPhase.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_SendRoshanSpectatorPhase;
    })();
    
    $root.CDOTAUserMsg_SendRoshanPopup = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_SendRoshanPopup.
         * @exports ICDOTAUserMsg_SendRoshanPopup
         * @interface ICDOTAUserMsg_SendRoshanPopup
         * @property {boolean|null} [reclaimed] CDOTAUserMsg_SendRoshanPopup reclaimed
         * @property {number|null} [gametime] CDOTAUserMsg_SendRoshanPopup gametime
         */
    
        /**
         * Constructs a new CDOTAUserMsg_SendRoshanPopup.
         * @exports CDOTAUserMsg_SendRoshanPopup
         * @classdesc Represents a CDOTAUserMsg_SendRoshanPopup.
         * @implements ICDOTAUserMsg_SendRoshanPopup
         * @constructor
         * @param {ICDOTAUserMsg_SendRoshanPopup=} [properties] Properties to set
         */
        function CDOTAUserMsg_SendRoshanPopup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_SendRoshanPopup reclaimed.
         * @member {boolean} reclaimed
         * @memberof CDOTAUserMsg_SendRoshanPopup
         * @instance
         */
        CDOTAUserMsg_SendRoshanPopup.prototype.reclaimed = false;
    
        /**
         * CDOTAUserMsg_SendRoshanPopup gametime.
         * @member {number} gametime
         * @memberof CDOTAUserMsg_SendRoshanPopup
         * @instance
         */
        CDOTAUserMsg_SendRoshanPopup.prototype.gametime = 0;
    
        /**
         * Creates a new CDOTAUserMsg_SendRoshanPopup instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_SendRoshanPopup
         * @static
         * @param {ICDOTAUserMsg_SendRoshanPopup=} [properties] Properties to set
         * @returns {CDOTAUserMsg_SendRoshanPopup} CDOTAUserMsg_SendRoshanPopup instance
         */
        CDOTAUserMsg_SendRoshanPopup.create = function create(properties) {
            return new CDOTAUserMsg_SendRoshanPopup(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SendRoshanPopup message. Does not implicitly {@link CDOTAUserMsg_SendRoshanPopup.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_SendRoshanPopup
         * @static
         * @param {ICDOTAUserMsg_SendRoshanPopup} message CDOTAUserMsg_SendRoshanPopup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SendRoshanPopup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reclaimed != null && Object.hasOwnProperty.call(message, "reclaimed"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.reclaimed);
            if (message.gametime != null && Object.hasOwnProperty.call(message, "gametime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.gametime);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SendRoshanPopup message, length delimited. Does not implicitly {@link CDOTAUserMsg_SendRoshanPopup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_SendRoshanPopup
         * @static
         * @param {ICDOTAUserMsg_SendRoshanPopup} message CDOTAUserMsg_SendRoshanPopup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SendRoshanPopup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_SendRoshanPopup message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_SendRoshanPopup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_SendRoshanPopup} CDOTAUserMsg_SendRoshanPopup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SendRoshanPopup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_SendRoshanPopup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reclaimed = reader.bool();
                    break;
                case 2:
                    message.gametime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_SendRoshanPopup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_SendRoshanPopup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_SendRoshanPopup} CDOTAUserMsg_SendRoshanPopup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SendRoshanPopup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_SendRoshanPopup message.
         * @function verify
         * @memberof CDOTAUserMsg_SendRoshanPopup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_SendRoshanPopup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reclaimed != null && message.hasOwnProperty("reclaimed"))
                if (typeof message.reclaimed !== "boolean")
                    return "reclaimed: boolean expected";
            if (message.gametime != null && message.hasOwnProperty("gametime"))
                if (!$util.isInteger(message.gametime))
                    return "gametime: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_SendRoshanPopup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_SendRoshanPopup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_SendRoshanPopup} CDOTAUserMsg_SendRoshanPopup
         */
        CDOTAUserMsg_SendRoshanPopup.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_SendRoshanPopup)
                return object;
            var message = new $root.CDOTAUserMsg_SendRoshanPopup();
            if (object.reclaimed != null)
                message.reclaimed = Boolean(object.reclaimed);
            if (object.gametime != null)
                message.gametime = object.gametime | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_SendRoshanPopup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_SendRoshanPopup
         * @static
         * @param {CDOTAUserMsg_SendRoshanPopup} message CDOTAUserMsg_SendRoshanPopup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_SendRoshanPopup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.reclaimed = false;
                object.gametime = 0;
            }
            if (message.reclaimed != null && message.hasOwnProperty("reclaimed"))
                object.reclaimed = message.reclaimed;
            if (message.gametime != null && message.hasOwnProperty("gametime"))
                object.gametime = message.gametime;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_SendRoshanPopup to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_SendRoshanPopup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_SendRoshanPopup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_SendRoshanPopup;
    })();
    
    $root.CDOTAUserMsg_SendFinalGold = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_SendFinalGold.
         * @exports ICDOTAUserMsg_SendFinalGold
         * @interface ICDOTAUserMsg_SendFinalGold
         * @property {Array.<number>|null} [reliable_gold] CDOTAUserMsg_SendFinalGold reliable_gold
         * @property {Array.<number>|null} [unreliable_gold] CDOTAUserMsg_SendFinalGold unreliable_gold
         */
    
        /**
         * Constructs a new CDOTAUserMsg_SendFinalGold.
         * @exports CDOTAUserMsg_SendFinalGold
         * @classdesc Represents a CDOTAUserMsg_SendFinalGold.
         * @implements ICDOTAUserMsg_SendFinalGold
         * @constructor
         * @param {ICDOTAUserMsg_SendFinalGold=} [properties] Properties to set
         */
        function CDOTAUserMsg_SendFinalGold(properties) {
            this.reliable_gold = [];
            this.unreliable_gold = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_SendFinalGold reliable_gold.
         * @member {Array.<number>} reliable_gold
         * @memberof CDOTAUserMsg_SendFinalGold
         * @instance
         */
        CDOTAUserMsg_SendFinalGold.prototype.reliable_gold = $util.emptyArray;
    
        /**
         * CDOTAUserMsg_SendFinalGold unreliable_gold.
         * @member {Array.<number>} unreliable_gold
         * @memberof CDOTAUserMsg_SendFinalGold
         * @instance
         */
        CDOTAUserMsg_SendFinalGold.prototype.unreliable_gold = $util.emptyArray;
    
        /**
         * Creates a new CDOTAUserMsg_SendFinalGold instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_SendFinalGold
         * @static
         * @param {ICDOTAUserMsg_SendFinalGold=} [properties] Properties to set
         * @returns {CDOTAUserMsg_SendFinalGold} CDOTAUserMsg_SendFinalGold instance
         */
        CDOTAUserMsg_SendFinalGold.create = function create(properties) {
            return new CDOTAUserMsg_SendFinalGold(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SendFinalGold message. Does not implicitly {@link CDOTAUserMsg_SendFinalGold.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_SendFinalGold
         * @static
         * @param {ICDOTAUserMsg_SendFinalGold} message CDOTAUserMsg_SendFinalGold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SendFinalGold.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reliable_gold != null && message.reliable_gold.length)
                for (var i = 0; i < message.reliable_gold.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.reliable_gold[i]);
            if (message.unreliable_gold != null && message.unreliable_gold.length)
                for (var i = 0; i < message.unreliable_gold.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.unreliable_gold[i]);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SendFinalGold message, length delimited. Does not implicitly {@link CDOTAUserMsg_SendFinalGold.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_SendFinalGold
         * @static
         * @param {ICDOTAUserMsg_SendFinalGold} message CDOTAUserMsg_SendFinalGold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SendFinalGold.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_SendFinalGold message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_SendFinalGold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_SendFinalGold} CDOTAUserMsg_SendFinalGold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SendFinalGold.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_SendFinalGold();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.reliable_gold && message.reliable_gold.length))
                        message.reliable_gold = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.reliable_gold.push(reader.uint32());
                    } else
                        message.reliable_gold.push(reader.uint32());
                    break;
                case 2:
                    if (!(message.unreliable_gold && message.unreliable_gold.length))
                        message.unreliable_gold = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.unreliable_gold.push(reader.uint32());
                    } else
                        message.unreliable_gold.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_SendFinalGold message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_SendFinalGold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_SendFinalGold} CDOTAUserMsg_SendFinalGold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SendFinalGold.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_SendFinalGold message.
         * @function verify
         * @memberof CDOTAUserMsg_SendFinalGold
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_SendFinalGold.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reliable_gold != null && message.hasOwnProperty("reliable_gold")) {
                if (!Array.isArray(message.reliable_gold))
                    return "reliable_gold: array expected";
                for (var i = 0; i < message.reliable_gold.length; ++i)
                    if (!$util.isInteger(message.reliable_gold[i]))
                        return "reliable_gold: integer[] expected";
            }
            if (message.unreliable_gold != null && message.hasOwnProperty("unreliable_gold")) {
                if (!Array.isArray(message.unreliable_gold))
                    return "unreliable_gold: array expected";
                for (var i = 0; i < message.unreliable_gold.length; ++i)
                    if (!$util.isInteger(message.unreliable_gold[i]))
                        return "unreliable_gold: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_SendFinalGold message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_SendFinalGold
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_SendFinalGold} CDOTAUserMsg_SendFinalGold
         */
        CDOTAUserMsg_SendFinalGold.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_SendFinalGold)
                return object;
            var message = new $root.CDOTAUserMsg_SendFinalGold();
            if (object.reliable_gold) {
                if (!Array.isArray(object.reliable_gold))
                    throw TypeError(".CDOTAUserMsg_SendFinalGold.reliable_gold: array expected");
                message.reliable_gold = [];
                for (var i = 0; i < object.reliable_gold.length; ++i)
                    message.reliable_gold[i] = object.reliable_gold[i] >>> 0;
            }
            if (object.unreliable_gold) {
                if (!Array.isArray(object.unreliable_gold))
                    throw TypeError(".CDOTAUserMsg_SendFinalGold.unreliable_gold: array expected");
                message.unreliable_gold = [];
                for (var i = 0; i < object.unreliable_gold.length; ++i)
                    message.unreliable_gold[i] = object.unreliable_gold[i] >>> 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_SendFinalGold message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_SendFinalGold
         * @static
         * @param {CDOTAUserMsg_SendFinalGold} message CDOTAUserMsg_SendFinalGold
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_SendFinalGold.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.reliable_gold = [];
                object.unreliable_gold = [];
            }
            if (message.reliable_gold && message.reliable_gold.length) {
                object.reliable_gold = [];
                for (var j = 0; j < message.reliable_gold.length; ++j)
                    object.reliable_gold[j] = message.reliable_gold[j];
            }
            if (message.unreliable_gold && message.unreliable_gold.length) {
                object.unreliable_gold = [];
                for (var j = 0; j < message.unreliable_gold.length; ++j)
                    object.unreliable_gold[j] = message.unreliable_gold[j];
            }
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_SendFinalGold to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_SendFinalGold
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_SendFinalGold.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_SendFinalGold;
    })();
    
    $root.CDOTAUserMsg_CustomMsg = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_CustomMsg.
         * @exports ICDOTAUserMsg_CustomMsg
         * @interface ICDOTAUserMsg_CustomMsg
         * @property {string|null} [message] CDOTAUserMsg_CustomMsg message
         * @property {number|null} [player_id] CDOTAUserMsg_CustomMsg player_id
         * @property {number|null} [value] CDOTAUserMsg_CustomMsg value
         */
    
        /**
         * Constructs a new CDOTAUserMsg_CustomMsg.
         * @exports CDOTAUserMsg_CustomMsg
         * @classdesc Represents a CDOTAUserMsg_CustomMsg.
         * @implements ICDOTAUserMsg_CustomMsg
         * @constructor
         * @param {ICDOTAUserMsg_CustomMsg=} [properties] Properties to set
         */
        function CDOTAUserMsg_CustomMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_CustomMsg message.
         * @member {string} message
         * @memberof CDOTAUserMsg_CustomMsg
         * @instance
         */
        CDOTAUserMsg_CustomMsg.prototype.message = "";
    
        /**
         * CDOTAUserMsg_CustomMsg player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_CustomMsg
         * @instance
         */
        CDOTAUserMsg_CustomMsg.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_CustomMsg value.
         * @member {number} value
         * @memberof CDOTAUserMsg_CustomMsg
         * @instance
         */
        CDOTAUserMsg_CustomMsg.prototype.value = 0;
    
        /**
         * Creates a new CDOTAUserMsg_CustomMsg instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_CustomMsg
         * @static
         * @param {ICDOTAUserMsg_CustomMsg=} [properties] Properties to set
         * @returns {CDOTAUserMsg_CustomMsg} CDOTAUserMsg_CustomMsg instance
         */
        CDOTAUserMsg_CustomMsg.create = function create(properties) {
            return new CDOTAUserMsg_CustomMsg(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CustomMsg message. Does not implicitly {@link CDOTAUserMsg_CustomMsg.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_CustomMsg
         * @static
         * @param {ICDOTAUserMsg_CustomMsg} message CDOTAUserMsg_CustomMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CustomMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.player_id);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.value);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CustomMsg message, length delimited. Does not implicitly {@link CDOTAUserMsg_CustomMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_CustomMsg
         * @static
         * @param {ICDOTAUserMsg_CustomMsg} message CDOTAUserMsg_CustomMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CustomMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_CustomMsg message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_CustomMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_CustomMsg} CDOTAUserMsg_CustomMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CustomMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_CustomMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.message = reader.string();
                    break;
                case 2:
                    message.player_id = reader.int32();
                    break;
                case 3:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_CustomMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_CustomMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_CustomMsg} CDOTAUserMsg_CustomMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CustomMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_CustomMsg message.
         * @function verify
         * @memberof CDOTAUserMsg_CustomMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_CustomMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value))
                    return "value: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_CustomMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_CustomMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_CustomMsg} CDOTAUserMsg_CustomMsg
         */
        CDOTAUserMsg_CustomMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_CustomMsg)
                return object;
            var message = new $root.CDOTAUserMsg_CustomMsg();
            if (object.message != null)
                message.message = String(object.message);
            if (object.player_id != null)
                message.player_id = object.player_id | 0;
            if (object.value != null)
                message.value = object.value | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_CustomMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_CustomMsg
         * @static
         * @param {CDOTAUserMsg_CustomMsg} message CDOTAUserMsg_CustomMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_CustomMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.message = "";
                object.player_id = 0;
                object.value = 0;
            }
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_CustomMsg to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_CustomMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_CustomMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_CustomMsg;
    })();
    
    $root.CDOTAUserMsg_CoachHUDPing = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_CoachHUDPing.
         * @exports ICDOTAUserMsg_CoachHUDPing
         * @interface ICDOTAUserMsg_CoachHUDPing
         * @property {number|null} [player_id] CDOTAUserMsg_CoachHUDPing player_id
         * @property {ICDOTAMsg_CoachHUDPing|null} [hud_ping] CDOTAUserMsg_CoachHUDPing hud_ping
         */
    
        /**
         * Constructs a new CDOTAUserMsg_CoachHUDPing.
         * @exports CDOTAUserMsg_CoachHUDPing
         * @classdesc Represents a CDOTAUserMsg_CoachHUDPing.
         * @implements ICDOTAUserMsg_CoachHUDPing
         * @constructor
         * @param {ICDOTAUserMsg_CoachHUDPing=} [properties] Properties to set
         */
        function CDOTAUserMsg_CoachHUDPing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_CoachHUDPing player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_CoachHUDPing
         * @instance
         */
        CDOTAUserMsg_CoachHUDPing.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_CoachHUDPing hud_ping.
         * @member {ICDOTAMsg_CoachHUDPing|null|undefined} hud_ping
         * @memberof CDOTAUserMsg_CoachHUDPing
         * @instance
         */
        CDOTAUserMsg_CoachHUDPing.prototype.hud_ping = null;
    
        /**
         * Creates a new CDOTAUserMsg_CoachHUDPing instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_CoachHUDPing
         * @static
         * @param {ICDOTAUserMsg_CoachHUDPing=} [properties] Properties to set
         * @returns {CDOTAUserMsg_CoachHUDPing} CDOTAUserMsg_CoachHUDPing instance
         */
        CDOTAUserMsg_CoachHUDPing.create = function create(properties) {
            return new CDOTAUserMsg_CoachHUDPing(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CoachHUDPing message. Does not implicitly {@link CDOTAUserMsg_CoachHUDPing.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_CoachHUDPing
         * @static
         * @param {ICDOTAUserMsg_CoachHUDPing} message CDOTAUserMsg_CoachHUDPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CoachHUDPing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.hud_ping != null && Object.hasOwnProperty.call(message, "hud_ping"))
                $root.CDOTAMsg_CoachHUDPing.encode(message.hud_ping, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CoachHUDPing message, length delimited. Does not implicitly {@link CDOTAUserMsg_CoachHUDPing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_CoachHUDPing
         * @static
         * @param {ICDOTAUserMsg_CoachHUDPing} message CDOTAUserMsg_CoachHUDPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CoachHUDPing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_CoachHUDPing message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_CoachHUDPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_CoachHUDPing} CDOTAUserMsg_CoachHUDPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CoachHUDPing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_CoachHUDPing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.hud_ping = $root.CDOTAMsg_CoachHUDPing.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_CoachHUDPing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_CoachHUDPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_CoachHUDPing} CDOTAUserMsg_CoachHUDPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CoachHUDPing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_CoachHUDPing message.
         * @function verify
         * @memberof CDOTAUserMsg_CoachHUDPing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_CoachHUDPing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.hud_ping != null && message.hasOwnProperty("hud_ping")) {
                var error = $root.CDOTAMsg_CoachHUDPing.verify(message.hud_ping);
                if (error)
                    return "hud_ping." + error;
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_CoachHUDPing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_CoachHUDPing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_CoachHUDPing} CDOTAUserMsg_CoachHUDPing
         */
        CDOTAUserMsg_CoachHUDPing.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_CoachHUDPing)
                return object;
            var message = new $root.CDOTAUserMsg_CoachHUDPing();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.hud_ping != null) {
                if (typeof object.hud_ping !== "object")
                    throw TypeError(".CDOTAUserMsg_CoachHUDPing.hud_ping: object expected");
                message.hud_ping = $root.CDOTAMsg_CoachHUDPing.fromObject(object.hud_ping);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_CoachHUDPing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_CoachHUDPing
         * @static
         * @param {CDOTAUserMsg_CoachHUDPing} message CDOTAUserMsg_CoachHUDPing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_CoachHUDPing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.hud_ping = null;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.hud_ping != null && message.hasOwnProperty("hud_ping"))
                object.hud_ping = $root.CDOTAMsg_CoachHUDPing.toObject(message.hud_ping, options);
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_CoachHUDPing to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_CoachHUDPing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_CoachHUDPing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_CoachHUDPing;
    })();
    
    $root.CDOTAUserMsg_ClientLoadGridNav = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_ClientLoadGridNav.
         * @exports ICDOTAUserMsg_ClientLoadGridNav
         * @interface ICDOTAUserMsg_ClientLoadGridNav
         */
    
        /**
         * Constructs a new CDOTAUserMsg_ClientLoadGridNav.
         * @exports CDOTAUserMsg_ClientLoadGridNav
         * @classdesc Represents a CDOTAUserMsg_ClientLoadGridNav.
         * @implements ICDOTAUserMsg_ClientLoadGridNav
         * @constructor
         * @param {ICDOTAUserMsg_ClientLoadGridNav=} [properties] Properties to set
         */
        function CDOTAUserMsg_ClientLoadGridNav(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CDOTAUserMsg_ClientLoadGridNav instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_ClientLoadGridNav
         * @static
         * @param {ICDOTAUserMsg_ClientLoadGridNav=} [properties] Properties to set
         * @returns {CDOTAUserMsg_ClientLoadGridNav} CDOTAUserMsg_ClientLoadGridNav instance
         */
        CDOTAUserMsg_ClientLoadGridNav.create = function create(properties) {
            return new CDOTAUserMsg_ClientLoadGridNav(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ClientLoadGridNav message. Does not implicitly {@link CDOTAUserMsg_ClientLoadGridNav.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_ClientLoadGridNav
         * @static
         * @param {ICDOTAUserMsg_ClientLoadGridNav} message CDOTAUserMsg_ClientLoadGridNav message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ClientLoadGridNav.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ClientLoadGridNav message, length delimited. Does not implicitly {@link CDOTAUserMsg_ClientLoadGridNav.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_ClientLoadGridNav
         * @static
         * @param {ICDOTAUserMsg_ClientLoadGridNav} message CDOTAUserMsg_ClientLoadGridNav message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ClientLoadGridNav.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_ClientLoadGridNav message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_ClientLoadGridNav
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_ClientLoadGridNav} CDOTAUserMsg_ClientLoadGridNav
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ClientLoadGridNav.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_ClientLoadGridNav();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_ClientLoadGridNav message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_ClientLoadGridNav
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_ClientLoadGridNav} CDOTAUserMsg_ClientLoadGridNav
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ClientLoadGridNav.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_ClientLoadGridNav message.
         * @function verify
         * @memberof CDOTAUserMsg_ClientLoadGridNav
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_ClientLoadGridNav.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_ClientLoadGridNav message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_ClientLoadGridNav
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_ClientLoadGridNav} CDOTAUserMsg_ClientLoadGridNav
         */
        CDOTAUserMsg_ClientLoadGridNav.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_ClientLoadGridNav)
                return object;
            return new $root.CDOTAUserMsg_ClientLoadGridNav();
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_ClientLoadGridNav message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_ClientLoadGridNav
         * @static
         * @param {CDOTAUserMsg_ClientLoadGridNav} message CDOTAUserMsg_ClientLoadGridNav
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_ClientLoadGridNav.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CDOTAUserMsg_ClientLoadGridNav to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_ClientLoadGridNav
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_ClientLoadGridNav.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_ClientLoadGridNav;
    })();
    
    $root.CDOTAUserMsg_TE_Projectile = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_TE_Projectile.
         * @exports ICDOTAUserMsg_TE_Projectile
         * @interface ICDOTAUserMsg_TE_Projectile
         * @property {number|null} [hSource] CDOTAUserMsg_TE_Projectile hSource
         * @property {number|null} [hTarget] CDOTAUserMsg_TE_Projectile hTarget
         * @property {number|null} [moveSpeed] CDOTAUserMsg_TE_Projectile moveSpeed
         * @property {number|null} [sourceAttachment] CDOTAUserMsg_TE_Projectile sourceAttachment
         * @property {number|Long|null} [particleSystemHandle] CDOTAUserMsg_TE_Projectile particleSystemHandle
         * @property {boolean|null} [dodgeable] CDOTAUserMsg_TE_Projectile dodgeable
         * @property {boolean|null} [isAttack] CDOTAUserMsg_TE_Projectile isAttack
         * @property {number|null} [expireTime] CDOTAUserMsg_TE_Projectile expireTime
         * @property {number|null} [maximpacttime] CDOTAUserMsg_TE_Projectile maximpacttime
         * @property {number|null} [colorgemcolor] CDOTAUserMsg_TE_Projectile colorgemcolor
         * @property {number|null} [launch_tick] CDOTAUserMsg_TE_Projectile launch_tick
         * @property {number|null} [handle] CDOTAUserMsg_TE_Projectile handle
         * @property {ICMsgVector|null} [vTargetLoc] CDOTAUserMsg_TE_Projectile vTargetLoc
         */
    
        /**
         * Constructs a new CDOTAUserMsg_TE_Projectile.
         * @exports CDOTAUserMsg_TE_Projectile
         * @classdesc Represents a CDOTAUserMsg_TE_Projectile.
         * @implements ICDOTAUserMsg_TE_Projectile
         * @constructor
         * @param {ICDOTAUserMsg_TE_Projectile=} [properties] Properties to set
         */
        function CDOTAUserMsg_TE_Projectile(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_TE_Projectile hSource.
         * @member {number} hSource
         * @memberof CDOTAUserMsg_TE_Projectile
         * @instance
         */
        CDOTAUserMsg_TE_Projectile.prototype.hSource = 0;
    
        /**
         * CDOTAUserMsg_TE_Projectile hTarget.
         * @member {number} hTarget
         * @memberof CDOTAUserMsg_TE_Projectile
         * @instance
         */
        CDOTAUserMsg_TE_Projectile.prototype.hTarget = 0;
    
        /**
         * CDOTAUserMsg_TE_Projectile moveSpeed.
         * @member {number} moveSpeed
         * @memberof CDOTAUserMsg_TE_Projectile
         * @instance
         */
        CDOTAUserMsg_TE_Projectile.prototype.moveSpeed = 0;
    
        /**
         * CDOTAUserMsg_TE_Projectile sourceAttachment.
         * @member {number} sourceAttachment
         * @memberof CDOTAUserMsg_TE_Projectile
         * @instance
         */
        CDOTAUserMsg_TE_Projectile.prototype.sourceAttachment = 0;
    
        /**
         * CDOTAUserMsg_TE_Projectile particleSystemHandle.
         * @member {number|Long} particleSystemHandle
         * @memberof CDOTAUserMsg_TE_Projectile
         * @instance
         */
        CDOTAUserMsg_TE_Projectile.prototype.particleSystemHandle = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CDOTAUserMsg_TE_Projectile dodgeable.
         * @member {boolean} dodgeable
         * @memberof CDOTAUserMsg_TE_Projectile
         * @instance
         */
        CDOTAUserMsg_TE_Projectile.prototype.dodgeable = false;
    
        /**
         * CDOTAUserMsg_TE_Projectile isAttack.
         * @member {boolean} isAttack
         * @memberof CDOTAUserMsg_TE_Projectile
         * @instance
         */
        CDOTAUserMsg_TE_Projectile.prototype.isAttack = false;
    
        /**
         * CDOTAUserMsg_TE_Projectile expireTime.
         * @member {number} expireTime
         * @memberof CDOTAUserMsg_TE_Projectile
         * @instance
         */
        CDOTAUserMsg_TE_Projectile.prototype.expireTime = 0;
    
        /**
         * CDOTAUserMsg_TE_Projectile maximpacttime.
         * @member {number} maximpacttime
         * @memberof CDOTAUserMsg_TE_Projectile
         * @instance
         */
        CDOTAUserMsg_TE_Projectile.prototype.maximpacttime = 0;
    
        /**
         * CDOTAUserMsg_TE_Projectile colorgemcolor.
         * @member {number} colorgemcolor
         * @memberof CDOTAUserMsg_TE_Projectile
         * @instance
         */
        CDOTAUserMsg_TE_Projectile.prototype.colorgemcolor = 0;
    
        /**
         * CDOTAUserMsg_TE_Projectile launch_tick.
         * @member {number} launch_tick
         * @memberof CDOTAUserMsg_TE_Projectile
         * @instance
         */
        CDOTAUserMsg_TE_Projectile.prototype.launch_tick = 0;
    
        /**
         * CDOTAUserMsg_TE_Projectile handle.
         * @member {number} handle
         * @memberof CDOTAUserMsg_TE_Projectile
         * @instance
         */
        CDOTAUserMsg_TE_Projectile.prototype.handle = 0;
    
        /**
         * CDOTAUserMsg_TE_Projectile vTargetLoc.
         * @member {ICMsgVector|null|undefined} vTargetLoc
         * @memberof CDOTAUserMsg_TE_Projectile
         * @instance
         */
        CDOTAUserMsg_TE_Projectile.prototype.vTargetLoc = null;
    
        /**
         * Creates a new CDOTAUserMsg_TE_Projectile instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_TE_Projectile
         * @static
         * @param {ICDOTAUserMsg_TE_Projectile=} [properties] Properties to set
         * @returns {CDOTAUserMsg_TE_Projectile} CDOTAUserMsg_TE_Projectile instance
         */
        CDOTAUserMsg_TE_Projectile.create = function create(properties) {
            return new CDOTAUserMsg_TE_Projectile(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TE_Projectile message. Does not implicitly {@link CDOTAUserMsg_TE_Projectile.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_TE_Projectile
         * @static
         * @param {ICDOTAUserMsg_TE_Projectile} message CDOTAUserMsg_TE_Projectile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TE_Projectile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hSource != null && Object.hasOwnProperty.call(message, "hSource"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hSource);
            if (message.hTarget != null && Object.hasOwnProperty.call(message, "hTarget"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.hTarget);
            if (message.moveSpeed != null && Object.hasOwnProperty.call(message, "moveSpeed"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.moveSpeed);
            if (message.sourceAttachment != null && Object.hasOwnProperty.call(message, "sourceAttachment"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.sourceAttachment);
            if (message.particleSystemHandle != null && Object.hasOwnProperty.call(message, "particleSystemHandle"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.particleSystemHandle);
            if (message.dodgeable != null && Object.hasOwnProperty.call(message, "dodgeable"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.dodgeable);
            if (message.isAttack != null && Object.hasOwnProperty.call(message, "isAttack"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isAttack);
            if (message.expireTime != null && Object.hasOwnProperty.call(message, "expireTime"))
                writer.uint32(/* id 9, wireType 5 =*/77).float(message.expireTime);
            if (message.maximpacttime != null && Object.hasOwnProperty.call(message, "maximpacttime"))
                writer.uint32(/* id 10, wireType 5 =*/85).float(message.maximpacttime);
            if (message.colorgemcolor != null && Object.hasOwnProperty.call(message, "colorgemcolor"))
                writer.uint32(/* id 11, wireType 5 =*/93).fixed32(message.colorgemcolor);
            if (message.launch_tick != null && Object.hasOwnProperty.call(message, "launch_tick"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.launch_tick);
            if (message.handle != null && Object.hasOwnProperty.call(message, "handle"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.handle);
            if (message.vTargetLoc != null && Object.hasOwnProperty.call(message, "vTargetLoc"))
                $root.CMsgVector.encode(message.vTargetLoc, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TE_Projectile message, length delimited. Does not implicitly {@link CDOTAUserMsg_TE_Projectile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_TE_Projectile
         * @static
         * @param {ICDOTAUserMsg_TE_Projectile} message CDOTAUserMsg_TE_Projectile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TE_Projectile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_TE_Projectile message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_TE_Projectile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_TE_Projectile} CDOTAUserMsg_TE_Projectile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TE_Projectile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_TE_Projectile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hSource = reader.int32();
                    break;
                case 2:
                    message.hTarget = reader.int32();
                    break;
                case 3:
                    message.moveSpeed = reader.int32();
                    break;
                case 4:
                    message.sourceAttachment = reader.int32();
                    break;
                case 5:
                    message.particleSystemHandle = reader.int64();
                    break;
                case 6:
                    message.dodgeable = reader.bool();
                    break;
                case 7:
                    message.isAttack = reader.bool();
                    break;
                case 9:
                    message.expireTime = reader.float();
                    break;
                case 10:
                    message.maximpacttime = reader.float();
                    break;
                case 11:
                    message.colorgemcolor = reader.fixed32();
                    break;
                case 12:
                    message.launch_tick = reader.int32();
                    break;
                case 13:
                    message.handle = reader.int32();
                    break;
                case 14:
                    message.vTargetLoc = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_TE_Projectile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_TE_Projectile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_TE_Projectile} CDOTAUserMsg_TE_Projectile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TE_Projectile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_TE_Projectile message.
         * @function verify
         * @memberof CDOTAUserMsg_TE_Projectile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_TE_Projectile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hSource != null && message.hasOwnProperty("hSource"))
                if (!$util.isInteger(message.hSource))
                    return "hSource: integer expected";
            if (message.hTarget != null && message.hasOwnProperty("hTarget"))
                if (!$util.isInteger(message.hTarget))
                    return "hTarget: integer expected";
            if (message.moveSpeed != null && message.hasOwnProperty("moveSpeed"))
                if (!$util.isInteger(message.moveSpeed))
                    return "moveSpeed: integer expected";
            if (message.sourceAttachment != null && message.hasOwnProperty("sourceAttachment"))
                if (!$util.isInteger(message.sourceAttachment))
                    return "sourceAttachment: integer expected";
            if (message.particleSystemHandle != null && message.hasOwnProperty("particleSystemHandle"))
                if (!$util.isInteger(message.particleSystemHandle) && !(message.particleSystemHandle && $util.isInteger(message.particleSystemHandle.low) && $util.isInteger(message.particleSystemHandle.high)))
                    return "particleSystemHandle: integer|Long expected";
            if (message.dodgeable != null && message.hasOwnProperty("dodgeable"))
                if (typeof message.dodgeable !== "boolean")
                    return "dodgeable: boolean expected";
            if (message.isAttack != null && message.hasOwnProperty("isAttack"))
                if (typeof message.isAttack !== "boolean")
                    return "isAttack: boolean expected";
            if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                if (typeof message.expireTime !== "number")
                    return "expireTime: number expected";
            if (message.maximpacttime != null && message.hasOwnProperty("maximpacttime"))
                if (typeof message.maximpacttime !== "number")
                    return "maximpacttime: number expected";
            if (message.colorgemcolor != null && message.hasOwnProperty("colorgemcolor"))
                if (!$util.isInteger(message.colorgemcolor))
                    return "colorgemcolor: integer expected";
            if (message.launch_tick != null && message.hasOwnProperty("launch_tick"))
                if (!$util.isInteger(message.launch_tick))
                    return "launch_tick: integer expected";
            if (message.handle != null && message.hasOwnProperty("handle"))
                if (!$util.isInteger(message.handle))
                    return "handle: integer expected";
            if (message.vTargetLoc != null && message.hasOwnProperty("vTargetLoc")) {
                var error = $root.CMsgVector.verify(message.vTargetLoc);
                if (error)
                    return "vTargetLoc." + error;
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_TE_Projectile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_TE_Projectile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_TE_Projectile} CDOTAUserMsg_TE_Projectile
         */
        CDOTAUserMsg_TE_Projectile.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_TE_Projectile)
                return object;
            var message = new $root.CDOTAUserMsg_TE_Projectile();
            if (object.hSource != null)
                message.hSource = object.hSource | 0;
            if (object.hTarget != null)
                message.hTarget = object.hTarget | 0;
            if (object.moveSpeed != null)
                message.moveSpeed = object.moveSpeed | 0;
            if (object.sourceAttachment != null)
                message.sourceAttachment = object.sourceAttachment | 0;
            if (object.particleSystemHandle != null)
                if ($util.Long)
                    (message.particleSystemHandle = $util.Long.fromValue(object.particleSystemHandle)).unsigned = false;
                else if (typeof object.particleSystemHandle === "string")
                    message.particleSystemHandle = parseInt(object.particleSystemHandle, 10);
                else if (typeof object.particleSystemHandle === "number")
                    message.particleSystemHandle = object.particleSystemHandle;
                else if (typeof object.particleSystemHandle === "object")
                    message.particleSystemHandle = new $util.LongBits(object.particleSystemHandle.low >>> 0, object.particleSystemHandle.high >>> 0).toNumber();
            if (object.dodgeable != null)
                message.dodgeable = Boolean(object.dodgeable);
            if (object.isAttack != null)
                message.isAttack = Boolean(object.isAttack);
            if (object.expireTime != null)
                message.expireTime = Number(object.expireTime);
            if (object.maximpacttime != null)
                message.maximpacttime = Number(object.maximpacttime);
            if (object.colorgemcolor != null)
                message.colorgemcolor = object.colorgemcolor >>> 0;
            if (object.launch_tick != null)
                message.launch_tick = object.launch_tick | 0;
            if (object.handle != null)
                message.handle = object.handle | 0;
            if (object.vTargetLoc != null) {
                if (typeof object.vTargetLoc !== "object")
                    throw TypeError(".CDOTAUserMsg_TE_Projectile.vTargetLoc: object expected");
                message.vTargetLoc = $root.CMsgVector.fromObject(object.vTargetLoc);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_TE_Projectile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_TE_Projectile
         * @static
         * @param {CDOTAUserMsg_TE_Projectile} message CDOTAUserMsg_TE_Projectile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_TE_Projectile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.hSource = 0;
                object.hTarget = 0;
                object.moveSpeed = 0;
                object.sourceAttachment = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.particleSystemHandle = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.particleSystemHandle = options.longs === String ? "0" : 0;
                object.dodgeable = false;
                object.isAttack = false;
                object.expireTime = 0;
                object.maximpacttime = 0;
                object.colorgemcolor = 0;
                object.launch_tick = 0;
                object.handle = 0;
                object.vTargetLoc = null;
            }
            if (message.hSource != null && message.hasOwnProperty("hSource"))
                object.hSource = message.hSource;
            if (message.hTarget != null && message.hasOwnProperty("hTarget"))
                object.hTarget = message.hTarget;
            if (message.moveSpeed != null && message.hasOwnProperty("moveSpeed"))
                object.moveSpeed = message.moveSpeed;
            if (message.sourceAttachment != null && message.hasOwnProperty("sourceAttachment"))
                object.sourceAttachment = message.sourceAttachment;
            if (message.particleSystemHandle != null && message.hasOwnProperty("particleSystemHandle"))
                if (typeof message.particleSystemHandle === "number")
                    object.particleSystemHandle = options.longs === String ? String(message.particleSystemHandle) : message.particleSystemHandle;
                else
                    object.particleSystemHandle = options.longs === String ? $util.Long.prototype.toString.call(message.particleSystemHandle) : options.longs === Number ? new $util.LongBits(message.particleSystemHandle.low >>> 0, message.particleSystemHandle.high >>> 0).toNumber() : message.particleSystemHandle;
            if (message.dodgeable != null && message.hasOwnProperty("dodgeable"))
                object.dodgeable = message.dodgeable;
            if (message.isAttack != null && message.hasOwnProperty("isAttack"))
                object.isAttack = message.isAttack;
            if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                object.expireTime = options.json && !isFinite(message.expireTime) ? String(message.expireTime) : message.expireTime;
            if (message.maximpacttime != null && message.hasOwnProperty("maximpacttime"))
                object.maximpacttime = options.json && !isFinite(message.maximpacttime) ? String(message.maximpacttime) : message.maximpacttime;
            if (message.colorgemcolor != null && message.hasOwnProperty("colorgemcolor"))
                object.colorgemcolor = message.colorgemcolor;
            if (message.launch_tick != null && message.hasOwnProperty("launch_tick"))
                object.launch_tick = message.launch_tick;
            if (message.handle != null && message.hasOwnProperty("handle"))
                object.handle = message.handle;
            if (message.vTargetLoc != null && message.hasOwnProperty("vTargetLoc"))
                object.vTargetLoc = $root.CMsgVector.toObject(message.vTargetLoc, options);
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_TE_Projectile to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_TE_Projectile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_TE_Projectile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_TE_Projectile;
    })();
    
    $root.CDOTAUserMsg_TE_ProjectileLoc = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_TE_ProjectileLoc.
         * @exports ICDOTAUserMsg_TE_ProjectileLoc
         * @interface ICDOTAUserMsg_TE_ProjectileLoc
         * @property {ICMsgVector|null} [vSourceLoc] CDOTAUserMsg_TE_ProjectileLoc vSourceLoc
         * @property {number|null} [hTarget] CDOTAUserMsg_TE_ProjectileLoc hTarget
         * @property {number|null} [moveSpeed] CDOTAUserMsg_TE_ProjectileLoc moveSpeed
         * @property {number|Long|null} [particleSystemHandle] CDOTAUserMsg_TE_ProjectileLoc particleSystemHandle
         * @property {boolean|null} [dodgeable] CDOTAUserMsg_TE_ProjectileLoc dodgeable
         * @property {boolean|null} [isAttack] CDOTAUserMsg_TE_ProjectileLoc isAttack
         * @property {number|null} [expireTime] CDOTAUserMsg_TE_ProjectileLoc expireTime
         * @property {ICMsgVector|null} [vTargetLoc] CDOTAUserMsg_TE_ProjectileLoc vTargetLoc
         * @property {number|null} [colorgemcolor] CDOTAUserMsg_TE_ProjectileLoc colorgemcolor
         * @property {number|null} [launch_tick] CDOTAUserMsg_TE_ProjectileLoc launch_tick
         * @property {number|null} [handle] CDOTAUserMsg_TE_ProjectileLoc handle
         */
    
        /**
         * Constructs a new CDOTAUserMsg_TE_ProjectileLoc.
         * @exports CDOTAUserMsg_TE_ProjectileLoc
         * @classdesc Represents a CDOTAUserMsg_TE_ProjectileLoc.
         * @implements ICDOTAUserMsg_TE_ProjectileLoc
         * @constructor
         * @param {ICDOTAUserMsg_TE_ProjectileLoc=} [properties] Properties to set
         */
        function CDOTAUserMsg_TE_ProjectileLoc(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_TE_ProjectileLoc vSourceLoc.
         * @member {ICMsgVector|null|undefined} vSourceLoc
         * @memberof CDOTAUserMsg_TE_ProjectileLoc
         * @instance
         */
        CDOTAUserMsg_TE_ProjectileLoc.prototype.vSourceLoc = null;
    
        /**
         * CDOTAUserMsg_TE_ProjectileLoc hTarget.
         * @member {number} hTarget
         * @memberof CDOTAUserMsg_TE_ProjectileLoc
         * @instance
         */
        CDOTAUserMsg_TE_ProjectileLoc.prototype.hTarget = 0;
    
        /**
         * CDOTAUserMsg_TE_ProjectileLoc moveSpeed.
         * @member {number} moveSpeed
         * @memberof CDOTAUserMsg_TE_ProjectileLoc
         * @instance
         */
        CDOTAUserMsg_TE_ProjectileLoc.prototype.moveSpeed = 0;
    
        /**
         * CDOTAUserMsg_TE_ProjectileLoc particleSystemHandle.
         * @member {number|Long} particleSystemHandle
         * @memberof CDOTAUserMsg_TE_ProjectileLoc
         * @instance
         */
        CDOTAUserMsg_TE_ProjectileLoc.prototype.particleSystemHandle = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CDOTAUserMsg_TE_ProjectileLoc dodgeable.
         * @member {boolean} dodgeable
         * @memberof CDOTAUserMsg_TE_ProjectileLoc
         * @instance
         */
        CDOTAUserMsg_TE_ProjectileLoc.prototype.dodgeable = false;
    
        /**
         * CDOTAUserMsg_TE_ProjectileLoc isAttack.
         * @member {boolean} isAttack
         * @memberof CDOTAUserMsg_TE_ProjectileLoc
         * @instance
         */
        CDOTAUserMsg_TE_ProjectileLoc.prototype.isAttack = false;
    
        /**
         * CDOTAUserMsg_TE_ProjectileLoc expireTime.
         * @member {number} expireTime
         * @memberof CDOTAUserMsg_TE_ProjectileLoc
         * @instance
         */
        CDOTAUserMsg_TE_ProjectileLoc.prototype.expireTime = 0;
    
        /**
         * CDOTAUserMsg_TE_ProjectileLoc vTargetLoc.
         * @member {ICMsgVector|null|undefined} vTargetLoc
         * @memberof CDOTAUserMsg_TE_ProjectileLoc
         * @instance
         */
        CDOTAUserMsg_TE_ProjectileLoc.prototype.vTargetLoc = null;
    
        /**
         * CDOTAUserMsg_TE_ProjectileLoc colorgemcolor.
         * @member {number} colorgemcolor
         * @memberof CDOTAUserMsg_TE_ProjectileLoc
         * @instance
         */
        CDOTAUserMsg_TE_ProjectileLoc.prototype.colorgemcolor = 0;
    
        /**
         * CDOTAUserMsg_TE_ProjectileLoc launch_tick.
         * @member {number} launch_tick
         * @memberof CDOTAUserMsg_TE_ProjectileLoc
         * @instance
         */
        CDOTAUserMsg_TE_ProjectileLoc.prototype.launch_tick = 0;
    
        /**
         * CDOTAUserMsg_TE_ProjectileLoc handle.
         * @member {number} handle
         * @memberof CDOTAUserMsg_TE_ProjectileLoc
         * @instance
         */
        CDOTAUserMsg_TE_ProjectileLoc.prototype.handle = 0;
    
        /**
         * Creates a new CDOTAUserMsg_TE_ProjectileLoc instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_TE_ProjectileLoc
         * @static
         * @param {ICDOTAUserMsg_TE_ProjectileLoc=} [properties] Properties to set
         * @returns {CDOTAUserMsg_TE_ProjectileLoc} CDOTAUserMsg_TE_ProjectileLoc instance
         */
        CDOTAUserMsg_TE_ProjectileLoc.create = function create(properties) {
            return new CDOTAUserMsg_TE_ProjectileLoc(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TE_ProjectileLoc message. Does not implicitly {@link CDOTAUserMsg_TE_ProjectileLoc.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_TE_ProjectileLoc
         * @static
         * @param {ICDOTAUserMsg_TE_ProjectileLoc} message CDOTAUserMsg_TE_ProjectileLoc message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TE_ProjectileLoc.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.vSourceLoc != null && Object.hasOwnProperty.call(message, "vSourceLoc"))
                $root.CMsgVector.encode(message.vSourceLoc, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.hTarget != null && Object.hasOwnProperty.call(message, "hTarget"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.hTarget);
            if (message.moveSpeed != null && Object.hasOwnProperty.call(message, "moveSpeed"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.moveSpeed);
            if (message.particleSystemHandle != null && Object.hasOwnProperty.call(message, "particleSystemHandle"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.particleSystemHandle);
            if (message.dodgeable != null && Object.hasOwnProperty.call(message, "dodgeable"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.dodgeable);
            if (message.isAttack != null && Object.hasOwnProperty.call(message, "isAttack"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isAttack);
            if (message.expireTime != null && Object.hasOwnProperty.call(message, "expireTime"))
                writer.uint32(/* id 9, wireType 5 =*/77).float(message.expireTime);
            if (message.vTargetLoc != null && Object.hasOwnProperty.call(message, "vTargetLoc"))
                $root.CMsgVector.encode(message.vTargetLoc, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.colorgemcolor != null && Object.hasOwnProperty.call(message, "colorgemcolor"))
                writer.uint32(/* id 11, wireType 5 =*/93).fixed32(message.colorgemcolor);
            if (message.launch_tick != null && Object.hasOwnProperty.call(message, "launch_tick"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.launch_tick);
            if (message.handle != null && Object.hasOwnProperty.call(message, "handle"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.handle);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TE_ProjectileLoc message, length delimited. Does not implicitly {@link CDOTAUserMsg_TE_ProjectileLoc.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_TE_ProjectileLoc
         * @static
         * @param {ICDOTAUserMsg_TE_ProjectileLoc} message CDOTAUserMsg_TE_ProjectileLoc message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TE_ProjectileLoc.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_TE_ProjectileLoc message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_TE_ProjectileLoc
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_TE_ProjectileLoc} CDOTAUserMsg_TE_ProjectileLoc
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TE_ProjectileLoc.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_TE_ProjectileLoc();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.vSourceLoc = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.hTarget = reader.int32();
                    break;
                case 3:
                    message.moveSpeed = reader.int32();
                    break;
                case 4:
                    message.particleSystemHandle = reader.int64();
                    break;
                case 5:
                    message.dodgeable = reader.bool();
                    break;
                case 6:
                    message.isAttack = reader.bool();
                    break;
                case 9:
                    message.expireTime = reader.float();
                    break;
                case 10:
                    message.vTargetLoc = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.colorgemcolor = reader.fixed32();
                    break;
                case 12:
                    message.launch_tick = reader.int32();
                    break;
                case 13:
                    message.handle = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_TE_ProjectileLoc message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_TE_ProjectileLoc
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_TE_ProjectileLoc} CDOTAUserMsg_TE_ProjectileLoc
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TE_ProjectileLoc.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_TE_ProjectileLoc message.
         * @function verify
         * @memberof CDOTAUserMsg_TE_ProjectileLoc
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_TE_ProjectileLoc.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.vSourceLoc != null && message.hasOwnProperty("vSourceLoc")) {
                var error = $root.CMsgVector.verify(message.vSourceLoc);
                if (error)
                    return "vSourceLoc." + error;
            }
            if (message.hTarget != null && message.hasOwnProperty("hTarget"))
                if (!$util.isInteger(message.hTarget))
                    return "hTarget: integer expected";
            if (message.moveSpeed != null && message.hasOwnProperty("moveSpeed"))
                if (!$util.isInteger(message.moveSpeed))
                    return "moveSpeed: integer expected";
            if (message.particleSystemHandle != null && message.hasOwnProperty("particleSystemHandle"))
                if (!$util.isInteger(message.particleSystemHandle) && !(message.particleSystemHandle && $util.isInteger(message.particleSystemHandle.low) && $util.isInteger(message.particleSystemHandle.high)))
                    return "particleSystemHandle: integer|Long expected";
            if (message.dodgeable != null && message.hasOwnProperty("dodgeable"))
                if (typeof message.dodgeable !== "boolean")
                    return "dodgeable: boolean expected";
            if (message.isAttack != null && message.hasOwnProperty("isAttack"))
                if (typeof message.isAttack !== "boolean")
                    return "isAttack: boolean expected";
            if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                if (typeof message.expireTime !== "number")
                    return "expireTime: number expected";
            if (message.vTargetLoc != null && message.hasOwnProperty("vTargetLoc")) {
                var error = $root.CMsgVector.verify(message.vTargetLoc);
                if (error)
                    return "vTargetLoc." + error;
            }
            if (message.colorgemcolor != null && message.hasOwnProperty("colorgemcolor"))
                if (!$util.isInteger(message.colorgemcolor))
                    return "colorgemcolor: integer expected";
            if (message.launch_tick != null && message.hasOwnProperty("launch_tick"))
                if (!$util.isInteger(message.launch_tick))
                    return "launch_tick: integer expected";
            if (message.handle != null && message.hasOwnProperty("handle"))
                if (!$util.isInteger(message.handle))
                    return "handle: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_TE_ProjectileLoc message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_TE_ProjectileLoc
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_TE_ProjectileLoc} CDOTAUserMsg_TE_ProjectileLoc
         */
        CDOTAUserMsg_TE_ProjectileLoc.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_TE_ProjectileLoc)
                return object;
            var message = new $root.CDOTAUserMsg_TE_ProjectileLoc();
            if (object.vSourceLoc != null) {
                if (typeof object.vSourceLoc !== "object")
                    throw TypeError(".CDOTAUserMsg_TE_ProjectileLoc.vSourceLoc: object expected");
                message.vSourceLoc = $root.CMsgVector.fromObject(object.vSourceLoc);
            }
            if (object.hTarget != null)
                message.hTarget = object.hTarget | 0;
            if (object.moveSpeed != null)
                message.moveSpeed = object.moveSpeed | 0;
            if (object.particleSystemHandle != null)
                if ($util.Long)
                    (message.particleSystemHandle = $util.Long.fromValue(object.particleSystemHandle)).unsigned = false;
                else if (typeof object.particleSystemHandle === "string")
                    message.particleSystemHandle = parseInt(object.particleSystemHandle, 10);
                else if (typeof object.particleSystemHandle === "number")
                    message.particleSystemHandle = object.particleSystemHandle;
                else if (typeof object.particleSystemHandle === "object")
                    message.particleSystemHandle = new $util.LongBits(object.particleSystemHandle.low >>> 0, object.particleSystemHandle.high >>> 0).toNumber();
            if (object.dodgeable != null)
                message.dodgeable = Boolean(object.dodgeable);
            if (object.isAttack != null)
                message.isAttack = Boolean(object.isAttack);
            if (object.expireTime != null)
                message.expireTime = Number(object.expireTime);
            if (object.vTargetLoc != null) {
                if (typeof object.vTargetLoc !== "object")
                    throw TypeError(".CDOTAUserMsg_TE_ProjectileLoc.vTargetLoc: object expected");
                message.vTargetLoc = $root.CMsgVector.fromObject(object.vTargetLoc);
            }
            if (object.colorgemcolor != null)
                message.colorgemcolor = object.colorgemcolor >>> 0;
            if (object.launch_tick != null)
                message.launch_tick = object.launch_tick | 0;
            if (object.handle != null)
                message.handle = object.handle | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_TE_ProjectileLoc message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_TE_ProjectileLoc
         * @static
         * @param {CDOTAUserMsg_TE_ProjectileLoc} message CDOTAUserMsg_TE_ProjectileLoc
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_TE_ProjectileLoc.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.vSourceLoc = null;
                object.hTarget = 0;
                object.moveSpeed = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.particleSystemHandle = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.particleSystemHandle = options.longs === String ? "0" : 0;
                object.dodgeable = false;
                object.isAttack = false;
                object.expireTime = 0;
                object.vTargetLoc = null;
                object.colorgemcolor = 0;
                object.launch_tick = 0;
                object.handle = 0;
            }
            if (message.vSourceLoc != null && message.hasOwnProperty("vSourceLoc"))
                object.vSourceLoc = $root.CMsgVector.toObject(message.vSourceLoc, options);
            if (message.hTarget != null && message.hasOwnProperty("hTarget"))
                object.hTarget = message.hTarget;
            if (message.moveSpeed != null && message.hasOwnProperty("moveSpeed"))
                object.moveSpeed = message.moveSpeed;
            if (message.particleSystemHandle != null && message.hasOwnProperty("particleSystemHandle"))
                if (typeof message.particleSystemHandle === "number")
                    object.particleSystemHandle = options.longs === String ? String(message.particleSystemHandle) : message.particleSystemHandle;
                else
                    object.particleSystemHandle = options.longs === String ? $util.Long.prototype.toString.call(message.particleSystemHandle) : options.longs === Number ? new $util.LongBits(message.particleSystemHandle.low >>> 0, message.particleSystemHandle.high >>> 0).toNumber() : message.particleSystemHandle;
            if (message.dodgeable != null && message.hasOwnProperty("dodgeable"))
                object.dodgeable = message.dodgeable;
            if (message.isAttack != null && message.hasOwnProperty("isAttack"))
                object.isAttack = message.isAttack;
            if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                object.expireTime = options.json && !isFinite(message.expireTime) ? String(message.expireTime) : message.expireTime;
            if (message.vTargetLoc != null && message.hasOwnProperty("vTargetLoc"))
                object.vTargetLoc = $root.CMsgVector.toObject(message.vTargetLoc, options);
            if (message.colorgemcolor != null && message.hasOwnProperty("colorgemcolor"))
                object.colorgemcolor = message.colorgemcolor;
            if (message.launch_tick != null && message.hasOwnProperty("launch_tick"))
                object.launch_tick = message.launch_tick;
            if (message.handle != null && message.hasOwnProperty("handle"))
                object.handle = message.handle;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_TE_ProjectileLoc to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_TE_ProjectileLoc
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_TE_ProjectileLoc.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_TE_ProjectileLoc;
    })();
    
    $root.CDOTAUserMsg_TE_DestroyProjectile = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_TE_DestroyProjectile.
         * @exports ICDOTAUserMsg_TE_DestroyProjectile
         * @interface ICDOTAUserMsg_TE_DestroyProjectile
         * @property {number|null} [handle] CDOTAUserMsg_TE_DestroyProjectile handle
         */
    
        /**
         * Constructs a new CDOTAUserMsg_TE_DestroyProjectile.
         * @exports CDOTAUserMsg_TE_DestroyProjectile
         * @classdesc Represents a CDOTAUserMsg_TE_DestroyProjectile.
         * @implements ICDOTAUserMsg_TE_DestroyProjectile
         * @constructor
         * @param {ICDOTAUserMsg_TE_DestroyProjectile=} [properties] Properties to set
         */
        function CDOTAUserMsg_TE_DestroyProjectile(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_TE_DestroyProjectile handle.
         * @member {number} handle
         * @memberof CDOTAUserMsg_TE_DestroyProjectile
         * @instance
         */
        CDOTAUserMsg_TE_DestroyProjectile.prototype.handle = 0;
    
        /**
         * Creates a new CDOTAUserMsg_TE_DestroyProjectile instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_TE_DestroyProjectile
         * @static
         * @param {ICDOTAUserMsg_TE_DestroyProjectile=} [properties] Properties to set
         * @returns {CDOTAUserMsg_TE_DestroyProjectile} CDOTAUserMsg_TE_DestroyProjectile instance
         */
        CDOTAUserMsg_TE_DestroyProjectile.create = function create(properties) {
            return new CDOTAUserMsg_TE_DestroyProjectile(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TE_DestroyProjectile message. Does not implicitly {@link CDOTAUserMsg_TE_DestroyProjectile.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_TE_DestroyProjectile
         * @static
         * @param {ICDOTAUserMsg_TE_DestroyProjectile} message CDOTAUserMsg_TE_DestroyProjectile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TE_DestroyProjectile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.handle != null && Object.hasOwnProperty.call(message, "handle"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.handle);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TE_DestroyProjectile message, length delimited. Does not implicitly {@link CDOTAUserMsg_TE_DestroyProjectile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_TE_DestroyProjectile
         * @static
         * @param {ICDOTAUserMsg_TE_DestroyProjectile} message CDOTAUserMsg_TE_DestroyProjectile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TE_DestroyProjectile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_TE_DestroyProjectile message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_TE_DestroyProjectile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_TE_DestroyProjectile} CDOTAUserMsg_TE_DestroyProjectile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TE_DestroyProjectile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_TE_DestroyProjectile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.handle = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_TE_DestroyProjectile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_TE_DestroyProjectile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_TE_DestroyProjectile} CDOTAUserMsg_TE_DestroyProjectile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TE_DestroyProjectile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_TE_DestroyProjectile message.
         * @function verify
         * @memberof CDOTAUserMsg_TE_DestroyProjectile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_TE_DestroyProjectile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.handle != null && message.hasOwnProperty("handle"))
                if (!$util.isInteger(message.handle))
                    return "handle: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_TE_DestroyProjectile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_TE_DestroyProjectile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_TE_DestroyProjectile} CDOTAUserMsg_TE_DestroyProjectile
         */
        CDOTAUserMsg_TE_DestroyProjectile.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_TE_DestroyProjectile)
                return object;
            var message = new $root.CDOTAUserMsg_TE_DestroyProjectile();
            if (object.handle != null)
                message.handle = object.handle | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_TE_DestroyProjectile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_TE_DestroyProjectile
         * @static
         * @param {CDOTAUserMsg_TE_DestroyProjectile} message CDOTAUserMsg_TE_DestroyProjectile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_TE_DestroyProjectile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.handle = 0;
            if (message.handle != null && message.hasOwnProperty("handle"))
                object.handle = message.handle;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_TE_DestroyProjectile to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_TE_DestroyProjectile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_TE_DestroyProjectile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_TE_DestroyProjectile;
    })();
    
    $root.CDOTAUserMsg_TE_DotaBloodImpact = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_TE_DotaBloodImpact.
         * @exports ICDOTAUserMsg_TE_DotaBloodImpact
         * @interface ICDOTAUserMsg_TE_DotaBloodImpact
         * @property {number|null} [entity] CDOTAUserMsg_TE_DotaBloodImpact entity
         * @property {number|null} [scale] CDOTAUserMsg_TE_DotaBloodImpact scale
         * @property {number|null} [xnormal] CDOTAUserMsg_TE_DotaBloodImpact xnormal
         * @property {number|null} [ynormal] CDOTAUserMsg_TE_DotaBloodImpact ynormal
         */
    
        /**
         * Constructs a new CDOTAUserMsg_TE_DotaBloodImpact.
         * @exports CDOTAUserMsg_TE_DotaBloodImpact
         * @classdesc Represents a CDOTAUserMsg_TE_DotaBloodImpact.
         * @implements ICDOTAUserMsg_TE_DotaBloodImpact
         * @constructor
         * @param {ICDOTAUserMsg_TE_DotaBloodImpact=} [properties] Properties to set
         */
        function CDOTAUserMsg_TE_DotaBloodImpact(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_TE_DotaBloodImpact entity.
         * @member {number} entity
         * @memberof CDOTAUserMsg_TE_DotaBloodImpact
         * @instance
         */
        CDOTAUserMsg_TE_DotaBloodImpact.prototype.entity = 0;
    
        /**
         * CDOTAUserMsg_TE_DotaBloodImpact scale.
         * @member {number} scale
         * @memberof CDOTAUserMsg_TE_DotaBloodImpact
         * @instance
         */
        CDOTAUserMsg_TE_DotaBloodImpact.prototype.scale = 0;
    
        /**
         * CDOTAUserMsg_TE_DotaBloodImpact xnormal.
         * @member {number} xnormal
         * @memberof CDOTAUserMsg_TE_DotaBloodImpact
         * @instance
         */
        CDOTAUserMsg_TE_DotaBloodImpact.prototype.xnormal = 0;
    
        /**
         * CDOTAUserMsg_TE_DotaBloodImpact ynormal.
         * @member {number} ynormal
         * @memberof CDOTAUserMsg_TE_DotaBloodImpact
         * @instance
         */
        CDOTAUserMsg_TE_DotaBloodImpact.prototype.ynormal = 0;
    
        /**
         * Creates a new CDOTAUserMsg_TE_DotaBloodImpact instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_TE_DotaBloodImpact
         * @static
         * @param {ICDOTAUserMsg_TE_DotaBloodImpact=} [properties] Properties to set
         * @returns {CDOTAUserMsg_TE_DotaBloodImpact} CDOTAUserMsg_TE_DotaBloodImpact instance
         */
        CDOTAUserMsg_TE_DotaBloodImpact.create = function create(properties) {
            return new CDOTAUserMsg_TE_DotaBloodImpact(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TE_DotaBloodImpact message. Does not implicitly {@link CDOTAUserMsg_TE_DotaBloodImpact.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_TE_DotaBloodImpact
         * @static
         * @param {ICDOTAUserMsg_TE_DotaBloodImpact} message CDOTAUserMsg_TE_DotaBloodImpact message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TE_DotaBloodImpact.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entity != null && Object.hasOwnProperty.call(message, "entity"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.entity);
            if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.scale);
            if (message.xnormal != null && Object.hasOwnProperty.call(message, "xnormal"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.xnormal);
            if (message.ynormal != null && Object.hasOwnProperty.call(message, "ynormal"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.ynormal);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TE_DotaBloodImpact message, length delimited. Does not implicitly {@link CDOTAUserMsg_TE_DotaBloodImpact.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_TE_DotaBloodImpact
         * @static
         * @param {ICDOTAUserMsg_TE_DotaBloodImpact} message CDOTAUserMsg_TE_DotaBloodImpact message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TE_DotaBloodImpact.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_TE_DotaBloodImpact message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_TE_DotaBloodImpact
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_TE_DotaBloodImpact} CDOTAUserMsg_TE_DotaBloodImpact
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TE_DotaBloodImpact.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_TE_DotaBloodImpact();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.entity = reader.int32();
                    break;
                case 2:
                    message.scale = reader.float();
                    break;
                case 3:
                    message.xnormal = reader.float();
                    break;
                case 4:
                    message.ynormal = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_TE_DotaBloodImpact message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_TE_DotaBloodImpact
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_TE_DotaBloodImpact} CDOTAUserMsg_TE_DotaBloodImpact
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TE_DotaBloodImpact.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_TE_DotaBloodImpact message.
         * @function verify
         * @memberof CDOTAUserMsg_TE_DotaBloodImpact
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_TE_DotaBloodImpact.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entity != null && message.hasOwnProperty("entity"))
                if (!$util.isInteger(message.entity))
                    return "entity: integer expected";
            if (message.scale != null && message.hasOwnProperty("scale"))
                if (typeof message.scale !== "number")
                    return "scale: number expected";
            if (message.xnormal != null && message.hasOwnProperty("xnormal"))
                if (typeof message.xnormal !== "number")
                    return "xnormal: number expected";
            if (message.ynormal != null && message.hasOwnProperty("ynormal"))
                if (typeof message.ynormal !== "number")
                    return "ynormal: number expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_TE_DotaBloodImpact message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_TE_DotaBloodImpact
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_TE_DotaBloodImpact} CDOTAUserMsg_TE_DotaBloodImpact
         */
        CDOTAUserMsg_TE_DotaBloodImpact.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_TE_DotaBloodImpact)
                return object;
            var message = new $root.CDOTAUserMsg_TE_DotaBloodImpact();
            if (object.entity != null)
                message.entity = object.entity | 0;
            if (object.scale != null)
                message.scale = Number(object.scale);
            if (object.xnormal != null)
                message.xnormal = Number(object.xnormal);
            if (object.ynormal != null)
                message.ynormal = Number(object.ynormal);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_TE_DotaBloodImpact message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_TE_DotaBloodImpact
         * @static
         * @param {CDOTAUserMsg_TE_DotaBloodImpact} message CDOTAUserMsg_TE_DotaBloodImpact
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_TE_DotaBloodImpact.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.entity = 0;
                object.scale = 0;
                object.xnormal = 0;
                object.ynormal = 0;
            }
            if (message.entity != null && message.hasOwnProperty("entity"))
                object.entity = message.entity;
            if (message.scale != null && message.hasOwnProperty("scale"))
                object.scale = options.json && !isFinite(message.scale) ? String(message.scale) : message.scale;
            if (message.xnormal != null && message.hasOwnProperty("xnormal"))
                object.xnormal = options.json && !isFinite(message.xnormal) ? String(message.xnormal) : message.xnormal;
            if (message.ynormal != null && message.hasOwnProperty("ynormal"))
                object.ynormal = options.json && !isFinite(message.ynormal) ? String(message.ynormal) : message.ynormal;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_TE_DotaBloodImpact to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_TE_DotaBloodImpact
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_TE_DotaBloodImpact.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_TE_DotaBloodImpact;
    })();
    
    $root.CDOTAUserMsg_AbilityPing = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_AbilityPing.
         * @exports ICDOTAUserMsg_AbilityPing
         * @interface ICDOTAUserMsg_AbilityPing
         * @property {number|null} [player_id] CDOTAUserMsg_AbilityPing player_id
         * @property {number|null} [ability_id] CDOTAUserMsg_AbilityPing ability_id
         * @property {DOTA_ABILITY_PING_TYPE|null} [type] CDOTAUserMsg_AbilityPing type
         * @property {number|null} [cooldown_seconds] CDOTAUserMsg_AbilityPing cooldown_seconds
         * @property {number|null} [level] CDOTAUserMsg_AbilityPing level
         * @property {boolean|null} [passive] CDOTAUserMsg_AbilityPing passive
         * @property {number|null} [mana_needed] CDOTAUserMsg_AbilityPing mana_needed
         * @property {number|null} [entity_id] CDOTAUserMsg_AbilityPing entity_id
         * @property {number|null} [primary_charges] CDOTAUserMsg_AbilityPing primary_charges
         * @property {number|null} [secondary_charges] CDOTAUserMsg_AbilityPing secondary_charges
         * @property {number|null} [caster_id] CDOTAUserMsg_AbilityPing caster_id
         * @property {boolean|null} [ctrl_held] CDOTAUserMsg_AbilityPing ctrl_held
         */
    
        /**
         * Constructs a new CDOTAUserMsg_AbilityPing.
         * @exports CDOTAUserMsg_AbilityPing
         * @classdesc Represents a CDOTAUserMsg_AbilityPing.
         * @implements ICDOTAUserMsg_AbilityPing
         * @constructor
         * @param {ICDOTAUserMsg_AbilityPing=} [properties] Properties to set
         */
        function CDOTAUserMsg_AbilityPing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_AbilityPing player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_AbilityPing
         * @instance
         */
        CDOTAUserMsg_AbilityPing.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_AbilityPing ability_id.
         * @member {number} ability_id
         * @memberof CDOTAUserMsg_AbilityPing
         * @instance
         */
        CDOTAUserMsg_AbilityPing.prototype.ability_id = 0;
    
        /**
         * CDOTAUserMsg_AbilityPing type.
         * @member {DOTA_ABILITY_PING_TYPE} type
         * @memberof CDOTAUserMsg_AbilityPing
         * @instance
         */
        CDOTAUserMsg_AbilityPing.prototype.type = 1;
    
        /**
         * CDOTAUserMsg_AbilityPing cooldown_seconds.
         * @member {number} cooldown_seconds
         * @memberof CDOTAUserMsg_AbilityPing
         * @instance
         */
        CDOTAUserMsg_AbilityPing.prototype.cooldown_seconds = 0;
    
        /**
         * CDOTAUserMsg_AbilityPing level.
         * @member {number} level
         * @memberof CDOTAUserMsg_AbilityPing
         * @instance
         */
        CDOTAUserMsg_AbilityPing.prototype.level = 0;
    
        /**
         * CDOTAUserMsg_AbilityPing passive.
         * @member {boolean} passive
         * @memberof CDOTAUserMsg_AbilityPing
         * @instance
         */
        CDOTAUserMsg_AbilityPing.prototype.passive = false;
    
        /**
         * CDOTAUserMsg_AbilityPing mana_needed.
         * @member {number} mana_needed
         * @memberof CDOTAUserMsg_AbilityPing
         * @instance
         */
        CDOTAUserMsg_AbilityPing.prototype.mana_needed = 0;
    
        /**
         * CDOTAUserMsg_AbilityPing entity_id.
         * @member {number} entity_id
         * @memberof CDOTAUserMsg_AbilityPing
         * @instance
         */
        CDOTAUserMsg_AbilityPing.prototype.entity_id = 0;
    
        /**
         * CDOTAUserMsg_AbilityPing primary_charges.
         * @member {number} primary_charges
         * @memberof CDOTAUserMsg_AbilityPing
         * @instance
         */
        CDOTAUserMsg_AbilityPing.prototype.primary_charges = 0;
    
        /**
         * CDOTAUserMsg_AbilityPing secondary_charges.
         * @member {number} secondary_charges
         * @memberof CDOTAUserMsg_AbilityPing
         * @instance
         */
        CDOTAUserMsg_AbilityPing.prototype.secondary_charges = 0;
    
        /**
         * CDOTAUserMsg_AbilityPing caster_id.
         * @member {number} caster_id
         * @memberof CDOTAUserMsg_AbilityPing
         * @instance
         */
        CDOTAUserMsg_AbilityPing.prototype.caster_id = 0;
    
        /**
         * CDOTAUserMsg_AbilityPing ctrl_held.
         * @member {boolean} ctrl_held
         * @memberof CDOTAUserMsg_AbilityPing
         * @instance
         */
        CDOTAUserMsg_AbilityPing.prototype.ctrl_held = false;
    
        /**
         * Creates a new CDOTAUserMsg_AbilityPing instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_AbilityPing
         * @static
         * @param {ICDOTAUserMsg_AbilityPing=} [properties] Properties to set
         * @returns {CDOTAUserMsg_AbilityPing} CDOTAUserMsg_AbilityPing instance
         */
        CDOTAUserMsg_AbilityPing.create = function create(properties) {
            return new CDOTAUserMsg_AbilityPing(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_AbilityPing message. Does not implicitly {@link CDOTAUserMsg_AbilityPing.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_AbilityPing
         * @static
         * @param {ICDOTAUserMsg_AbilityPing} message CDOTAUserMsg_AbilityPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_AbilityPing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.ability_id != null && Object.hasOwnProperty.call(message, "ability_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.ability_id);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            if (message.cooldown_seconds != null && Object.hasOwnProperty.call(message, "cooldown_seconds"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.cooldown_seconds);
            if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.level);
            if (message.passive != null && Object.hasOwnProperty.call(message, "passive"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.passive);
            if (message.mana_needed != null && Object.hasOwnProperty.call(message, "mana_needed"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.mana_needed);
            if (message.entity_id != null && Object.hasOwnProperty.call(message, "entity_id"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.entity_id);
            if (message.primary_charges != null && Object.hasOwnProperty.call(message, "primary_charges"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.primary_charges);
            if (message.secondary_charges != null && Object.hasOwnProperty.call(message, "secondary_charges"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.secondary_charges);
            if (message.caster_id != null && Object.hasOwnProperty.call(message, "caster_id"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.caster_id);
            if (message.ctrl_held != null && Object.hasOwnProperty.call(message, "ctrl_held"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.ctrl_held);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_AbilityPing message, length delimited. Does not implicitly {@link CDOTAUserMsg_AbilityPing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_AbilityPing
         * @static
         * @param {ICDOTAUserMsg_AbilityPing} message CDOTAUserMsg_AbilityPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_AbilityPing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_AbilityPing message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_AbilityPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_AbilityPing} CDOTAUserMsg_AbilityPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_AbilityPing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_AbilityPing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.ability_id = reader.uint32();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.cooldown_seconds = reader.uint32();
                    break;
                case 5:
                    message.level = reader.uint32();
                    break;
                case 6:
                    message.passive = reader.bool();
                    break;
                case 7:
                    message.mana_needed = reader.uint32();
                    break;
                case 8:
                    message.entity_id = reader.uint32();
                    break;
                case 9:
                    message.primary_charges = reader.int32();
                    break;
                case 10:
                    message.secondary_charges = reader.int32();
                    break;
                case 11:
                    message.caster_id = reader.uint32();
                    break;
                case 12:
                    message.ctrl_held = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_AbilityPing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_AbilityPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_AbilityPing} CDOTAUserMsg_AbilityPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_AbilityPing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_AbilityPing message.
         * @function verify
         * @memberof CDOTAUserMsg_AbilityPing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_AbilityPing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.ability_id != null && message.hasOwnProperty("ability_id"))
                if (!$util.isInteger(message.ability_id))
                    return "ability_id: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                    break;
                }
            if (message.cooldown_seconds != null && message.hasOwnProperty("cooldown_seconds"))
                if (!$util.isInteger(message.cooldown_seconds))
                    return "cooldown_seconds: integer expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level))
                    return "level: integer expected";
            if (message.passive != null && message.hasOwnProperty("passive"))
                if (typeof message.passive !== "boolean")
                    return "passive: boolean expected";
            if (message.mana_needed != null && message.hasOwnProperty("mana_needed"))
                if (!$util.isInteger(message.mana_needed))
                    return "mana_needed: integer expected";
            if (message.entity_id != null && message.hasOwnProperty("entity_id"))
                if (!$util.isInteger(message.entity_id))
                    return "entity_id: integer expected";
            if (message.primary_charges != null && message.hasOwnProperty("primary_charges"))
                if (!$util.isInteger(message.primary_charges))
                    return "primary_charges: integer expected";
            if (message.secondary_charges != null && message.hasOwnProperty("secondary_charges"))
                if (!$util.isInteger(message.secondary_charges))
                    return "secondary_charges: integer expected";
            if (message.caster_id != null && message.hasOwnProperty("caster_id"))
                if (!$util.isInteger(message.caster_id))
                    return "caster_id: integer expected";
            if (message.ctrl_held != null && message.hasOwnProperty("ctrl_held"))
                if (typeof message.ctrl_held !== "boolean")
                    return "ctrl_held: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_AbilityPing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_AbilityPing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_AbilityPing} CDOTAUserMsg_AbilityPing
         */
        CDOTAUserMsg_AbilityPing.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_AbilityPing)
                return object;
            var message = new $root.CDOTAUserMsg_AbilityPing();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.ability_id != null)
                message.ability_id = object.ability_id >>> 0;
            switch (object.type) {
            case "ABILITY_PING_READY":
            case 1:
                message.type = 1;
                break;
            case "ABILITY_PING_MANA":
            case 2:
                message.type = 2;
                break;
            case "ABILITY_PING_COOLDOWN":
            case 3:
                message.type = 3;
                break;
            case "ABILITY_PING_ENEMY":
            case 4:
                message.type = 4;
                break;
            case "ABILITY_PING_UNLEARNED":
            case 5:
                message.type = 5;
                break;
            case "ABILITY_PING_INBACKPACK":
            case 6:
                message.type = 6;
                break;
            case "ABILITY_PING_INSTASH":
            case 7:
                message.type = 7;
                break;
            case "ABILITY_PING_ONCOURIER":
            case 8:
                message.type = 8;
                break;
            case "ABILITY_PING_ALLY":
            case 9:
                message.type = 9;
                break;
            case "ABILITY_PING_LEARN_READY":
            case 10:
                message.type = 10;
                break;
            case "ABILITY_PING_WILL_LEARN":
            case 11:
                message.type = 11;
                break;
            case "ABILITY_PING_FUTURE_LEARN":
            case 12:
                message.type = 12;
                break;
            case "ABILITY_PING_NEUTRAL_OFFER":
            case 13:
                message.type = 13;
                break;
            case "ABILITY_PING_NEUTRAL_REQUEST":
            case 14:
                message.type = 14;
                break;
            case "ABILITY_PING_NEUTRAL_EQUIP":
            case 15:
                message.type = 15;
                break;
            }
            if (object.cooldown_seconds != null)
                message.cooldown_seconds = object.cooldown_seconds >>> 0;
            if (object.level != null)
                message.level = object.level >>> 0;
            if (object.passive != null)
                message.passive = Boolean(object.passive);
            if (object.mana_needed != null)
                message.mana_needed = object.mana_needed >>> 0;
            if (object.entity_id != null)
                message.entity_id = object.entity_id >>> 0;
            if (object.primary_charges != null)
                message.primary_charges = object.primary_charges | 0;
            if (object.secondary_charges != null)
                message.secondary_charges = object.secondary_charges | 0;
            if (object.caster_id != null)
                message.caster_id = object.caster_id >>> 0;
            if (object.ctrl_held != null)
                message.ctrl_held = Boolean(object.ctrl_held);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_AbilityPing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_AbilityPing
         * @static
         * @param {CDOTAUserMsg_AbilityPing} message CDOTAUserMsg_AbilityPing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_AbilityPing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.ability_id = 0;
                object.type = options.enums === String ? "ABILITY_PING_READY" : 1;
                object.cooldown_seconds = 0;
                object.level = 0;
                object.passive = false;
                object.mana_needed = 0;
                object.entity_id = 0;
                object.primary_charges = 0;
                object.secondary_charges = 0;
                object.caster_id = 0;
                object.ctrl_held = false;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.ability_id != null && message.hasOwnProperty("ability_id"))
                object.ability_id = message.ability_id;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.DOTA_ABILITY_PING_TYPE[message.type] : message.type;
            if (message.cooldown_seconds != null && message.hasOwnProperty("cooldown_seconds"))
                object.cooldown_seconds = message.cooldown_seconds;
            if (message.level != null && message.hasOwnProperty("level"))
                object.level = message.level;
            if (message.passive != null && message.hasOwnProperty("passive"))
                object.passive = message.passive;
            if (message.mana_needed != null && message.hasOwnProperty("mana_needed"))
                object.mana_needed = message.mana_needed;
            if (message.entity_id != null && message.hasOwnProperty("entity_id"))
                object.entity_id = message.entity_id;
            if (message.primary_charges != null && message.hasOwnProperty("primary_charges"))
                object.primary_charges = message.primary_charges;
            if (message.secondary_charges != null && message.hasOwnProperty("secondary_charges"))
                object.secondary_charges = message.secondary_charges;
            if (message.caster_id != null && message.hasOwnProperty("caster_id"))
                object.caster_id = message.caster_id;
            if (message.ctrl_held != null && message.hasOwnProperty("ctrl_held"))
                object.ctrl_held = message.ctrl_held;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_AbilityPing to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_AbilityPing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_AbilityPing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_AbilityPing;
    })();
    
    $root.CDOTAUserMsg_TE_UnitAnimation = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_TE_UnitAnimation.
         * @exports ICDOTAUserMsg_TE_UnitAnimation
         * @interface ICDOTAUserMsg_TE_UnitAnimation
         * @property {number|null} [entity] CDOTAUserMsg_TE_UnitAnimation entity
         * @property {number|null} [sequenceVariant] CDOTAUserMsg_TE_UnitAnimation sequenceVariant
         * @property {number|null} [playbackrate] CDOTAUserMsg_TE_UnitAnimation playbackrate
         * @property {number|null} [castpoint] CDOTAUserMsg_TE_UnitAnimation castpoint
         * @property {number|null} [type] CDOTAUserMsg_TE_UnitAnimation type
         * @property {number|null} [activity] CDOTAUserMsg_TE_UnitAnimation activity
         */
    
        /**
         * Constructs a new CDOTAUserMsg_TE_UnitAnimation.
         * @exports CDOTAUserMsg_TE_UnitAnimation
         * @classdesc Represents a CDOTAUserMsg_TE_UnitAnimation.
         * @implements ICDOTAUserMsg_TE_UnitAnimation
         * @constructor
         * @param {ICDOTAUserMsg_TE_UnitAnimation=} [properties] Properties to set
         */
        function CDOTAUserMsg_TE_UnitAnimation(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_TE_UnitAnimation entity.
         * @member {number} entity
         * @memberof CDOTAUserMsg_TE_UnitAnimation
         * @instance
         */
        CDOTAUserMsg_TE_UnitAnimation.prototype.entity = 0;
    
        /**
         * CDOTAUserMsg_TE_UnitAnimation sequenceVariant.
         * @member {number} sequenceVariant
         * @memberof CDOTAUserMsg_TE_UnitAnimation
         * @instance
         */
        CDOTAUserMsg_TE_UnitAnimation.prototype.sequenceVariant = 0;
    
        /**
         * CDOTAUserMsg_TE_UnitAnimation playbackrate.
         * @member {number} playbackrate
         * @memberof CDOTAUserMsg_TE_UnitAnimation
         * @instance
         */
        CDOTAUserMsg_TE_UnitAnimation.prototype.playbackrate = 0;
    
        /**
         * CDOTAUserMsg_TE_UnitAnimation castpoint.
         * @member {number} castpoint
         * @memberof CDOTAUserMsg_TE_UnitAnimation
         * @instance
         */
        CDOTAUserMsg_TE_UnitAnimation.prototype.castpoint = 0;
    
        /**
         * CDOTAUserMsg_TE_UnitAnimation type.
         * @member {number} type
         * @memberof CDOTAUserMsg_TE_UnitAnimation
         * @instance
         */
        CDOTAUserMsg_TE_UnitAnimation.prototype.type = 0;
    
        /**
         * CDOTAUserMsg_TE_UnitAnimation activity.
         * @member {number} activity
         * @memberof CDOTAUserMsg_TE_UnitAnimation
         * @instance
         */
        CDOTAUserMsg_TE_UnitAnimation.prototype.activity = 0;
    
        /**
         * Creates a new CDOTAUserMsg_TE_UnitAnimation instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_TE_UnitAnimation
         * @static
         * @param {ICDOTAUserMsg_TE_UnitAnimation=} [properties] Properties to set
         * @returns {CDOTAUserMsg_TE_UnitAnimation} CDOTAUserMsg_TE_UnitAnimation instance
         */
        CDOTAUserMsg_TE_UnitAnimation.create = function create(properties) {
            return new CDOTAUserMsg_TE_UnitAnimation(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TE_UnitAnimation message. Does not implicitly {@link CDOTAUserMsg_TE_UnitAnimation.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_TE_UnitAnimation
         * @static
         * @param {ICDOTAUserMsg_TE_UnitAnimation} message CDOTAUserMsg_TE_UnitAnimation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TE_UnitAnimation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entity != null && Object.hasOwnProperty.call(message, "entity"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.entity);
            if (message.sequenceVariant != null && Object.hasOwnProperty.call(message, "sequenceVariant"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.sequenceVariant);
            if (message.playbackrate != null && Object.hasOwnProperty.call(message, "playbackrate"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.playbackrate);
            if (message.castpoint != null && Object.hasOwnProperty.call(message, "castpoint"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.castpoint);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
            if (message.activity != null && Object.hasOwnProperty.call(message, "activity"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.activity);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TE_UnitAnimation message, length delimited. Does not implicitly {@link CDOTAUserMsg_TE_UnitAnimation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_TE_UnitAnimation
         * @static
         * @param {ICDOTAUserMsg_TE_UnitAnimation} message CDOTAUserMsg_TE_UnitAnimation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TE_UnitAnimation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_TE_UnitAnimation message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_TE_UnitAnimation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_TE_UnitAnimation} CDOTAUserMsg_TE_UnitAnimation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TE_UnitAnimation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_TE_UnitAnimation();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.entity = reader.int32();
                    break;
                case 2:
                    message.sequenceVariant = reader.int32();
                    break;
                case 3:
                    message.playbackrate = reader.float();
                    break;
                case 4:
                    message.castpoint = reader.float();
                    break;
                case 5:
                    message.type = reader.int32();
                    break;
                case 6:
                    message.activity = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_TE_UnitAnimation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_TE_UnitAnimation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_TE_UnitAnimation} CDOTAUserMsg_TE_UnitAnimation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TE_UnitAnimation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_TE_UnitAnimation message.
         * @function verify
         * @memberof CDOTAUserMsg_TE_UnitAnimation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_TE_UnitAnimation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entity != null && message.hasOwnProperty("entity"))
                if (!$util.isInteger(message.entity))
                    return "entity: integer expected";
            if (message.sequenceVariant != null && message.hasOwnProperty("sequenceVariant"))
                if (!$util.isInteger(message.sequenceVariant))
                    return "sequenceVariant: integer expected";
            if (message.playbackrate != null && message.hasOwnProperty("playbackrate"))
                if (typeof message.playbackrate !== "number")
                    return "playbackrate: number expected";
            if (message.castpoint != null && message.hasOwnProperty("castpoint"))
                if (typeof message.castpoint !== "number")
                    return "castpoint: number expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.activity != null && message.hasOwnProperty("activity"))
                if (!$util.isInteger(message.activity))
                    return "activity: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_TE_UnitAnimation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_TE_UnitAnimation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_TE_UnitAnimation} CDOTAUserMsg_TE_UnitAnimation
         */
        CDOTAUserMsg_TE_UnitAnimation.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_TE_UnitAnimation)
                return object;
            var message = new $root.CDOTAUserMsg_TE_UnitAnimation();
            if (object.entity != null)
                message.entity = object.entity | 0;
            if (object.sequenceVariant != null)
                message.sequenceVariant = object.sequenceVariant | 0;
            if (object.playbackrate != null)
                message.playbackrate = Number(object.playbackrate);
            if (object.castpoint != null)
                message.castpoint = Number(object.castpoint);
            if (object.type != null)
                message.type = object.type | 0;
            if (object.activity != null)
                message.activity = object.activity | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_TE_UnitAnimation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_TE_UnitAnimation
         * @static
         * @param {CDOTAUserMsg_TE_UnitAnimation} message CDOTAUserMsg_TE_UnitAnimation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_TE_UnitAnimation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.entity = 0;
                object.sequenceVariant = 0;
                object.playbackrate = 0;
                object.castpoint = 0;
                object.type = 0;
                object.activity = 0;
            }
            if (message.entity != null && message.hasOwnProperty("entity"))
                object.entity = message.entity;
            if (message.sequenceVariant != null && message.hasOwnProperty("sequenceVariant"))
                object.sequenceVariant = message.sequenceVariant;
            if (message.playbackrate != null && message.hasOwnProperty("playbackrate"))
                object.playbackrate = options.json && !isFinite(message.playbackrate) ? String(message.playbackrate) : message.playbackrate;
            if (message.castpoint != null && message.hasOwnProperty("castpoint"))
                object.castpoint = options.json && !isFinite(message.castpoint) ? String(message.castpoint) : message.castpoint;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.activity != null && message.hasOwnProperty("activity"))
                object.activity = message.activity;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_TE_UnitAnimation to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_TE_UnitAnimation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_TE_UnitAnimation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_TE_UnitAnimation;
    })();
    
    $root.CDOTAUserMsg_TE_UnitAnimationEnd = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_TE_UnitAnimationEnd.
         * @exports ICDOTAUserMsg_TE_UnitAnimationEnd
         * @interface ICDOTAUserMsg_TE_UnitAnimationEnd
         * @property {number|null} [entity] CDOTAUserMsg_TE_UnitAnimationEnd entity
         * @property {boolean|null} [snap] CDOTAUserMsg_TE_UnitAnimationEnd snap
         */
    
        /**
         * Constructs a new CDOTAUserMsg_TE_UnitAnimationEnd.
         * @exports CDOTAUserMsg_TE_UnitAnimationEnd
         * @classdesc Represents a CDOTAUserMsg_TE_UnitAnimationEnd.
         * @implements ICDOTAUserMsg_TE_UnitAnimationEnd
         * @constructor
         * @param {ICDOTAUserMsg_TE_UnitAnimationEnd=} [properties] Properties to set
         */
        function CDOTAUserMsg_TE_UnitAnimationEnd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_TE_UnitAnimationEnd entity.
         * @member {number} entity
         * @memberof CDOTAUserMsg_TE_UnitAnimationEnd
         * @instance
         */
        CDOTAUserMsg_TE_UnitAnimationEnd.prototype.entity = 0;
    
        /**
         * CDOTAUserMsg_TE_UnitAnimationEnd snap.
         * @member {boolean} snap
         * @memberof CDOTAUserMsg_TE_UnitAnimationEnd
         * @instance
         */
        CDOTAUserMsg_TE_UnitAnimationEnd.prototype.snap = false;
    
        /**
         * Creates a new CDOTAUserMsg_TE_UnitAnimationEnd instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_TE_UnitAnimationEnd
         * @static
         * @param {ICDOTAUserMsg_TE_UnitAnimationEnd=} [properties] Properties to set
         * @returns {CDOTAUserMsg_TE_UnitAnimationEnd} CDOTAUserMsg_TE_UnitAnimationEnd instance
         */
        CDOTAUserMsg_TE_UnitAnimationEnd.create = function create(properties) {
            return new CDOTAUserMsg_TE_UnitAnimationEnd(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TE_UnitAnimationEnd message. Does not implicitly {@link CDOTAUserMsg_TE_UnitAnimationEnd.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_TE_UnitAnimationEnd
         * @static
         * @param {ICDOTAUserMsg_TE_UnitAnimationEnd} message CDOTAUserMsg_TE_UnitAnimationEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TE_UnitAnimationEnd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entity != null && Object.hasOwnProperty.call(message, "entity"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.entity);
            if (message.snap != null && Object.hasOwnProperty.call(message, "snap"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.snap);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TE_UnitAnimationEnd message, length delimited. Does not implicitly {@link CDOTAUserMsg_TE_UnitAnimationEnd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_TE_UnitAnimationEnd
         * @static
         * @param {ICDOTAUserMsg_TE_UnitAnimationEnd} message CDOTAUserMsg_TE_UnitAnimationEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TE_UnitAnimationEnd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_TE_UnitAnimationEnd message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_TE_UnitAnimationEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_TE_UnitAnimationEnd} CDOTAUserMsg_TE_UnitAnimationEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TE_UnitAnimationEnd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_TE_UnitAnimationEnd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.entity = reader.int32();
                    break;
                case 2:
                    message.snap = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_TE_UnitAnimationEnd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_TE_UnitAnimationEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_TE_UnitAnimationEnd} CDOTAUserMsg_TE_UnitAnimationEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TE_UnitAnimationEnd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_TE_UnitAnimationEnd message.
         * @function verify
         * @memberof CDOTAUserMsg_TE_UnitAnimationEnd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_TE_UnitAnimationEnd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entity != null && message.hasOwnProperty("entity"))
                if (!$util.isInteger(message.entity))
                    return "entity: integer expected";
            if (message.snap != null && message.hasOwnProperty("snap"))
                if (typeof message.snap !== "boolean")
                    return "snap: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_TE_UnitAnimationEnd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_TE_UnitAnimationEnd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_TE_UnitAnimationEnd} CDOTAUserMsg_TE_UnitAnimationEnd
         */
        CDOTAUserMsg_TE_UnitAnimationEnd.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_TE_UnitAnimationEnd)
                return object;
            var message = new $root.CDOTAUserMsg_TE_UnitAnimationEnd();
            if (object.entity != null)
                message.entity = object.entity | 0;
            if (object.snap != null)
                message.snap = Boolean(object.snap);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_TE_UnitAnimationEnd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_TE_UnitAnimationEnd
         * @static
         * @param {CDOTAUserMsg_TE_UnitAnimationEnd} message CDOTAUserMsg_TE_UnitAnimationEnd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_TE_UnitAnimationEnd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.entity = 0;
                object.snap = false;
            }
            if (message.entity != null && message.hasOwnProperty("entity"))
                object.entity = message.entity;
            if (message.snap != null && message.hasOwnProperty("snap"))
                object.snap = message.snap;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_TE_UnitAnimationEnd to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_TE_UnitAnimationEnd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_TE_UnitAnimationEnd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_TE_UnitAnimationEnd;
    })();
    
    $root.CDOTAUserMsg_ShowGenericPopup = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_ShowGenericPopup.
         * @exports ICDOTAUserMsg_ShowGenericPopup
         * @interface ICDOTAUserMsg_ShowGenericPopup
         * @property {string} header CDOTAUserMsg_ShowGenericPopup header
         * @property {string} body CDOTAUserMsg_ShowGenericPopup body
         * @property {string|null} [param1] CDOTAUserMsg_ShowGenericPopup param1
         * @property {string|null} [param2] CDOTAUserMsg_ShowGenericPopup param2
         * @property {boolean|null} [tint_screen] CDOTAUserMsg_ShowGenericPopup tint_screen
         * @property {boolean|null} [show_no_other_dialogs] CDOTAUserMsg_ShowGenericPopup show_no_other_dialogs
         */
    
        /**
         * Constructs a new CDOTAUserMsg_ShowGenericPopup.
         * @exports CDOTAUserMsg_ShowGenericPopup
         * @classdesc Represents a CDOTAUserMsg_ShowGenericPopup.
         * @implements ICDOTAUserMsg_ShowGenericPopup
         * @constructor
         * @param {ICDOTAUserMsg_ShowGenericPopup=} [properties] Properties to set
         */
        function CDOTAUserMsg_ShowGenericPopup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_ShowGenericPopup header.
         * @member {string} header
         * @memberof CDOTAUserMsg_ShowGenericPopup
         * @instance
         */
        CDOTAUserMsg_ShowGenericPopup.prototype.header = "";
    
        /**
         * CDOTAUserMsg_ShowGenericPopup body.
         * @member {string} body
         * @memberof CDOTAUserMsg_ShowGenericPopup
         * @instance
         */
        CDOTAUserMsg_ShowGenericPopup.prototype.body = "";
    
        /**
         * CDOTAUserMsg_ShowGenericPopup param1.
         * @member {string} param1
         * @memberof CDOTAUserMsg_ShowGenericPopup
         * @instance
         */
        CDOTAUserMsg_ShowGenericPopup.prototype.param1 = "";
    
        /**
         * CDOTAUserMsg_ShowGenericPopup param2.
         * @member {string} param2
         * @memberof CDOTAUserMsg_ShowGenericPopup
         * @instance
         */
        CDOTAUserMsg_ShowGenericPopup.prototype.param2 = "";
    
        /**
         * CDOTAUserMsg_ShowGenericPopup tint_screen.
         * @member {boolean} tint_screen
         * @memberof CDOTAUserMsg_ShowGenericPopup
         * @instance
         */
        CDOTAUserMsg_ShowGenericPopup.prototype.tint_screen = false;
    
        /**
         * CDOTAUserMsg_ShowGenericPopup show_no_other_dialogs.
         * @member {boolean} show_no_other_dialogs
         * @memberof CDOTAUserMsg_ShowGenericPopup
         * @instance
         */
        CDOTAUserMsg_ShowGenericPopup.prototype.show_no_other_dialogs = false;
    
        /**
         * Creates a new CDOTAUserMsg_ShowGenericPopup instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_ShowGenericPopup
         * @static
         * @param {ICDOTAUserMsg_ShowGenericPopup=} [properties] Properties to set
         * @returns {CDOTAUserMsg_ShowGenericPopup} CDOTAUserMsg_ShowGenericPopup instance
         */
        CDOTAUserMsg_ShowGenericPopup.create = function create(properties) {
            return new CDOTAUserMsg_ShowGenericPopup(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ShowGenericPopup message. Does not implicitly {@link CDOTAUserMsg_ShowGenericPopup.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_ShowGenericPopup
         * @static
         * @param {ICDOTAUserMsg_ShowGenericPopup} message CDOTAUserMsg_ShowGenericPopup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ShowGenericPopup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.header);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.body);
            if (message.param1 != null && Object.hasOwnProperty.call(message, "param1"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.param1);
            if (message.param2 != null && Object.hasOwnProperty.call(message, "param2"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.param2);
            if (message.tint_screen != null && Object.hasOwnProperty.call(message, "tint_screen"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.tint_screen);
            if (message.show_no_other_dialogs != null && Object.hasOwnProperty.call(message, "show_no_other_dialogs"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.show_no_other_dialogs);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ShowGenericPopup message, length delimited. Does not implicitly {@link CDOTAUserMsg_ShowGenericPopup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_ShowGenericPopup
         * @static
         * @param {ICDOTAUserMsg_ShowGenericPopup} message CDOTAUserMsg_ShowGenericPopup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ShowGenericPopup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_ShowGenericPopup message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_ShowGenericPopup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_ShowGenericPopup} CDOTAUserMsg_ShowGenericPopup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ShowGenericPopup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_ShowGenericPopup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = reader.string();
                    break;
                case 2:
                    message.body = reader.string();
                    break;
                case 3:
                    message.param1 = reader.string();
                    break;
                case 4:
                    message.param2 = reader.string();
                    break;
                case 5:
                    message.tint_screen = reader.bool();
                    break;
                case 6:
                    message.show_no_other_dialogs = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("body"))
                throw $util.ProtocolError("missing required 'body'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_ShowGenericPopup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_ShowGenericPopup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_ShowGenericPopup} CDOTAUserMsg_ShowGenericPopup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ShowGenericPopup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_ShowGenericPopup message.
         * @function verify
         * @memberof CDOTAUserMsg_ShowGenericPopup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_ShowGenericPopup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.header))
                return "header: string expected";
            if (!$util.isString(message.body))
                return "body: string expected";
            if (message.param1 != null && message.hasOwnProperty("param1"))
                if (!$util.isString(message.param1))
                    return "param1: string expected";
            if (message.param2 != null && message.hasOwnProperty("param2"))
                if (!$util.isString(message.param2))
                    return "param2: string expected";
            if (message.tint_screen != null && message.hasOwnProperty("tint_screen"))
                if (typeof message.tint_screen !== "boolean")
                    return "tint_screen: boolean expected";
            if (message.show_no_other_dialogs != null && message.hasOwnProperty("show_no_other_dialogs"))
                if (typeof message.show_no_other_dialogs !== "boolean")
                    return "show_no_other_dialogs: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_ShowGenericPopup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_ShowGenericPopup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_ShowGenericPopup} CDOTAUserMsg_ShowGenericPopup
         */
        CDOTAUserMsg_ShowGenericPopup.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_ShowGenericPopup)
                return object;
            var message = new $root.CDOTAUserMsg_ShowGenericPopup();
            if (object.header != null)
                message.header = String(object.header);
            if (object.body != null)
                message.body = String(object.body);
            if (object.param1 != null)
                message.param1 = String(object.param1);
            if (object.param2 != null)
                message.param2 = String(object.param2);
            if (object.tint_screen != null)
                message.tint_screen = Boolean(object.tint_screen);
            if (object.show_no_other_dialogs != null)
                message.show_no_other_dialogs = Boolean(object.show_no_other_dialogs);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_ShowGenericPopup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_ShowGenericPopup
         * @static
         * @param {CDOTAUserMsg_ShowGenericPopup} message CDOTAUserMsg_ShowGenericPopup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_ShowGenericPopup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = "";
                object.body = "";
                object.param1 = "";
                object.param2 = "";
                object.tint_screen = false;
                object.show_no_other_dialogs = false;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = message.header;
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = message.body;
            if (message.param1 != null && message.hasOwnProperty("param1"))
                object.param1 = message.param1;
            if (message.param2 != null && message.hasOwnProperty("param2"))
                object.param2 = message.param2;
            if (message.tint_screen != null && message.hasOwnProperty("tint_screen"))
                object.tint_screen = message.tint_screen;
            if (message.show_no_other_dialogs != null && message.hasOwnProperty("show_no_other_dialogs"))
                object.show_no_other_dialogs = message.show_no_other_dialogs;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_ShowGenericPopup to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_ShowGenericPopup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_ShowGenericPopup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_ShowGenericPopup;
    })();
    
    $root.CDOTAUserMsg_VoteStart = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_VoteStart.
         * @exports ICDOTAUserMsg_VoteStart
         * @interface ICDOTAUserMsg_VoteStart
         * @property {string|null} [title] CDOTAUserMsg_VoteStart title
         * @property {number|null} [duration] CDOTAUserMsg_VoteStart duration
         * @property {number|null} [choice_count] CDOTAUserMsg_VoteStart choice_count
         * @property {Array.<string>|null} [choices] CDOTAUserMsg_VoteStart choices
         */
    
        /**
         * Constructs a new CDOTAUserMsg_VoteStart.
         * @exports CDOTAUserMsg_VoteStart
         * @classdesc Represents a CDOTAUserMsg_VoteStart.
         * @implements ICDOTAUserMsg_VoteStart
         * @constructor
         * @param {ICDOTAUserMsg_VoteStart=} [properties] Properties to set
         */
        function CDOTAUserMsg_VoteStart(properties) {
            this.choices = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_VoteStart title.
         * @member {string} title
         * @memberof CDOTAUserMsg_VoteStart
         * @instance
         */
        CDOTAUserMsg_VoteStart.prototype.title = "";
    
        /**
         * CDOTAUserMsg_VoteStart duration.
         * @member {number} duration
         * @memberof CDOTAUserMsg_VoteStart
         * @instance
         */
        CDOTAUserMsg_VoteStart.prototype.duration = 0;
    
        /**
         * CDOTAUserMsg_VoteStart choice_count.
         * @member {number} choice_count
         * @memberof CDOTAUserMsg_VoteStart
         * @instance
         */
        CDOTAUserMsg_VoteStart.prototype.choice_count = 0;
    
        /**
         * CDOTAUserMsg_VoteStart choices.
         * @member {Array.<string>} choices
         * @memberof CDOTAUserMsg_VoteStart
         * @instance
         */
        CDOTAUserMsg_VoteStart.prototype.choices = $util.emptyArray;
    
        /**
         * Creates a new CDOTAUserMsg_VoteStart instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_VoteStart
         * @static
         * @param {ICDOTAUserMsg_VoteStart=} [properties] Properties to set
         * @returns {CDOTAUserMsg_VoteStart} CDOTAUserMsg_VoteStart instance
         */
        CDOTAUserMsg_VoteStart.create = function create(properties) {
            return new CDOTAUserMsg_VoteStart(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_VoteStart message. Does not implicitly {@link CDOTAUserMsg_VoteStart.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_VoteStart
         * @static
         * @param {ICDOTAUserMsg_VoteStart} message CDOTAUserMsg_VoteStart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_VoteStart.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.duration);
            if (message.choice_count != null && Object.hasOwnProperty.call(message, "choice_count"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.choice_count);
            if (message.choices != null && message.choices.length)
                for (var i = 0; i < message.choices.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.choices[i]);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_VoteStart message, length delimited. Does not implicitly {@link CDOTAUserMsg_VoteStart.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_VoteStart
         * @static
         * @param {ICDOTAUserMsg_VoteStart} message CDOTAUserMsg_VoteStart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_VoteStart.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_VoteStart message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_VoteStart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_VoteStart} CDOTAUserMsg_VoteStart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_VoteStart.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_VoteStart();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.title = reader.string();
                    break;
                case 2:
                    message.duration = reader.float();
                    break;
                case 3:
                    message.choice_count = reader.int32();
                    break;
                case 4:
                    if (!(message.choices && message.choices.length))
                        message.choices = [];
                    message.choices.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_VoteStart message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_VoteStart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_VoteStart} CDOTAUserMsg_VoteStart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_VoteStart.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_VoteStart message.
         * @function verify
         * @memberof CDOTAUserMsg_VoteStart
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_VoteStart.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            if (message.choice_count != null && message.hasOwnProperty("choice_count"))
                if (!$util.isInteger(message.choice_count))
                    return "choice_count: integer expected";
            if (message.choices != null && message.hasOwnProperty("choices")) {
                if (!Array.isArray(message.choices))
                    return "choices: array expected";
                for (var i = 0; i < message.choices.length; ++i)
                    if (!$util.isString(message.choices[i]))
                        return "choices: string[] expected";
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_VoteStart message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_VoteStart
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_VoteStart} CDOTAUserMsg_VoteStart
         */
        CDOTAUserMsg_VoteStart.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_VoteStart)
                return object;
            var message = new $root.CDOTAUserMsg_VoteStart();
            if (object.title != null)
                message.title = String(object.title);
            if (object.duration != null)
                message.duration = Number(object.duration);
            if (object.choice_count != null)
                message.choice_count = object.choice_count | 0;
            if (object.choices) {
                if (!Array.isArray(object.choices))
                    throw TypeError(".CDOTAUserMsg_VoteStart.choices: array expected");
                message.choices = [];
                for (var i = 0; i < object.choices.length; ++i)
                    message.choices[i] = String(object.choices[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_VoteStart message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_VoteStart
         * @static
         * @param {CDOTAUserMsg_VoteStart} message CDOTAUserMsg_VoteStart
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_VoteStart.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.choices = [];
            if (options.defaults) {
                object.title = "";
                object.duration = 0;
                object.choice_count = 0;
            }
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            if (message.choice_count != null && message.hasOwnProperty("choice_count"))
                object.choice_count = message.choice_count;
            if (message.choices && message.choices.length) {
                object.choices = [];
                for (var j = 0; j < message.choices.length; ++j)
                    object.choices[j] = message.choices[j];
            }
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_VoteStart to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_VoteStart
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_VoteStart.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_VoteStart;
    })();
    
    $root.CDOTAUserMsg_VoteUpdate = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_VoteUpdate.
         * @exports ICDOTAUserMsg_VoteUpdate
         * @interface ICDOTAUserMsg_VoteUpdate
         * @property {Array.<number>|null} [choice_counts] CDOTAUserMsg_VoteUpdate choice_counts
         */
    
        /**
         * Constructs a new CDOTAUserMsg_VoteUpdate.
         * @exports CDOTAUserMsg_VoteUpdate
         * @classdesc Represents a CDOTAUserMsg_VoteUpdate.
         * @implements ICDOTAUserMsg_VoteUpdate
         * @constructor
         * @param {ICDOTAUserMsg_VoteUpdate=} [properties] Properties to set
         */
        function CDOTAUserMsg_VoteUpdate(properties) {
            this.choice_counts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_VoteUpdate choice_counts.
         * @member {Array.<number>} choice_counts
         * @memberof CDOTAUserMsg_VoteUpdate
         * @instance
         */
        CDOTAUserMsg_VoteUpdate.prototype.choice_counts = $util.emptyArray;
    
        /**
         * Creates a new CDOTAUserMsg_VoteUpdate instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_VoteUpdate
         * @static
         * @param {ICDOTAUserMsg_VoteUpdate=} [properties] Properties to set
         * @returns {CDOTAUserMsg_VoteUpdate} CDOTAUserMsg_VoteUpdate instance
         */
        CDOTAUserMsg_VoteUpdate.create = function create(properties) {
            return new CDOTAUserMsg_VoteUpdate(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_VoteUpdate message. Does not implicitly {@link CDOTAUserMsg_VoteUpdate.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_VoteUpdate
         * @static
         * @param {ICDOTAUserMsg_VoteUpdate} message CDOTAUserMsg_VoteUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_VoteUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.choice_counts != null && message.choice_counts.length)
                for (var i = 0; i < message.choice_counts.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.choice_counts[i]);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_VoteUpdate message, length delimited. Does not implicitly {@link CDOTAUserMsg_VoteUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_VoteUpdate
         * @static
         * @param {ICDOTAUserMsg_VoteUpdate} message CDOTAUserMsg_VoteUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_VoteUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_VoteUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_VoteUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_VoteUpdate} CDOTAUserMsg_VoteUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_VoteUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_VoteUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.choice_counts && message.choice_counts.length))
                        message.choice_counts = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.choice_counts.push(reader.int32());
                    } else
                        message.choice_counts.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_VoteUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_VoteUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_VoteUpdate} CDOTAUserMsg_VoteUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_VoteUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_VoteUpdate message.
         * @function verify
         * @memberof CDOTAUserMsg_VoteUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_VoteUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.choice_counts != null && message.hasOwnProperty("choice_counts")) {
                if (!Array.isArray(message.choice_counts))
                    return "choice_counts: array expected";
                for (var i = 0; i < message.choice_counts.length; ++i)
                    if (!$util.isInteger(message.choice_counts[i]))
                        return "choice_counts: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_VoteUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_VoteUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_VoteUpdate} CDOTAUserMsg_VoteUpdate
         */
        CDOTAUserMsg_VoteUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_VoteUpdate)
                return object;
            var message = new $root.CDOTAUserMsg_VoteUpdate();
            if (object.choice_counts) {
                if (!Array.isArray(object.choice_counts))
                    throw TypeError(".CDOTAUserMsg_VoteUpdate.choice_counts: array expected");
                message.choice_counts = [];
                for (var i = 0; i < object.choice_counts.length; ++i)
                    message.choice_counts[i] = object.choice_counts[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_VoteUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_VoteUpdate
         * @static
         * @param {CDOTAUserMsg_VoteUpdate} message CDOTAUserMsg_VoteUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_VoteUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.choice_counts = [];
            if (message.choice_counts && message.choice_counts.length) {
                object.choice_counts = [];
                for (var j = 0; j < message.choice_counts.length; ++j)
                    object.choice_counts[j] = message.choice_counts[j];
            }
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_VoteUpdate to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_VoteUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_VoteUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_VoteUpdate;
    })();
    
    $root.CDOTAUserMsg_VoteEnd = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_VoteEnd.
         * @exports ICDOTAUserMsg_VoteEnd
         * @interface ICDOTAUserMsg_VoteEnd
         * @property {number|null} [selected_choice] CDOTAUserMsg_VoteEnd selected_choice
         */
    
        /**
         * Constructs a new CDOTAUserMsg_VoteEnd.
         * @exports CDOTAUserMsg_VoteEnd
         * @classdesc Represents a CDOTAUserMsg_VoteEnd.
         * @implements ICDOTAUserMsg_VoteEnd
         * @constructor
         * @param {ICDOTAUserMsg_VoteEnd=} [properties] Properties to set
         */
        function CDOTAUserMsg_VoteEnd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_VoteEnd selected_choice.
         * @member {number} selected_choice
         * @memberof CDOTAUserMsg_VoteEnd
         * @instance
         */
        CDOTAUserMsg_VoteEnd.prototype.selected_choice = 0;
    
        /**
         * Creates a new CDOTAUserMsg_VoteEnd instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_VoteEnd
         * @static
         * @param {ICDOTAUserMsg_VoteEnd=} [properties] Properties to set
         * @returns {CDOTAUserMsg_VoteEnd} CDOTAUserMsg_VoteEnd instance
         */
        CDOTAUserMsg_VoteEnd.create = function create(properties) {
            return new CDOTAUserMsg_VoteEnd(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_VoteEnd message. Does not implicitly {@link CDOTAUserMsg_VoteEnd.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_VoteEnd
         * @static
         * @param {ICDOTAUserMsg_VoteEnd} message CDOTAUserMsg_VoteEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_VoteEnd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.selected_choice != null && Object.hasOwnProperty.call(message, "selected_choice"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.selected_choice);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_VoteEnd message, length delimited. Does not implicitly {@link CDOTAUserMsg_VoteEnd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_VoteEnd
         * @static
         * @param {ICDOTAUserMsg_VoteEnd} message CDOTAUserMsg_VoteEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_VoteEnd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_VoteEnd message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_VoteEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_VoteEnd} CDOTAUserMsg_VoteEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_VoteEnd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_VoteEnd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.selected_choice = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_VoteEnd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_VoteEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_VoteEnd} CDOTAUserMsg_VoteEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_VoteEnd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_VoteEnd message.
         * @function verify
         * @memberof CDOTAUserMsg_VoteEnd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_VoteEnd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.selected_choice != null && message.hasOwnProperty("selected_choice"))
                if (!$util.isInteger(message.selected_choice))
                    return "selected_choice: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_VoteEnd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_VoteEnd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_VoteEnd} CDOTAUserMsg_VoteEnd
         */
        CDOTAUserMsg_VoteEnd.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_VoteEnd)
                return object;
            var message = new $root.CDOTAUserMsg_VoteEnd();
            if (object.selected_choice != null)
                message.selected_choice = object.selected_choice | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_VoteEnd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_VoteEnd
         * @static
         * @param {CDOTAUserMsg_VoteEnd} message CDOTAUserMsg_VoteEnd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_VoteEnd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.selected_choice = 0;
            if (message.selected_choice != null && message.hasOwnProperty("selected_choice"))
                object.selected_choice = message.selected_choice;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_VoteEnd to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_VoteEnd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_VoteEnd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_VoteEnd;
    })();
    
    $root.CDOTAUserMsg_BoosterStatePlayer = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_BoosterStatePlayer.
         * @exports ICDOTAUserMsg_BoosterStatePlayer
         * @interface ICDOTAUserMsg_BoosterStatePlayer
         * @property {number|null} [player_id] CDOTAUserMsg_BoosterStatePlayer player_id
         * @property {number|null} [bonus] CDOTAUserMsg_BoosterStatePlayer bonus
         * @property {number|null} [event_bonus] CDOTAUserMsg_BoosterStatePlayer event_bonus
         * @property {number|null} [bonus_item_id] CDOTAUserMsg_BoosterStatePlayer bonus_item_id
         * @property {number|null} [event_bonus_item_id] CDOTAUserMsg_BoosterStatePlayer event_bonus_item_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_BoosterStatePlayer.
         * @exports CDOTAUserMsg_BoosterStatePlayer
         * @classdesc Represents a CDOTAUserMsg_BoosterStatePlayer.
         * @implements ICDOTAUserMsg_BoosterStatePlayer
         * @constructor
         * @param {ICDOTAUserMsg_BoosterStatePlayer=} [properties] Properties to set
         */
        function CDOTAUserMsg_BoosterStatePlayer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_BoosterStatePlayer player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_BoosterStatePlayer
         * @instance
         */
        CDOTAUserMsg_BoosterStatePlayer.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_BoosterStatePlayer bonus.
         * @member {number} bonus
         * @memberof CDOTAUserMsg_BoosterStatePlayer
         * @instance
         */
        CDOTAUserMsg_BoosterStatePlayer.prototype.bonus = 0;
    
        /**
         * CDOTAUserMsg_BoosterStatePlayer event_bonus.
         * @member {number} event_bonus
         * @memberof CDOTAUserMsg_BoosterStatePlayer
         * @instance
         */
        CDOTAUserMsg_BoosterStatePlayer.prototype.event_bonus = 0;
    
        /**
         * CDOTAUserMsg_BoosterStatePlayer bonus_item_id.
         * @member {number} bonus_item_id
         * @memberof CDOTAUserMsg_BoosterStatePlayer
         * @instance
         */
        CDOTAUserMsg_BoosterStatePlayer.prototype.bonus_item_id = 0;
    
        /**
         * CDOTAUserMsg_BoosterStatePlayer event_bonus_item_id.
         * @member {number} event_bonus_item_id
         * @memberof CDOTAUserMsg_BoosterStatePlayer
         * @instance
         */
        CDOTAUserMsg_BoosterStatePlayer.prototype.event_bonus_item_id = 0;
    
        /**
         * Creates a new CDOTAUserMsg_BoosterStatePlayer instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_BoosterStatePlayer
         * @static
         * @param {ICDOTAUserMsg_BoosterStatePlayer=} [properties] Properties to set
         * @returns {CDOTAUserMsg_BoosterStatePlayer} CDOTAUserMsg_BoosterStatePlayer instance
         */
        CDOTAUserMsg_BoosterStatePlayer.create = function create(properties) {
            return new CDOTAUserMsg_BoosterStatePlayer(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_BoosterStatePlayer message. Does not implicitly {@link CDOTAUserMsg_BoosterStatePlayer.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_BoosterStatePlayer
         * @static
         * @param {ICDOTAUserMsg_BoosterStatePlayer} message CDOTAUserMsg_BoosterStatePlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_BoosterStatePlayer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.bonus != null && Object.hasOwnProperty.call(message, "bonus"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.bonus);
            if (message.event_bonus != null && Object.hasOwnProperty.call(message, "event_bonus"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.event_bonus);
            if (message.bonus_item_id != null && Object.hasOwnProperty.call(message, "bonus_item_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.bonus_item_id);
            if (message.event_bonus_item_id != null && Object.hasOwnProperty.call(message, "event_bonus_item_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.event_bonus_item_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_BoosterStatePlayer message, length delimited. Does not implicitly {@link CDOTAUserMsg_BoosterStatePlayer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_BoosterStatePlayer
         * @static
         * @param {ICDOTAUserMsg_BoosterStatePlayer} message CDOTAUserMsg_BoosterStatePlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_BoosterStatePlayer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_BoosterStatePlayer message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_BoosterStatePlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_BoosterStatePlayer} CDOTAUserMsg_BoosterStatePlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_BoosterStatePlayer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_BoosterStatePlayer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.bonus = reader.float();
                    break;
                case 3:
                    message.event_bonus = reader.float();
                    break;
                case 4:
                    message.bonus_item_id = reader.uint32();
                    break;
                case 5:
                    message.event_bonus_item_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_BoosterStatePlayer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_BoosterStatePlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_BoosterStatePlayer} CDOTAUserMsg_BoosterStatePlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_BoosterStatePlayer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_BoosterStatePlayer message.
         * @function verify
         * @memberof CDOTAUserMsg_BoosterStatePlayer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_BoosterStatePlayer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.bonus != null && message.hasOwnProperty("bonus"))
                if (typeof message.bonus !== "number")
                    return "bonus: number expected";
            if (message.event_bonus != null && message.hasOwnProperty("event_bonus"))
                if (typeof message.event_bonus !== "number")
                    return "event_bonus: number expected";
            if (message.bonus_item_id != null && message.hasOwnProperty("bonus_item_id"))
                if (!$util.isInteger(message.bonus_item_id))
                    return "bonus_item_id: integer expected";
            if (message.event_bonus_item_id != null && message.hasOwnProperty("event_bonus_item_id"))
                if (!$util.isInteger(message.event_bonus_item_id))
                    return "event_bonus_item_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_BoosterStatePlayer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_BoosterStatePlayer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_BoosterStatePlayer} CDOTAUserMsg_BoosterStatePlayer
         */
        CDOTAUserMsg_BoosterStatePlayer.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_BoosterStatePlayer)
                return object;
            var message = new $root.CDOTAUserMsg_BoosterStatePlayer();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.bonus != null)
                message.bonus = Number(object.bonus);
            if (object.event_bonus != null)
                message.event_bonus = Number(object.event_bonus);
            if (object.bonus_item_id != null)
                message.bonus_item_id = object.bonus_item_id >>> 0;
            if (object.event_bonus_item_id != null)
                message.event_bonus_item_id = object.event_bonus_item_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_BoosterStatePlayer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_BoosterStatePlayer
         * @static
         * @param {CDOTAUserMsg_BoosterStatePlayer} message CDOTAUserMsg_BoosterStatePlayer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_BoosterStatePlayer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.bonus = 0;
                object.event_bonus = 0;
                object.bonus_item_id = 0;
                object.event_bonus_item_id = 0;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.bonus != null && message.hasOwnProperty("bonus"))
                object.bonus = options.json && !isFinite(message.bonus) ? String(message.bonus) : message.bonus;
            if (message.event_bonus != null && message.hasOwnProperty("event_bonus"))
                object.event_bonus = options.json && !isFinite(message.event_bonus) ? String(message.event_bonus) : message.event_bonus;
            if (message.bonus_item_id != null && message.hasOwnProperty("bonus_item_id"))
                object.bonus_item_id = message.bonus_item_id;
            if (message.event_bonus_item_id != null && message.hasOwnProperty("event_bonus_item_id"))
                object.event_bonus_item_id = message.event_bonus_item_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_BoosterStatePlayer to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_BoosterStatePlayer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_BoosterStatePlayer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_BoosterStatePlayer;
    })();
    
    $root.CDOTAUserMsg_BoosterState = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_BoosterState.
         * @exports ICDOTAUserMsg_BoosterState
         * @interface ICDOTAUserMsg_BoosterState
         * @property {Array.<ICDOTAUserMsg_BoosterStatePlayer>|null} [boosted_players] CDOTAUserMsg_BoosterState boosted_players
         */
    
        /**
         * Constructs a new CDOTAUserMsg_BoosterState.
         * @exports CDOTAUserMsg_BoosterState
         * @classdesc Represents a CDOTAUserMsg_BoosterState.
         * @implements ICDOTAUserMsg_BoosterState
         * @constructor
         * @param {ICDOTAUserMsg_BoosterState=} [properties] Properties to set
         */
        function CDOTAUserMsg_BoosterState(properties) {
            this.boosted_players = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_BoosterState boosted_players.
         * @member {Array.<ICDOTAUserMsg_BoosterStatePlayer>} boosted_players
         * @memberof CDOTAUserMsg_BoosterState
         * @instance
         */
        CDOTAUserMsg_BoosterState.prototype.boosted_players = $util.emptyArray;
    
        /**
         * Creates a new CDOTAUserMsg_BoosterState instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_BoosterState
         * @static
         * @param {ICDOTAUserMsg_BoosterState=} [properties] Properties to set
         * @returns {CDOTAUserMsg_BoosterState} CDOTAUserMsg_BoosterState instance
         */
        CDOTAUserMsg_BoosterState.create = function create(properties) {
            return new CDOTAUserMsg_BoosterState(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_BoosterState message. Does not implicitly {@link CDOTAUserMsg_BoosterState.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_BoosterState
         * @static
         * @param {ICDOTAUserMsg_BoosterState} message CDOTAUserMsg_BoosterState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_BoosterState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.boosted_players != null && message.boosted_players.length)
                for (var i = 0; i < message.boosted_players.length; ++i)
                    $root.CDOTAUserMsg_BoosterStatePlayer.encode(message.boosted_players[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_BoosterState message, length delimited. Does not implicitly {@link CDOTAUserMsg_BoosterState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_BoosterState
         * @static
         * @param {ICDOTAUserMsg_BoosterState} message CDOTAUserMsg_BoosterState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_BoosterState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_BoosterState message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_BoosterState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_BoosterState} CDOTAUserMsg_BoosterState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_BoosterState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_BoosterState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.boosted_players && message.boosted_players.length))
                        message.boosted_players = [];
                    message.boosted_players.push($root.CDOTAUserMsg_BoosterStatePlayer.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_BoosterState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_BoosterState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_BoosterState} CDOTAUserMsg_BoosterState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_BoosterState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_BoosterState message.
         * @function verify
         * @memberof CDOTAUserMsg_BoosterState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_BoosterState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.boosted_players != null && message.hasOwnProperty("boosted_players")) {
                if (!Array.isArray(message.boosted_players))
                    return "boosted_players: array expected";
                for (var i = 0; i < message.boosted_players.length; ++i) {
                    var error = $root.CDOTAUserMsg_BoosterStatePlayer.verify(message.boosted_players[i]);
                    if (error)
                        return "boosted_players." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_BoosterState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_BoosterState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_BoosterState} CDOTAUserMsg_BoosterState
         */
        CDOTAUserMsg_BoosterState.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_BoosterState)
                return object;
            var message = new $root.CDOTAUserMsg_BoosterState();
            if (object.boosted_players) {
                if (!Array.isArray(object.boosted_players))
                    throw TypeError(".CDOTAUserMsg_BoosterState.boosted_players: array expected");
                message.boosted_players = [];
                for (var i = 0; i < object.boosted_players.length; ++i) {
                    if (typeof object.boosted_players[i] !== "object")
                        throw TypeError(".CDOTAUserMsg_BoosterState.boosted_players: object expected");
                    message.boosted_players[i] = $root.CDOTAUserMsg_BoosterStatePlayer.fromObject(object.boosted_players[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_BoosterState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_BoosterState
         * @static
         * @param {CDOTAUserMsg_BoosterState} message CDOTAUserMsg_BoosterState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_BoosterState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.boosted_players = [];
            if (message.boosted_players && message.boosted_players.length) {
                object.boosted_players = [];
                for (var j = 0; j < message.boosted_players.length; ++j)
                    object.boosted_players[j] = $root.CDOTAUserMsg_BoosterStatePlayer.toObject(message.boosted_players[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_BoosterState to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_BoosterState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_BoosterState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_BoosterState;
    })();
    
    $root.CDOTAUserMsg_PlayerMMR = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_PlayerMMR.
         * @exports ICDOTAUserMsg_PlayerMMR
         * @interface ICDOTAUserMsg_PlayerMMR
         * @property {Array.<number>|null} [mmr] CDOTAUserMsg_PlayerMMR mmr
         */
    
        /**
         * Constructs a new CDOTAUserMsg_PlayerMMR.
         * @exports CDOTAUserMsg_PlayerMMR
         * @classdesc Represents a CDOTAUserMsg_PlayerMMR.
         * @implements ICDOTAUserMsg_PlayerMMR
         * @constructor
         * @param {ICDOTAUserMsg_PlayerMMR=} [properties] Properties to set
         */
        function CDOTAUserMsg_PlayerMMR(properties) {
            this.mmr = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_PlayerMMR mmr.
         * @member {Array.<number>} mmr
         * @memberof CDOTAUserMsg_PlayerMMR
         * @instance
         */
        CDOTAUserMsg_PlayerMMR.prototype.mmr = $util.emptyArray;
    
        /**
         * Creates a new CDOTAUserMsg_PlayerMMR instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_PlayerMMR
         * @static
         * @param {ICDOTAUserMsg_PlayerMMR=} [properties] Properties to set
         * @returns {CDOTAUserMsg_PlayerMMR} CDOTAUserMsg_PlayerMMR instance
         */
        CDOTAUserMsg_PlayerMMR.create = function create(properties) {
            return new CDOTAUserMsg_PlayerMMR(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_PlayerMMR message. Does not implicitly {@link CDOTAUserMsg_PlayerMMR.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_PlayerMMR
         * @static
         * @param {ICDOTAUserMsg_PlayerMMR} message CDOTAUserMsg_PlayerMMR message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_PlayerMMR.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mmr != null && message.mmr.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.mmr.length; ++i)
                    writer.sint32(message.mmr[i]);
                writer.ldelim();
            }
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_PlayerMMR message, length delimited. Does not implicitly {@link CDOTAUserMsg_PlayerMMR.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_PlayerMMR
         * @static
         * @param {ICDOTAUserMsg_PlayerMMR} message CDOTAUserMsg_PlayerMMR message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_PlayerMMR.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_PlayerMMR message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_PlayerMMR
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_PlayerMMR} CDOTAUserMsg_PlayerMMR
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_PlayerMMR.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_PlayerMMR();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.mmr && message.mmr.length))
                        message.mmr = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.mmr.push(reader.sint32());
                    } else
                        message.mmr.push(reader.sint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_PlayerMMR message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_PlayerMMR
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_PlayerMMR} CDOTAUserMsg_PlayerMMR
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_PlayerMMR.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_PlayerMMR message.
         * @function verify
         * @memberof CDOTAUserMsg_PlayerMMR
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_PlayerMMR.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mmr != null && message.hasOwnProperty("mmr")) {
                if (!Array.isArray(message.mmr))
                    return "mmr: array expected";
                for (var i = 0; i < message.mmr.length; ++i)
                    if (!$util.isInteger(message.mmr[i]))
                        return "mmr: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_PlayerMMR message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_PlayerMMR
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_PlayerMMR} CDOTAUserMsg_PlayerMMR
         */
        CDOTAUserMsg_PlayerMMR.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_PlayerMMR)
                return object;
            var message = new $root.CDOTAUserMsg_PlayerMMR();
            if (object.mmr) {
                if (!Array.isArray(object.mmr))
                    throw TypeError(".CDOTAUserMsg_PlayerMMR.mmr: array expected");
                message.mmr = [];
                for (var i = 0; i < object.mmr.length; ++i)
                    message.mmr[i] = object.mmr[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_PlayerMMR message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_PlayerMMR
         * @static
         * @param {CDOTAUserMsg_PlayerMMR} message CDOTAUserMsg_PlayerMMR
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_PlayerMMR.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mmr = [];
            if (message.mmr && message.mmr.length) {
                object.mmr = [];
                for (var j = 0; j < message.mmr.length; ++j)
                    object.mmr[j] = message.mmr[j];
            }
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_PlayerMMR to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_PlayerMMR
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_PlayerMMR.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_PlayerMMR;
    })();
    
    $root.CDOTAUserMsg_AbilitySteal = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_AbilitySteal.
         * @exports ICDOTAUserMsg_AbilitySteal
         * @interface ICDOTAUserMsg_AbilitySteal
         * @property {number|null} [player_id] CDOTAUserMsg_AbilitySteal player_id
         * @property {number|null} [ability_id] CDOTAUserMsg_AbilitySteal ability_id
         * @property {number|null} [ability_level] CDOTAUserMsg_AbilitySteal ability_level
         */
    
        /**
         * Constructs a new CDOTAUserMsg_AbilitySteal.
         * @exports CDOTAUserMsg_AbilitySteal
         * @classdesc Represents a CDOTAUserMsg_AbilitySteal.
         * @implements ICDOTAUserMsg_AbilitySteal
         * @constructor
         * @param {ICDOTAUserMsg_AbilitySteal=} [properties] Properties to set
         */
        function CDOTAUserMsg_AbilitySteal(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_AbilitySteal player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_AbilitySteal
         * @instance
         */
        CDOTAUserMsg_AbilitySteal.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_AbilitySteal ability_id.
         * @member {number} ability_id
         * @memberof CDOTAUserMsg_AbilitySteal
         * @instance
         */
        CDOTAUserMsg_AbilitySteal.prototype.ability_id = 0;
    
        /**
         * CDOTAUserMsg_AbilitySteal ability_level.
         * @member {number} ability_level
         * @memberof CDOTAUserMsg_AbilitySteal
         * @instance
         */
        CDOTAUserMsg_AbilitySteal.prototype.ability_level = 0;
    
        /**
         * Creates a new CDOTAUserMsg_AbilitySteal instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_AbilitySteal
         * @static
         * @param {ICDOTAUserMsg_AbilitySteal=} [properties] Properties to set
         * @returns {CDOTAUserMsg_AbilitySteal} CDOTAUserMsg_AbilitySteal instance
         */
        CDOTAUserMsg_AbilitySteal.create = function create(properties) {
            return new CDOTAUserMsg_AbilitySteal(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_AbilitySteal message. Does not implicitly {@link CDOTAUserMsg_AbilitySteal.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_AbilitySteal
         * @static
         * @param {ICDOTAUserMsg_AbilitySteal} message CDOTAUserMsg_AbilitySteal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_AbilitySteal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.ability_id != null && Object.hasOwnProperty.call(message, "ability_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.ability_id);
            if (message.ability_level != null && Object.hasOwnProperty.call(message, "ability_level"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.ability_level);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_AbilitySteal message, length delimited. Does not implicitly {@link CDOTAUserMsg_AbilitySteal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_AbilitySteal
         * @static
         * @param {ICDOTAUserMsg_AbilitySteal} message CDOTAUserMsg_AbilitySteal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_AbilitySteal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_AbilitySteal message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_AbilitySteal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_AbilitySteal} CDOTAUserMsg_AbilitySteal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_AbilitySteal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_AbilitySteal();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.ability_id = reader.uint32();
                    break;
                case 3:
                    message.ability_level = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_AbilitySteal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_AbilitySteal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_AbilitySteal} CDOTAUserMsg_AbilitySteal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_AbilitySteal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_AbilitySteal message.
         * @function verify
         * @memberof CDOTAUserMsg_AbilitySteal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_AbilitySteal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.ability_id != null && message.hasOwnProperty("ability_id"))
                if (!$util.isInteger(message.ability_id))
                    return "ability_id: integer expected";
            if (message.ability_level != null && message.hasOwnProperty("ability_level"))
                if (!$util.isInteger(message.ability_level))
                    return "ability_level: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_AbilitySteal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_AbilitySteal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_AbilitySteal} CDOTAUserMsg_AbilitySteal
         */
        CDOTAUserMsg_AbilitySteal.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_AbilitySteal)
                return object;
            var message = new $root.CDOTAUserMsg_AbilitySteal();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.ability_id != null)
                message.ability_id = object.ability_id >>> 0;
            if (object.ability_level != null)
                message.ability_level = object.ability_level >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_AbilitySteal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_AbilitySteal
         * @static
         * @param {CDOTAUserMsg_AbilitySteal} message CDOTAUserMsg_AbilitySteal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_AbilitySteal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.ability_id = 0;
                object.ability_level = 0;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.ability_id != null && message.hasOwnProperty("ability_id"))
                object.ability_id = message.ability_id;
            if (message.ability_level != null && message.hasOwnProperty("ability_level"))
                object.ability_level = message.ability_level;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_AbilitySteal to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_AbilitySteal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_AbilitySteal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_AbilitySteal;
    })();
    
    $root.CDOTAUserMsg_StatsHeroLookup = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_StatsHeroLookup.
         * @exports ICDOTAUserMsg_StatsHeroLookup
         * @interface ICDOTAUserMsg_StatsHeroLookup
         * @property {number|null} [player_id] CDOTAUserMsg_StatsHeroLookup player_id
         * @property {number|null} [hero_id] CDOTAUserMsg_StatsHeroLookup hero_id
         * @property {string|null} [hero_name] CDOTAUserMsg_StatsHeroLookup hero_name
         * @property {string|null} [persona] CDOTAUserMsg_StatsHeroLookup persona
         */
    
        /**
         * Constructs a new CDOTAUserMsg_StatsHeroLookup.
         * @exports CDOTAUserMsg_StatsHeroLookup
         * @classdesc Represents a CDOTAUserMsg_StatsHeroLookup.
         * @implements ICDOTAUserMsg_StatsHeroLookup
         * @constructor
         * @param {ICDOTAUserMsg_StatsHeroLookup=} [properties] Properties to set
         */
        function CDOTAUserMsg_StatsHeroLookup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_StatsHeroLookup player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_StatsHeroLookup
         * @instance
         */
        CDOTAUserMsg_StatsHeroLookup.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_StatsHeroLookup hero_id.
         * @member {number} hero_id
         * @memberof CDOTAUserMsg_StatsHeroLookup
         * @instance
         */
        CDOTAUserMsg_StatsHeroLookup.prototype.hero_id = 0;
    
        /**
         * CDOTAUserMsg_StatsHeroLookup hero_name.
         * @member {string} hero_name
         * @memberof CDOTAUserMsg_StatsHeroLookup
         * @instance
         */
        CDOTAUserMsg_StatsHeroLookup.prototype.hero_name = "";
    
        /**
         * CDOTAUserMsg_StatsHeroLookup persona.
         * @member {string} persona
         * @memberof CDOTAUserMsg_StatsHeroLookup
         * @instance
         */
        CDOTAUserMsg_StatsHeroLookup.prototype.persona = "";
    
        /**
         * Creates a new CDOTAUserMsg_StatsHeroLookup instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_StatsHeroLookup
         * @static
         * @param {ICDOTAUserMsg_StatsHeroLookup=} [properties] Properties to set
         * @returns {CDOTAUserMsg_StatsHeroLookup} CDOTAUserMsg_StatsHeroLookup instance
         */
        CDOTAUserMsg_StatsHeroLookup.create = function create(properties) {
            return new CDOTAUserMsg_StatsHeroLookup(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_StatsHeroLookup message. Does not implicitly {@link CDOTAUserMsg_StatsHeroLookup.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_StatsHeroLookup
         * @static
         * @param {ICDOTAUserMsg_StatsHeroLookup} message CDOTAUserMsg_StatsHeroLookup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_StatsHeroLookup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.player_id);
            if (message.hero_id != null && Object.hasOwnProperty.call(message, "hero_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.hero_id);
            if (message.hero_name != null && Object.hasOwnProperty.call(message, "hero_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.hero_name);
            if (message.persona != null && Object.hasOwnProperty.call(message, "persona"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.persona);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_StatsHeroLookup message, length delimited. Does not implicitly {@link CDOTAUserMsg_StatsHeroLookup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_StatsHeroLookup
         * @static
         * @param {ICDOTAUserMsg_StatsHeroLookup} message CDOTAUserMsg_StatsHeroLookup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_StatsHeroLookup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_StatsHeroLookup message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_StatsHeroLookup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_StatsHeroLookup} CDOTAUserMsg_StatsHeroLookup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_StatsHeroLookup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_StatsHeroLookup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.int32();
                    break;
                case 2:
                    message.hero_id = reader.int32();
                    break;
                case 3:
                    message.hero_name = reader.string();
                    break;
                case 4:
                    message.persona = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_StatsHeroLookup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_StatsHeroLookup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_StatsHeroLookup} CDOTAUserMsg_StatsHeroLookup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_StatsHeroLookup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_StatsHeroLookup message.
         * @function verify
         * @memberof CDOTAUserMsg_StatsHeroLookup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_StatsHeroLookup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.hero_id != null && message.hasOwnProperty("hero_id"))
                if (!$util.isInteger(message.hero_id))
                    return "hero_id: integer expected";
            if (message.hero_name != null && message.hasOwnProperty("hero_name"))
                if (!$util.isString(message.hero_name))
                    return "hero_name: string expected";
            if (message.persona != null && message.hasOwnProperty("persona"))
                if (!$util.isString(message.persona))
                    return "persona: string expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_StatsHeroLookup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_StatsHeroLookup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_StatsHeroLookup} CDOTAUserMsg_StatsHeroLookup
         */
        CDOTAUserMsg_StatsHeroLookup.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_StatsHeroLookup)
                return object;
            var message = new $root.CDOTAUserMsg_StatsHeroLookup();
            if (object.player_id != null)
                message.player_id = object.player_id | 0;
            if (object.hero_id != null)
                message.hero_id = object.hero_id | 0;
            if (object.hero_name != null)
                message.hero_name = String(object.hero_name);
            if (object.persona != null)
                message.persona = String(object.persona);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_StatsHeroLookup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_StatsHeroLookup
         * @static
         * @param {CDOTAUserMsg_StatsHeroLookup} message CDOTAUserMsg_StatsHeroLookup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_StatsHeroLookup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.hero_id = 0;
                object.hero_name = "";
                object.persona = "";
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.hero_id != null && message.hasOwnProperty("hero_id"))
                object.hero_id = message.hero_id;
            if (message.hero_name != null && message.hasOwnProperty("hero_name"))
                object.hero_name = message.hero_name;
            if (message.persona != null && message.hasOwnProperty("persona"))
                object.persona = message.persona;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_StatsHeroLookup to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_StatsHeroLookup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_StatsHeroLookup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_StatsHeroLookup;
    })();
    
    $root.CDOTAUserMsg_StatsHeroPositionInfo = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_StatsHeroPositionInfo.
         * @exports ICDOTAUserMsg_StatsHeroPositionInfo
         * @interface ICDOTAUserMsg_StatsHeroPositionInfo
         * @property {number|null} [average_position] CDOTAUserMsg_StatsHeroPositionInfo average_position
         * @property {Array.<CDOTAUserMsg_StatsHeroPositionInfo.IPositionPair>|null} [position_details] CDOTAUserMsg_StatsHeroPositionInfo position_details
         */
    
        /**
         * Constructs a new CDOTAUserMsg_StatsHeroPositionInfo.
         * @exports CDOTAUserMsg_StatsHeroPositionInfo
         * @classdesc Represents a CDOTAUserMsg_StatsHeroPositionInfo.
         * @implements ICDOTAUserMsg_StatsHeroPositionInfo
         * @constructor
         * @param {ICDOTAUserMsg_StatsHeroPositionInfo=} [properties] Properties to set
         */
        function CDOTAUserMsg_StatsHeroPositionInfo(properties) {
            this.position_details = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_StatsHeroPositionInfo average_position.
         * @member {number} average_position
         * @memberof CDOTAUserMsg_StatsHeroPositionInfo
         * @instance
         */
        CDOTAUserMsg_StatsHeroPositionInfo.prototype.average_position = 0;
    
        /**
         * CDOTAUserMsg_StatsHeroPositionInfo position_details.
         * @member {Array.<CDOTAUserMsg_StatsHeroPositionInfo.IPositionPair>} position_details
         * @memberof CDOTAUserMsg_StatsHeroPositionInfo
         * @instance
         */
        CDOTAUserMsg_StatsHeroPositionInfo.prototype.position_details = $util.emptyArray;
    
        /**
         * Creates a new CDOTAUserMsg_StatsHeroPositionInfo instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_StatsHeroPositionInfo
         * @static
         * @param {ICDOTAUserMsg_StatsHeroPositionInfo=} [properties] Properties to set
         * @returns {CDOTAUserMsg_StatsHeroPositionInfo} CDOTAUserMsg_StatsHeroPositionInfo instance
         */
        CDOTAUserMsg_StatsHeroPositionInfo.create = function create(properties) {
            return new CDOTAUserMsg_StatsHeroPositionInfo(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_StatsHeroPositionInfo message. Does not implicitly {@link CDOTAUserMsg_StatsHeroPositionInfo.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_StatsHeroPositionInfo
         * @static
         * @param {ICDOTAUserMsg_StatsHeroPositionInfo} message CDOTAUserMsg_StatsHeroPositionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_StatsHeroPositionInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.average_position != null && Object.hasOwnProperty.call(message, "average_position"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.average_position);
            if (message.position_details != null && message.position_details.length)
                for (var i = 0; i < message.position_details.length; ++i)
                    $root.CDOTAUserMsg_StatsHeroPositionInfo.PositionPair.encode(message.position_details[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_StatsHeroPositionInfo message, length delimited. Does not implicitly {@link CDOTAUserMsg_StatsHeroPositionInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_StatsHeroPositionInfo
         * @static
         * @param {ICDOTAUserMsg_StatsHeroPositionInfo} message CDOTAUserMsg_StatsHeroPositionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_StatsHeroPositionInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_StatsHeroPositionInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_StatsHeroPositionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_StatsHeroPositionInfo} CDOTAUserMsg_StatsHeroPositionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_StatsHeroPositionInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_StatsHeroPositionInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.average_position = reader.float();
                    break;
                case 2:
                    if (!(message.position_details && message.position_details.length))
                        message.position_details = [];
                    message.position_details.push($root.CDOTAUserMsg_StatsHeroPositionInfo.PositionPair.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_StatsHeroPositionInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_StatsHeroPositionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_StatsHeroPositionInfo} CDOTAUserMsg_StatsHeroPositionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_StatsHeroPositionInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_StatsHeroPositionInfo message.
         * @function verify
         * @memberof CDOTAUserMsg_StatsHeroPositionInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_StatsHeroPositionInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.average_position != null && message.hasOwnProperty("average_position"))
                if (typeof message.average_position !== "number")
                    return "average_position: number expected";
            if (message.position_details != null && message.hasOwnProperty("position_details")) {
                if (!Array.isArray(message.position_details))
                    return "position_details: array expected";
                for (var i = 0; i < message.position_details.length; ++i) {
                    var error = $root.CDOTAUserMsg_StatsHeroPositionInfo.PositionPair.verify(message.position_details[i]);
                    if (error)
                        return "position_details." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_StatsHeroPositionInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_StatsHeroPositionInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_StatsHeroPositionInfo} CDOTAUserMsg_StatsHeroPositionInfo
         */
        CDOTAUserMsg_StatsHeroPositionInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_StatsHeroPositionInfo)
                return object;
            var message = new $root.CDOTAUserMsg_StatsHeroPositionInfo();
            if (object.average_position != null)
                message.average_position = Number(object.average_position);
            if (object.position_details) {
                if (!Array.isArray(object.position_details))
                    throw TypeError(".CDOTAUserMsg_StatsHeroPositionInfo.position_details: array expected");
                message.position_details = [];
                for (var i = 0; i < object.position_details.length; ++i) {
                    if (typeof object.position_details[i] !== "object")
                        throw TypeError(".CDOTAUserMsg_StatsHeroPositionInfo.position_details: object expected");
                    message.position_details[i] = $root.CDOTAUserMsg_StatsHeroPositionInfo.PositionPair.fromObject(object.position_details[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_StatsHeroPositionInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_StatsHeroPositionInfo
         * @static
         * @param {CDOTAUserMsg_StatsHeroPositionInfo} message CDOTAUserMsg_StatsHeroPositionInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_StatsHeroPositionInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.position_details = [];
            if (options.defaults)
                object.average_position = 0;
            if (message.average_position != null && message.hasOwnProperty("average_position"))
                object.average_position = options.json && !isFinite(message.average_position) ? String(message.average_position) : message.average_position;
            if (message.position_details && message.position_details.length) {
                object.position_details = [];
                for (var j = 0; j < message.position_details.length; ++j)
                    object.position_details[j] = $root.CDOTAUserMsg_StatsHeroPositionInfo.PositionPair.toObject(message.position_details[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_StatsHeroPositionInfo to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_StatsHeroPositionInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_StatsHeroPositionInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CDOTAUserMsg_StatsHeroPositionInfo.PositionPair = (function() {
    
            /**
             * Properties of a PositionPair.
             * @memberof CDOTAUserMsg_StatsHeroPositionInfo
             * @interface IPositionPair
             * @property {DOTA_POSITION_CATEGORY|null} [position_category] PositionPair position_category
             * @property {number|null} [position_count] PositionPair position_count
             */
    
            /**
             * Constructs a new PositionPair.
             * @memberof CDOTAUserMsg_StatsHeroPositionInfo
             * @classdesc Represents a PositionPair.
             * @implements IPositionPair
             * @constructor
             * @param {CDOTAUserMsg_StatsHeroPositionInfo.IPositionPair=} [properties] Properties to set
             */
            function PositionPair(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PositionPair position_category.
             * @member {DOTA_POSITION_CATEGORY} position_category
             * @memberof CDOTAUserMsg_StatsHeroPositionInfo.PositionPair
             * @instance
             */
            PositionPair.prototype.position_category = 0;
    
            /**
             * PositionPair position_count.
             * @member {number} position_count
             * @memberof CDOTAUserMsg_StatsHeroPositionInfo.PositionPair
             * @instance
             */
            PositionPair.prototype.position_count = 0;
    
            /**
             * Creates a new PositionPair instance using the specified properties.
             * @function create
             * @memberof CDOTAUserMsg_StatsHeroPositionInfo.PositionPair
             * @static
             * @param {CDOTAUserMsg_StatsHeroPositionInfo.IPositionPair=} [properties] Properties to set
             * @returns {CDOTAUserMsg_StatsHeroPositionInfo.PositionPair} PositionPair instance
             */
            PositionPair.create = function create(properties) {
                return new PositionPair(properties);
            };
    
            /**
             * Encodes the specified PositionPair message. Does not implicitly {@link CDOTAUserMsg_StatsHeroPositionInfo.PositionPair.verify|verify} messages.
             * @function encode
             * @memberof CDOTAUserMsg_StatsHeroPositionInfo.PositionPair
             * @static
             * @param {CDOTAUserMsg_StatsHeroPositionInfo.IPositionPair} message PositionPair message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PositionPair.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.position_category != null && Object.hasOwnProperty.call(message, "position_category"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.position_category);
                if (message.position_count != null && Object.hasOwnProperty.call(message, "position_count"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.position_count);
                return writer;
            };
    
            /**
             * Encodes the specified PositionPair message, length delimited. Does not implicitly {@link CDOTAUserMsg_StatsHeroPositionInfo.PositionPair.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTAUserMsg_StatsHeroPositionInfo.PositionPair
             * @static
             * @param {CDOTAUserMsg_StatsHeroPositionInfo.IPositionPair} message PositionPair message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PositionPair.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PositionPair message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTAUserMsg_StatsHeroPositionInfo.PositionPair
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTAUserMsg_StatsHeroPositionInfo.PositionPair} PositionPair
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PositionPair.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_StatsHeroPositionInfo.PositionPair();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.position_category = reader.int32();
                        break;
                    case 2:
                        message.position_count = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PositionPair message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTAUserMsg_StatsHeroPositionInfo.PositionPair
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTAUserMsg_StatsHeroPositionInfo.PositionPair} PositionPair
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PositionPair.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PositionPair message.
             * @function verify
             * @memberof CDOTAUserMsg_StatsHeroPositionInfo.PositionPair
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PositionPair.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.position_category != null && message.hasOwnProperty("position_category"))
                    switch (message.position_category) {
                    default:
                        return "position_category: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                        break;
                    }
                if (message.position_count != null && message.hasOwnProperty("position_count"))
                    if (!$util.isInteger(message.position_count))
                        return "position_count: integer expected";
                return null;
            };
    
            /**
             * Creates a PositionPair message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTAUserMsg_StatsHeroPositionInfo.PositionPair
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTAUserMsg_StatsHeroPositionInfo.PositionPair} PositionPair
             */
            PositionPair.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTAUserMsg_StatsHeroPositionInfo.PositionPair)
                    return object;
                var message = new $root.CDOTAUserMsg_StatsHeroPositionInfo.PositionPair();
                switch (object.position_category) {
                case "DOTA_POSITION_NONE":
                case 0:
                    message.position_category = 0;
                    break;
                case "DOTA_POSITION_BOTTOM_LANE":
                case 1:
                    message.position_category = 1;
                    break;
                case "DOTA_POSITION_MID_LANE":
                case 2:
                    message.position_category = 2;
                    break;
                case "DOTA_POSITION_TOP_LANE":
                case 3:
                    message.position_category = 3;
                    break;
                case "DOTA_POSITION_RADIANT_JUNGLE":
                case 4:
                    message.position_category = 4;
                    break;
                case "DOTA_POSITION_DIRE_JUNGLE":
                case 5:
                    message.position_category = 5;
                    break;
                case "DOTA_POSITION_RADIANT_ANCIENTS":
                case 6:
                    message.position_category = 6;
                    break;
                case "DOTA_POSITION_DIRE_ANCIENTS":
                case 7:
                    message.position_category = 7;
                    break;
                case "DOTA_POSITION_RADIANT_SECRET_SHOP":
                case 8:
                    message.position_category = 8;
                    break;
                case "DOTA_POSITION_DIRE_SECRET_SHOP":
                case 9:
                    message.position_category = 9;
                    break;
                case "DOTA_POSITION_RIVER":
                case 10:
                    message.position_category = 10;
                    break;
                case "DOTA_POSITION_ROSHAN_PIT":
                case 11:
                    message.position_category = 11;
                    break;
                case "DOTA_POSITION_RADIANT_BASE":
                case 12:
                    message.position_category = 12;
                    break;
                case "DOTA_POSITION_DIRE_BASE":
                case 13:
                    message.position_category = 13;
                    break;
                case "DOTA_POSITION_FOUNTAIN":
                case 14:
                    message.position_category = 14;
                    break;
                case "DOTA_POSITION_OTHER":
                case 15:
                    message.position_category = 15;
                    break;
                }
                if (object.position_count != null)
                    message.position_count = object.position_count >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a PositionPair message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTAUserMsg_StatsHeroPositionInfo.PositionPair
             * @static
             * @param {CDOTAUserMsg_StatsHeroPositionInfo.PositionPair} message PositionPair
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PositionPair.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.position_category = options.enums === String ? "DOTA_POSITION_NONE" : 0;
                    object.position_count = 0;
                }
                if (message.position_category != null && message.hasOwnProperty("position_category"))
                    object.position_category = options.enums === String ? $root.DOTA_POSITION_CATEGORY[message.position_category] : message.position_category;
                if (message.position_count != null && message.hasOwnProperty("position_count"))
                    object.position_count = message.position_count;
                return object;
            };
    
            /**
             * Converts this PositionPair to JSON.
             * @function toJSON
             * @memberof CDOTAUserMsg_StatsHeroPositionInfo.PositionPair
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PositionPair.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PositionPair;
        })();
    
        return CDOTAUserMsg_StatsHeroPositionInfo;
    })();
    
    $root.CDOTAUserMsg_StatsHeroMinuteDetails = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_StatsHeroMinuteDetails.
         * @exports ICDOTAUserMsg_StatsHeroMinuteDetails
         * @interface ICDOTAUserMsg_StatsHeroMinuteDetails
         * @property {number|null} [last_hits] CDOTAUserMsg_StatsHeroMinuteDetails last_hits
         * @property {number|null} [hero_kills] CDOTAUserMsg_StatsHeroMinuteDetails hero_kills
         * @property {number|null} [hero_damage] CDOTAUserMsg_StatsHeroMinuteDetails hero_damage
         * @property {number|null} [tower_damage] CDOTAUserMsg_StatsHeroMinuteDetails tower_damage
         * @property {ICDOTAUserMsg_StatsHeroPositionInfo|null} [position_info] CDOTAUserMsg_StatsHeroMinuteDetails position_info
         * @property {number|null} [total_xp] CDOTAUserMsg_StatsHeroMinuteDetails total_xp
         * @property {number|null} [net_worth] CDOTAUserMsg_StatsHeroMinuteDetails net_worth
         * @property {number|null} [harvested_creep_gold] CDOTAUserMsg_StatsHeroMinuteDetails harvested_creep_gold
         * @property {number|null} [claimed_farm] CDOTAUserMsg_StatsHeroMinuteDetails claimed_farm
         * @property {number|null} [wards_placed] CDOTAUserMsg_StatsHeroMinuteDetails wards_placed
         * @property {number|null} [runes_collected] CDOTAUserMsg_StatsHeroMinuteDetails runes_collected
         * @property {number|null} [tps_used] CDOTAUserMsg_StatsHeroMinuteDetails tps_used
         * @property {Array.<number>|null} [mana_spent] CDOTAUserMsg_StatsHeroMinuteDetails mana_spent
         * @property {Array.<number>|null} [damage_absorbed] CDOTAUserMsg_StatsHeroMinuteDetails damage_absorbed
         * @property {Array.<number>|null} [damage_done] CDOTAUserMsg_StatsHeroMinuteDetails damage_done
         */
    
        /**
         * Constructs a new CDOTAUserMsg_StatsHeroMinuteDetails.
         * @exports CDOTAUserMsg_StatsHeroMinuteDetails
         * @classdesc Represents a CDOTAUserMsg_StatsHeroMinuteDetails.
         * @implements ICDOTAUserMsg_StatsHeroMinuteDetails
         * @constructor
         * @param {ICDOTAUserMsg_StatsHeroMinuteDetails=} [properties] Properties to set
         */
        function CDOTAUserMsg_StatsHeroMinuteDetails(properties) {
            this.mana_spent = [];
            this.damage_absorbed = [];
            this.damage_done = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_StatsHeroMinuteDetails last_hits.
         * @member {number} last_hits
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.prototype.last_hits = 0;
    
        /**
         * CDOTAUserMsg_StatsHeroMinuteDetails hero_kills.
         * @member {number} hero_kills
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.prototype.hero_kills = 0;
    
        /**
         * CDOTAUserMsg_StatsHeroMinuteDetails hero_damage.
         * @member {number} hero_damage
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.prototype.hero_damage = 0;
    
        /**
         * CDOTAUserMsg_StatsHeroMinuteDetails tower_damage.
         * @member {number} tower_damage
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.prototype.tower_damage = 0;
    
        /**
         * CDOTAUserMsg_StatsHeroMinuteDetails position_info.
         * @member {ICDOTAUserMsg_StatsHeroPositionInfo|null|undefined} position_info
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.prototype.position_info = null;
    
        /**
         * CDOTAUserMsg_StatsHeroMinuteDetails total_xp.
         * @member {number} total_xp
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.prototype.total_xp = 0;
    
        /**
         * CDOTAUserMsg_StatsHeroMinuteDetails net_worth.
         * @member {number} net_worth
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.prototype.net_worth = 0;
    
        /**
         * CDOTAUserMsg_StatsHeroMinuteDetails harvested_creep_gold.
         * @member {number} harvested_creep_gold
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.prototype.harvested_creep_gold = 0;
    
        /**
         * CDOTAUserMsg_StatsHeroMinuteDetails claimed_farm.
         * @member {number} claimed_farm
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.prototype.claimed_farm = 0;
    
        /**
         * CDOTAUserMsg_StatsHeroMinuteDetails wards_placed.
         * @member {number} wards_placed
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.prototype.wards_placed = 0;
    
        /**
         * CDOTAUserMsg_StatsHeroMinuteDetails runes_collected.
         * @member {number} runes_collected
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.prototype.runes_collected = 0;
    
        /**
         * CDOTAUserMsg_StatsHeroMinuteDetails tps_used.
         * @member {number} tps_used
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.prototype.tps_used = 0;
    
        /**
         * CDOTAUserMsg_StatsHeroMinuteDetails mana_spent.
         * @member {Array.<number>} mana_spent
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.prototype.mana_spent = $util.emptyArray;
    
        /**
         * CDOTAUserMsg_StatsHeroMinuteDetails damage_absorbed.
         * @member {Array.<number>} damage_absorbed
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.prototype.damage_absorbed = $util.emptyArray;
    
        /**
         * CDOTAUserMsg_StatsHeroMinuteDetails damage_done.
         * @member {Array.<number>} damage_done
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.prototype.damage_done = $util.emptyArray;
    
        /**
         * Creates a new CDOTAUserMsg_StatsHeroMinuteDetails instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @static
         * @param {ICDOTAUserMsg_StatsHeroMinuteDetails=} [properties] Properties to set
         * @returns {CDOTAUserMsg_StatsHeroMinuteDetails} CDOTAUserMsg_StatsHeroMinuteDetails instance
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.create = function create(properties) {
            return new CDOTAUserMsg_StatsHeroMinuteDetails(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_StatsHeroMinuteDetails message. Does not implicitly {@link CDOTAUserMsg_StatsHeroMinuteDetails.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @static
         * @param {ICDOTAUserMsg_StatsHeroMinuteDetails} message CDOTAUserMsg_StatsHeroMinuteDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.last_hits != null && Object.hasOwnProperty.call(message, "last_hits"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.last_hits);
            if (message.hero_kills != null && Object.hasOwnProperty.call(message, "hero_kills"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.hero_kills);
            if (message.hero_damage != null && Object.hasOwnProperty.call(message, "hero_damage"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.hero_damage);
            if (message.tower_damage != null && Object.hasOwnProperty.call(message, "tower_damage"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.tower_damage);
            if (message.position_info != null && Object.hasOwnProperty.call(message, "position_info"))
                $root.CDOTAUserMsg_StatsHeroPositionInfo.encode(message.position_info, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.total_xp != null && Object.hasOwnProperty.call(message, "total_xp"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.total_xp);
            if (message.net_worth != null && Object.hasOwnProperty.call(message, "net_worth"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.net_worth);
            if (message.harvested_creep_gold != null && Object.hasOwnProperty.call(message, "harvested_creep_gold"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.harvested_creep_gold);
            if (message.claimed_farm != null && Object.hasOwnProperty.call(message, "claimed_farm"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.claimed_farm);
            if (message.wards_placed != null && Object.hasOwnProperty.call(message, "wards_placed"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.wards_placed);
            if (message.runes_collected != null && Object.hasOwnProperty.call(message, "runes_collected"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.runes_collected);
            if (message.tps_used != null && Object.hasOwnProperty.call(message, "tps_used"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.tps_used);
            if (message.mana_spent != null && message.mana_spent.length)
                for (var i = 0; i < message.mana_spent.length; ++i)
                    writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.mana_spent[i]);
            if (message.damage_absorbed != null && message.damage_absorbed.length)
                for (var i = 0; i < message.damage_absorbed.length; ++i)
                    writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.damage_absorbed[i]);
            if (message.damage_done != null && message.damage_done.length)
                for (var i = 0; i < message.damage_done.length; ++i)
                    writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.damage_done[i]);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_StatsHeroMinuteDetails message, length delimited. Does not implicitly {@link CDOTAUserMsg_StatsHeroMinuteDetails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @static
         * @param {ICDOTAUserMsg_StatsHeroMinuteDetails} message CDOTAUserMsg_StatsHeroMinuteDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_StatsHeroMinuteDetails message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_StatsHeroMinuteDetails} CDOTAUserMsg_StatsHeroMinuteDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_StatsHeroMinuteDetails();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.last_hits = reader.uint32();
                    break;
                case 2:
                    message.hero_kills = reader.uint32();
                    break;
                case 3:
                    message.hero_damage = reader.uint32();
                    break;
                case 4:
                    message.tower_damage = reader.uint32();
                    break;
                case 5:
                    message.position_info = $root.CDOTAUserMsg_StatsHeroPositionInfo.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.total_xp = reader.uint32();
                    break;
                case 7:
                    message.net_worth = reader.uint32();
                    break;
                case 8:
                    message.harvested_creep_gold = reader.uint32();
                    break;
                case 9:
                    message.claimed_farm = reader.uint32();
                    break;
                case 10:
                    message.wards_placed = reader.uint32();
                    break;
                case 11:
                    message.runes_collected = reader.uint32();
                    break;
                case 12:
                    message.tps_used = reader.uint32();
                    break;
                case 13:
                    if (!(message.mana_spent && message.mana_spent.length))
                        message.mana_spent = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.mana_spent.push(reader.uint32());
                    } else
                        message.mana_spent.push(reader.uint32());
                    break;
                case 14:
                    if (!(message.damage_absorbed && message.damage_absorbed.length))
                        message.damage_absorbed = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.damage_absorbed.push(reader.uint32());
                    } else
                        message.damage_absorbed.push(reader.uint32());
                    break;
                case 15:
                    if (!(message.damage_done && message.damage_done.length))
                        message.damage_done = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.damage_done.push(reader.uint32());
                    } else
                        message.damage_done.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_StatsHeroMinuteDetails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_StatsHeroMinuteDetails} CDOTAUserMsg_StatsHeroMinuteDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_StatsHeroMinuteDetails message.
         * @function verify
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.last_hits != null && message.hasOwnProperty("last_hits"))
                if (!$util.isInteger(message.last_hits))
                    return "last_hits: integer expected";
            if (message.hero_kills != null && message.hasOwnProperty("hero_kills"))
                if (!$util.isInteger(message.hero_kills))
                    return "hero_kills: integer expected";
            if (message.hero_damage != null && message.hasOwnProperty("hero_damage"))
                if (!$util.isInteger(message.hero_damage))
                    return "hero_damage: integer expected";
            if (message.tower_damage != null && message.hasOwnProperty("tower_damage"))
                if (!$util.isInteger(message.tower_damage))
                    return "tower_damage: integer expected";
            if (message.position_info != null && message.hasOwnProperty("position_info")) {
                var error = $root.CDOTAUserMsg_StatsHeroPositionInfo.verify(message.position_info);
                if (error)
                    return "position_info." + error;
            }
            if (message.total_xp != null && message.hasOwnProperty("total_xp"))
                if (!$util.isInteger(message.total_xp))
                    return "total_xp: integer expected";
            if (message.net_worth != null && message.hasOwnProperty("net_worth"))
                if (!$util.isInteger(message.net_worth))
                    return "net_worth: integer expected";
            if (message.harvested_creep_gold != null && message.hasOwnProperty("harvested_creep_gold"))
                if (!$util.isInteger(message.harvested_creep_gold))
                    return "harvested_creep_gold: integer expected";
            if (message.claimed_farm != null && message.hasOwnProperty("claimed_farm"))
                if (!$util.isInteger(message.claimed_farm))
                    return "claimed_farm: integer expected";
            if (message.wards_placed != null && message.hasOwnProperty("wards_placed"))
                if (!$util.isInteger(message.wards_placed))
                    return "wards_placed: integer expected";
            if (message.runes_collected != null && message.hasOwnProperty("runes_collected"))
                if (!$util.isInteger(message.runes_collected))
                    return "runes_collected: integer expected";
            if (message.tps_used != null && message.hasOwnProperty("tps_used"))
                if (!$util.isInteger(message.tps_used))
                    return "tps_used: integer expected";
            if (message.mana_spent != null && message.hasOwnProperty("mana_spent")) {
                if (!Array.isArray(message.mana_spent))
                    return "mana_spent: array expected";
                for (var i = 0; i < message.mana_spent.length; ++i)
                    if (!$util.isInteger(message.mana_spent[i]))
                        return "mana_spent: integer[] expected";
            }
            if (message.damage_absorbed != null && message.hasOwnProperty("damage_absorbed")) {
                if (!Array.isArray(message.damage_absorbed))
                    return "damage_absorbed: array expected";
                for (var i = 0; i < message.damage_absorbed.length; ++i)
                    if (!$util.isInteger(message.damage_absorbed[i]))
                        return "damage_absorbed: integer[] expected";
            }
            if (message.damage_done != null && message.hasOwnProperty("damage_done")) {
                if (!Array.isArray(message.damage_done))
                    return "damage_done: array expected";
                for (var i = 0; i < message.damage_done.length; ++i)
                    if (!$util.isInteger(message.damage_done[i]))
                        return "damage_done: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_StatsHeroMinuteDetails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_StatsHeroMinuteDetails} CDOTAUserMsg_StatsHeroMinuteDetails
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_StatsHeroMinuteDetails)
                return object;
            var message = new $root.CDOTAUserMsg_StatsHeroMinuteDetails();
            if (object.last_hits != null)
                message.last_hits = object.last_hits >>> 0;
            if (object.hero_kills != null)
                message.hero_kills = object.hero_kills >>> 0;
            if (object.hero_damage != null)
                message.hero_damage = object.hero_damage >>> 0;
            if (object.tower_damage != null)
                message.tower_damage = object.tower_damage >>> 0;
            if (object.position_info != null) {
                if (typeof object.position_info !== "object")
                    throw TypeError(".CDOTAUserMsg_StatsHeroMinuteDetails.position_info: object expected");
                message.position_info = $root.CDOTAUserMsg_StatsHeroPositionInfo.fromObject(object.position_info);
            }
            if (object.total_xp != null)
                message.total_xp = object.total_xp >>> 0;
            if (object.net_worth != null)
                message.net_worth = object.net_worth >>> 0;
            if (object.harvested_creep_gold != null)
                message.harvested_creep_gold = object.harvested_creep_gold >>> 0;
            if (object.claimed_farm != null)
                message.claimed_farm = object.claimed_farm >>> 0;
            if (object.wards_placed != null)
                message.wards_placed = object.wards_placed >>> 0;
            if (object.runes_collected != null)
                message.runes_collected = object.runes_collected >>> 0;
            if (object.tps_used != null)
                message.tps_used = object.tps_used >>> 0;
            if (object.mana_spent) {
                if (!Array.isArray(object.mana_spent))
                    throw TypeError(".CDOTAUserMsg_StatsHeroMinuteDetails.mana_spent: array expected");
                message.mana_spent = [];
                for (var i = 0; i < object.mana_spent.length; ++i)
                    message.mana_spent[i] = object.mana_spent[i] >>> 0;
            }
            if (object.damage_absorbed) {
                if (!Array.isArray(object.damage_absorbed))
                    throw TypeError(".CDOTAUserMsg_StatsHeroMinuteDetails.damage_absorbed: array expected");
                message.damage_absorbed = [];
                for (var i = 0; i < object.damage_absorbed.length; ++i)
                    message.damage_absorbed[i] = object.damage_absorbed[i] >>> 0;
            }
            if (object.damage_done) {
                if (!Array.isArray(object.damage_done))
                    throw TypeError(".CDOTAUserMsg_StatsHeroMinuteDetails.damage_done: array expected");
                message.damage_done = [];
                for (var i = 0; i < object.damage_done.length; ++i)
                    message.damage_done[i] = object.damage_done[i] >>> 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_StatsHeroMinuteDetails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @static
         * @param {CDOTAUserMsg_StatsHeroMinuteDetails} message CDOTAUserMsg_StatsHeroMinuteDetails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.mana_spent = [];
                object.damage_absorbed = [];
                object.damage_done = [];
            }
            if (options.defaults) {
                object.last_hits = 0;
                object.hero_kills = 0;
                object.hero_damage = 0;
                object.tower_damage = 0;
                object.position_info = null;
                object.total_xp = 0;
                object.net_worth = 0;
                object.harvested_creep_gold = 0;
                object.claimed_farm = 0;
                object.wards_placed = 0;
                object.runes_collected = 0;
                object.tps_used = 0;
            }
            if (message.last_hits != null && message.hasOwnProperty("last_hits"))
                object.last_hits = message.last_hits;
            if (message.hero_kills != null && message.hasOwnProperty("hero_kills"))
                object.hero_kills = message.hero_kills;
            if (message.hero_damage != null && message.hasOwnProperty("hero_damage"))
                object.hero_damage = message.hero_damage;
            if (message.tower_damage != null && message.hasOwnProperty("tower_damage"))
                object.tower_damage = message.tower_damage;
            if (message.position_info != null && message.hasOwnProperty("position_info"))
                object.position_info = $root.CDOTAUserMsg_StatsHeroPositionInfo.toObject(message.position_info, options);
            if (message.total_xp != null && message.hasOwnProperty("total_xp"))
                object.total_xp = message.total_xp;
            if (message.net_worth != null && message.hasOwnProperty("net_worth"))
                object.net_worth = message.net_worth;
            if (message.harvested_creep_gold != null && message.hasOwnProperty("harvested_creep_gold"))
                object.harvested_creep_gold = message.harvested_creep_gold;
            if (message.claimed_farm != null && message.hasOwnProperty("claimed_farm"))
                object.claimed_farm = message.claimed_farm;
            if (message.wards_placed != null && message.hasOwnProperty("wards_placed"))
                object.wards_placed = message.wards_placed;
            if (message.runes_collected != null && message.hasOwnProperty("runes_collected"))
                object.runes_collected = message.runes_collected;
            if (message.tps_used != null && message.hasOwnProperty("tps_used"))
                object.tps_used = message.tps_used;
            if (message.mana_spent && message.mana_spent.length) {
                object.mana_spent = [];
                for (var j = 0; j < message.mana_spent.length; ++j)
                    object.mana_spent[j] = message.mana_spent[j];
            }
            if (message.damage_absorbed && message.damage_absorbed.length) {
                object.damage_absorbed = [];
                for (var j = 0; j < message.damage_absorbed.length; ++j)
                    object.damage_absorbed[j] = message.damage_absorbed[j];
            }
            if (message.damage_done && message.damage_done.length) {
                object.damage_done = [];
                for (var j = 0; j < message.damage_done.length; ++j)
                    object.damage_done[j] = message.damage_done[j];
            }
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_StatsHeroMinuteDetails to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_StatsHeroMinuteDetails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_StatsHeroMinuteDetails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_StatsHeroMinuteDetails;
    })();
    
    $root.CDOTAUserMsg_StatsTeamMinuteDetails = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_StatsTeamMinuteDetails.
         * @exports ICDOTAUserMsg_StatsTeamMinuteDetails
         * @interface ICDOTAUserMsg_StatsTeamMinuteDetails
         * @property {Array.<ICDOTAUserMsg_StatsHeroMinuteDetails>|null} [player_stats] CDOTAUserMsg_StatsTeamMinuteDetails player_stats
         * @property {number|null} [tower_kills] CDOTAUserMsg_StatsTeamMinuteDetails tower_kills
         * @property {number|null} [barrack_kills] CDOTAUserMsg_StatsTeamMinuteDetails barrack_kills
         * @property {number|null} [available_lane_creep_gold] CDOTAUserMsg_StatsTeamMinuteDetails available_lane_creep_gold
         * @property {number|null} [balance_kill_value] CDOTAUserMsg_StatsTeamMinuteDetails balance_kill_value
         * @property {number|null} [balance_tower_value] CDOTAUserMsg_StatsTeamMinuteDetails balance_tower_value
         * @property {number|null} [balance_barracks_value] CDOTAUserMsg_StatsTeamMinuteDetails balance_barracks_value
         * @property {number|null} [balance_gold_value] CDOTAUserMsg_StatsTeamMinuteDetails balance_gold_value
         * @property {number|null} [balance_xp_value] CDOTAUserMsg_StatsTeamMinuteDetails balance_xp_value
         * @property {Array.<CDOTAUserMsg_StatsTeamMinuteDetails.ILocationPerformance>|null} [lane_performance] CDOTAUserMsg_StatsTeamMinuteDetails lane_performance
         */
    
        /**
         * Constructs a new CDOTAUserMsg_StatsTeamMinuteDetails.
         * @exports CDOTAUserMsg_StatsTeamMinuteDetails
         * @classdesc Represents a CDOTAUserMsg_StatsTeamMinuteDetails.
         * @implements ICDOTAUserMsg_StatsTeamMinuteDetails
         * @constructor
         * @param {ICDOTAUserMsg_StatsTeamMinuteDetails=} [properties] Properties to set
         */
        function CDOTAUserMsg_StatsTeamMinuteDetails(properties) {
            this.player_stats = [];
            this.lane_performance = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_StatsTeamMinuteDetails player_stats.
         * @member {Array.<ICDOTAUserMsg_StatsHeroMinuteDetails>} player_stats
         * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsTeamMinuteDetails.prototype.player_stats = $util.emptyArray;
    
        /**
         * CDOTAUserMsg_StatsTeamMinuteDetails tower_kills.
         * @member {number} tower_kills
         * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsTeamMinuteDetails.prototype.tower_kills = 0;
    
        /**
         * CDOTAUserMsg_StatsTeamMinuteDetails barrack_kills.
         * @member {number} barrack_kills
         * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsTeamMinuteDetails.prototype.barrack_kills = 0;
    
        /**
         * CDOTAUserMsg_StatsTeamMinuteDetails available_lane_creep_gold.
         * @member {number} available_lane_creep_gold
         * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsTeamMinuteDetails.prototype.available_lane_creep_gold = 0;
    
        /**
         * CDOTAUserMsg_StatsTeamMinuteDetails balance_kill_value.
         * @member {number} balance_kill_value
         * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsTeamMinuteDetails.prototype.balance_kill_value = 0;
    
        /**
         * CDOTAUserMsg_StatsTeamMinuteDetails balance_tower_value.
         * @member {number} balance_tower_value
         * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsTeamMinuteDetails.prototype.balance_tower_value = 0;
    
        /**
         * CDOTAUserMsg_StatsTeamMinuteDetails balance_barracks_value.
         * @member {number} balance_barracks_value
         * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsTeamMinuteDetails.prototype.balance_barracks_value = 0;
    
        /**
         * CDOTAUserMsg_StatsTeamMinuteDetails balance_gold_value.
         * @member {number} balance_gold_value
         * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsTeamMinuteDetails.prototype.balance_gold_value = 0;
    
        /**
         * CDOTAUserMsg_StatsTeamMinuteDetails balance_xp_value.
         * @member {number} balance_xp_value
         * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsTeamMinuteDetails.prototype.balance_xp_value = 0;
    
        /**
         * CDOTAUserMsg_StatsTeamMinuteDetails lane_performance.
         * @member {Array.<CDOTAUserMsg_StatsTeamMinuteDetails.ILocationPerformance>} lane_performance
         * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
         * @instance
         */
        CDOTAUserMsg_StatsTeamMinuteDetails.prototype.lane_performance = $util.emptyArray;
    
        /**
         * Creates a new CDOTAUserMsg_StatsTeamMinuteDetails instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
         * @static
         * @param {ICDOTAUserMsg_StatsTeamMinuteDetails=} [properties] Properties to set
         * @returns {CDOTAUserMsg_StatsTeamMinuteDetails} CDOTAUserMsg_StatsTeamMinuteDetails instance
         */
        CDOTAUserMsg_StatsTeamMinuteDetails.create = function create(properties) {
            return new CDOTAUserMsg_StatsTeamMinuteDetails(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_StatsTeamMinuteDetails message. Does not implicitly {@link CDOTAUserMsg_StatsTeamMinuteDetails.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
         * @static
         * @param {ICDOTAUserMsg_StatsTeamMinuteDetails} message CDOTAUserMsg_StatsTeamMinuteDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_StatsTeamMinuteDetails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_stats != null && message.player_stats.length)
                for (var i = 0; i < message.player_stats.length; ++i)
                    $root.CDOTAUserMsg_StatsHeroMinuteDetails.encode(message.player_stats[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.tower_kills != null && Object.hasOwnProperty.call(message, "tower_kills"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.tower_kills);
            if (message.barrack_kills != null && Object.hasOwnProperty.call(message, "barrack_kills"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.barrack_kills);
            if (message.available_lane_creep_gold != null && Object.hasOwnProperty.call(message, "available_lane_creep_gold"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.available_lane_creep_gold);
            if (message.balance_kill_value != null && Object.hasOwnProperty.call(message, "balance_kill_value"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.balance_kill_value);
            if (message.balance_tower_value != null && Object.hasOwnProperty.call(message, "balance_tower_value"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.balance_tower_value);
            if (message.balance_barracks_value != null && Object.hasOwnProperty.call(message, "balance_barracks_value"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.balance_barracks_value);
            if (message.balance_gold_value != null && Object.hasOwnProperty.call(message, "balance_gold_value"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.balance_gold_value);
            if (message.balance_xp_value != null && Object.hasOwnProperty.call(message, "balance_xp_value"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.balance_xp_value);
            if (message.lane_performance != null && message.lane_performance.length)
                for (var i = 0; i < message.lane_performance.length; ++i)
                    $root.CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance.encode(message.lane_performance[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_StatsTeamMinuteDetails message, length delimited. Does not implicitly {@link CDOTAUserMsg_StatsTeamMinuteDetails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
         * @static
         * @param {ICDOTAUserMsg_StatsTeamMinuteDetails} message CDOTAUserMsg_StatsTeamMinuteDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_StatsTeamMinuteDetails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_StatsTeamMinuteDetails message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_StatsTeamMinuteDetails} CDOTAUserMsg_StatsTeamMinuteDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_StatsTeamMinuteDetails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_StatsTeamMinuteDetails();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.player_stats && message.player_stats.length))
                        message.player_stats = [];
                    message.player_stats.push($root.CDOTAUserMsg_StatsHeroMinuteDetails.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.tower_kills = reader.uint32();
                    break;
                case 3:
                    message.barrack_kills = reader.uint32();
                    break;
                case 4:
                    message.available_lane_creep_gold = reader.uint32();
                    break;
                case 5:
                    message.balance_kill_value = reader.uint32();
                    break;
                case 6:
                    message.balance_tower_value = reader.uint32();
                    break;
                case 7:
                    message.balance_barracks_value = reader.uint32();
                    break;
                case 8:
                    message.balance_gold_value = reader.uint32();
                    break;
                case 9:
                    message.balance_xp_value = reader.uint32();
                    break;
                case 10:
                    if (!(message.lane_performance && message.lane_performance.length))
                        message.lane_performance = [];
                    message.lane_performance.push($root.CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_StatsTeamMinuteDetails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_StatsTeamMinuteDetails} CDOTAUserMsg_StatsTeamMinuteDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_StatsTeamMinuteDetails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_StatsTeamMinuteDetails message.
         * @function verify
         * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_StatsTeamMinuteDetails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_stats != null && message.hasOwnProperty("player_stats")) {
                if (!Array.isArray(message.player_stats))
                    return "player_stats: array expected";
                for (var i = 0; i < message.player_stats.length; ++i) {
                    var error = $root.CDOTAUserMsg_StatsHeroMinuteDetails.verify(message.player_stats[i]);
                    if (error)
                        return "player_stats." + error;
                }
            }
            if (message.tower_kills != null && message.hasOwnProperty("tower_kills"))
                if (!$util.isInteger(message.tower_kills))
                    return "tower_kills: integer expected";
            if (message.barrack_kills != null && message.hasOwnProperty("barrack_kills"))
                if (!$util.isInteger(message.barrack_kills))
                    return "barrack_kills: integer expected";
            if (message.available_lane_creep_gold != null && message.hasOwnProperty("available_lane_creep_gold"))
                if (!$util.isInteger(message.available_lane_creep_gold))
                    return "available_lane_creep_gold: integer expected";
            if (message.balance_kill_value != null && message.hasOwnProperty("balance_kill_value"))
                if (!$util.isInteger(message.balance_kill_value))
                    return "balance_kill_value: integer expected";
            if (message.balance_tower_value != null && message.hasOwnProperty("balance_tower_value"))
                if (!$util.isInteger(message.balance_tower_value))
                    return "balance_tower_value: integer expected";
            if (message.balance_barracks_value != null && message.hasOwnProperty("balance_barracks_value"))
                if (!$util.isInteger(message.balance_barracks_value))
                    return "balance_barracks_value: integer expected";
            if (message.balance_gold_value != null && message.hasOwnProperty("balance_gold_value"))
                if (!$util.isInteger(message.balance_gold_value))
                    return "balance_gold_value: integer expected";
            if (message.balance_xp_value != null && message.hasOwnProperty("balance_xp_value"))
                if (!$util.isInteger(message.balance_xp_value))
                    return "balance_xp_value: integer expected";
            if (message.lane_performance != null && message.hasOwnProperty("lane_performance")) {
                if (!Array.isArray(message.lane_performance))
                    return "lane_performance: array expected";
                for (var i = 0; i < message.lane_performance.length; ++i) {
                    var error = $root.CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance.verify(message.lane_performance[i]);
                    if (error)
                        return "lane_performance." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_StatsTeamMinuteDetails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_StatsTeamMinuteDetails} CDOTAUserMsg_StatsTeamMinuteDetails
         */
        CDOTAUserMsg_StatsTeamMinuteDetails.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_StatsTeamMinuteDetails)
                return object;
            var message = new $root.CDOTAUserMsg_StatsTeamMinuteDetails();
            if (object.player_stats) {
                if (!Array.isArray(object.player_stats))
                    throw TypeError(".CDOTAUserMsg_StatsTeamMinuteDetails.player_stats: array expected");
                message.player_stats = [];
                for (var i = 0; i < object.player_stats.length; ++i) {
                    if (typeof object.player_stats[i] !== "object")
                        throw TypeError(".CDOTAUserMsg_StatsTeamMinuteDetails.player_stats: object expected");
                    message.player_stats[i] = $root.CDOTAUserMsg_StatsHeroMinuteDetails.fromObject(object.player_stats[i]);
                }
            }
            if (object.tower_kills != null)
                message.tower_kills = object.tower_kills >>> 0;
            if (object.barrack_kills != null)
                message.barrack_kills = object.barrack_kills >>> 0;
            if (object.available_lane_creep_gold != null)
                message.available_lane_creep_gold = object.available_lane_creep_gold >>> 0;
            if (object.balance_kill_value != null)
                message.balance_kill_value = object.balance_kill_value >>> 0;
            if (object.balance_tower_value != null)
                message.balance_tower_value = object.balance_tower_value >>> 0;
            if (object.balance_barracks_value != null)
                message.balance_barracks_value = object.balance_barracks_value >>> 0;
            if (object.balance_gold_value != null)
                message.balance_gold_value = object.balance_gold_value >>> 0;
            if (object.balance_xp_value != null)
                message.balance_xp_value = object.balance_xp_value >>> 0;
            if (object.lane_performance) {
                if (!Array.isArray(object.lane_performance))
                    throw TypeError(".CDOTAUserMsg_StatsTeamMinuteDetails.lane_performance: array expected");
                message.lane_performance = [];
                for (var i = 0; i < object.lane_performance.length; ++i) {
                    if (typeof object.lane_performance[i] !== "object")
                        throw TypeError(".CDOTAUserMsg_StatsTeamMinuteDetails.lane_performance: object expected");
                    message.lane_performance[i] = $root.CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance.fromObject(object.lane_performance[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_StatsTeamMinuteDetails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
         * @static
         * @param {CDOTAUserMsg_StatsTeamMinuteDetails} message CDOTAUserMsg_StatsTeamMinuteDetails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_StatsTeamMinuteDetails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.player_stats = [];
                object.lane_performance = [];
            }
            if (options.defaults) {
                object.tower_kills = 0;
                object.barrack_kills = 0;
                object.available_lane_creep_gold = 0;
                object.balance_kill_value = 0;
                object.balance_tower_value = 0;
                object.balance_barracks_value = 0;
                object.balance_gold_value = 0;
                object.balance_xp_value = 0;
            }
            if (message.player_stats && message.player_stats.length) {
                object.player_stats = [];
                for (var j = 0; j < message.player_stats.length; ++j)
                    object.player_stats[j] = $root.CDOTAUserMsg_StatsHeroMinuteDetails.toObject(message.player_stats[j], options);
            }
            if (message.tower_kills != null && message.hasOwnProperty("tower_kills"))
                object.tower_kills = message.tower_kills;
            if (message.barrack_kills != null && message.hasOwnProperty("barrack_kills"))
                object.barrack_kills = message.barrack_kills;
            if (message.available_lane_creep_gold != null && message.hasOwnProperty("available_lane_creep_gold"))
                object.available_lane_creep_gold = message.available_lane_creep_gold;
            if (message.balance_kill_value != null && message.hasOwnProperty("balance_kill_value"))
                object.balance_kill_value = message.balance_kill_value;
            if (message.balance_tower_value != null && message.hasOwnProperty("balance_tower_value"))
                object.balance_tower_value = message.balance_tower_value;
            if (message.balance_barracks_value != null && message.hasOwnProperty("balance_barracks_value"))
                object.balance_barracks_value = message.balance_barracks_value;
            if (message.balance_gold_value != null && message.hasOwnProperty("balance_gold_value"))
                object.balance_gold_value = message.balance_gold_value;
            if (message.balance_xp_value != null && message.hasOwnProperty("balance_xp_value"))
                object.balance_xp_value = message.balance_xp_value;
            if (message.lane_performance && message.lane_performance.length) {
                object.lane_performance = [];
                for (var j = 0; j < message.lane_performance.length; ++j)
                    object.lane_performance[j] = $root.CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance.toObject(message.lane_performance[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_StatsTeamMinuteDetails to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_StatsTeamMinuteDetails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance = (function() {
    
            /**
             * Properties of a LocationPerformance.
             * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
             * @interface ILocationPerformance
             * @property {number|null} [location_category] LocationPerformance location_category
             * @property {number|null} [stat_type] LocationPerformance stat_type
             * @property {number|null} [value] LocationPerformance value
             */
    
            /**
             * Constructs a new LocationPerformance.
             * @memberof CDOTAUserMsg_StatsTeamMinuteDetails
             * @classdesc Represents a LocationPerformance.
             * @implements ILocationPerformance
             * @constructor
             * @param {CDOTAUserMsg_StatsTeamMinuteDetails.ILocationPerformance=} [properties] Properties to set
             */
            function LocationPerformance(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LocationPerformance location_category.
             * @member {number} location_category
             * @memberof CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance
             * @instance
             */
            LocationPerformance.prototype.location_category = 0;
    
            /**
             * LocationPerformance stat_type.
             * @member {number} stat_type
             * @memberof CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance
             * @instance
             */
            LocationPerformance.prototype.stat_type = 0;
    
            /**
             * LocationPerformance value.
             * @member {number} value
             * @memberof CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance
             * @instance
             */
            LocationPerformance.prototype.value = 0;
    
            /**
             * Creates a new LocationPerformance instance using the specified properties.
             * @function create
             * @memberof CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance
             * @static
             * @param {CDOTAUserMsg_StatsTeamMinuteDetails.ILocationPerformance=} [properties] Properties to set
             * @returns {CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance} LocationPerformance instance
             */
            LocationPerformance.create = function create(properties) {
                return new LocationPerformance(properties);
            };
    
            /**
             * Encodes the specified LocationPerformance message. Does not implicitly {@link CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance.verify|verify} messages.
             * @function encode
             * @memberof CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance
             * @static
             * @param {CDOTAUserMsg_StatsTeamMinuteDetails.ILocationPerformance} message LocationPerformance message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationPerformance.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.location_category != null && Object.hasOwnProperty.call(message, "location_category"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.location_category);
                if (message.stat_type != null && Object.hasOwnProperty.call(message, "stat_type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stat_type);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified LocationPerformance message, length delimited. Does not implicitly {@link CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance
             * @static
             * @param {CDOTAUserMsg_StatsTeamMinuteDetails.ILocationPerformance} message LocationPerformance message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationPerformance.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a LocationPerformance message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance} LocationPerformance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationPerformance.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.location_category = reader.uint32();
                        break;
                    case 2:
                        message.stat_type = reader.uint32();
                        break;
                    case 3:
                        message.value = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a LocationPerformance message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance} LocationPerformance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationPerformance.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a LocationPerformance message.
             * @function verify
             * @memberof CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocationPerformance.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.location_category != null && message.hasOwnProperty("location_category"))
                    if (!$util.isInteger(message.location_category))
                        return "location_category: integer expected";
                if (message.stat_type != null && message.hasOwnProperty("stat_type"))
                    if (!$util.isInteger(message.stat_type))
                        return "stat_type: integer expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                return null;
            };
    
            /**
             * Creates a LocationPerformance message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance} LocationPerformance
             */
            LocationPerformance.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance)
                    return object;
                var message = new $root.CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance();
                if (object.location_category != null)
                    message.location_category = object.location_category >>> 0;
                if (object.stat_type != null)
                    message.stat_type = object.stat_type >>> 0;
                if (object.value != null)
                    message.value = object.value >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a LocationPerformance message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance
             * @static
             * @param {CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance} message LocationPerformance
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocationPerformance.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.location_category = 0;
                    object.stat_type = 0;
                    object.value = 0;
                }
                if (message.location_category != null && message.hasOwnProperty("location_category"))
                    object.location_category = message.location_category;
                if (message.stat_type != null && message.hasOwnProperty("stat_type"))
                    object.stat_type = message.stat_type;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };
    
            /**
             * Converts this LocationPerformance to JSON.
             * @function toJSON
             * @memberof CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocationPerformance.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return LocationPerformance;
        })();
    
        return CDOTAUserMsg_StatsTeamMinuteDetails;
    })();
    
    $root.CDOTAUserMsg_StatsPlayerKillShare = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_StatsPlayerKillShare.
         * @exports ICDOTAUserMsg_StatsPlayerKillShare
         * @interface ICDOTAUserMsg_StatsPlayerKillShare
         * @property {number|null} [player_id] CDOTAUserMsg_StatsPlayerKillShare player_id
         * @property {number|null} [kill_share_percent] CDOTAUserMsg_StatsPlayerKillShare kill_share_percent
         * @property {number|null} [player_loc_x] CDOTAUserMsg_StatsPlayerKillShare player_loc_x
         * @property {number|null} [player_loc_y] CDOTAUserMsg_StatsPlayerKillShare player_loc_y
         * @property {number|null} [health_percent] CDOTAUserMsg_StatsPlayerKillShare health_percent
         * @property {number|null} [mana_percent] CDOTAUserMsg_StatsPlayerKillShare mana_percent
         */
    
        /**
         * Constructs a new CDOTAUserMsg_StatsPlayerKillShare.
         * @exports CDOTAUserMsg_StatsPlayerKillShare
         * @classdesc Represents a CDOTAUserMsg_StatsPlayerKillShare.
         * @implements ICDOTAUserMsg_StatsPlayerKillShare
         * @constructor
         * @param {ICDOTAUserMsg_StatsPlayerKillShare=} [properties] Properties to set
         */
        function CDOTAUserMsg_StatsPlayerKillShare(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_StatsPlayerKillShare player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_StatsPlayerKillShare
         * @instance
         */
        CDOTAUserMsg_StatsPlayerKillShare.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_StatsPlayerKillShare kill_share_percent.
         * @member {number} kill_share_percent
         * @memberof CDOTAUserMsg_StatsPlayerKillShare
         * @instance
         */
        CDOTAUserMsg_StatsPlayerKillShare.prototype.kill_share_percent = 0;
    
        /**
         * CDOTAUserMsg_StatsPlayerKillShare player_loc_x.
         * @member {number} player_loc_x
         * @memberof CDOTAUserMsg_StatsPlayerKillShare
         * @instance
         */
        CDOTAUserMsg_StatsPlayerKillShare.prototype.player_loc_x = 0;
    
        /**
         * CDOTAUserMsg_StatsPlayerKillShare player_loc_y.
         * @member {number} player_loc_y
         * @memberof CDOTAUserMsg_StatsPlayerKillShare
         * @instance
         */
        CDOTAUserMsg_StatsPlayerKillShare.prototype.player_loc_y = 0;
    
        /**
         * CDOTAUserMsg_StatsPlayerKillShare health_percent.
         * @member {number} health_percent
         * @memberof CDOTAUserMsg_StatsPlayerKillShare
         * @instance
         */
        CDOTAUserMsg_StatsPlayerKillShare.prototype.health_percent = 0;
    
        /**
         * CDOTAUserMsg_StatsPlayerKillShare mana_percent.
         * @member {number} mana_percent
         * @memberof CDOTAUserMsg_StatsPlayerKillShare
         * @instance
         */
        CDOTAUserMsg_StatsPlayerKillShare.prototype.mana_percent = 0;
    
        /**
         * Creates a new CDOTAUserMsg_StatsPlayerKillShare instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_StatsPlayerKillShare
         * @static
         * @param {ICDOTAUserMsg_StatsPlayerKillShare=} [properties] Properties to set
         * @returns {CDOTAUserMsg_StatsPlayerKillShare} CDOTAUserMsg_StatsPlayerKillShare instance
         */
        CDOTAUserMsg_StatsPlayerKillShare.create = function create(properties) {
            return new CDOTAUserMsg_StatsPlayerKillShare(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_StatsPlayerKillShare message. Does not implicitly {@link CDOTAUserMsg_StatsPlayerKillShare.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_StatsPlayerKillShare
         * @static
         * @param {ICDOTAUserMsg_StatsPlayerKillShare} message CDOTAUserMsg_StatsPlayerKillShare message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_StatsPlayerKillShare.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.player_id);
            if (message.kill_share_percent != null && Object.hasOwnProperty.call(message, "kill_share_percent"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.kill_share_percent);
            if (message.player_loc_x != null && Object.hasOwnProperty.call(message, "player_loc_x"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.player_loc_x);
            if (message.player_loc_y != null && Object.hasOwnProperty.call(message, "player_loc_y"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.player_loc_y);
            if (message.health_percent != null && Object.hasOwnProperty.call(message, "health_percent"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.health_percent);
            if (message.mana_percent != null && Object.hasOwnProperty.call(message, "mana_percent"))
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.mana_percent);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_StatsPlayerKillShare message, length delimited. Does not implicitly {@link CDOTAUserMsg_StatsPlayerKillShare.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_StatsPlayerKillShare
         * @static
         * @param {ICDOTAUserMsg_StatsPlayerKillShare} message CDOTAUserMsg_StatsPlayerKillShare message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_StatsPlayerKillShare.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_StatsPlayerKillShare message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_StatsPlayerKillShare
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_StatsPlayerKillShare} CDOTAUserMsg_StatsPlayerKillShare
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_StatsPlayerKillShare.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_StatsPlayerKillShare();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.int32();
                    break;
                case 2:
                    message.kill_share_percent = reader.float();
                    break;
                case 3:
                    message.player_loc_x = reader.float();
                    break;
                case 4:
                    message.player_loc_y = reader.float();
                    break;
                case 5:
                    message.health_percent = reader.float();
                    break;
                case 6:
                    message.mana_percent = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_StatsPlayerKillShare message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_StatsPlayerKillShare
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_StatsPlayerKillShare} CDOTAUserMsg_StatsPlayerKillShare
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_StatsPlayerKillShare.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_StatsPlayerKillShare message.
         * @function verify
         * @memberof CDOTAUserMsg_StatsPlayerKillShare
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_StatsPlayerKillShare.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.kill_share_percent != null && message.hasOwnProperty("kill_share_percent"))
                if (typeof message.kill_share_percent !== "number")
                    return "kill_share_percent: number expected";
            if (message.player_loc_x != null && message.hasOwnProperty("player_loc_x"))
                if (typeof message.player_loc_x !== "number")
                    return "player_loc_x: number expected";
            if (message.player_loc_y != null && message.hasOwnProperty("player_loc_y"))
                if (typeof message.player_loc_y !== "number")
                    return "player_loc_y: number expected";
            if (message.health_percent != null && message.hasOwnProperty("health_percent"))
                if (typeof message.health_percent !== "number")
                    return "health_percent: number expected";
            if (message.mana_percent != null && message.hasOwnProperty("mana_percent"))
                if (typeof message.mana_percent !== "number")
                    return "mana_percent: number expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_StatsPlayerKillShare message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_StatsPlayerKillShare
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_StatsPlayerKillShare} CDOTAUserMsg_StatsPlayerKillShare
         */
        CDOTAUserMsg_StatsPlayerKillShare.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_StatsPlayerKillShare)
                return object;
            var message = new $root.CDOTAUserMsg_StatsPlayerKillShare();
            if (object.player_id != null)
                message.player_id = object.player_id | 0;
            if (object.kill_share_percent != null)
                message.kill_share_percent = Number(object.kill_share_percent);
            if (object.player_loc_x != null)
                message.player_loc_x = Number(object.player_loc_x);
            if (object.player_loc_y != null)
                message.player_loc_y = Number(object.player_loc_y);
            if (object.health_percent != null)
                message.health_percent = Number(object.health_percent);
            if (object.mana_percent != null)
                message.mana_percent = Number(object.mana_percent);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_StatsPlayerKillShare message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_StatsPlayerKillShare
         * @static
         * @param {CDOTAUserMsg_StatsPlayerKillShare} message CDOTAUserMsg_StatsPlayerKillShare
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_StatsPlayerKillShare.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.kill_share_percent = 0;
                object.player_loc_x = 0;
                object.player_loc_y = 0;
                object.health_percent = 0;
                object.mana_percent = 0;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.kill_share_percent != null && message.hasOwnProperty("kill_share_percent"))
                object.kill_share_percent = options.json && !isFinite(message.kill_share_percent) ? String(message.kill_share_percent) : message.kill_share_percent;
            if (message.player_loc_x != null && message.hasOwnProperty("player_loc_x"))
                object.player_loc_x = options.json && !isFinite(message.player_loc_x) ? String(message.player_loc_x) : message.player_loc_x;
            if (message.player_loc_y != null && message.hasOwnProperty("player_loc_y"))
                object.player_loc_y = options.json && !isFinite(message.player_loc_y) ? String(message.player_loc_y) : message.player_loc_y;
            if (message.health_percent != null && message.hasOwnProperty("health_percent"))
                object.health_percent = options.json && !isFinite(message.health_percent) ? String(message.health_percent) : message.health_percent;
            if (message.mana_percent != null && message.hasOwnProperty("mana_percent"))
                object.mana_percent = options.json && !isFinite(message.mana_percent) ? String(message.mana_percent) : message.mana_percent;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_StatsPlayerKillShare to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_StatsPlayerKillShare
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_StatsPlayerKillShare.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_StatsPlayerKillShare;
    })();
    
    $root.CDOTAUserMsg_StatsKillDetails = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_StatsKillDetails.
         * @exports ICDOTAUserMsg_StatsKillDetails
         * @interface ICDOTAUserMsg_StatsKillDetails
         * @property {number|null} [victim_id] CDOTAUserMsg_StatsKillDetails victim_id
         * @property {Array.<ICDOTAUserMsg_StatsPlayerKillShare>|null} [kill_shares] CDOTAUserMsg_StatsKillDetails kill_shares
         * @property {number|null} [damage_to_kill] CDOTAUserMsg_StatsKillDetails damage_to_kill
         * @property {number|null} [effective_health] CDOTAUserMsg_StatsKillDetails effective_health
         * @property {number|null} [death_time] CDOTAUserMsg_StatsKillDetails death_time
         * @property {number|null} [killer_id] CDOTAUserMsg_StatsKillDetails killer_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_StatsKillDetails.
         * @exports CDOTAUserMsg_StatsKillDetails
         * @classdesc Represents a CDOTAUserMsg_StatsKillDetails.
         * @implements ICDOTAUserMsg_StatsKillDetails
         * @constructor
         * @param {ICDOTAUserMsg_StatsKillDetails=} [properties] Properties to set
         */
        function CDOTAUserMsg_StatsKillDetails(properties) {
            this.kill_shares = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_StatsKillDetails victim_id.
         * @member {number} victim_id
         * @memberof CDOTAUserMsg_StatsKillDetails
         * @instance
         */
        CDOTAUserMsg_StatsKillDetails.prototype.victim_id = 0;
    
        /**
         * CDOTAUserMsg_StatsKillDetails kill_shares.
         * @member {Array.<ICDOTAUserMsg_StatsPlayerKillShare>} kill_shares
         * @memberof CDOTAUserMsg_StatsKillDetails
         * @instance
         */
        CDOTAUserMsg_StatsKillDetails.prototype.kill_shares = $util.emptyArray;
    
        /**
         * CDOTAUserMsg_StatsKillDetails damage_to_kill.
         * @member {number} damage_to_kill
         * @memberof CDOTAUserMsg_StatsKillDetails
         * @instance
         */
        CDOTAUserMsg_StatsKillDetails.prototype.damage_to_kill = 0;
    
        /**
         * CDOTAUserMsg_StatsKillDetails effective_health.
         * @member {number} effective_health
         * @memberof CDOTAUserMsg_StatsKillDetails
         * @instance
         */
        CDOTAUserMsg_StatsKillDetails.prototype.effective_health = 0;
    
        /**
         * CDOTAUserMsg_StatsKillDetails death_time.
         * @member {number} death_time
         * @memberof CDOTAUserMsg_StatsKillDetails
         * @instance
         */
        CDOTAUserMsg_StatsKillDetails.prototype.death_time = 0;
    
        /**
         * CDOTAUserMsg_StatsKillDetails killer_id.
         * @member {number} killer_id
         * @memberof CDOTAUserMsg_StatsKillDetails
         * @instance
         */
        CDOTAUserMsg_StatsKillDetails.prototype.killer_id = 0;
    
        /**
         * Creates a new CDOTAUserMsg_StatsKillDetails instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_StatsKillDetails
         * @static
         * @param {ICDOTAUserMsg_StatsKillDetails=} [properties] Properties to set
         * @returns {CDOTAUserMsg_StatsKillDetails} CDOTAUserMsg_StatsKillDetails instance
         */
        CDOTAUserMsg_StatsKillDetails.create = function create(properties) {
            return new CDOTAUserMsg_StatsKillDetails(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_StatsKillDetails message. Does not implicitly {@link CDOTAUserMsg_StatsKillDetails.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_StatsKillDetails
         * @static
         * @param {ICDOTAUserMsg_StatsKillDetails} message CDOTAUserMsg_StatsKillDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_StatsKillDetails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.victim_id != null && Object.hasOwnProperty.call(message, "victim_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.victim_id);
            if (message.kill_shares != null && message.kill_shares.length)
                for (var i = 0; i < message.kill_shares.length; ++i)
                    $root.CDOTAUserMsg_StatsPlayerKillShare.encode(message.kill_shares[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.damage_to_kill != null && Object.hasOwnProperty.call(message, "damage_to_kill"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.damage_to_kill);
            if (message.effective_health != null && Object.hasOwnProperty.call(message, "effective_health"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.effective_health);
            if (message.death_time != null && Object.hasOwnProperty.call(message, "death_time"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.death_time);
            if (message.killer_id != null && Object.hasOwnProperty.call(message, "killer_id"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.killer_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_StatsKillDetails message, length delimited. Does not implicitly {@link CDOTAUserMsg_StatsKillDetails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_StatsKillDetails
         * @static
         * @param {ICDOTAUserMsg_StatsKillDetails} message CDOTAUserMsg_StatsKillDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_StatsKillDetails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_StatsKillDetails message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_StatsKillDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_StatsKillDetails} CDOTAUserMsg_StatsKillDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_StatsKillDetails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_StatsKillDetails();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.victim_id = reader.uint32();
                    break;
                case 2:
                    if (!(message.kill_shares && message.kill_shares.length))
                        message.kill_shares = [];
                    message.kill_shares.push($root.CDOTAUserMsg_StatsPlayerKillShare.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.damage_to_kill = reader.uint32();
                    break;
                case 4:
                    message.effective_health = reader.uint32();
                    break;
                case 5:
                    message.death_time = reader.float();
                    break;
                case 6:
                    message.killer_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_StatsKillDetails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_StatsKillDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_StatsKillDetails} CDOTAUserMsg_StatsKillDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_StatsKillDetails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_StatsKillDetails message.
         * @function verify
         * @memberof CDOTAUserMsg_StatsKillDetails
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_StatsKillDetails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.victim_id != null && message.hasOwnProperty("victim_id"))
                if (!$util.isInteger(message.victim_id))
                    return "victim_id: integer expected";
            if (message.kill_shares != null && message.hasOwnProperty("kill_shares")) {
                if (!Array.isArray(message.kill_shares))
                    return "kill_shares: array expected";
                for (var i = 0; i < message.kill_shares.length; ++i) {
                    var error = $root.CDOTAUserMsg_StatsPlayerKillShare.verify(message.kill_shares[i]);
                    if (error)
                        return "kill_shares." + error;
                }
            }
            if (message.damage_to_kill != null && message.hasOwnProperty("damage_to_kill"))
                if (!$util.isInteger(message.damage_to_kill))
                    return "damage_to_kill: integer expected";
            if (message.effective_health != null && message.hasOwnProperty("effective_health"))
                if (!$util.isInteger(message.effective_health))
                    return "effective_health: integer expected";
            if (message.death_time != null && message.hasOwnProperty("death_time"))
                if (typeof message.death_time !== "number")
                    return "death_time: number expected";
            if (message.killer_id != null && message.hasOwnProperty("killer_id"))
                if (!$util.isInteger(message.killer_id))
                    return "killer_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_StatsKillDetails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_StatsKillDetails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_StatsKillDetails} CDOTAUserMsg_StatsKillDetails
         */
        CDOTAUserMsg_StatsKillDetails.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_StatsKillDetails)
                return object;
            var message = new $root.CDOTAUserMsg_StatsKillDetails();
            if (object.victim_id != null)
                message.victim_id = object.victim_id >>> 0;
            if (object.kill_shares) {
                if (!Array.isArray(object.kill_shares))
                    throw TypeError(".CDOTAUserMsg_StatsKillDetails.kill_shares: array expected");
                message.kill_shares = [];
                for (var i = 0; i < object.kill_shares.length; ++i) {
                    if (typeof object.kill_shares[i] !== "object")
                        throw TypeError(".CDOTAUserMsg_StatsKillDetails.kill_shares: object expected");
                    message.kill_shares[i] = $root.CDOTAUserMsg_StatsPlayerKillShare.fromObject(object.kill_shares[i]);
                }
            }
            if (object.damage_to_kill != null)
                message.damage_to_kill = object.damage_to_kill >>> 0;
            if (object.effective_health != null)
                message.effective_health = object.effective_health >>> 0;
            if (object.death_time != null)
                message.death_time = Number(object.death_time);
            if (object.killer_id != null)
                message.killer_id = object.killer_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_StatsKillDetails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_StatsKillDetails
         * @static
         * @param {CDOTAUserMsg_StatsKillDetails} message CDOTAUserMsg_StatsKillDetails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_StatsKillDetails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.kill_shares = [];
            if (options.defaults) {
                object.victim_id = 0;
                object.damage_to_kill = 0;
                object.effective_health = 0;
                object.death_time = 0;
                object.killer_id = 0;
            }
            if (message.victim_id != null && message.hasOwnProperty("victim_id"))
                object.victim_id = message.victim_id;
            if (message.kill_shares && message.kill_shares.length) {
                object.kill_shares = [];
                for (var j = 0; j < message.kill_shares.length; ++j)
                    object.kill_shares[j] = $root.CDOTAUserMsg_StatsPlayerKillShare.toObject(message.kill_shares[j], options);
            }
            if (message.damage_to_kill != null && message.hasOwnProperty("damage_to_kill"))
                object.damage_to_kill = message.damage_to_kill;
            if (message.effective_health != null && message.hasOwnProperty("effective_health"))
                object.effective_health = message.effective_health;
            if (message.death_time != null && message.hasOwnProperty("death_time"))
                object.death_time = options.json && !isFinite(message.death_time) ? String(message.death_time) : message.death_time;
            if (message.killer_id != null && message.hasOwnProperty("killer_id"))
                object.killer_id = message.killer_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_StatsKillDetails to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_StatsKillDetails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_StatsKillDetails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_StatsKillDetails;
    })();
    
    $root.CDOTAUserMsg_StatsMatchDetails = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_StatsMatchDetails.
         * @exports ICDOTAUserMsg_StatsMatchDetails
         * @interface ICDOTAUserMsg_StatsMatchDetails
         * @property {Array.<ICDOTAUserMsg_StatsHeroLookup>|null} [hero_lookup] CDOTAUserMsg_StatsMatchDetails hero_lookup
         * @property {Array.<ICDOTAUserMsg_StatsTeamMinuteDetails>|null} [radiant_stats] CDOTAUserMsg_StatsMatchDetails radiant_stats
         * @property {Array.<ICDOTAUserMsg_StatsTeamMinuteDetails>|null} [dire_stats] CDOTAUserMsg_StatsMatchDetails dire_stats
         * @property {Array.<ICDOTAUserMsg_StatsKillDetails>|null} [radiant_kills] CDOTAUserMsg_StatsMatchDetails radiant_kills
         * @property {Array.<ICDOTAUserMsg_StatsKillDetails>|null} [dire_kills] CDOTAUserMsg_StatsMatchDetails dire_kills
         * @property {Array.<CDOTAUserMsg_StatsMatchDetails.ICDOTAUserMsg_StatsFightDetails>|null} [fight_details] CDOTAUserMsg_StatsMatchDetails fight_details
         */
    
        /**
         * Constructs a new CDOTAUserMsg_StatsMatchDetails.
         * @exports CDOTAUserMsg_StatsMatchDetails
         * @classdesc Represents a CDOTAUserMsg_StatsMatchDetails.
         * @implements ICDOTAUserMsg_StatsMatchDetails
         * @constructor
         * @param {ICDOTAUserMsg_StatsMatchDetails=} [properties] Properties to set
         */
        function CDOTAUserMsg_StatsMatchDetails(properties) {
            this.hero_lookup = [];
            this.radiant_stats = [];
            this.dire_stats = [];
            this.radiant_kills = [];
            this.dire_kills = [];
            this.fight_details = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_StatsMatchDetails hero_lookup.
         * @member {Array.<ICDOTAUserMsg_StatsHeroLookup>} hero_lookup
         * @memberof CDOTAUserMsg_StatsMatchDetails
         * @instance
         */
        CDOTAUserMsg_StatsMatchDetails.prototype.hero_lookup = $util.emptyArray;
    
        /**
         * CDOTAUserMsg_StatsMatchDetails radiant_stats.
         * @member {Array.<ICDOTAUserMsg_StatsTeamMinuteDetails>} radiant_stats
         * @memberof CDOTAUserMsg_StatsMatchDetails
         * @instance
         */
        CDOTAUserMsg_StatsMatchDetails.prototype.radiant_stats = $util.emptyArray;
    
        /**
         * CDOTAUserMsg_StatsMatchDetails dire_stats.
         * @member {Array.<ICDOTAUserMsg_StatsTeamMinuteDetails>} dire_stats
         * @memberof CDOTAUserMsg_StatsMatchDetails
         * @instance
         */
        CDOTAUserMsg_StatsMatchDetails.prototype.dire_stats = $util.emptyArray;
    
        /**
         * CDOTAUserMsg_StatsMatchDetails radiant_kills.
         * @member {Array.<ICDOTAUserMsg_StatsKillDetails>} radiant_kills
         * @memberof CDOTAUserMsg_StatsMatchDetails
         * @instance
         */
        CDOTAUserMsg_StatsMatchDetails.prototype.radiant_kills = $util.emptyArray;
    
        /**
         * CDOTAUserMsg_StatsMatchDetails dire_kills.
         * @member {Array.<ICDOTAUserMsg_StatsKillDetails>} dire_kills
         * @memberof CDOTAUserMsg_StatsMatchDetails
         * @instance
         */
        CDOTAUserMsg_StatsMatchDetails.prototype.dire_kills = $util.emptyArray;
    
        /**
         * CDOTAUserMsg_StatsMatchDetails fight_details.
         * @member {Array.<CDOTAUserMsg_StatsMatchDetails.ICDOTAUserMsg_StatsFightDetails>} fight_details
         * @memberof CDOTAUserMsg_StatsMatchDetails
         * @instance
         */
        CDOTAUserMsg_StatsMatchDetails.prototype.fight_details = $util.emptyArray;
    
        /**
         * Creates a new CDOTAUserMsg_StatsMatchDetails instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_StatsMatchDetails
         * @static
         * @param {ICDOTAUserMsg_StatsMatchDetails=} [properties] Properties to set
         * @returns {CDOTAUserMsg_StatsMatchDetails} CDOTAUserMsg_StatsMatchDetails instance
         */
        CDOTAUserMsg_StatsMatchDetails.create = function create(properties) {
            return new CDOTAUserMsg_StatsMatchDetails(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_StatsMatchDetails message. Does not implicitly {@link CDOTAUserMsg_StatsMatchDetails.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_StatsMatchDetails
         * @static
         * @param {ICDOTAUserMsg_StatsMatchDetails} message CDOTAUserMsg_StatsMatchDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_StatsMatchDetails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hero_lookup != null && message.hero_lookup.length)
                for (var i = 0; i < message.hero_lookup.length; ++i)
                    $root.CDOTAUserMsg_StatsHeroLookup.encode(message.hero_lookup[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.radiant_stats != null && message.radiant_stats.length)
                for (var i = 0; i < message.radiant_stats.length; ++i)
                    $root.CDOTAUserMsg_StatsTeamMinuteDetails.encode(message.radiant_stats[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.dire_stats != null && message.dire_stats.length)
                for (var i = 0; i < message.dire_stats.length; ++i)
                    $root.CDOTAUserMsg_StatsTeamMinuteDetails.encode(message.dire_stats[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.radiant_kills != null && message.radiant_kills.length)
                for (var i = 0; i < message.radiant_kills.length; ++i)
                    $root.CDOTAUserMsg_StatsKillDetails.encode(message.radiant_kills[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.dire_kills != null && message.dire_kills.length)
                for (var i = 0; i < message.dire_kills.length; ++i)
                    $root.CDOTAUserMsg_StatsKillDetails.encode(message.dire_kills[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.fight_details != null && message.fight_details.length)
                for (var i = 0; i < message.fight_details.length; ++i)
                    $root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails.encode(message.fight_details[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_StatsMatchDetails message, length delimited. Does not implicitly {@link CDOTAUserMsg_StatsMatchDetails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_StatsMatchDetails
         * @static
         * @param {ICDOTAUserMsg_StatsMatchDetails} message CDOTAUserMsg_StatsMatchDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_StatsMatchDetails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_StatsMatchDetails message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_StatsMatchDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_StatsMatchDetails} CDOTAUserMsg_StatsMatchDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_StatsMatchDetails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_StatsMatchDetails();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.hero_lookup && message.hero_lookup.length))
                        message.hero_lookup = [];
                    message.hero_lookup.push($root.CDOTAUserMsg_StatsHeroLookup.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.radiant_stats && message.radiant_stats.length))
                        message.radiant_stats = [];
                    message.radiant_stats.push($root.CDOTAUserMsg_StatsTeamMinuteDetails.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.dire_stats && message.dire_stats.length))
                        message.dire_stats = [];
                    message.dire_stats.push($root.CDOTAUserMsg_StatsTeamMinuteDetails.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.radiant_kills && message.radiant_kills.length))
                        message.radiant_kills = [];
                    message.radiant_kills.push($root.CDOTAUserMsg_StatsKillDetails.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.dire_kills && message.dire_kills.length))
                        message.dire_kills = [];
                    message.dire_kills.push($root.CDOTAUserMsg_StatsKillDetails.decode(reader, reader.uint32()));
                    break;
                case 6:
                    if (!(message.fight_details && message.fight_details.length))
                        message.fight_details = [];
                    message.fight_details.push($root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_StatsMatchDetails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_StatsMatchDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_StatsMatchDetails} CDOTAUserMsg_StatsMatchDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_StatsMatchDetails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_StatsMatchDetails message.
         * @function verify
         * @memberof CDOTAUserMsg_StatsMatchDetails
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_StatsMatchDetails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hero_lookup != null && message.hasOwnProperty("hero_lookup")) {
                if (!Array.isArray(message.hero_lookup))
                    return "hero_lookup: array expected";
                for (var i = 0; i < message.hero_lookup.length; ++i) {
                    var error = $root.CDOTAUserMsg_StatsHeroLookup.verify(message.hero_lookup[i]);
                    if (error)
                        return "hero_lookup." + error;
                }
            }
            if (message.radiant_stats != null && message.hasOwnProperty("radiant_stats")) {
                if (!Array.isArray(message.radiant_stats))
                    return "radiant_stats: array expected";
                for (var i = 0; i < message.radiant_stats.length; ++i) {
                    var error = $root.CDOTAUserMsg_StatsTeamMinuteDetails.verify(message.radiant_stats[i]);
                    if (error)
                        return "radiant_stats." + error;
                }
            }
            if (message.dire_stats != null && message.hasOwnProperty("dire_stats")) {
                if (!Array.isArray(message.dire_stats))
                    return "dire_stats: array expected";
                for (var i = 0; i < message.dire_stats.length; ++i) {
                    var error = $root.CDOTAUserMsg_StatsTeamMinuteDetails.verify(message.dire_stats[i]);
                    if (error)
                        return "dire_stats." + error;
                }
            }
            if (message.radiant_kills != null && message.hasOwnProperty("radiant_kills")) {
                if (!Array.isArray(message.radiant_kills))
                    return "radiant_kills: array expected";
                for (var i = 0; i < message.radiant_kills.length; ++i) {
                    var error = $root.CDOTAUserMsg_StatsKillDetails.verify(message.radiant_kills[i]);
                    if (error)
                        return "radiant_kills." + error;
                }
            }
            if (message.dire_kills != null && message.hasOwnProperty("dire_kills")) {
                if (!Array.isArray(message.dire_kills))
                    return "dire_kills: array expected";
                for (var i = 0; i < message.dire_kills.length; ++i) {
                    var error = $root.CDOTAUserMsg_StatsKillDetails.verify(message.dire_kills[i]);
                    if (error)
                        return "dire_kills." + error;
                }
            }
            if (message.fight_details != null && message.hasOwnProperty("fight_details")) {
                if (!Array.isArray(message.fight_details))
                    return "fight_details: array expected";
                for (var i = 0; i < message.fight_details.length; ++i) {
                    var error = $root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails.verify(message.fight_details[i]);
                    if (error)
                        return "fight_details." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_StatsMatchDetails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_StatsMatchDetails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_StatsMatchDetails} CDOTAUserMsg_StatsMatchDetails
         */
        CDOTAUserMsg_StatsMatchDetails.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_StatsMatchDetails)
                return object;
            var message = new $root.CDOTAUserMsg_StatsMatchDetails();
            if (object.hero_lookup) {
                if (!Array.isArray(object.hero_lookup))
                    throw TypeError(".CDOTAUserMsg_StatsMatchDetails.hero_lookup: array expected");
                message.hero_lookup = [];
                for (var i = 0; i < object.hero_lookup.length; ++i) {
                    if (typeof object.hero_lookup[i] !== "object")
                        throw TypeError(".CDOTAUserMsg_StatsMatchDetails.hero_lookup: object expected");
                    message.hero_lookup[i] = $root.CDOTAUserMsg_StatsHeroLookup.fromObject(object.hero_lookup[i]);
                }
            }
            if (object.radiant_stats) {
                if (!Array.isArray(object.radiant_stats))
                    throw TypeError(".CDOTAUserMsg_StatsMatchDetails.radiant_stats: array expected");
                message.radiant_stats = [];
                for (var i = 0; i < object.radiant_stats.length; ++i) {
                    if (typeof object.radiant_stats[i] !== "object")
                        throw TypeError(".CDOTAUserMsg_StatsMatchDetails.radiant_stats: object expected");
                    message.radiant_stats[i] = $root.CDOTAUserMsg_StatsTeamMinuteDetails.fromObject(object.radiant_stats[i]);
                }
            }
            if (object.dire_stats) {
                if (!Array.isArray(object.dire_stats))
                    throw TypeError(".CDOTAUserMsg_StatsMatchDetails.dire_stats: array expected");
                message.dire_stats = [];
                for (var i = 0; i < object.dire_stats.length; ++i) {
                    if (typeof object.dire_stats[i] !== "object")
                        throw TypeError(".CDOTAUserMsg_StatsMatchDetails.dire_stats: object expected");
                    message.dire_stats[i] = $root.CDOTAUserMsg_StatsTeamMinuteDetails.fromObject(object.dire_stats[i]);
                }
            }
            if (object.radiant_kills) {
                if (!Array.isArray(object.radiant_kills))
                    throw TypeError(".CDOTAUserMsg_StatsMatchDetails.radiant_kills: array expected");
                message.radiant_kills = [];
                for (var i = 0; i < object.radiant_kills.length; ++i) {
                    if (typeof object.radiant_kills[i] !== "object")
                        throw TypeError(".CDOTAUserMsg_StatsMatchDetails.radiant_kills: object expected");
                    message.radiant_kills[i] = $root.CDOTAUserMsg_StatsKillDetails.fromObject(object.radiant_kills[i]);
                }
            }
            if (object.dire_kills) {
                if (!Array.isArray(object.dire_kills))
                    throw TypeError(".CDOTAUserMsg_StatsMatchDetails.dire_kills: array expected");
                message.dire_kills = [];
                for (var i = 0; i < object.dire_kills.length; ++i) {
                    if (typeof object.dire_kills[i] !== "object")
                        throw TypeError(".CDOTAUserMsg_StatsMatchDetails.dire_kills: object expected");
                    message.dire_kills[i] = $root.CDOTAUserMsg_StatsKillDetails.fromObject(object.dire_kills[i]);
                }
            }
            if (object.fight_details) {
                if (!Array.isArray(object.fight_details))
                    throw TypeError(".CDOTAUserMsg_StatsMatchDetails.fight_details: array expected");
                message.fight_details = [];
                for (var i = 0; i < object.fight_details.length; ++i) {
                    if (typeof object.fight_details[i] !== "object")
                        throw TypeError(".CDOTAUserMsg_StatsMatchDetails.fight_details: object expected");
                    message.fight_details[i] = $root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails.fromObject(object.fight_details[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_StatsMatchDetails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_StatsMatchDetails
         * @static
         * @param {CDOTAUserMsg_StatsMatchDetails} message CDOTAUserMsg_StatsMatchDetails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_StatsMatchDetails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.hero_lookup = [];
                object.radiant_stats = [];
                object.dire_stats = [];
                object.radiant_kills = [];
                object.dire_kills = [];
                object.fight_details = [];
            }
            if (message.hero_lookup && message.hero_lookup.length) {
                object.hero_lookup = [];
                for (var j = 0; j < message.hero_lookup.length; ++j)
                    object.hero_lookup[j] = $root.CDOTAUserMsg_StatsHeroLookup.toObject(message.hero_lookup[j], options);
            }
            if (message.radiant_stats && message.radiant_stats.length) {
                object.radiant_stats = [];
                for (var j = 0; j < message.radiant_stats.length; ++j)
                    object.radiant_stats[j] = $root.CDOTAUserMsg_StatsTeamMinuteDetails.toObject(message.radiant_stats[j], options);
            }
            if (message.dire_stats && message.dire_stats.length) {
                object.dire_stats = [];
                for (var j = 0; j < message.dire_stats.length; ++j)
                    object.dire_stats[j] = $root.CDOTAUserMsg_StatsTeamMinuteDetails.toObject(message.dire_stats[j], options);
            }
            if (message.radiant_kills && message.radiant_kills.length) {
                object.radiant_kills = [];
                for (var j = 0; j < message.radiant_kills.length; ++j)
                    object.radiant_kills[j] = $root.CDOTAUserMsg_StatsKillDetails.toObject(message.radiant_kills[j], options);
            }
            if (message.dire_kills && message.dire_kills.length) {
                object.dire_kills = [];
                for (var j = 0; j < message.dire_kills.length; ++j)
                    object.dire_kills[j] = $root.CDOTAUserMsg_StatsKillDetails.toObject(message.dire_kills[j], options);
            }
            if (message.fight_details && message.fight_details.length) {
                object.fight_details = [];
                for (var j = 0; j < message.fight_details.length; ++j)
                    object.fight_details[j] = $root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails.toObject(message.fight_details[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_StatsMatchDetails to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_StatsMatchDetails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_StatsMatchDetails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails = (function() {
    
            /**
             * Properties of a CDOTAUserMsg_StatsFightTeamDetails.
             * @memberof CDOTAUserMsg_StatsMatchDetails
             * @interface ICDOTAUserMsg_StatsFightTeamDetails
             * @property {Array.<number>|null} [participants] CDOTAUserMsg_StatsFightTeamDetails participants
             * @property {Array.<number>|null} [deaths] CDOTAUserMsg_StatsFightTeamDetails deaths
             * @property {number|null} [gold_delta] CDOTAUserMsg_StatsFightTeamDetails gold_delta
             * @property {number|null} [xp_delta] CDOTAUserMsg_StatsFightTeamDetails xp_delta
             */
    
            /**
             * Constructs a new CDOTAUserMsg_StatsFightTeamDetails.
             * @memberof CDOTAUserMsg_StatsMatchDetails
             * @classdesc Represents a CDOTAUserMsg_StatsFightTeamDetails.
             * @implements ICDOTAUserMsg_StatsFightTeamDetails
             * @constructor
             * @param {CDOTAUserMsg_StatsMatchDetails.ICDOTAUserMsg_StatsFightTeamDetails=} [properties] Properties to set
             */
            function CDOTAUserMsg_StatsFightTeamDetails(properties) {
                this.participants = [];
                this.deaths = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CDOTAUserMsg_StatsFightTeamDetails participants.
             * @member {Array.<number>} participants
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails
             * @instance
             */
            CDOTAUserMsg_StatsFightTeamDetails.prototype.participants = $util.emptyArray;
    
            /**
             * CDOTAUserMsg_StatsFightTeamDetails deaths.
             * @member {Array.<number>} deaths
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails
             * @instance
             */
            CDOTAUserMsg_StatsFightTeamDetails.prototype.deaths = $util.emptyArray;
    
            /**
             * CDOTAUserMsg_StatsFightTeamDetails gold_delta.
             * @member {number} gold_delta
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails
             * @instance
             */
            CDOTAUserMsg_StatsFightTeamDetails.prototype.gold_delta = 0;
    
            /**
             * CDOTAUserMsg_StatsFightTeamDetails xp_delta.
             * @member {number} xp_delta
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails
             * @instance
             */
            CDOTAUserMsg_StatsFightTeamDetails.prototype.xp_delta = 0;
    
            /**
             * Creates a new CDOTAUserMsg_StatsFightTeamDetails instance using the specified properties.
             * @function create
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails
             * @static
             * @param {CDOTAUserMsg_StatsMatchDetails.ICDOTAUserMsg_StatsFightTeamDetails=} [properties] Properties to set
             * @returns {CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails} CDOTAUserMsg_StatsFightTeamDetails instance
             */
            CDOTAUserMsg_StatsFightTeamDetails.create = function create(properties) {
                return new CDOTAUserMsg_StatsFightTeamDetails(properties);
            };
    
            /**
             * Encodes the specified CDOTAUserMsg_StatsFightTeamDetails message. Does not implicitly {@link CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.verify|verify} messages.
             * @function encode
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails
             * @static
             * @param {CDOTAUserMsg_StatsMatchDetails.ICDOTAUserMsg_StatsFightTeamDetails} message CDOTAUserMsg_StatsFightTeamDetails message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CDOTAUserMsg_StatsFightTeamDetails.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.participants != null && message.participants.length)
                    for (var i = 0; i < message.participants.length; ++i)
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.participants[i]);
                if (message.deaths != null && message.deaths.length)
                    for (var i = 0; i < message.deaths.length; ++i)
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.deaths[i]);
                if (message.gold_delta != null && Object.hasOwnProperty.call(message, "gold_delta"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.gold_delta);
                if (message.xp_delta != null && Object.hasOwnProperty.call(message, "xp_delta"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.xp_delta);
                return writer;
            };
    
            /**
             * Encodes the specified CDOTAUserMsg_StatsFightTeamDetails message, length delimited. Does not implicitly {@link CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails
             * @static
             * @param {CDOTAUserMsg_StatsMatchDetails.ICDOTAUserMsg_StatsFightTeamDetails} message CDOTAUserMsg_StatsFightTeamDetails message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CDOTAUserMsg_StatsFightTeamDetails.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CDOTAUserMsg_StatsFightTeamDetails message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails} CDOTAUserMsg_StatsFightTeamDetails
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CDOTAUserMsg_StatsFightTeamDetails.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.participants && message.participants.length))
                            message.participants = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.participants.push(reader.uint32());
                        } else
                            message.participants.push(reader.uint32());
                        break;
                    case 2:
                        if (!(message.deaths && message.deaths.length))
                            message.deaths = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.deaths.push(reader.uint32());
                        } else
                            message.deaths.push(reader.uint32());
                        break;
                    case 3:
                        message.gold_delta = reader.uint32();
                        break;
                    case 4:
                        message.xp_delta = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CDOTAUserMsg_StatsFightTeamDetails message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails} CDOTAUserMsg_StatsFightTeamDetails
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CDOTAUserMsg_StatsFightTeamDetails.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CDOTAUserMsg_StatsFightTeamDetails message.
             * @function verify
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CDOTAUserMsg_StatsFightTeamDetails.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.participants != null && message.hasOwnProperty("participants")) {
                    if (!Array.isArray(message.participants))
                        return "participants: array expected";
                    for (var i = 0; i < message.participants.length; ++i)
                        if (!$util.isInteger(message.participants[i]))
                            return "participants: integer[] expected";
                }
                if (message.deaths != null && message.hasOwnProperty("deaths")) {
                    if (!Array.isArray(message.deaths))
                        return "deaths: array expected";
                    for (var i = 0; i < message.deaths.length; ++i)
                        if (!$util.isInteger(message.deaths[i]))
                            return "deaths: integer[] expected";
                }
                if (message.gold_delta != null && message.hasOwnProperty("gold_delta"))
                    if (!$util.isInteger(message.gold_delta))
                        return "gold_delta: integer expected";
                if (message.xp_delta != null && message.hasOwnProperty("xp_delta"))
                    if (!$util.isInteger(message.xp_delta))
                        return "xp_delta: integer expected";
                return null;
            };
    
            /**
             * Creates a CDOTAUserMsg_StatsFightTeamDetails message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails} CDOTAUserMsg_StatsFightTeamDetails
             */
            CDOTAUserMsg_StatsFightTeamDetails.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails)
                    return object;
                var message = new $root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails();
                if (object.participants) {
                    if (!Array.isArray(object.participants))
                        throw TypeError(".CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.participants: array expected");
                    message.participants = [];
                    for (var i = 0; i < object.participants.length; ++i)
                        message.participants[i] = object.participants[i] >>> 0;
                }
                if (object.deaths) {
                    if (!Array.isArray(object.deaths))
                        throw TypeError(".CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.deaths: array expected");
                    message.deaths = [];
                    for (var i = 0; i < object.deaths.length; ++i)
                        message.deaths[i] = object.deaths[i] >>> 0;
                }
                if (object.gold_delta != null)
                    message.gold_delta = object.gold_delta >>> 0;
                if (object.xp_delta != null)
                    message.xp_delta = object.xp_delta >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a CDOTAUserMsg_StatsFightTeamDetails message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails
             * @static
             * @param {CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails} message CDOTAUserMsg_StatsFightTeamDetails
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CDOTAUserMsg_StatsFightTeamDetails.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.participants = [];
                    object.deaths = [];
                }
                if (options.defaults) {
                    object.gold_delta = 0;
                    object.xp_delta = 0;
                }
                if (message.participants && message.participants.length) {
                    object.participants = [];
                    for (var j = 0; j < message.participants.length; ++j)
                        object.participants[j] = message.participants[j];
                }
                if (message.deaths && message.deaths.length) {
                    object.deaths = [];
                    for (var j = 0; j < message.deaths.length; ++j)
                        object.deaths[j] = message.deaths[j];
                }
                if (message.gold_delta != null && message.hasOwnProperty("gold_delta"))
                    object.gold_delta = message.gold_delta;
                if (message.xp_delta != null && message.hasOwnProperty("xp_delta"))
                    object.xp_delta = message.xp_delta;
                return object;
            };
    
            /**
             * Converts this CDOTAUserMsg_StatsFightTeamDetails to JSON.
             * @function toJSON
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CDOTAUserMsg_StatsFightTeamDetails.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CDOTAUserMsg_StatsFightTeamDetails;
        })();
    
        CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails = (function() {
    
            /**
             * Properties of a CDOTAUserMsg_StatsFightDetails.
             * @memberof CDOTAUserMsg_StatsMatchDetails
             * @interface ICDOTAUserMsg_StatsFightDetails
             * @property {number|null} [start_time] CDOTAUserMsg_StatsFightDetails start_time
             * @property {number|null} [end_time] CDOTAUserMsg_StatsFightDetails end_time
             * @property {CDOTAUserMsg_StatsMatchDetails.ICDOTAUserMsg_StatsFightTeamDetails|null} [radiant_fight_details] CDOTAUserMsg_StatsFightDetails radiant_fight_details
             * @property {CDOTAUserMsg_StatsMatchDetails.ICDOTAUserMsg_StatsFightTeamDetails|null} [dire_fight_details] CDOTAUserMsg_StatsFightDetails dire_fight_details
             */
    
            /**
             * Constructs a new CDOTAUserMsg_StatsFightDetails.
             * @memberof CDOTAUserMsg_StatsMatchDetails
             * @classdesc Represents a CDOTAUserMsg_StatsFightDetails.
             * @implements ICDOTAUserMsg_StatsFightDetails
             * @constructor
             * @param {CDOTAUserMsg_StatsMatchDetails.ICDOTAUserMsg_StatsFightDetails=} [properties] Properties to set
             */
            function CDOTAUserMsg_StatsFightDetails(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CDOTAUserMsg_StatsFightDetails start_time.
             * @member {number} start_time
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails
             * @instance
             */
            CDOTAUserMsg_StatsFightDetails.prototype.start_time = 0;
    
            /**
             * CDOTAUserMsg_StatsFightDetails end_time.
             * @member {number} end_time
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails
             * @instance
             */
            CDOTAUserMsg_StatsFightDetails.prototype.end_time = 0;
    
            /**
             * CDOTAUserMsg_StatsFightDetails radiant_fight_details.
             * @member {CDOTAUserMsg_StatsMatchDetails.ICDOTAUserMsg_StatsFightTeamDetails|null|undefined} radiant_fight_details
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails
             * @instance
             */
            CDOTAUserMsg_StatsFightDetails.prototype.radiant_fight_details = null;
    
            /**
             * CDOTAUserMsg_StatsFightDetails dire_fight_details.
             * @member {CDOTAUserMsg_StatsMatchDetails.ICDOTAUserMsg_StatsFightTeamDetails|null|undefined} dire_fight_details
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails
             * @instance
             */
            CDOTAUserMsg_StatsFightDetails.prototype.dire_fight_details = null;
    
            /**
             * Creates a new CDOTAUserMsg_StatsFightDetails instance using the specified properties.
             * @function create
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails
             * @static
             * @param {CDOTAUserMsg_StatsMatchDetails.ICDOTAUserMsg_StatsFightDetails=} [properties] Properties to set
             * @returns {CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails} CDOTAUserMsg_StatsFightDetails instance
             */
            CDOTAUserMsg_StatsFightDetails.create = function create(properties) {
                return new CDOTAUserMsg_StatsFightDetails(properties);
            };
    
            /**
             * Encodes the specified CDOTAUserMsg_StatsFightDetails message. Does not implicitly {@link CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails.verify|verify} messages.
             * @function encode
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails
             * @static
             * @param {CDOTAUserMsg_StatsMatchDetails.ICDOTAUserMsg_StatsFightDetails} message CDOTAUserMsg_StatsFightDetails message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CDOTAUserMsg_StatsFightDetails.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.start_time != null && Object.hasOwnProperty.call(message, "start_time"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.start_time);
                if (message.end_time != null && Object.hasOwnProperty.call(message, "end_time"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.end_time);
                if (message.radiant_fight_details != null && Object.hasOwnProperty.call(message, "radiant_fight_details"))
                    $root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.encode(message.radiant_fight_details, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.dire_fight_details != null && Object.hasOwnProperty.call(message, "dire_fight_details"))
                    $root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.encode(message.dire_fight_details, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified CDOTAUserMsg_StatsFightDetails message, length delimited. Does not implicitly {@link CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails
             * @static
             * @param {CDOTAUserMsg_StatsMatchDetails.ICDOTAUserMsg_StatsFightDetails} message CDOTAUserMsg_StatsFightDetails message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CDOTAUserMsg_StatsFightDetails.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CDOTAUserMsg_StatsFightDetails message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails} CDOTAUserMsg_StatsFightDetails
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CDOTAUserMsg_StatsFightDetails.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.start_time = reader.float();
                        break;
                    case 2:
                        message.end_time = reader.float();
                        break;
                    case 3:
                        message.radiant_fight_details = $root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.dire_fight_details = $root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CDOTAUserMsg_StatsFightDetails message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails} CDOTAUserMsg_StatsFightDetails
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CDOTAUserMsg_StatsFightDetails.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CDOTAUserMsg_StatsFightDetails message.
             * @function verify
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CDOTAUserMsg_StatsFightDetails.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.start_time != null && message.hasOwnProperty("start_time"))
                    if (typeof message.start_time !== "number")
                        return "start_time: number expected";
                if (message.end_time != null && message.hasOwnProperty("end_time"))
                    if (typeof message.end_time !== "number")
                        return "end_time: number expected";
                if (message.radiant_fight_details != null && message.hasOwnProperty("radiant_fight_details")) {
                    var error = $root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.verify(message.radiant_fight_details);
                    if (error)
                        return "radiant_fight_details." + error;
                }
                if (message.dire_fight_details != null && message.hasOwnProperty("dire_fight_details")) {
                    var error = $root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.verify(message.dire_fight_details);
                    if (error)
                        return "dire_fight_details." + error;
                }
                return null;
            };
    
            /**
             * Creates a CDOTAUserMsg_StatsFightDetails message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails} CDOTAUserMsg_StatsFightDetails
             */
            CDOTAUserMsg_StatsFightDetails.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails)
                    return object;
                var message = new $root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails();
                if (object.start_time != null)
                    message.start_time = Number(object.start_time);
                if (object.end_time != null)
                    message.end_time = Number(object.end_time);
                if (object.radiant_fight_details != null) {
                    if (typeof object.radiant_fight_details !== "object")
                        throw TypeError(".CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails.radiant_fight_details: object expected");
                    message.radiant_fight_details = $root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.fromObject(object.radiant_fight_details);
                }
                if (object.dire_fight_details != null) {
                    if (typeof object.dire_fight_details !== "object")
                        throw TypeError(".CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails.dire_fight_details: object expected");
                    message.dire_fight_details = $root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.fromObject(object.dire_fight_details);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a CDOTAUserMsg_StatsFightDetails message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails
             * @static
             * @param {CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails} message CDOTAUserMsg_StatsFightDetails
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CDOTAUserMsg_StatsFightDetails.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.start_time = 0;
                    object.end_time = 0;
                    object.radiant_fight_details = null;
                    object.dire_fight_details = null;
                }
                if (message.start_time != null && message.hasOwnProperty("start_time"))
                    object.start_time = options.json && !isFinite(message.start_time) ? String(message.start_time) : message.start_time;
                if (message.end_time != null && message.hasOwnProperty("end_time"))
                    object.end_time = options.json && !isFinite(message.end_time) ? String(message.end_time) : message.end_time;
                if (message.radiant_fight_details != null && message.hasOwnProperty("radiant_fight_details"))
                    object.radiant_fight_details = $root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.toObject(message.radiant_fight_details, options);
                if (message.dire_fight_details != null && message.hasOwnProperty("dire_fight_details"))
                    object.dire_fight_details = $root.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.toObject(message.dire_fight_details, options);
                return object;
            };
    
            /**
             * Converts this CDOTAUserMsg_StatsFightDetails to JSON.
             * @function toJSON
             * @memberof CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CDOTAUserMsg_StatsFightDetails.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CDOTAUserMsg_StatsFightDetails;
        })();
    
        return CDOTAUserMsg_StatsMatchDetails;
    })();
    
    $root.CDOTAUserMsg_MiniTaunt = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_MiniTaunt.
         * @exports ICDOTAUserMsg_MiniTaunt
         * @interface ICDOTAUserMsg_MiniTaunt
         * @property {number|null} [taunting_player_id] CDOTAUserMsg_MiniTaunt taunting_player_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_MiniTaunt.
         * @exports CDOTAUserMsg_MiniTaunt
         * @classdesc Represents a CDOTAUserMsg_MiniTaunt.
         * @implements ICDOTAUserMsg_MiniTaunt
         * @constructor
         * @param {ICDOTAUserMsg_MiniTaunt=} [properties] Properties to set
         */
        function CDOTAUserMsg_MiniTaunt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_MiniTaunt taunting_player_id.
         * @member {number} taunting_player_id
         * @memberof CDOTAUserMsg_MiniTaunt
         * @instance
         */
        CDOTAUserMsg_MiniTaunt.prototype.taunting_player_id = 0;
    
        /**
         * Creates a new CDOTAUserMsg_MiniTaunt instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_MiniTaunt
         * @static
         * @param {ICDOTAUserMsg_MiniTaunt=} [properties] Properties to set
         * @returns {CDOTAUserMsg_MiniTaunt} CDOTAUserMsg_MiniTaunt instance
         */
        CDOTAUserMsg_MiniTaunt.create = function create(properties) {
            return new CDOTAUserMsg_MiniTaunt(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_MiniTaunt message. Does not implicitly {@link CDOTAUserMsg_MiniTaunt.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_MiniTaunt
         * @static
         * @param {ICDOTAUserMsg_MiniTaunt} message CDOTAUserMsg_MiniTaunt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_MiniTaunt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taunting_player_id != null && Object.hasOwnProperty.call(message, "taunting_player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.taunting_player_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_MiniTaunt message, length delimited. Does not implicitly {@link CDOTAUserMsg_MiniTaunt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_MiniTaunt
         * @static
         * @param {ICDOTAUserMsg_MiniTaunt} message CDOTAUserMsg_MiniTaunt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_MiniTaunt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_MiniTaunt message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_MiniTaunt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_MiniTaunt} CDOTAUserMsg_MiniTaunt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_MiniTaunt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_MiniTaunt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.taunting_player_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_MiniTaunt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_MiniTaunt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_MiniTaunt} CDOTAUserMsg_MiniTaunt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_MiniTaunt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_MiniTaunt message.
         * @function verify
         * @memberof CDOTAUserMsg_MiniTaunt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_MiniTaunt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taunting_player_id != null && message.hasOwnProperty("taunting_player_id"))
                if (!$util.isInteger(message.taunting_player_id))
                    return "taunting_player_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_MiniTaunt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_MiniTaunt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_MiniTaunt} CDOTAUserMsg_MiniTaunt
         */
        CDOTAUserMsg_MiniTaunt.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_MiniTaunt)
                return object;
            var message = new $root.CDOTAUserMsg_MiniTaunt();
            if (object.taunting_player_id != null)
                message.taunting_player_id = object.taunting_player_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_MiniTaunt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_MiniTaunt
         * @static
         * @param {CDOTAUserMsg_MiniTaunt} message CDOTAUserMsg_MiniTaunt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_MiniTaunt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.taunting_player_id = 0;
            if (message.taunting_player_id != null && message.hasOwnProperty("taunting_player_id"))
                object.taunting_player_id = message.taunting_player_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_MiniTaunt to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_MiniTaunt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_MiniTaunt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_MiniTaunt;
    })();
    
    $root.CDOTAUserMsg_SpeechBubble = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_SpeechBubble.
         * @exports ICDOTAUserMsg_SpeechBubble
         * @interface ICDOTAUserMsg_SpeechBubble
         * @property {boolean|null} [destroy_all] CDOTAUserMsg_SpeechBubble destroy_all
         */
    
        /**
         * Constructs a new CDOTAUserMsg_SpeechBubble.
         * @exports CDOTAUserMsg_SpeechBubble
         * @classdesc Represents a CDOTAUserMsg_SpeechBubble.
         * @implements ICDOTAUserMsg_SpeechBubble
         * @constructor
         * @param {ICDOTAUserMsg_SpeechBubble=} [properties] Properties to set
         */
        function CDOTAUserMsg_SpeechBubble(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_SpeechBubble destroy_all.
         * @member {boolean} destroy_all
         * @memberof CDOTAUserMsg_SpeechBubble
         * @instance
         */
        CDOTAUserMsg_SpeechBubble.prototype.destroy_all = false;
    
        /**
         * Creates a new CDOTAUserMsg_SpeechBubble instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_SpeechBubble
         * @static
         * @param {ICDOTAUserMsg_SpeechBubble=} [properties] Properties to set
         * @returns {CDOTAUserMsg_SpeechBubble} CDOTAUserMsg_SpeechBubble instance
         */
        CDOTAUserMsg_SpeechBubble.create = function create(properties) {
            return new CDOTAUserMsg_SpeechBubble(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SpeechBubble message. Does not implicitly {@link CDOTAUserMsg_SpeechBubble.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_SpeechBubble
         * @static
         * @param {ICDOTAUserMsg_SpeechBubble} message CDOTAUserMsg_SpeechBubble message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SpeechBubble.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.destroy_all != null && Object.hasOwnProperty.call(message, "destroy_all"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.destroy_all);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SpeechBubble message, length delimited. Does not implicitly {@link CDOTAUserMsg_SpeechBubble.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_SpeechBubble
         * @static
         * @param {ICDOTAUserMsg_SpeechBubble} message CDOTAUserMsg_SpeechBubble message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SpeechBubble.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_SpeechBubble message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_SpeechBubble
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_SpeechBubble} CDOTAUserMsg_SpeechBubble
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SpeechBubble.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_SpeechBubble();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.destroy_all = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_SpeechBubble message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_SpeechBubble
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_SpeechBubble} CDOTAUserMsg_SpeechBubble
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SpeechBubble.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_SpeechBubble message.
         * @function verify
         * @memberof CDOTAUserMsg_SpeechBubble
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_SpeechBubble.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.destroy_all != null && message.hasOwnProperty("destroy_all"))
                if (typeof message.destroy_all !== "boolean")
                    return "destroy_all: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_SpeechBubble message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_SpeechBubble
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_SpeechBubble} CDOTAUserMsg_SpeechBubble
         */
        CDOTAUserMsg_SpeechBubble.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_SpeechBubble)
                return object;
            var message = new $root.CDOTAUserMsg_SpeechBubble();
            if (object.destroy_all != null)
                message.destroy_all = Boolean(object.destroy_all);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_SpeechBubble message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_SpeechBubble
         * @static
         * @param {CDOTAUserMsg_SpeechBubble} message CDOTAUserMsg_SpeechBubble
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_SpeechBubble.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.destroy_all = false;
            if (message.destroy_all != null && message.hasOwnProperty("destroy_all"))
                object.destroy_all = message.destroy_all;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_SpeechBubble to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_SpeechBubble
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_SpeechBubble.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_SpeechBubble;
    })();
    
    $root.CDOTAUserMsg_CustomHeaderMessage = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_CustomHeaderMessage.
         * @exports ICDOTAUserMsg_CustomHeaderMessage
         * @interface ICDOTAUserMsg_CustomHeaderMessage
         * @property {number|null} [player_id] CDOTAUserMsg_CustomHeaderMessage player_id
         * @property {number|null} [duration] CDOTAUserMsg_CustomHeaderMessage duration
         * @property {string|null} [message] CDOTAUserMsg_CustomHeaderMessage message
         * @property {number|null} [value] CDOTAUserMsg_CustomHeaderMessage value
         */
    
        /**
         * Constructs a new CDOTAUserMsg_CustomHeaderMessage.
         * @exports CDOTAUserMsg_CustomHeaderMessage
         * @classdesc Represents a CDOTAUserMsg_CustomHeaderMessage.
         * @implements ICDOTAUserMsg_CustomHeaderMessage
         * @constructor
         * @param {ICDOTAUserMsg_CustomHeaderMessage=} [properties] Properties to set
         */
        function CDOTAUserMsg_CustomHeaderMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_CustomHeaderMessage player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_CustomHeaderMessage
         * @instance
         */
        CDOTAUserMsg_CustomHeaderMessage.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_CustomHeaderMessage duration.
         * @member {number} duration
         * @memberof CDOTAUserMsg_CustomHeaderMessage
         * @instance
         */
        CDOTAUserMsg_CustomHeaderMessage.prototype.duration = 0;
    
        /**
         * CDOTAUserMsg_CustomHeaderMessage message.
         * @member {string} message
         * @memberof CDOTAUserMsg_CustomHeaderMessage
         * @instance
         */
        CDOTAUserMsg_CustomHeaderMessage.prototype.message = "";
    
        /**
         * CDOTAUserMsg_CustomHeaderMessage value.
         * @member {number} value
         * @memberof CDOTAUserMsg_CustomHeaderMessage
         * @instance
         */
        CDOTAUserMsg_CustomHeaderMessage.prototype.value = 0;
    
        /**
         * Creates a new CDOTAUserMsg_CustomHeaderMessage instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_CustomHeaderMessage
         * @static
         * @param {ICDOTAUserMsg_CustomHeaderMessage=} [properties] Properties to set
         * @returns {CDOTAUserMsg_CustomHeaderMessage} CDOTAUserMsg_CustomHeaderMessage instance
         */
        CDOTAUserMsg_CustomHeaderMessage.create = function create(properties) {
            return new CDOTAUserMsg_CustomHeaderMessage(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CustomHeaderMessage message. Does not implicitly {@link CDOTAUserMsg_CustomHeaderMessage.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_CustomHeaderMessage
         * @static
         * @param {ICDOTAUserMsg_CustomHeaderMessage} message CDOTAUserMsg_CustomHeaderMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CustomHeaderMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.duration);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.message);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.value);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CustomHeaderMessage message, length delimited. Does not implicitly {@link CDOTAUserMsg_CustomHeaderMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_CustomHeaderMessage
         * @static
         * @param {ICDOTAUserMsg_CustomHeaderMessage} message CDOTAUserMsg_CustomHeaderMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CustomHeaderMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_CustomHeaderMessage message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_CustomHeaderMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_CustomHeaderMessage} CDOTAUserMsg_CustomHeaderMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CustomHeaderMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_CustomHeaderMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.duration = reader.float();
                    break;
                case 3:
                    message.message = reader.string();
                    break;
                case 4:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_CustomHeaderMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_CustomHeaderMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_CustomHeaderMessage} CDOTAUserMsg_CustomHeaderMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CustomHeaderMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_CustomHeaderMessage message.
         * @function verify
         * @memberof CDOTAUserMsg_CustomHeaderMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_CustomHeaderMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value))
                    return "value: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_CustomHeaderMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_CustomHeaderMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_CustomHeaderMessage} CDOTAUserMsg_CustomHeaderMessage
         */
        CDOTAUserMsg_CustomHeaderMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_CustomHeaderMessage)
                return object;
            var message = new $root.CDOTAUserMsg_CustomHeaderMessage();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.duration != null)
                message.duration = Number(object.duration);
            if (object.message != null)
                message.message = String(object.message);
            if (object.value != null)
                message.value = object.value | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_CustomHeaderMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_CustomHeaderMessage
         * @static
         * @param {CDOTAUserMsg_CustomHeaderMessage} message CDOTAUserMsg_CustomHeaderMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_CustomHeaderMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.duration = 0;
                object.message = "";
                object.value = 0;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_CustomHeaderMessage to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_CustomHeaderMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_CustomHeaderMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_CustomHeaderMessage;
    })();
    
    $root.CMsgHeroAbilityStat = (function() {
    
        /**
         * Properties of a CMsgHeroAbilityStat.
         * @exports ICMsgHeroAbilityStat
         * @interface ICMsgHeroAbilityStat
         * @property {EHeroStatType|null} [stat_type] CMsgHeroAbilityStat stat_type
         * @property {number|null} [int_value] CMsgHeroAbilityStat int_value
         * @property {number|null} [float_value] CMsgHeroAbilityStat float_value
         */
    
        /**
         * Constructs a new CMsgHeroAbilityStat.
         * @exports CMsgHeroAbilityStat
         * @classdesc Represents a CMsgHeroAbilityStat.
         * @implements ICMsgHeroAbilityStat
         * @constructor
         * @param {ICMsgHeroAbilityStat=} [properties] Properties to set
         */
        function CMsgHeroAbilityStat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgHeroAbilityStat stat_type.
         * @member {EHeroStatType} stat_type
         * @memberof CMsgHeroAbilityStat
         * @instance
         */
        CMsgHeroAbilityStat.prototype.stat_type = 0;
    
        /**
         * CMsgHeroAbilityStat int_value.
         * @member {number} int_value
         * @memberof CMsgHeroAbilityStat
         * @instance
         */
        CMsgHeroAbilityStat.prototype.int_value = 0;
    
        /**
         * CMsgHeroAbilityStat float_value.
         * @member {number} float_value
         * @memberof CMsgHeroAbilityStat
         * @instance
         */
        CMsgHeroAbilityStat.prototype.float_value = 0;
    
        /**
         * Creates a new CMsgHeroAbilityStat instance using the specified properties.
         * @function create
         * @memberof CMsgHeroAbilityStat
         * @static
         * @param {ICMsgHeroAbilityStat=} [properties] Properties to set
         * @returns {CMsgHeroAbilityStat} CMsgHeroAbilityStat instance
         */
        CMsgHeroAbilityStat.create = function create(properties) {
            return new CMsgHeroAbilityStat(properties);
        };
    
        /**
         * Encodes the specified CMsgHeroAbilityStat message. Does not implicitly {@link CMsgHeroAbilityStat.verify|verify} messages.
         * @function encode
         * @memberof CMsgHeroAbilityStat
         * @static
         * @param {ICMsgHeroAbilityStat} message CMsgHeroAbilityStat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgHeroAbilityStat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stat_type != null && Object.hasOwnProperty.call(message, "stat_type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.stat_type);
            if (message.int_value != null && Object.hasOwnProperty.call(message, "int_value"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.int_value);
            if (message.float_value != null && Object.hasOwnProperty.call(message, "float_value"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.float_value);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgHeroAbilityStat message, length delimited. Does not implicitly {@link CMsgHeroAbilityStat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgHeroAbilityStat
         * @static
         * @param {ICMsgHeroAbilityStat} message CMsgHeroAbilityStat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgHeroAbilityStat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgHeroAbilityStat message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgHeroAbilityStat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgHeroAbilityStat} CMsgHeroAbilityStat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgHeroAbilityStat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgHeroAbilityStat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stat_type = reader.int32();
                    break;
                case 2:
                    message.int_value = reader.int32();
                    break;
                case 3:
                    message.float_value = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgHeroAbilityStat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgHeroAbilityStat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgHeroAbilityStat} CMsgHeroAbilityStat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgHeroAbilityStat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgHeroAbilityStat message.
         * @function verify
         * @memberof CMsgHeroAbilityStat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgHeroAbilityStat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stat_type != null && message.hasOwnProperty("stat_type"))
                switch (message.stat_type) {
                default:
                    return "stat_type: enum value expected";
                case 0:
                case 2000:
                case 2001:
                case 2002:
                case 2003:
                case 2004:
                case 2005:
                case 2006:
                case 2007:
                case 2008:
                case 2009:
                case 2010:
                case 2011:
                case 2012:
                case 2013:
                case 2014:
                case 2015:
                case 2016:
                case 2017:
                case 2018:
                case 2019:
                case 2020:
                    break;
                }
            if (message.int_value != null && message.hasOwnProperty("int_value"))
                if (!$util.isInteger(message.int_value))
                    return "int_value: integer expected";
            if (message.float_value != null && message.hasOwnProperty("float_value"))
                if (typeof message.float_value !== "number")
                    return "float_value: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgHeroAbilityStat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgHeroAbilityStat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgHeroAbilityStat} CMsgHeroAbilityStat
         */
        CMsgHeroAbilityStat.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgHeroAbilityStat)
                return object;
            var message = new $root.CMsgHeroAbilityStat();
            switch (object.stat_type) {
            case "k_EHeroStatType_None":
            case 0:
                message.stat_type = 0;
                break;
            case "k_EHeroStatType_AxeTotalDamage":
            case 2000:
                message.stat_type = 2000;
                break;
            case "k_EHeroStatType_BattleHungerDamage":
            case 2001:
                message.stat_type = 2001;
                break;
            case "k_EHeroStatType_CounterHelixDamage":
            case 2002:
                message.stat_type = 2002;
                break;
            case "k_EHeroStatType_CullingBladeDamage":
            case 2003:
                message.stat_type = 2003;
                break;
            case "k_EHeroStatType_BerserkersCallCastCount":
            case 2004:
                message.stat_type = 2004;
                break;
            case "k_EHeroStatType_BerserkersCallHeroesHitAverage":
            case 2005:
                message.stat_type = 2005;
                break;
            case "k_EHeroStatType_BerserkersCallOtherUnitsHit":
            case 2006:
                message.stat_type = 2006;
                break;
            case "k_EHeroStatType_BerserkersCallHeroAttacksTaken":
            case 2007:
                message.stat_type = 2007;
                break;
            case "k_EHeroStatType_BerserkersCallOtherAttacksTaken":
            case 2008:
                message.stat_type = 2008;
                break;
            case "k_EHeroStatType_BattleHungerCastCount":
            case 2009:
                message.stat_type = 2009;
                break;
            case "k_EHeroStatType_BattleHungerPotentialDuration":
            case 2010:
                message.stat_type = 2010;
                break;
            case "k_EHeroStatType_BattleHungerAverageDuration":
            case 2011:
                message.stat_type = 2011;
                break;
            case "k_EHeroStatType_CounterHelixProcCount":
            case 2012:
                message.stat_type = 2012;
                break;
            case "k_EHeroStatType_CounterHelixHeroProcCount":
            case 2013:
                message.stat_type = 2013;
                break;
            case "k_EHeroStatType_CounterHelixHeroesHitAverage":
            case 2014:
                message.stat_type = 2014;
                break;
            case "k_EHeroStatType_CounterHelixOtherUnitsHitCount":
            case 2015:
                message.stat_type = 2015;
                break;
            case "k_EHeroStatType_CullingBladeCastCount":
            case 2016:
                message.stat_type = 2016;
                break;
            case "k_EHeroStatType_CullingBladeKillCount":
            case 2017:
                message.stat_type = 2017;
                break;
            case "k_EHeroStatType_CullingBladeAverageHealthCulled":
            case 2018:
                message.stat_type = 2018;
                break;
            case "k_EHeroStatType_CullingBladeAverageDamageAvailable":
            case 2019:
                message.stat_type = 2019;
                break;
            case "k_EHeroStatType_CullingBladeHeroBuffAverage":
            case 2020:
                message.stat_type = 2020;
                break;
            }
            if (object.int_value != null)
                message.int_value = object.int_value | 0;
            if (object.float_value != null)
                message.float_value = Number(object.float_value);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgHeroAbilityStat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgHeroAbilityStat
         * @static
         * @param {CMsgHeroAbilityStat} message CMsgHeroAbilityStat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgHeroAbilityStat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.stat_type = options.enums === String ? "k_EHeroStatType_None" : 0;
                object.int_value = 0;
                object.float_value = 0;
            }
            if (message.stat_type != null && message.hasOwnProperty("stat_type"))
                object.stat_type = options.enums === String ? $root.EHeroStatType[message.stat_type] : message.stat_type;
            if (message.int_value != null && message.hasOwnProperty("int_value"))
                object.int_value = message.int_value;
            if (message.float_value != null && message.hasOwnProperty("float_value"))
                object.float_value = options.json && !isFinite(message.float_value) ? String(message.float_value) : message.float_value;
            return object;
        };
    
        /**
         * Converts this CMsgHeroAbilityStat to JSON.
         * @function toJSON
         * @memberof CMsgHeroAbilityStat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgHeroAbilityStat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgHeroAbilityStat;
    })();
    
    $root.CMsgCombatAnalyzerPlayerStat = (function() {
    
        /**
         * Properties of a CMsgCombatAnalyzerPlayerStat.
         * @exports ICMsgCombatAnalyzerPlayerStat
         * @interface ICMsgCombatAnalyzerPlayerStat
         * @property {number|null} [account_id] CMsgCombatAnalyzerPlayerStat account_id
         * @property {Array.<ICMsgHeroAbilityStat>|null} [hero_ability_stats] CMsgCombatAnalyzerPlayerStat hero_ability_stats
         */
    
        /**
         * Constructs a new CMsgCombatAnalyzerPlayerStat.
         * @exports CMsgCombatAnalyzerPlayerStat
         * @classdesc Represents a CMsgCombatAnalyzerPlayerStat.
         * @implements ICMsgCombatAnalyzerPlayerStat
         * @constructor
         * @param {ICMsgCombatAnalyzerPlayerStat=} [properties] Properties to set
         */
        function CMsgCombatAnalyzerPlayerStat(properties) {
            this.hero_ability_stats = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgCombatAnalyzerPlayerStat account_id.
         * @member {number} account_id
         * @memberof CMsgCombatAnalyzerPlayerStat
         * @instance
         */
        CMsgCombatAnalyzerPlayerStat.prototype.account_id = 0;
    
        /**
         * CMsgCombatAnalyzerPlayerStat hero_ability_stats.
         * @member {Array.<ICMsgHeroAbilityStat>} hero_ability_stats
         * @memberof CMsgCombatAnalyzerPlayerStat
         * @instance
         */
        CMsgCombatAnalyzerPlayerStat.prototype.hero_ability_stats = $util.emptyArray;
    
        /**
         * Creates a new CMsgCombatAnalyzerPlayerStat instance using the specified properties.
         * @function create
         * @memberof CMsgCombatAnalyzerPlayerStat
         * @static
         * @param {ICMsgCombatAnalyzerPlayerStat=} [properties] Properties to set
         * @returns {CMsgCombatAnalyzerPlayerStat} CMsgCombatAnalyzerPlayerStat instance
         */
        CMsgCombatAnalyzerPlayerStat.create = function create(properties) {
            return new CMsgCombatAnalyzerPlayerStat(properties);
        };
    
        /**
         * Encodes the specified CMsgCombatAnalyzerPlayerStat message. Does not implicitly {@link CMsgCombatAnalyzerPlayerStat.verify|verify} messages.
         * @function encode
         * @memberof CMsgCombatAnalyzerPlayerStat
         * @static
         * @param {ICMsgCombatAnalyzerPlayerStat} message CMsgCombatAnalyzerPlayerStat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgCombatAnalyzerPlayerStat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account_id != null && Object.hasOwnProperty.call(message, "account_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.account_id);
            if (message.hero_ability_stats != null && message.hero_ability_stats.length)
                for (var i = 0; i < message.hero_ability_stats.length; ++i)
                    $root.CMsgHeroAbilityStat.encode(message.hero_ability_stats[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgCombatAnalyzerPlayerStat message, length delimited. Does not implicitly {@link CMsgCombatAnalyzerPlayerStat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgCombatAnalyzerPlayerStat
         * @static
         * @param {ICMsgCombatAnalyzerPlayerStat} message CMsgCombatAnalyzerPlayerStat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgCombatAnalyzerPlayerStat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgCombatAnalyzerPlayerStat message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgCombatAnalyzerPlayerStat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgCombatAnalyzerPlayerStat} CMsgCombatAnalyzerPlayerStat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgCombatAnalyzerPlayerStat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgCombatAnalyzerPlayerStat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.account_id = reader.uint32();
                    break;
                case 2:
                    if (!(message.hero_ability_stats && message.hero_ability_stats.length))
                        message.hero_ability_stats = [];
                    message.hero_ability_stats.push($root.CMsgHeroAbilityStat.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgCombatAnalyzerPlayerStat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgCombatAnalyzerPlayerStat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgCombatAnalyzerPlayerStat} CMsgCombatAnalyzerPlayerStat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgCombatAnalyzerPlayerStat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgCombatAnalyzerPlayerStat message.
         * @function verify
         * @memberof CMsgCombatAnalyzerPlayerStat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgCombatAnalyzerPlayerStat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account_id != null && message.hasOwnProperty("account_id"))
                if (!$util.isInteger(message.account_id))
                    return "account_id: integer expected";
            if (message.hero_ability_stats != null && message.hasOwnProperty("hero_ability_stats")) {
                if (!Array.isArray(message.hero_ability_stats))
                    return "hero_ability_stats: array expected";
                for (var i = 0; i < message.hero_ability_stats.length; ++i) {
                    var error = $root.CMsgHeroAbilityStat.verify(message.hero_ability_stats[i]);
                    if (error)
                        return "hero_ability_stats." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsgCombatAnalyzerPlayerStat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgCombatAnalyzerPlayerStat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgCombatAnalyzerPlayerStat} CMsgCombatAnalyzerPlayerStat
         */
        CMsgCombatAnalyzerPlayerStat.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgCombatAnalyzerPlayerStat)
                return object;
            var message = new $root.CMsgCombatAnalyzerPlayerStat();
            if (object.account_id != null)
                message.account_id = object.account_id >>> 0;
            if (object.hero_ability_stats) {
                if (!Array.isArray(object.hero_ability_stats))
                    throw TypeError(".CMsgCombatAnalyzerPlayerStat.hero_ability_stats: array expected");
                message.hero_ability_stats = [];
                for (var i = 0; i < object.hero_ability_stats.length; ++i) {
                    if (typeof object.hero_ability_stats[i] !== "object")
                        throw TypeError(".CMsgCombatAnalyzerPlayerStat.hero_ability_stats: object expected");
                    message.hero_ability_stats[i] = $root.CMsgHeroAbilityStat.fromObject(object.hero_ability_stats[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgCombatAnalyzerPlayerStat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgCombatAnalyzerPlayerStat
         * @static
         * @param {CMsgCombatAnalyzerPlayerStat} message CMsgCombatAnalyzerPlayerStat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgCombatAnalyzerPlayerStat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.hero_ability_stats = [];
            if (options.defaults)
                object.account_id = 0;
            if (message.account_id != null && message.hasOwnProperty("account_id"))
                object.account_id = message.account_id;
            if (message.hero_ability_stats && message.hero_ability_stats.length) {
                object.hero_ability_stats = [];
                for (var j = 0; j < message.hero_ability_stats.length; ++j)
                    object.hero_ability_stats[j] = $root.CMsgHeroAbilityStat.toObject(message.hero_ability_stats[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsgCombatAnalyzerPlayerStat to JSON.
         * @function toJSON
         * @memberof CMsgCombatAnalyzerPlayerStat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgCombatAnalyzerPlayerStat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgCombatAnalyzerPlayerStat;
    })();
    
    $root.CMsgCombatAnalyzerStats = (function() {
    
        /**
         * Properties of a CMsgCombatAnalyzerStats.
         * @exports ICMsgCombatAnalyzerStats
         * @interface ICMsgCombatAnalyzerStats
         * @property {number|Long|null} [match_id] CMsgCombatAnalyzerStats match_id
         * @property {Array.<ICMsgCombatAnalyzerPlayerStat>|null} [player_stats] CMsgCombatAnalyzerStats player_stats
         */
    
        /**
         * Constructs a new CMsgCombatAnalyzerStats.
         * @exports CMsgCombatAnalyzerStats
         * @classdesc Represents a CMsgCombatAnalyzerStats.
         * @implements ICMsgCombatAnalyzerStats
         * @constructor
         * @param {ICMsgCombatAnalyzerStats=} [properties] Properties to set
         */
        function CMsgCombatAnalyzerStats(properties) {
            this.player_stats = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgCombatAnalyzerStats match_id.
         * @member {number|Long} match_id
         * @memberof CMsgCombatAnalyzerStats
         * @instance
         */
        CMsgCombatAnalyzerStats.prototype.match_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CMsgCombatAnalyzerStats player_stats.
         * @member {Array.<ICMsgCombatAnalyzerPlayerStat>} player_stats
         * @memberof CMsgCombatAnalyzerStats
         * @instance
         */
        CMsgCombatAnalyzerStats.prototype.player_stats = $util.emptyArray;
    
        /**
         * Creates a new CMsgCombatAnalyzerStats instance using the specified properties.
         * @function create
         * @memberof CMsgCombatAnalyzerStats
         * @static
         * @param {ICMsgCombatAnalyzerStats=} [properties] Properties to set
         * @returns {CMsgCombatAnalyzerStats} CMsgCombatAnalyzerStats instance
         */
        CMsgCombatAnalyzerStats.create = function create(properties) {
            return new CMsgCombatAnalyzerStats(properties);
        };
    
        /**
         * Encodes the specified CMsgCombatAnalyzerStats message. Does not implicitly {@link CMsgCombatAnalyzerStats.verify|verify} messages.
         * @function encode
         * @memberof CMsgCombatAnalyzerStats
         * @static
         * @param {ICMsgCombatAnalyzerStats} message CMsgCombatAnalyzerStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgCombatAnalyzerStats.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.match_id != null && Object.hasOwnProperty.call(message, "match_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.match_id);
            if (message.player_stats != null && message.player_stats.length)
                for (var i = 0; i < message.player_stats.length; ++i)
                    $root.CMsgCombatAnalyzerPlayerStat.encode(message.player_stats[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgCombatAnalyzerStats message, length delimited. Does not implicitly {@link CMsgCombatAnalyzerStats.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgCombatAnalyzerStats
         * @static
         * @param {ICMsgCombatAnalyzerStats} message CMsgCombatAnalyzerStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgCombatAnalyzerStats.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgCombatAnalyzerStats message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgCombatAnalyzerStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgCombatAnalyzerStats} CMsgCombatAnalyzerStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgCombatAnalyzerStats.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgCombatAnalyzerStats();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.match_id = reader.uint64();
                    break;
                case 2:
                    if (!(message.player_stats && message.player_stats.length))
                        message.player_stats = [];
                    message.player_stats.push($root.CMsgCombatAnalyzerPlayerStat.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgCombatAnalyzerStats message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgCombatAnalyzerStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgCombatAnalyzerStats} CMsgCombatAnalyzerStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgCombatAnalyzerStats.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgCombatAnalyzerStats message.
         * @function verify
         * @memberof CMsgCombatAnalyzerStats
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgCombatAnalyzerStats.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.match_id != null && message.hasOwnProperty("match_id"))
                if (!$util.isInteger(message.match_id) && !(message.match_id && $util.isInteger(message.match_id.low) && $util.isInteger(message.match_id.high)))
                    return "match_id: integer|Long expected";
            if (message.player_stats != null && message.hasOwnProperty("player_stats")) {
                if (!Array.isArray(message.player_stats))
                    return "player_stats: array expected";
                for (var i = 0; i < message.player_stats.length; ++i) {
                    var error = $root.CMsgCombatAnalyzerPlayerStat.verify(message.player_stats[i]);
                    if (error)
                        return "player_stats." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsgCombatAnalyzerStats message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgCombatAnalyzerStats
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgCombatAnalyzerStats} CMsgCombatAnalyzerStats
         */
        CMsgCombatAnalyzerStats.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgCombatAnalyzerStats)
                return object;
            var message = new $root.CMsgCombatAnalyzerStats();
            if (object.match_id != null)
                if ($util.Long)
                    (message.match_id = $util.Long.fromValue(object.match_id)).unsigned = true;
                else if (typeof object.match_id === "string")
                    message.match_id = parseInt(object.match_id, 10);
                else if (typeof object.match_id === "number")
                    message.match_id = object.match_id;
                else if (typeof object.match_id === "object")
                    message.match_id = new $util.LongBits(object.match_id.low >>> 0, object.match_id.high >>> 0).toNumber(true);
            if (object.player_stats) {
                if (!Array.isArray(object.player_stats))
                    throw TypeError(".CMsgCombatAnalyzerStats.player_stats: array expected");
                message.player_stats = [];
                for (var i = 0; i < object.player_stats.length; ++i) {
                    if (typeof object.player_stats[i] !== "object")
                        throw TypeError(".CMsgCombatAnalyzerStats.player_stats: object expected");
                    message.player_stats[i] = $root.CMsgCombatAnalyzerPlayerStat.fromObject(object.player_stats[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgCombatAnalyzerStats message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgCombatAnalyzerStats
         * @static
         * @param {CMsgCombatAnalyzerStats} message CMsgCombatAnalyzerStats
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgCombatAnalyzerStats.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.player_stats = [];
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.match_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.match_id = options.longs === String ? "0" : 0;
            if (message.match_id != null && message.hasOwnProperty("match_id"))
                if (typeof message.match_id === "number")
                    object.match_id = options.longs === String ? String(message.match_id) : message.match_id;
                else
                    object.match_id = options.longs === String ? $util.Long.prototype.toString.call(message.match_id) : options.longs === Number ? new $util.LongBits(message.match_id.low >>> 0, message.match_id.high >>> 0).toNumber(true) : message.match_id;
            if (message.player_stats && message.player_stats.length) {
                object.player_stats = [];
                for (var j = 0; j < message.player_stats.length; ++j)
                    object.player_stats[j] = $root.CMsgCombatAnalyzerPlayerStat.toObject(message.player_stats[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsgCombatAnalyzerStats to JSON.
         * @function toJSON
         * @memberof CMsgCombatAnalyzerStats
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgCombatAnalyzerStats.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgCombatAnalyzerStats;
    })();
    
    $root.CDOTAUserMsg_BeastChat = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_BeastChat.
         * @exports ICDOTAUserMsg_BeastChat
         * @interface ICDOTAUserMsg_BeastChat
         * @property {number|null} [team] CDOTAUserMsg_BeastChat team
         * @property {string|null} [format] CDOTAUserMsg_BeastChat format
         * @property {string|null} [message] CDOTAUserMsg_BeastChat message
         * @property {string|null} [target] CDOTAUserMsg_BeastChat target
         */
    
        /**
         * Constructs a new CDOTAUserMsg_BeastChat.
         * @exports CDOTAUserMsg_BeastChat
         * @classdesc Represents a CDOTAUserMsg_BeastChat.
         * @implements ICDOTAUserMsg_BeastChat
         * @constructor
         * @param {ICDOTAUserMsg_BeastChat=} [properties] Properties to set
         */
        function CDOTAUserMsg_BeastChat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_BeastChat team.
         * @member {number} team
         * @memberof CDOTAUserMsg_BeastChat
         * @instance
         */
        CDOTAUserMsg_BeastChat.prototype.team = 0;
    
        /**
         * CDOTAUserMsg_BeastChat format.
         * @member {string} format
         * @memberof CDOTAUserMsg_BeastChat
         * @instance
         */
        CDOTAUserMsg_BeastChat.prototype.format = "";
    
        /**
         * CDOTAUserMsg_BeastChat message.
         * @member {string} message
         * @memberof CDOTAUserMsg_BeastChat
         * @instance
         */
        CDOTAUserMsg_BeastChat.prototype.message = "";
    
        /**
         * CDOTAUserMsg_BeastChat target.
         * @member {string} target
         * @memberof CDOTAUserMsg_BeastChat
         * @instance
         */
        CDOTAUserMsg_BeastChat.prototype.target = "";
    
        /**
         * Creates a new CDOTAUserMsg_BeastChat instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_BeastChat
         * @static
         * @param {ICDOTAUserMsg_BeastChat=} [properties] Properties to set
         * @returns {CDOTAUserMsg_BeastChat} CDOTAUserMsg_BeastChat instance
         */
        CDOTAUserMsg_BeastChat.create = function create(properties) {
            return new CDOTAUserMsg_BeastChat(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_BeastChat message. Does not implicitly {@link CDOTAUserMsg_BeastChat.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_BeastChat
         * @static
         * @param {ICDOTAUserMsg_BeastChat} message CDOTAUserMsg_BeastChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_BeastChat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.team != null && Object.hasOwnProperty.call(message, "team"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.team);
            if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.format);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.message);
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.target);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_BeastChat message, length delimited. Does not implicitly {@link CDOTAUserMsg_BeastChat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_BeastChat
         * @static
         * @param {ICDOTAUserMsg_BeastChat} message CDOTAUserMsg_BeastChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_BeastChat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_BeastChat message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_BeastChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_BeastChat} CDOTAUserMsg_BeastChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_BeastChat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_BeastChat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.team = reader.uint32();
                    break;
                case 2:
                    message.format = reader.string();
                    break;
                case 3:
                    message.message = reader.string();
                    break;
                case 4:
                    message.target = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_BeastChat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_BeastChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_BeastChat} CDOTAUserMsg_BeastChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_BeastChat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_BeastChat message.
         * @function verify
         * @memberof CDOTAUserMsg_BeastChat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_BeastChat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.team != null && message.hasOwnProperty("team"))
                if (!$util.isInteger(message.team))
                    return "team: integer expected";
            if (message.format != null && message.hasOwnProperty("format"))
                if (!$util.isString(message.format))
                    return "format: string expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.target != null && message.hasOwnProperty("target"))
                if (!$util.isString(message.target))
                    return "target: string expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_BeastChat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_BeastChat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_BeastChat} CDOTAUserMsg_BeastChat
         */
        CDOTAUserMsg_BeastChat.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_BeastChat)
                return object;
            var message = new $root.CDOTAUserMsg_BeastChat();
            if (object.team != null)
                message.team = object.team >>> 0;
            if (object.format != null)
                message.format = String(object.format);
            if (object.message != null)
                message.message = String(object.message);
            if (object.target != null)
                message.target = String(object.target);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_BeastChat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_BeastChat
         * @static
         * @param {CDOTAUserMsg_BeastChat} message CDOTAUserMsg_BeastChat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_BeastChat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.team = 0;
                object.format = "";
                object.message = "";
                object.target = "";
            }
            if (message.team != null && message.hasOwnProperty("team"))
                object.team = message.team;
            if (message.format != null && message.hasOwnProperty("format"))
                object.format = message.format;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = message.target;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_BeastChat to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_BeastChat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_BeastChat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_BeastChat;
    })();
    
    $root.CDOTAUserMsg_CustomHudElement_Create = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_CustomHudElement_Create.
         * @exports ICDOTAUserMsg_CustomHudElement_Create
         * @interface ICDOTAUserMsg_CustomHudElement_Create
         * @property {string|null} [element_id] CDOTAUserMsg_CustomHudElement_Create element_id
         * @property {string|null} [layout_filename] CDOTAUserMsg_CustomHudElement_Create layout_filename
         * @property {Uint8Array|null} [data] CDOTAUserMsg_CustomHudElement_Create data
         */
    
        /**
         * Constructs a new CDOTAUserMsg_CustomHudElement_Create.
         * @exports CDOTAUserMsg_CustomHudElement_Create
         * @classdesc Represents a CDOTAUserMsg_CustomHudElement_Create.
         * @implements ICDOTAUserMsg_CustomHudElement_Create
         * @constructor
         * @param {ICDOTAUserMsg_CustomHudElement_Create=} [properties] Properties to set
         */
        function CDOTAUserMsg_CustomHudElement_Create(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_CustomHudElement_Create element_id.
         * @member {string} element_id
         * @memberof CDOTAUserMsg_CustomHudElement_Create
         * @instance
         */
        CDOTAUserMsg_CustomHudElement_Create.prototype.element_id = "";
    
        /**
         * CDOTAUserMsg_CustomHudElement_Create layout_filename.
         * @member {string} layout_filename
         * @memberof CDOTAUserMsg_CustomHudElement_Create
         * @instance
         */
        CDOTAUserMsg_CustomHudElement_Create.prototype.layout_filename = "";
    
        /**
         * CDOTAUserMsg_CustomHudElement_Create data.
         * @member {Uint8Array} data
         * @memberof CDOTAUserMsg_CustomHudElement_Create
         * @instance
         */
        CDOTAUserMsg_CustomHudElement_Create.prototype.data = $util.newBuffer([]);
    
        /**
         * Creates a new CDOTAUserMsg_CustomHudElement_Create instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_CustomHudElement_Create
         * @static
         * @param {ICDOTAUserMsg_CustomHudElement_Create=} [properties] Properties to set
         * @returns {CDOTAUserMsg_CustomHudElement_Create} CDOTAUserMsg_CustomHudElement_Create instance
         */
        CDOTAUserMsg_CustomHudElement_Create.create = function create(properties) {
            return new CDOTAUserMsg_CustomHudElement_Create(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CustomHudElement_Create message. Does not implicitly {@link CDOTAUserMsg_CustomHudElement_Create.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_CustomHudElement_Create
         * @static
         * @param {ICDOTAUserMsg_CustomHudElement_Create} message CDOTAUserMsg_CustomHudElement_Create message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CustomHudElement_Create.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.element_id != null && Object.hasOwnProperty.call(message, "element_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.element_id);
            if (message.layout_filename != null && Object.hasOwnProperty.call(message, "layout_filename"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.layout_filename);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CustomHudElement_Create message, length delimited. Does not implicitly {@link CDOTAUserMsg_CustomHudElement_Create.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_CustomHudElement_Create
         * @static
         * @param {ICDOTAUserMsg_CustomHudElement_Create} message CDOTAUserMsg_CustomHudElement_Create message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CustomHudElement_Create.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_CustomHudElement_Create message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_CustomHudElement_Create
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_CustomHudElement_Create} CDOTAUserMsg_CustomHudElement_Create
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CustomHudElement_Create.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_CustomHudElement_Create();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.element_id = reader.string();
                    break;
                case 2:
                    message.layout_filename = reader.string();
                    break;
                case 3:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_CustomHudElement_Create message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_CustomHudElement_Create
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_CustomHudElement_Create} CDOTAUserMsg_CustomHudElement_Create
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CustomHudElement_Create.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_CustomHudElement_Create message.
         * @function verify
         * @memberof CDOTAUserMsg_CustomHudElement_Create
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_CustomHudElement_Create.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.element_id != null && message.hasOwnProperty("element_id"))
                if (!$util.isString(message.element_id))
                    return "element_id: string expected";
            if (message.layout_filename != null && message.hasOwnProperty("layout_filename"))
                if (!$util.isString(message.layout_filename))
                    return "layout_filename: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_CustomHudElement_Create message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_CustomHudElement_Create
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_CustomHudElement_Create} CDOTAUserMsg_CustomHudElement_Create
         */
        CDOTAUserMsg_CustomHudElement_Create.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_CustomHudElement_Create)
                return object;
            var message = new $root.CDOTAUserMsg_CustomHudElement_Create();
            if (object.element_id != null)
                message.element_id = String(object.element_id);
            if (object.layout_filename != null)
                message.layout_filename = String(object.layout_filename);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_CustomHudElement_Create message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_CustomHudElement_Create
         * @static
         * @param {CDOTAUserMsg_CustomHudElement_Create} message CDOTAUserMsg_CustomHudElement_Create
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_CustomHudElement_Create.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.element_id = "";
                object.layout_filename = "";
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.element_id != null && message.hasOwnProperty("element_id"))
                object.element_id = message.element_id;
            if (message.layout_filename != null && message.hasOwnProperty("layout_filename"))
                object.layout_filename = message.layout_filename;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_CustomHudElement_Create to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_CustomHudElement_Create
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_CustomHudElement_Create.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_CustomHudElement_Create;
    })();
    
    $root.CDOTAUserMsg_CustomHudElement_Modify = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_CustomHudElement_Modify.
         * @exports ICDOTAUserMsg_CustomHudElement_Modify
         * @interface ICDOTAUserMsg_CustomHudElement_Modify
         * @property {string|null} [element_id] CDOTAUserMsg_CustomHudElement_Modify element_id
         * @property {boolean|null} [modify_visible] CDOTAUserMsg_CustomHudElement_Modify modify_visible
         * @property {Uint8Array|null} [data] CDOTAUserMsg_CustomHudElement_Modify data
         */
    
        /**
         * Constructs a new CDOTAUserMsg_CustomHudElement_Modify.
         * @exports CDOTAUserMsg_CustomHudElement_Modify
         * @classdesc Represents a CDOTAUserMsg_CustomHudElement_Modify.
         * @implements ICDOTAUserMsg_CustomHudElement_Modify
         * @constructor
         * @param {ICDOTAUserMsg_CustomHudElement_Modify=} [properties] Properties to set
         */
        function CDOTAUserMsg_CustomHudElement_Modify(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_CustomHudElement_Modify element_id.
         * @member {string} element_id
         * @memberof CDOTAUserMsg_CustomHudElement_Modify
         * @instance
         */
        CDOTAUserMsg_CustomHudElement_Modify.prototype.element_id = "";
    
        /**
         * CDOTAUserMsg_CustomHudElement_Modify modify_visible.
         * @member {boolean} modify_visible
         * @memberof CDOTAUserMsg_CustomHudElement_Modify
         * @instance
         */
        CDOTAUserMsg_CustomHudElement_Modify.prototype.modify_visible = false;
    
        /**
         * CDOTAUserMsg_CustomHudElement_Modify data.
         * @member {Uint8Array} data
         * @memberof CDOTAUserMsg_CustomHudElement_Modify
         * @instance
         */
        CDOTAUserMsg_CustomHudElement_Modify.prototype.data = $util.newBuffer([]);
    
        /**
         * Creates a new CDOTAUserMsg_CustomHudElement_Modify instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_CustomHudElement_Modify
         * @static
         * @param {ICDOTAUserMsg_CustomHudElement_Modify=} [properties] Properties to set
         * @returns {CDOTAUserMsg_CustomHudElement_Modify} CDOTAUserMsg_CustomHudElement_Modify instance
         */
        CDOTAUserMsg_CustomHudElement_Modify.create = function create(properties) {
            return new CDOTAUserMsg_CustomHudElement_Modify(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CustomHudElement_Modify message. Does not implicitly {@link CDOTAUserMsg_CustomHudElement_Modify.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_CustomHudElement_Modify
         * @static
         * @param {ICDOTAUserMsg_CustomHudElement_Modify} message CDOTAUserMsg_CustomHudElement_Modify message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CustomHudElement_Modify.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.element_id != null && Object.hasOwnProperty.call(message, "element_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.element_id);
            if (message.modify_visible != null && Object.hasOwnProperty.call(message, "modify_visible"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.modify_visible);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CustomHudElement_Modify message, length delimited. Does not implicitly {@link CDOTAUserMsg_CustomHudElement_Modify.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_CustomHudElement_Modify
         * @static
         * @param {ICDOTAUserMsg_CustomHudElement_Modify} message CDOTAUserMsg_CustomHudElement_Modify message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CustomHudElement_Modify.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_CustomHudElement_Modify message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_CustomHudElement_Modify
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_CustomHudElement_Modify} CDOTAUserMsg_CustomHudElement_Modify
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CustomHudElement_Modify.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_CustomHudElement_Modify();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.element_id = reader.string();
                    break;
                case 2:
                    message.modify_visible = reader.bool();
                    break;
                case 3:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_CustomHudElement_Modify message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_CustomHudElement_Modify
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_CustomHudElement_Modify} CDOTAUserMsg_CustomHudElement_Modify
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CustomHudElement_Modify.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_CustomHudElement_Modify message.
         * @function verify
         * @memberof CDOTAUserMsg_CustomHudElement_Modify
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_CustomHudElement_Modify.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.element_id != null && message.hasOwnProperty("element_id"))
                if (!$util.isString(message.element_id))
                    return "element_id: string expected";
            if (message.modify_visible != null && message.hasOwnProperty("modify_visible"))
                if (typeof message.modify_visible !== "boolean")
                    return "modify_visible: boolean expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_CustomHudElement_Modify message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_CustomHudElement_Modify
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_CustomHudElement_Modify} CDOTAUserMsg_CustomHudElement_Modify
         */
        CDOTAUserMsg_CustomHudElement_Modify.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_CustomHudElement_Modify)
                return object;
            var message = new $root.CDOTAUserMsg_CustomHudElement_Modify();
            if (object.element_id != null)
                message.element_id = String(object.element_id);
            if (object.modify_visible != null)
                message.modify_visible = Boolean(object.modify_visible);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_CustomHudElement_Modify message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_CustomHudElement_Modify
         * @static
         * @param {CDOTAUserMsg_CustomHudElement_Modify} message CDOTAUserMsg_CustomHudElement_Modify
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_CustomHudElement_Modify.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.element_id = "";
                object.modify_visible = false;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.element_id != null && message.hasOwnProperty("element_id"))
                object.element_id = message.element_id;
            if (message.modify_visible != null && message.hasOwnProperty("modify_visible"))
                object.modify_visible = message.modify_visible;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_CustomHudElement_Modify to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_CustomHudElement_Modify
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_CustomHudElement_Modify.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_CustomHudElement_Modify;
    })();
    
    $root.CDOTAUserMsg_CustomHudElement_Destroy = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_CustomHudElement_Destroy.
         * @exports ICDOTAUserMsg_CustomHudElement_Destroy
         * @interface ICDOTAUserMsg_CustomHudElement_Destroy
         * @property {string|null} [element_id] CDOTAUserMsg_CustomHudElement_Destroy element_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_CustomHudElement_Destroy.
         * @exports CDOTAUserMsg_CustomHudElement_Destroy
         * @classdesc Represents a CDOTAUserMsg_CustomHudElement_Destroy.
         * @implements ICDOTAUserMsg_CustomHudElement_Destroy
         * @constructor
         * @param {ICDOTAUserMsg_CustomHudElement_Destroy=} [properties] Properties to set
         */
        function CDOTAUserMsg_CustomHudElement_Destroy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_CustomHudElement_Destroy element_id.
         * @member {string} element_id
         * @memberof CDOTAUserMsg_CustomHudElement_Destroy
         * @instance
         */
        CDOTAUserMsg_CustomHudElement_Destroy.prototype.element_id = "";
    
        /**
         * Creates a new CDOTAUserMsg_CustomHudElement_Destroy instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_CustomHudElement_Destroy
         * @static
         * @param {ICDOTAUserMsg_CustomHudElement_Destroy=} [properties] Properties to set
         * @returns {CDOTAUserMsg_CustomHudElement_Destroy} CDOTAUserMsg_CustomHudElement_Destroy instance
         */
        CDOTAUserMsg_CustomHudElement_Destroy.create = function create(properties) {
            return new CDOTAUserMsg_CustomHudElement_Destroy(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CustomHudElement_Destroy message. Does not implicitly {@link CDOTAUserMsg_CustomHudElement_Destroy.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_CustomHudElement_Destroy
         * @static
         * @param {ICDOTAUserMsg_CustomHudElement_Destroy} message CDOTAUserMsg_CustomHudElement_Destroy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CustomHudElement_Destroy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.element_id != null && Object.hasOwnProperty.call(message, "element_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.element_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CustomHudElement_Destroy message, length delimited. Does not implicitly {@link CDOTAUserMsg_CustomHudElement_Destroy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_CustomHudElement_Destroy
         * @static
         * @param {ICDOTAUserMsg_CustomHudElement_Destroy} message CDOTAUserMsg_CustomHudElement_Destroy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CustomHudElement_Destroy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_CustomHudElement_Destroy message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_CustomHudElement_Destroy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_CustomHudElement_Destroy} CDOTAUserMsg_CustomHudElement_Destroy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CustomHudElement_Destroy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_CustomHudElement_Destroy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.element_id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_CustomHudElement_Destroy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_CustomHudElement_Destroy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_CustomHudElement_Destroy} CDOTAUserMsg_CustomHudElement_Destroy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CustomHudElement_Destroy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_CustomHudElement_Destroy message.
         * @function verify
         * @memberof CDOTAUserMsg_CustomHudElement_Destroy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_CustomHudElement_Destroy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.element_id != null && message.hasOwnProperty("element_id"))
                if (!$util.isString(message.element_id))
                    return "element_id: string expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_CustomHudElement_Destroy message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_CustomHudElement_Destroy
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_CustomHudElement_Destroy} CDOTAUserMsg_CustomHudElement_Destroy
         */
        CDOTAUserMsg_CustomHudElement_Destroy.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_CustomHudElement_Destroy)
                return object;
            var message = new $root.CDOTAUserMsg_CustomHudElement_Destroy();
            if (object.element_id != null)
                message.element_id = String(object.element_id);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_CustomHudElement_Destroy message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_CustomHudElement_Destroy
         * @static
         * @param {CDOTAUserMsg_CustomHudElement_Destroy} message CDOTAUserMsg_CustomHudElement_Destroy
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_CustomHudElement_Destroy.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.element_id = "";
            if (message.element_id != null && message.hasOwnProperty("element_id"))
                object.element_id = message.element_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_CustomHudElement_Destroy to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_CustomHudElement_Destroy
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_CustomHudElement_Destroy.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_CustomHudElement_Destroy;
    })();
    
    $root.CDOTAUserMsg_CompendiumStatePlayer = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_CompendiumStatePlayer.
         * @exports ICDOTAUserMsg_CompendiumStatePlayer
         * @interface ICDOTAUserMsg_CompendiumStatePlayer
         * @property {number|null} [player_id] CDOTAUserMsg_CompendiumStatePlayer player_id
         * @property {number|null} [level] CDOTAUserMsg_CompendiumStatePlayer level
         */
    
        /**
         * Constructs a new CDOTAUserMsg_CompendiumStatePlayer.
         * @exports CDOTAUserMsg_CompendiumStatePlayer
         * @classdesc Represents a CDOTAUserMsg_CompendiumStatePlayer.
         * @implements ICDOTAUserMsg_CompendiumStatePlayer
         * @constructor
         * @param {ICDOTAUserMsg_CompendiumStatePlayer=} [properties] Properties to set
         */
        function CDOTAUserMsg_CompendiumStatePlayer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_CompendiumStatePlayer player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_CompendiumStatePlayer
         * @instance
         */
        CDOTAUserMsg_CompendiumStatePlayer.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_CompendiumStatePlayer level.
         * @member {number} level
         * @memberof CDOTAUserMsg_CompendiumStatePlayer
         * @instance
         */
        CDOTAUserMsg_CompendiumStatePlayer.prototype.level = 0;
    
        /**
         * Creates a new CDOTAUserMsg_CompendiumStatePlayer instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_CompendiumStatePlayer
         * @static
         * @param {ICDOTAUserMsg_CompendiumStatePlayer=} [properties] Properties to set
         * @returns {CDOTAUserMsg_CompendiumStatePlayer} CDOTAUserMsg_CompendiumStatePlayer instance
         */
        CDOTAUserMsg_CompendiumStatePlayer.create = function create(properties) {
            return new CDOTAUserMsg_CompendiumStatePlayer(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CompendiumStatePlayer message. Does not implicitly {@link CDOTAUserMsg_CompendiumStatePlayer.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_CompendiumStatePlayer
         * @static
         * @param {ICDOTAUserMsg_CompendiumStatePlayer} message CDOTAUserMsg_CompendiumStatePlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CompendiumStatePlayer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.level);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CompendiumStatePlayer message, length delimited. Does not implicitly {@link CDOTAUserMsg_CompendiumStatePlayer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_CompendiumStatePlayer
         * @static
         * @param {ICDOTAUserMsg_CompendiumStatePlayer} message CDOTAUserMsg_CompendiumStatePlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CompendiumStatePlayer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_CompendiumStatePlayer message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_CompendiumStatePlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_CompendiumStatePlayer} CDOTAUserMsg_CompendiumStatePlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CompendiumStatePlayer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_CompendiumStatePlayer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.level = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_CompendiumStatePlayer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_CompendiumStatePlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_CompendiumStatePlayer} CDOTAUserMsg_CompendiumStatePlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CompendiumStatePlayer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_CompendiumStatePlayer message.
         * @function verify
         * @memberof CDOTAUserMsg_CompendiumStatePlayer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_CompendiumStatePlayer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level))
                    return "level: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_CompendiumStatePlayer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_CompendiumStatePlayer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_CompendiumStatePlayer} CDOTAUserMsg_CompendiumStatePlayer
         */
        CDOTAUserMsg_CompendiumStatePlayer.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_CompendiumStatePlayer)
                return object;
            var message = new $root.CDOTAUserMsg_CompendiumStatePlayer();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.level != null)
                message.level = object.level >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_CompendiumStatePlayer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_CompendiumStatePlayer
         * @static
         * @param {CDOTAUserMsg_CompendiumStatePlayer} message CDOTAUserMsg_CompendiumStatePlayer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_CompendiumStatePlayer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.level = 0;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.level != null && message.hasOwnProperty("level"))
                object.level = message.level;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_CompendiumStatePlayer to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_CompendiumStatePlayer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_CompendiumStatePlayer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_CompendiumStatePlayer;
    })();
    
    $root.CDOTAUserMsg_CompendiumState = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_CompendiumState.
         * @exports ICDOTAUserMsg_CompendiumState
         * @interface ICDOTAUserMsg_CompendiumState
         * @property {Array.<ICDOTAUserMsg_CompendiumStatePlayer>|null} [compendium_players] CDOTAUserMsg_CompendiumState compendium_players
         */
    
        /**
         * Constructs a new CDOTAUserMsg_CompendiumState.
         * @exports CDOTAUserMsg_CompendiumState
         * @classdesc Represents a CDOTAUserMsg_CompendiumState.
         * @implements ICDOTAUserMsg_CompendiumState
         * @constructor
         * @param {ICDOTAUserMsg_CompendiumState=} [properties] Properties to set
         */
        function CDOTAUserMsg_CompendiumState(properties) {
            this.compendium_players = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_CompendiumState compendium_players.
         * @member {Array.<ICDOTAUserMsg_CompendiumStatePlayer>} compendium_players
         * @memberof CDOTAUserMsg_CompendiumState
         * @instance
         */
        CDOTAUserMsg_CompendiumState.prototype.compendium_players = $util.emptyArray;
    
        /**
         * Creates a new CDOTAUserMsg_CompendiumState instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_CompendiumState
         * @static
         * @param {ICDOTAUserMsg_CompendiumState=} [properties] Properties to set
         * @returns {CDOTAUserMsg_CompendiumState} CDOTAUserMsg_CompendiumState instance
         */
        CDOTAUserMsg_CompendiumState.create = function create(properties) {
            return new CDOTAUserMsg_CompendiumState(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CompendiumState message. Does not implicitly {@link CDOTAUserMsg_CompendiumState.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_CompendiumState
         * @static
         * @param {ICDOTAUserMsg_CompendiumState} message CDOTAUserMsg_CompendiumState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CompendiumState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.compendium_players != null && message.compendium_players.length)
                for (var i = 0; i < message.compendium_players.length; ++i)
                    $root.CDOTAUserMsg_CompendiumStatePlayer.encode(message.compendium_players[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_CompendiumState message, length delimited. Does not implicitly {@link CDOTAUserMsg_CompendiumState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_CompendiumState
         * @static
         * @param {ICDOTAUserMsg_CompendiumState} message CDOTAUserMsg_CompendiumState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_CompendiumState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_CompendiumState message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_CompendiumState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_CompendiumState} CDOTAUserMsg_CompendiumState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CompendiumState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_CompendiumState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.compendium_players && message.compendium_players.length))
                        message.compendium_players = [];
                    message.compendium_players.push($root.CDOTAUserMsg_CompendiumStatePlayer.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_CompendiumState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_CompendiumState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_CompendiumState} CDOTAUserMsg_CompendiumState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_CompendiumState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_CompendiumState message.
         * @function verify
         * @memberof CDOTAUserMsg_CompendiumState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_CompendiumState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.compendium_players != null && message.hasOwnProperty("compendium_players")) {
                if (!Array.isArray(message.compendium_players))
                    return "compendium_players: array expected";
                for (var i = 0; i < message.compendium_players.length; ++i) {
                    var error = $root.CDOTAUserMsg_CompendiumStatePlayer.verify(message.compendium_players[i]);
                    if (error)
                        return "compendium_players." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_CompendiumState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_CompendiumState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_CompendiumState} CDOTAUserMsg_CompendiumState
         */
        CDOTAUserMsg_CompendiumState.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_CompendiumState)
                return object;
            var message = new $root.CDOTAUserMsg_CompendiumState();
            if (object.compendium_players) {
                if (!Array.isArray(object.compendium_players))
                    throw TypeError(".CDOTAUserMsg_CompendiumState.compendium_players: array expected");
                message.compendium_players = [];
                for (var i = 0; i < object.compendium_players.length; ++i) {
                    if (typeof object.compendium_players[i] !== "object")
                        throw TypeError(".CDOTAUserMsg_CompendiumState.compendium_players: object expected");
                    message.compendium_players[i] = $root.CDOTAUserMsg_CompendiumStatePlayer.fromObject(object.compendium_players[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_CompendiumState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_CompendiumState
         * @static
         * @param {CDOTAUserMsg_CompendiumState} message CDOTAUserMsg_CompendiumState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_CompendiumState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.compendium_players = [];
            if (message.compendium_players && message.compendium_players.length) {
                object.compendium_players = [];
                for (var j = 0; j < message.compendium_players.length; ++j)
                    object.compendium_players[j] = $root.CDOTAUserMsg_CompendiumStatePlayer.toObject(message.compendium_players[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_CompendiumState to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_CompendiumState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_CompendiumState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_CompendiumState;
    })();
    
    $root.CDOTAUserMsg_ProjectionAbility = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_ProjectionAbility.
         * @exports ICDOTAUserMsg_ProjectionAbility
         * @interface ICDOTAUserMsg_ProjectionAbility
         * @property {number|null} [ability_id] CDOTAUserMsg_ProjectionAbility ability_id
         * @property {number|null} [caster_ent_index] CDOTAUserMsg_ProjectionAbility caster_ent_index
         * @property {number|null} [caster_team] CDOTAUserMsg_ProjectionAbility caster_team
         * @property {boolean|null} [channel_end] CDOTAUserMsg_ProjectionAbility channel_end
         * @property {ICMsgVector|null} [origin] CDOTAUserMsg_ProjectionAbility origin
         * @property {boolean|null} [track_caster_only] CDOTAUserMsg_ProjectionAbility track_caster_only
         * @property {number|null} [end_time] CDOTAUserMsg_ProjectionAbility end_time
         * @property {number|null} [victim_ent_index] CDOTAUserMsg_ProjectionAbility victim_ent_index
         */
    
        /**
         * Constructs a new CDOTAUserMsg_ProjectionAbility.
         * @exports CDOTAUserMsg_ProjectionAbility
         * @classdesc Represents a CDOTAUserMsg_ProjectionAbility.
         * @implements ICDOTAUserMsg_ProjectionAbility
         * @constructor
         * @param {ICDOTAUserMsg_ProjectionAbility=} [properties] Properties to set
         */
        function CDOTAUserMsg_ProjectionAbility(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_ProjectionAbility ability_id.
         * @member {number} ability_id
         * @memberof CDOTAUserMsg_ProjectionAbility
         * @instance
         */
        CDOTAUserMsg_ProjectionAbility.prototype.ability_id = 0;
    
        /**
         * CDOTAUserMsg_ProjectionAbility caster_ent_index.
         * @member {number} caster_ent_index
         * @memberof CDOTAUserMsg_ProjectionAbility
         * @instance
         */
        CDOTAUserMsg_ProjectionAbility.prototype.caster_ent_index = 0;
    
        /**
         * CDOTAUserMsg_ProjectionAbility caster_team.
         * @member {number} caster_team
         * @memberof CDOTAUserMsg_ProjectionAbility
         * @instance
         */
        CDOTAUserMsg_ProjectionAbility.prototype.caster_team = 0;
    
        /**
         * CDOTAUserMsg_ProjectionAbility channel_end.
         * @member {boolean} channel_end
         * @memberof CDOTAUserMsg_ProjectionAbility
         * @instance
         */
        CDOTAUserMsg_ProjectionAbility.prototype.channel_end = false;
    
        /**
         * CDOTAUserMsg_ProjectionAbility origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CDOTAUserMsg_ProjectionAbility
         * @instance
         */
        CDOTAUserMsg_ProjectionAbility.prototype.origin = null;
    
        /**
         * CDOTAUserMsg_ProjectionAbility track_caster_only.
         * @member {boolean} track_caster_only
         * @memberof CDOTAUserMsg_ProjectionAbility
         * @instance
         */
        CDOTAUserMsg_ProjectionAbility.prototype.track_caster_only = false;
    
        /**
         * CDOTAUserMsg_ProjectionAbility end_time.
         * @member {number} end_time
         * @memberof CDOTAUserMsg_ProjectionAbility
         * @instance
         */
        CDOTAUserMsg_ProjectionAbility.prototype.end_time = 0;
    
        /**
         * CDOTAUserMsg_ProjectionAbility victim_ent_index.
         * @member {number} victim_ent_index
         * @memberof CDOTAUserMsg_ProjectionAbility
         * @instance
         */
        CDOTAUserMsg_ProjectionAbility.prototype.victim_ent_index = 0;
    
        /**
         * Creates a new CDOTAUserMsg_ProjectionAbility instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_ProjectionAbility
         * @static
         * @param {ICDOTAUserMsg_ProjectionAbility=} [properties] Properties to set
         * @returns {CDOTAUserMsg_ProjectionAbility} CDOTAUserMsg_ProjectionAbility instance
         */
        CDOTAUserMsg_ProjectionAbility.create = function create(properties) {
            return new CDOTAUserMsg_ProjectionAbility(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ProjectionAbility message. Does not implicitly {@link CDOTAUserMsg_ProjectionAbility.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_ProjectionAbility
         * @static
         * @param {ICDOTAUserMsg_ProjectionAbility} message CDOTAUserMsg_ProjectionAbility message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ProjectionAbility.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ability_id != null && Object.hasOwnProperty.call(message, "ability_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ability_id);
            if (message.caster_ent_index != null && Object.hasOwnProperty.call(message, "caster_ent_index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.caster_ent_index);
            if (message.caster_team != null && Object.hasOwnProperty.call(message, "caster_team"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.caster_team);
            if (message.channel_end != null && Object.hasOwnProperty.call(message, "channel_end"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.channel_end);
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.track_caster_only != null && Object.hasOwnProperty.call(message, "track_caster_only"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.track_caster_only);
            if (message.end_time != null && Object.hasOwnProperty.call(message, "end_time"))
                writer.uint32(/* id 7, wireType 5 =*/61).float(message.end_time);
            if (message.victim_ent_index != null && Object.hasOwnProperty.call(message, "victim_ent_index"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.victim_ent_index);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ProjectionAbility message, length delimited. Does not implicitly {@link CDOTAUserMsg_ProjectionAbility.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_ProjectionAbility
         * @static
         * @param {ICDOTAUserMsg_ProjectionAbility} message CDOTAUserMsg_ProjectionAbility message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ProjectionAbility.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_ProjectionAbility message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_ProjectionAbility
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_ProjectionAbility} CDOTAUserMsg_ProjectionAbility
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ProjectionAbility.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_ProjectionAbility();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ability_id = reader.uint32();
                    break;
                case 2:
                    message.caster_ent_index = reader.int32();
                    break;
                case 3:
                    message.caster_team = reader.int32();
                    break;
                case 4:
                    message.channel_end = reader.bool();
                    break;
                case 5:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.track_caster_only = reader.bool();
                    break;
                case 7:
                    message.end_time = reader.float();
                    break;
                case 8:
                    message.victim_ent_index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_ProjectionAbility message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_ProjectionAbility
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_ProjectionAbility} CDOTAUserMsg_ProjectionAbility
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ProjectionAbility.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_ProjectionAbility message.
         * @function verify
         * @memberof CDOTAUserMsg_ProjectionAbility
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_ProjectionAbility.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ability_id != null && message.hasOwnProperty("ability_id"))
                if (!$util.isInteger(message.ability_id))
                    return "ability_id: integer expected";
            if (message.caster_ent_index != null && message.hasOwnProperty("caster_ent_index"))
                if (!$util.isInteger(message.caster_ent_index))
                    return "caster_ent_index: integer expected";
            if (message.caster_team != null && message.hasOwnProperty("caster_team"))
                if (!$util.isInteger(message.caster_team))
                    return "caster_team: integer expected";
            if (message.channel_end != null && message.hasOwnProperty("channel_end"))
                if (typeof message.channel_end !== "boolean")
                    return "channel_end: boolean expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.track_caster_only != null && message.hasOwnProperty("track_caster_only"))
                if (typeof message.track_caster_only !== "boolean")
                    return "track_caster_only: boolean expected";
            if (message.end_time != null && message.hasOwnProperty("end_time"))
                if (typeof message.end_time !== "number")
                    return "end_time: number expected";
            if (message.victim_ent_index != null && message.hasOwnProperty("victim_ent_index"))
                if (!$util.isInteger(message.victim_ent_index))
                    return "victim_ent_index: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_ProjectionAbility message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_ProjectionAbility
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_ProjectionAbility} CDOTAUserMsg_ProjectionAbility
         */
        CDOTAUserMsg_ProjectionAbility.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_ProjectionAbility)
                return object;
            var message = new $root.CDOTAUserMsg_ProjectionAbility();
            if (object.ability_id != null)
                message.ability_id = object.ability_id >>> 0;
            if (object.caster_ent_index != null)
                message.caster_ent_index = object.caster_ent_index | 0;
            if (object.caster_team != null)
                message.caster_team = object.caster_team | 0;
            if (object.channel_end != null)
                message.channel_end = Boolean(object.channel_end);
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CDOTAUserMsg_ProjectionAbility.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.track_caster_only != null)
                message.track_caster_only = Boolean(object.track_caster_only);
            if (object.end_time != null)
                message.end_time = Number(object.end_time);
            if (object.victim_ent_index != null)
                message.victim_ent_index = object.victim_ent_index | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_ProjectionAbility message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_ProjectionAbility
         * @static
         * @param {CDOTAUserMsg_ProjectionAbility} message CDOTAUserMsg_ProjectionAbility
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_ProjectionAbility.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ability_id = 0;
                object.caster_ent_index = 0;
                object.caster_team = 0;
                object.channel_end = false;
                object.origin = null;
                object.track_caster_only = false;
                object.end_time = 0;
                object.victim_ent_index = 0;
            }
            if (message.ability_id != null && message.hasOwnProperty("ability_id"))
                object.ability_id = message.ability_id;
            if (message.caster_ent_index != null && message.hasOwnProperty("caster_ent_index"))
                object.caster_ent_index = message.caster_ent_index;
            if (message.caster_team != null && message.hasOwnProperty("caster_team"))
                object.caster_team = message.caster_team;
            if (message.channel_end != null && message.hasOwnProperty("channel_end"))
                object.channel_end = message.channel_end;
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.track_caster_only != null && message.hasOwnProperty("track_caster_only"))
                object.track_caster_only = message.track_caster_only;
            if (message.end_time != null && message.hasOwnProperty("end_time"))
                object.end_time = options.json && !isFinite(message.end_time) ? String(message.end_time) : message.end_time;
            if (message.victim_ent_index != null && message.hasOwnProperty("victim_ent_index"))
                object.victim_ent_index = message.victim_ent_index;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_ProjectionAbility to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_ProjectionAbility
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_ProjectionAbility.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_ProjectionAbility;
    })();
    
    $root.CDOTAUserMsg_ProjectionEvent = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_ProjectionEvent.
         * @exports ICDOTAUserMsg_ProjectionEvent
         * @interface ICDOTAUserMsg_ProjectionEvent
         * @property {EProjectionEvent|null} [event_id] CDOTAUserMsg_ProjectionEvent event_id
         * @property {number|null} [team] CDOTAUserMsg_ProjectionEvent team
         */
    
        /**
         * Constructs a new CDOTAUserMsg_ProjectionEvent.
         * @exports CDOTAUserMsg_ProjectionEvent
         * @classdesc Represents a CDOTAUserMsg_ProjectionEvent.
         * @implements ICDOTAUserMsg_ProjectionEvent
         * @constructor
         * @param {ICDOTAUserMsg_ProjectionEvent=} [properties] Properties to set
         */
        function CDOTAUserMsg_ProjectionEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_ProjectionEvent event_id.
         * @member {EProjectionEvent} event_id
         * @memberof CDOTAUserMsg_ProjectionEvent
         * @instance
         */
        CDOTAUserMsg_ProjectionEvent.prototype.event_id = 0;
    
        /**
         * CDOTAUserMsg_ProjectionEvent team.
         * @member {number} team
         * @memberof CDOTAUserMsg_ProjectionEvent
         * @instance
         */
        CDOTAUserMsg_ProjectionEvent.prototype.team = 0;
    
        /**
         * Creates a new CDOTAUserMsg_ProjectionEvent instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_ProjectionEvent
         * @static
         * @param {ICDOTAUserMsg_ProjectionEvent=} [properties] Properties to set
         * @returns {CDOTAUserMsg_ProjectionEvent} CDOTAUserMsg_ProjectionEvent instance
         */
        CDOTAUserMsg_ProjectionEvent.create = function create(properties) {
            return new CDOTAUserMsg_ProjectionEvent(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ProjectionEvent message. Does not implicitly {@link CDOTAUserMsg_ProjectionEvent.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_ProjectionEvent
         * @static
         * @param {ICDOTAUserMsg_ProjectionEvent} message CDOTAUserMsg_ProjectionEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ProjectionEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event_id != null && Object.hasOwnProperty.call(message, "event_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.event_id);
            if (message.team != null && Object.hasOwnProperty.call(message, "team"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.team);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ProjectionEvent message, length delimited. Does not implicitly {@link CDOTAUserMsg_ProjectionEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_ProjectionEvent
         * @static
         * @param {ICDOTAUserMsg_ProjectionEvent} message CDOTAUserMsg_ProjectionEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ProjectionEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_ProjectionEvent message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_ProjectionEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_ProjectionEvent} CDOTAUserMsg_ProjectionEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ProjectionEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_ProjectionEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.event_id = reader.int32();
                    break;
                case 2:
                    message.team = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_ProjectionEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_ProjectionEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_ProjectionEvent} CDOTAUserMsg_ProjectionEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ProjectionEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_ProjectionEvent message.
         * @function verify
         * @memberof CDOTAUserMsg_ProjectionEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_ProjectionEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                switch (message.event_id) {
                default:
                    return "event_id: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.team != null && message.hasOwnProperty("team"))
                if (!$util.isInteger(message.team))
                    return "team: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_ProjectionEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_ProjectionEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_ProjectionEvent} CDOTAUserMsg_ProjectionEvent
         */
        CDOTAUserMsg_ProjectionEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_ProjectionEvent)
                return object;
            var message = new $root.CDOTAUserMsg_ProjectionEvent();
            switch (object.event_id) {
            case "ePE_FirstBlood":
            case 0:
                message.event_id = 0;
                break;
            case "ePE_Killstreak_godlike":
            case 1:
                message.event_id = 1;
                break;
            }
            if (object.team != null)
                message.team = object.team >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_ProjectionEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_ProjectionEvent
         * @static
         * @param {CDOTAUserMsg_ProjectionEvent} message CDOTAUserMsg_ProjectionEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_ProjectionEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.event_id = options.enums === String ? "ePE_FirstBlood" : 0;
                object.team = 0;
            }
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                object.event_id = options.enums === String ? $root.EProjectionEvent[message.event_id] : message.event_id;
            if (message.team != null && message.hasOwnProperty("team"))
                object.team = message.team;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_ProjectionEvent to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_ProjectionEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_ProjectionEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_ProjectionEvent;
    })();
    
    $root.CDOTAUserMsg_XPAlert = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_XPAlert.
         * @exports ICDOTAUserMsg_XPAlert
         * @interface ICDOTAUserMsg_XPAlert
         * @property {number|null} [player_id] CDOTAUserMsg_XPAlert player_id
         * @property {number|null} [target_entindex] CDOTAUserMsg_XPAlert target_entindex
         */
    
        /**
         * Constructs a new CDOTAUserMsg_XPAlert.
         * @exports CDOTAUserMsg_XPAlert
         * @classdesc Represents a CDOTAUserMsg_XPAlert.
         * @implements ICDOTAUserMsg_XPAlert
         * @constructor
         * @param {ICDOTAUserMsg_XPAlert=} [properties] Properties to set
         */
        function CDOTAUserMsg_XPAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_XPAlert player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_XPAlert
         * @instance
         */
        CDOTAUserMsg_XPAlert.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_XPAlert target_entindex.
         * @member {number} target_entindex
         * @memberof CDOTAUserMsg_XPAlert
         * @instance
         */
        CDOTAUserMsg_XPAlert.prototype.target_entindex = 0;
    
        /**
         * Creates a new CDOTAUserMsg_XPAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_XPAlert
         * @static
         * @param {ICDOTAUserMsg_XPAlert=} [properties] Properties to set
         * @returns {CDOTAUserMsg_XPAlert} CDOTAUserMsg_XPAlert instance
         */
        CDOTAUserMsg_XPAlert.create = function create(properties) {
            return new CDOTAUserMsg_XPAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_XPAlert message. Does not implicitly {@link CDOTAUserMsg_XPAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_XPAlert
         * @static
         * @param {ICDOTAUserMsg_XPAlert} message CDOTAUserMsg_XPAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_XPAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.target_entindex != null && Object.hasOwnProperty.call(message, "target_entindex"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.target_entindex);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_XPAlert message, length delimited. Does not implicitly {@link CDOTAUserMsg_XPAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_XPAlert
         * @static
         * @param {ICDOTAUserMsg_XPAlert} message CDOTAUserMsg_XPAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_XPAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_XPAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_XPAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_XPAlert} CDOTAUserMsg_XPAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_XPAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_XPAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.target_entindex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_XPAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_XPAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_XPAlert} CDOTAUserMsg_XPAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_XPAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_XPAlert message.
         * @function verify
         * @memberof CDOTAUserMsg_XPAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_XPAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                if (!$util.isInteger(message.target_entindex))
                    return "target_entindex: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_XPAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_XPAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_XPAlert} CDOTAUserMsg_XPAlert
         */
        CDOTAUserMsg_XPAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_XPAlert)
                return object;
            var message = new $root.CDOTAUserMsg_XPAlert();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.target_entindex != null)
                message.target_entindex = object.target_entindex >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_XPAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_XPAlert
         * @static
         * @param {CDOTAUserMsg_XPAlert} message CDOTAUserMsg_XPAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_XPAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.target_entindex = 0;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                object.target_entindex = message.target_entindex;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_XPAlert to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_XPAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_XPAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_XPAlert;
    })();
    
    $root.CDOTAUserMsg_TalentTreeAlert = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_TalentTreeAlert.
         * @exports ICDOTAUserMsg_TalentTreeAlert
         * @interface ICDOTAUserMsg_TalentTreeAlert
         * @property {number|null} [player_id] CDOTAUserMsg_TalentTreeAlert player_id
         * @property {number|null} [target_entindex] CDOTAUserMsg_TalentTreeAlert target_entindex
         * @property {number|null} [ability_id] CDOTAUserMsg_TalentTreeAlert ability_id
         * @property {number|null} [slot] CDOTAUserMsg_TalentTreeAlert slot
         * @property {boolean|null} [learned] CDOTAUserMsg_TalentTreeAlert learned
         */
    
        /**
         * Constructs a new CDOTAUserMsg_TalentTreeAlert.
         * @exports CDOTAUserMsg_TalentTreeAlert
         * @classdesc Represents a CDOTAUserMsg_TalentTreeAlert.
         * @implements ICDOTAUserMsg_TalentTreeAlert
         * @constructor
         * @param {ICDOTAUserMsg_TalentTreeAlert=} [properties] Properties to set
         */
        function CDOTAUserMsg_TalentTreeAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_TalentTreeAlert player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_TalentTreeAlert
         * @instance
         */
        CDOTAUserMsg_TalentTreeAlert.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_TalentTreeAlert target_entindex.
         * @member {number} target_entindex
         * @memberof CDOTAUserMsg_TalentTreeAlert
         * @instance
         */
        CDOTAUserMsg_TalentTreeAlert.prototype.target_entindex = 0;
    
        /**
         * CDOTAUserMsg_TalentTreeAlert ability_id.
         * @member {number} ability_id
         * @memberof CDOTAUserMsg_TalentTreeAlert
         * @instance
         */
        CDOTAUserMsg_TalentTreeAlert.prototype.ability_id = 0;
    
        /**
         * CDOTAUserMsg_TalentTreeAlert slot.
         * @member {number} slot
         * @memberof CDOTAUserMsg_TalentTreeAlert
         * @instance
         */
        CDOTAUserMsg_TalentTreeAlert.prototype.slot = 0;
    
        /**
         * CDOTAUserMsg_TalentTreeAlert learned.
         * @member {boolean} learned
         * @memberof CDOTAUserMsg_TalentTreeAlert
         * @instance
         */
        CDOTAUserMsg_TalentTreeAlert.prototype.learned = false;
    
        /**
         * Creates a new CDOTAUserMsg_TalentTreeAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_TalentTreeAlert
         * @static
         * @param {ICDOTAUserMsg_TalentTreeAlert=} [properties] Properties to set
         * @returns {CDOTAUserMsg_TalentTreeAlert} CDOTAUserMsg_TalentTreeAlert instance
         */
        CDOTAUserMsg_TalentTreeAlert.create = function create(properties) {
            return new CDOTAUserMsg_TalentTreeAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TalentTreeAlert message. Does not implicitly {@link CDOTAUserMsg_TalentTreeAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_TalentTreeAlert
         * @static
         * @param {ICDOTAUserMsg_TalentTreeAlert} message CDOTAUserMsg_TalentTreeAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TalentTreeAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.target_entindex != null && Object.hasOwnProperty.call(message, "target_entindex"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.target_entindex);
            if (message.ability_id != null && Object.hasOwnProperty.call(message, "ability_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.ability_id);
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.slot);
            if (message.learned != null && Object.hasOwnProperty.call(message, "learned"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.learned);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TalentTreeAlert message, length delimited. Does not implicitly {@link CDOTAUserMsg_TalentTreeAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_TalentTreeAlert
         * @static
         * @param {ICDOTAUserMsg_TalentTreeAlert} message CDOTAUserMsg_TalentTreeAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TalentTreeAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_TalentTreeAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_TalentTreeAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_TalentTreeAlert} CDOTAUserMsg_TalentTreeAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TalentTreeAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_TalentTreeAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.target_entindex = reader.uint32();
                    break;
                case 3:
                    message.ability_id = reader.int32();
                    break;
                case 4:
                    message.slot = reader.int32();
                    break;
                case 5:
                    message.learned = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_TalentTreeAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_TalentTreeAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_TalentTreeAlert} CDOTAUserMsg_TalentTreeAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TalentTreeAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_TalentTreeAlert message.
         * @function verify
         * @memberof CDOTAUserMsg_TalentTreeAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_TalentTreeAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                if (!$util.isInteger(message.target_entindex))
                    return "target_entindex: integer expected";
            if (message.ability_id != null && message.hasOwnProperty("ability_id"))
                if (!$util.isInteger(message.ability_id))
                    return "ability_id: integer expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot))
                    return "slot: integer expected";
            if (message.learned != null && message.hasOwnProperty("learned"))
                if (typeof message.learned !== "boolean")
                    return "learned: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_TalentTreeAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_TalentTreeAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_TalentTreeAlert} CDOTAUserMsg_TalentTreeAlert
         */
        CDOTAUserMsg_TalentTreeAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_TalentTreeAlert)
                return object;
            var message = new $root.CDOTAUserMsg_TalentTreeAlert();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.target_entindex != null)
                message.target_entindex = object.target_entindex >>> 0;
            if (object.ability_id != null)
                message.ability_id = object.ability_id | 0;
            if (object.slot != null)
                message.slot = object.slot | 0;
            if (object.learned != null)
                message.learned = Boolean(object.learned);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_TalentTreeAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_TalentTreeAlert
         * @static
         * @param {CDOTAUserMsg_TalentTreeAlert} message CDOTAUserMsg_TalentTreeAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_TalentTreeAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.target_entindex = 0;
                object.ability_id = 0;
                object.slot = 0;
                object.learned = false;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                object.target_entindex = message.target_entindex;
            if (message.ability_id != null && message.hasOwnProperty("ability_id"))
                object.ability_id = message.ability_id;
            if (message.slot != null && message.hasOwnProperty("slot"))
                object.slot = message.slot;
            if (message.learned != null && message.hasOwnProperty("learned"))
                object.learned = message.learned;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_TalentTreeAlert to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_TalentTreeAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_TalentTreeAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_TalentTreeAlert;
    })();
    
    $root.CDOTAUserMsg_UpdateQuestProgress = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_UpdateQuestProgress.
         * @exports ICDOTAUserMsg_UpdateQuestProgress
         * @interface ICDOTAUserMsg_UpdateQuestProgress
         */
    
        /**
         * Constructs a new CDOTAUserMsg_UpdateQuestProgress.
         * @exports CDOTAUserMsg_UpdateQuestProgress
         * @classdesc Represents a CDOTAUserMsg_UpdateQuestProgress.
         * @implements ICDOTAUserMsg_UpdateQuestProgress
         * @constructor
         * @param {ICDOTAUserMsg_UpdateQuestProgress=} [properties] Properties to set
         */
        function CDOTAUserMsg_UpdateQuestProgress(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CDOTAUserMsg_UpdateQuestProgress instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_UpdateQuestProgress
         * @static
         * @param {ICDOTAUserMsg_UpdateQuestProgress=} [properties] Properties to set
         * @returns {CDOTAUserMsg_UpdateQuestProgress} CDOTAUserMsg_UpdateQuestProgress instance
         */
        CDOTAUserMsg_UpdateQuestProgress.create = function create(properties) {
            return new CDOTAUserMsg_UpdateQuestProgress(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_UpdateQuestProgress message. Does not implicitly {@link CDOTAUserMsg_UpdateQuestProgress.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_UpdateQuestProgress
         * @static
         * @param {ICDOTAUserMsg_UpdateQuestProgress} message CDOTAUserMsg_UpdateQuestProgress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_UpdateQuestProgress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_UpdateQuestProgress message, length delimited. Does not implicitly {@link CDOTAUserMsg_UpdateQuestProgress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_UpdateQuestProgress
         * @static
         * @param {ICDOTAUserMsg_UpdateQuestProgress} message CDOTAUserMsg_UpdateQuestProgress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_UpdateQuestProgress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_UpdateQuestProgress message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_UpdateQuestProgress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_UpdateQuestProgress} CDOTAUserMsg_UpdateQuestProgress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_UpdateQuestProgress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_UpdateQuestProgress();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_UpdateQuestProgress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_UpdateQuestProgress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_UpdateQuestProgress} CDOTAUserMsg_UpdateQuestProgress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_UpdateQuestProgress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_UpdateQuestProgress message.
         * @function verify
         * @memberof CDOTAUserMsg_UpdateQuestProgress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_UpdateQuestProgress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_UpdateQuestProgress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_UpdateQuestProgress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_UpdateQuestProgress} CDOTAUserMsg_UpdateQuestProgress
         */
        CDOTAUserMsg_UpdateQuestProgress.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_UpdateQuestProgress)
                return object;
            return new $root.CDOTAUserMsg_UpdateQuestProgress();
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_UpdateQuestProgress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_UpdateQuestProgress
         * @static
         * @param {CDOTAUserMsg_UpdateQuestProgress} message CDOTAUserMsg_UpdateQuestProgress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_UpdateQuestProgress.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CDOTAUserMsg_UpdateQuestProgress to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_UpdateQuestProgress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_UpdateQuestProgress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_UpdateQuestProgress;
    })();
    
    $root.CDOTAUserMsg_QuestStatus = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_QuestStatus.
         * @exports ICDOTAUserMsg_QuestStatus
         * @interface ICDOTAUserMsg_QuestStatus
         * @property {number} player_id CDOTAUserMsg_QuestStatus player_id
         * @property {number|null} [quest_id] CDOTAUserMsg_QuestStatus quest_id
         * @property {number|null} [challenge_id] CDOTAUserMsg_QuestStatus challenge_id
         * @property {number|null} [progress] CDOTAUserMsg_QuestStatus progress
         * @property {number|null} [goal] CDOTAUserMsg_QuestStatus goal
         * @property {number|null} [query] CDOTAUserMsg_QuestStatus query
         * @property {number|null} [fail_gametime] CDOTAUserMsg_QuestStatus fail_gametime
         * @property {number|null} [item_ability_id] CDOTAUserMsg_QuestStatus item_ability_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_QuestStatus.
         * @exports CDOTAUserMsg_QuestStatus
         * @classdesc Represents a CDOTAUserMsg_QuestStatus.
         * @implements ICDOTAUserMsg_QuestStatus
         * @constructor
         * @param {ICDOTAUserMsg_QuestStatus=} [properties] Properties to set
         */
        function CDOTAUserMsg_QuestStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_QuestStatus player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_QuestStatus
         * @instance
         */
        CDOTAUserMsg_QuestStatus.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_QuestStatus quest_id.
         * @member {number} quest_id
         * @memberof CDOTAUserMsg_QuestStatus
         * @instance
         */
        CDOTAUserMsg_QuestStatus.prototype.quest_id = 0;
    
        /**
         * CDOTAUserMsg_QuestStatus challenge_id.
         * @member {number} challenge_id
         * @memberof CDOTAUserMsg_QuestStatus
         * @instance
         */
        CDOTAUserMsg_QuestStatus.prototype.challenge_id = 0;
    
        /**
         * CDOTAUserMsg_QuestStatus progress.
         * @member {number} progress
         * @memberof CDOTAUserMsg_QuestStatus
         * @instance
         */
        CDOTAUserMsg_QuestStatus.prototype.progress = 0;
    
        /**
         * CDOTAUserMsg_QuestStatus goal.
         * @member {number} goal
         * @memberof CDOTAUserMsg_QuestStatus
         * @instance
         */
        CDOTAUserMsg_QuestStatus.prototype.goal = 0;
    
        /**
         * CDOTAUserMsg_QuestStatus query.
         * @member {number} query
         * @memberof CDOTAUserMsg_QuestStatus
         * @instance
         */
        CDOTAUserMsg_QuestStatus.prototype.query = 0;
    
        /**
         * CDOTAUserMsg_QuestStatus fail_gametime.
         * @member {number} fail_gametime
         * @memberof CDOTAUserMsg_QuestStatus
         * @instance
         */
        CDOTAUserMsg_QuestStatus.prototype.fail_gametime = 0;
    
        /**
         * CDOTAUserMsg_QuestStatus item_ability_id.
         * @member {number} item_ability_id
         * @memberof CDOTAUserMsg_QuestStatus
         * @instance
         */
        CDOTAUserMsg_QuestStatus.prototype.item_ability_id = 0;
    
        /**
         * Creates a new CDOTAUserMsg_QuestStatus instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_QuestStatus
         * @static
         * @param {ICDOTAUserMsg_QuestStatus=} [properties] Properties to set
         * @returns {CDOTAUserMsg_QuestStatus} CDOTAUserMsg_QuestStatus instance
         */
        CDOTAUserMsg_QuestStatus.create = function create(properties) {
            return new CDOTAUserMsg_QuestStatus(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_QuestStatus message. Does not implicitly {@link CDOTAUserMsg_QuestStatus.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_QuestStatus
         * @static
         * @param {ICDOTAUserMsg_QuestStatus} message CDOTAUserMsg_QuestStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_QuestStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.quest_id != null && Object.hasOwnProperty.call(message, "quest_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.quest_id);
            if (message.challenge_id != null && Object.hasOwnProperty.call(message, "challenge_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.challenge_id);
            if (message.progress != null && Object.hasOwnProperty.call(message, "progress"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.progress);
            if (message.goal != null && Object.hasOwnProperty.call(message, "goal"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.goal);
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.query);
            if (message.fail_gametime != null && Object.hasOwnProperty.call(message, "fail_gametime"))
                writer.uint32(/* id 7, wireType 5 =*/61).float(message.fail_gametime);
            if (message.item_ability_id != null && Object.hasOwnProperty.call(message, "item_ability_id"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.item_ability_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_QuestStatus message, length delimited. Does not implicitly {@link CDOTAUserMsg_QuestStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_QuestStatus
         * @static
         * @param {ICDOTAUserMsg_QuestStatus} message CDOTAUserMsg_QuestStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_QuestStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_QuestStatus message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_QuestStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_QuestStatus} CDOTAUserMsg_QuestStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_QuestStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_QuestStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.quest_id = reader.uint32();
                    break;
                case 3:
                    message.challenge_id = reader.uint32();
                    break;
                case 4:
                    message.progress = reader.uint32();
                    break;
                case 5:
                    message.goal = reader.uint32();
                    break;
                case 6:
                    message.query = reader.uint32();
                    break;
                case 7:
                    message.fail_gametime = reader.float();
                    break;
                case 8:
                    message.item_ability_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("player_id"))
                throw $util.ProtocolError("missing required 'player_id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_QuestStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_QuestStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_QuestStatus} CDOTAUserMsg_QuestStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_QuestStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_QuestStatus message.
         * @function verify
         * @memberof CDOTAUserMsg_QuestStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_QuestStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.player_id))
                return "player_id: integer expected";
            if (message.quest_id != null && message.hasOwnProperty("quest_id"))
                if (!$util.isInteger(message.quest_id))
                    return "quest_id: integer expected";
            if (message.challenge_id != null && message.hasOwnProperty("challenge_id"))
                if (!$util.isInteger(message.challenge_id))
                    return "challenge_id: integer expected";
            if (message.progress != null && message.hasOwnProperty("progress"))
                if (!$util.isInteger(message.progress))
                    return "progress: integer expected";
            if (message.goal != null && message.hasOwnProperty("goal"))
                if (!$util.isInteger(message.goal))
                    return "goal: integer expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isInteger(message.query))
                    return "query: integer expected";
            if (message.fail_gametime != null && message.hasOwnProperty("fail_gametime"))
                if (typeof message.fail_gametime !== "number")
                    return "fail_gametime: number expected";
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                if (!$util.isInteger(message.item_ability_id))
                    return "item_ability_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_QuestStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_QuestStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_QuestStatus} CDOTAUserMsg_QuestStatus
         */
        CDOTAUserMsg_QuestStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_QuestStatus)
                return object;
            var message = new $root.CDOTAUserMsg_QuestStatus();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.quest_id != null)
                message.quest_id = object.quest_id >>> 0;
            if (object.challenge_id != null)
                message.challenge_id = object.challenge_id >>> 0;
            if (object.progress != null)
                message.progress = object.progress >>> 0;
            if (object.goal != null)
                message.goal = object.goal >>> 0;
            if (object.query != null)
                message.query = object.query >>> 0;
            if (object.fail_gametime != null)
                message.fail_gametime = Number(object.fail_gametime);
            if (object.item_ability_id != null)
                message.item_ability_id = object.item_ability_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_QuestStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_QuestStatus
         * @static
         * @param {CDOTAUserMsg_QuestStatus} message CDOTAUserMsg_QuestStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_QuestStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.quest_id = 0;
                object.challenge_id = 0;
                object.progress = 0;
                object.goal = 0;
                object.query = 0;
                object.fail_gametime = 0;
                object.item_ability_id = 0;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.quest_id != null && message.hasOwnProperty("quest_id"))
                object.quest_id = message.quest_id;
            if (message.challenge_id != null && message.hasOwnProperty("challenge_id"))
                object.challenge_id = message.challenge_id;
            if (message.progress != null && message.hasOwnProperty("progress"))
                object.progress = message.progress;
            if (message.goal != null && message.hasOwnProperty("goal"))
                object.goal = message.goal;
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            if (message.fail_gametime != null && message.hasOwnProperty("fail_gametime"))
                object.fail_gametime = options.json && !isFinite(message.fail_gametime) ? String(message.fail_gametime) : message.fail_gametime;
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                object.item_ability_id = message.item_ability_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_QuestStatus to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_QuestStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_QuestStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_QuestStatus;
    })();
    
    $root.CDOTAUserMsg_SuggestHeroPick = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_SuggestHeroPick.
         * @exports ICDOTAUserMsg_SuggestHeroPick
         * @interface ICDOTAUserMsg_SuggestHeroPick
         * @property {number} player_id CDOTAUserMsg_SuggestHeroPick player_id
         * @property {number|null} [hero_id] CDOTAUserMsg_SuggestHeroPick hero_id
         * @property {boolean|null} [ban] CDOTAUserMsg_SuggestHeroPick ban
         */
    
        /**
         * Constructs a new CDOTAUserMsg_SuggestHeroPick.
         * @exports CDOTAUserMsg_SuggestHeroPick
         * @classdesc Represents a CDOTAUserMsg_SuggestHeroPick.
         * @implements ICDOTAUserMsg_SuggestHeroPick
         * @constructor
         * @param {ICDOTAUserMsg_SuggestHeroPick=} [properties] Properties to set
         */
        function CDOTAUserMsg_SuggestHeroPick(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_SuggestHeroPick player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_SuggestHeroPick
         * @instance
         */
        CDOTAUserMsg_SuggestHeroPick.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_SuggestHeroPick hero_id.
         * @member {number} hero_id
         * @memberof CDOTAUserMsg_SuggestHeroPick
         * @instance
         */
        CDOTAUserMsg_SuggestHeroPick.prototype.hero_id = 0;
    
        /**
         * CDOTAUserMsg_SuggestHeroPick ban.
         * @member {boolean} ban
         * @memberof CDOTAUserMsg_SuggestHeroPick
         * @instance
         */
        CDOTAUserMsg_SuggestHeroPick.prototype.ban = false;
    
        /**
         * Creates a new CDOTAUserMsg_SuggestHeroPick instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_SuggestHeroPick
         * @static
         * @param {ICDOTAUserMsg_SuggestHeroPick=} [properties] Properties to set
         * @returns {CDOTAUserMsg_SuggestHeroPick} CDOTAUserMsg_SuggestHeroPick instance
         */
        CDOTAUserMsg_SuggestHeroPick.create = function create(properties) {
            return new CDOTAUserMsg_SuggestHeroPick(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SuggestHeroPick message. Does not implicitly {@link CDOTAUserMsg_SuggestHeroPick.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_SuggestHeroPick
         * @static
         * @param {ICDOTAUserMsg_SuggestHeroPick} message CDOTAUserMsg_SuggestHeroPick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SuggestHeroPick.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.hero_id != null && Object.hasOwnProperty.call(message, "hero_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.hero_id);
            if (message.ban != null && Object.hasOwnProperty.call(message, "ban"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.ban);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SuggestHeroPick message, length delimited. Does not implicitly {@link CDOTAUserMsg_SuggestHeroPick.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_SuggestHeroPick
         * @static
         * @param {ICDOTAUserMsg_SuggestHeroPick} message CDOTAUserMsg_SuggestHeroPick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SuggestHeroPick.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_SuggestHeroPick message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_SuggestHeroPick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_SuggestHeroPick} CDOTAUserMsg_SuggestHeroPick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SuggestHeroPick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_SuggestHeroPick();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.hero_id = reader.uint32();
                    break;
                case 3:
                    message.ban = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("player_id"))
                throw $util.ProtocolError("missing required 'player_id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_SuggestHeroPick message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_SuggestHeroPick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_SuggestHeroPick} CDOTAUserMsg_SuggestHeroPick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SuggestHeroPick.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_SuggestHeroPick message.
         * @function verify
         * @memberof CDOTAUserMsg_SuggestHeroPick
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_SuggestHeroPick.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.player_id))
                return "player_id: integer expected";
            if (message.hero_id != null && message.hasOwnProperty("hero_id"))
                if (!$util.isInteger(message.hero_id))
                    return "hero_id: integer expected";
            if (message.ban != null && message.hasOwnProperty("ban"))
                if (typeof message.ban !== "boolean")
                    return "ban: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_SuggestHeroPick message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_SuggestHeroPick
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_SuggestHeroPick} CDOTAUserMsg_SuggestHeroPick
         */
        CDOTAUserMsg_SuggestHeroPick.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_SuggestHeroPick)
                return object;
            var message = new $root.CDOTAUserMsg_SuggestHeroPick();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.hero_id != null)
                message.hero_id = object.hero_id >>> 0;
            if (object.ban != null)
                message.ban = Boolean(object.ban);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_SuggestHeroPick message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_SuggestHeroPick
         * @static
         * @param {CDOTAUserMsg_SuggestHeroPick} message CDOTAUserMsg_SuggestHeroPick
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_SuggestHeroPick.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.hero_id = 0;
                object.ban = false;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.hero_id != null && message.hasOwnProperty("hero_id"))
                object.hero_id = message.hero_id;
            if (message.ban != null && message.hasOwnProperty("ban"))
                object.ban = message.ban;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_SuggestHeroPick to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_SuggestHeroPick
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_SuggestHeroPick.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_SuggestHeroPick;
    })();
    
    $root.CDOTAUserMsg_SuggestHeroRole = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_SuggestHeroRole.
         * @exports ICDOTAUserMsg_SuggestHeroRole
         * @interface ICDOTAUserMsg_SuggestHeroRole
         * @property {number} player_id CDOTAUserMsg_SuggestHeroRole player_id
         * @property {string|null} [hero_role] CDOTAUserMsg_SuggestHeroRole hero_role
         */
    
        /**
         * Constructs a new CDOTAUserMsg_SuggestHeroRole.
         * @exports CDOTAUserMsg_SuggestHeroRole
         * @classdesc Represents a CDOTAUserMsg_SuggestHeroRole.
         * @implements ICDOTAUserMsg_SuggestHeroRole
         * @constructor
         * @param {ICDOTAUserMsg_SuggestHeroRole=} [properties] Properties to set
         */
        function CDOTAUserMsg_SuggestHeroRole(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_SuggestHeroRole player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_SuggestHeroRole
         * @instance
         */
        CDOTAUserMsg_SuggestHeroRole.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_SuggestHeroRole hero_role.
         * @member {string} hero_role
         * @memberof CDOTAUserMsg_SuggestHeroRole
         * @instance
         */
        CDOTAUserMsg_SuggestHeroRole.prototype.hero_role = "";
    
        /**
         * Creates a new CDOTAUserMsg_SuggestHeroRole instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_SuggestHeroRole
         * @static
         * @param {ICDOTAUserMsg_SuggestHeroRole=} [properties] Properties to set
         * @returns {CDOTAUserMsg_SuggestHeroRole} CDOTAUserMsg_SuggestHeroRole instance
         */
        CDOTAUserMsg_SuggestHeroRole.create = function create(properties) {
            return new CDOTAUserMsg_SuggestHeroRole(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SuggestHeroRole message. Does not implicitly {@link CDOTAUserMsg_SuggestHeroRole.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_SuggestHeroRole
         * @static
         * @param {ICDOTAUserMsg_SuggestHeroRole} message CDOTAUserMsg_SuggestHeroRole message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SuggestHeroRole.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.hero_role != null && Object.hasOwnProperty.call(message, "hero_role"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.hero_role);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SuggestHeroRole message, length delimited. Does not implicitly {@link CDOTAUserMsg_SuggestHeroRole.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_SuggestHeroRole
         * @static
         * @param {ICDOTAUserMsg_SuggestHeroRole} message CDOTAUserMsg_SuggestHeroRole message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SuggestHeroRole.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_SuggestHeroRole message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_SuggestHeroRole
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_SuggestHeroRole} CDOTAUserMsg_SuggestHeroRole
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SuggestHeroRole.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_SuggestHeroRole();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.hero_role = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("player_id"))
                throw $util.ProtocolError("missing required 'player_id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_SuggestHeroRole message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_SuggestHeroRole
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_SuggestHeroRole} CDOTAUserMsg_SuggestHeroRole
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SuggestHeroRole.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_SuggestHeroRole message.
         * @function verify
         * @memberof CDOTAUserMsg_SuggestHeroRole
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_SuggestHeroRole.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.player_id))
                return "player_id: integer expected";
            if (message.hero_role != null && message.hasOwnProperty("hero_role"))
                if (!$util.isString(message.hero_role))
                    return "hero_role: string expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_SuggestHeroRole message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_SuggestHeroRole
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_SuggestHeroRole} CDOTAUserMsg_SuggestHeroRole
         */
        CDOTAUserMsg_SuggestHeroRole.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_SuggestHeroRole)
                return object;
            var message = new $root.CDOTAUserMsg_SuggestHeroRole();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.hero_role != null)
                message.hero_role = String(object.hero_role);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_SuggestHeroRole message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_SuggestHeroRole
         * @static
         * @param {CDOTAUserMsg_SuggestHeroRole} message CDOTAUserMsg_SuggestHeroRole
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_SuggestHeroRole.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.hero_role = "";
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.hero_role != null && message.hasOwnProperty("hero_role"))
                object.hero_role = message.hero_role;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_SuggestHeroRole to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_SuggestHeroRole
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_SuggestHeroRole.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_SuggestHeroRole;
    })();
    
    $root.CDOTAUserMsg_KillcamDamageTaken = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_KillcamDamageTaken.
         * @exports ICDOTAUserMsg_KillcamDamageTaken
         * @interface ICDOTAUserMsg_KillcamDamageTaken
         * @property {number} player_id CDOTAUserMsg_KillcamDamageTaken player_id
         * @property {number|null} [damage_taken] CDOTAUserMsg_KillcamDamageTaken damage_taken
         * @property {number|null} [item_type] CDOTAUserMsg_KillcamDamageTaken item_type
         * @property {number|null} [item_ability_id] CDOTAUserMsg_KillcamDamageTaken item_ability_id
         * @property {string|null} [hero_name] CDOTAUserMsg_KillcamDamageTaken hero_name
         * @property {string|null} [damage_color] CDOTAUserMsg_KillcamDamageTaken damage_color
         */
    
        /**
         * Constructs a new CDOTAUserMsg_KillcamDamageTaken.
         * @exports CDOTAUserMsg_KillcamDamageTaken
         * @classdesc Represents a CDOTAUserMsg_KillcamDamageTaken.
         * @implements ICDOTAUserMsg_KillcamDamageTaken
         * @constructor
         * @param {ICDOTAUserMsg_KillcamDamageTaken=} [properties] Properties to set
         */
        function CDOTAUserMsg_KillcamDamageTaken(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_KillcamDamageTaken player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_KillcamDamageTaken
         * @instance
         */
        CDOTAUserMsg_KillcamDamageTaken.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_KillcamDamageTaken damage_taken.
         * @member {number} damage_taken
         * @memberof CDOTAUserMsg_KillcamDamageTaken
         * @instance
         */
        CDOTAUserMsg_KillcamDamageTaken.prototype.damage_taken = 0;
    
        /**
         * CDOTAUserMsg_KillcamDamageTaken item_type.
         * @member {number} item_type
         * @memberof CDOTAUserMsg_KillcamDamageTaken
         * @instance
         */
        CDOTAUserMsg_KillcamDamageTaken.prototype.item_type = 0;
    
        /**
         * CDOTAUserMsg_KillcamDamageTaken item_ability_id.
         * @member {number} item_ability_id
         * @memberof CDOTAUserMsg_KillcamDamageTaken
         * @instance
         */
        CDOTAUserMsg_KillcamDamageTaken.prototype.item_ability_id = 0;
    
        /**
         * CDOTAUserMsg_KillcamDamageTaken hero_name.
         * @member {string} hero_name
         * @memberof CDOTAUserMsg_KillcamDamageTaken
         * @instance
         */
        CDOTAUserMsg_KillcamDamageTaken.prototype.hero_name = "";
    
        /**
         * CDOTAUserMsg_KillcamDamageTaken damage_color.
         * @member {string} damage_color
         * @memberof CDOTAUserMsg_KillcamDamageTaken
         * @instance
         */
        CDOTAUserMsg_KillcamDamageTaken.prototype.damage_color = "";
    
        /**
         * Creates a new CDOTAUserMsg_KillcamDamageTaken instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_KillcamDamageTaken
         * @static
         * @param {ICDOTAUserMsg_KillcamDamageTaken=} [properties] Properties to set
         * @returns {CDOTAUserMsg_KillcamDamageTaken} CDOTAUserMsg_KillcamDamageTaken instance
         */
        CDOTAUserMsg_KillcamDamageTaken.create = function create(properties) {
            return new CDOTAUserMsg_KillcamDamageTaken(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_KillcamDamageTaken message. Does not implicitly {@link CDOTAUserMsg_KillcamDamageTaken.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_KillcamDamageTaken
         * @static
         * @param {ICDOTAUserMsg_KillcamDamageTaken} message CDOTAUserMsg_KillcamDamageTaken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_KillcamDamageTaken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.damage_taken != null && Object.hasOwnProperty.call(message, "damage_taken"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.damage_taken);
            if (message.item_type != null && Object.hasOwnProperty.call(message, "item_type"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.item_type);
            if (message.item_ability_id != null && Object.hasOwnProperty.call(message, "item_ability_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.item_ability_id);
            if (message.hero_name != null && Object.hasOwnProperty.call(message, "hero_name"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.hero_name);
            if (message.damage_color != null && Object.hasOwnProperty.call(message, "damage_color"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.damage_color);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_KillcamDamageTaken message, length delimited. Does not implicitly {@link CDOTAUserMsg_KillcamDamageTaken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_KillcamDamageTaken
         * @static
         * @param {ICDOTAUserMsg_KillcamDamageTaken} message CDOTAUserMsg_KillcamDamageTaken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_KillcamDamageTaken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_KillcamDamageTaken message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_KillcamDamageTaken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_KillcamDamageTaken} CDOTAUserMsg_KillcamDamageTaken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_KillcamDamageTaken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_KillcamDamageTaken();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.damage_taken = reader.uint32();
                    break;
                case 3:
                    message.item_type = reader.uint32();
                    break;
                case 4:
                    message.item_ability_id = reader.uint32();
                    break;
                case 5:
                    message.hero_name = reader.string();
                    break;
                case 6:
                    message.damage_color = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("player_id"))
                throw $util.ProtocolError("missing required 'player_id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_KillcamDamageTaken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_KillcamDamageTaken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_KillcamDamageTaken} CDOTAUserMsg_KillcamDamageTaken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_KillcamDamageTaken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_KillcamDamageTaken message.
         * @function verify
         * @memberof CDOTAUserMsg_KillcamDamageTaken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_KillcamDamageTaken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.player_id))
                return "player_id: integer expected";
            if (message.damage_taken != null && message.hasOwnProperty("damage_taken"))
                if (!$util.isInteger(message.damage_taken))
                    return "damage_taken: integer expected";
            if (message.item_type != null && message.hasOwnProperty("item_type"))
                if (!$util.isInteger(message.item_type))
                    return "item_type: integer expected";
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                if (!$util.isInteger(message.item_ability_id))
                    return "item_ability_id: integer expected";
            if (message.hero_name != null && message.hasOwnProperty("hero_name"))
                if (!$util.isString(message.hero_name))
                    return "hero_name: string expected";
            if (message.damage_color != null && message.hasOwnProperty("damage_color"))
                if (!$util.isString(message.damage_color))
                    return "damage_color: string expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_KillcamDamageTaken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_KillcamDamageTaken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_KillcamDamageTaken} CDOTAUserMsg_KillcamDamageTaken
         */
        CDOTAUserMsg_KillcamDamageTaken.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_KillcamDamageTaken)
                return object;
            var message = new $root.CDOTAUserMsg_KillcamDamageTaken();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.damage_taken != null)
                message.damage_taken = object.damage_taken >>> 0;
            if (object.item_type != null)
                message.item_type = object.item_type >>> 0;
            if (object.item_ability_id != null)
                message.item_ability_id = object.item_ability_id >>> 0;
            if (object.hero_name != null)
                message.hero_name = String(object.hero_name);
            if (object.damage_color != null)
                message.damage_color = String(object.damage_color);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_KillcamDamageTaken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_KillcamDamageTaken
         * @static
         * @param {CDOTAUserMsg_KillcamDamageTaken} message CDOTAUserMsg_KillcamDamageTaken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_KillcamDamageTaken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.damage_taken = 0;
                object.item_type = 0;
                object.item_ability_id = 0;
                object.hero_name = "";
                object.damage_color = "";
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.damage_taken != null && message.hasOwnProperty("damage_taken"))
                object.damage_taken = message.damage_taken;
            if (message.item_type != null && message.hasOwnProperty("item_type"))
                object.item_type = message.item_type;
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                object.item_ability_id = message.item_ability_id;
            if (message.hero_name != null && message.hasOwnProperty("hero_name"))
                object.hero_name = message.hero_name;
            if (message.damage_color != null && message.hasOwnProperty("damage_color"))
                object.damage_color = message.damage_color;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_KillcamDamageTaken to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_KillcamDamageTaken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_KillcamDamageTaken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_KillcamDamageTaken;
    })();
    
    $root.CDOTAUserMsg_SelectPenaltyGold = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_SelectPenaltyGold.
         * @exports ICDOTAUserMsg_SelectPenaltyGold
         * @interface ICDOTAUserMsg_SelectPenaltyGold
         * @property {number} player_id CDOTAUserMsg_SelectPenaltyGold player_id
         * @property {number|null} [cost] CDOTAUserMsg_SelectPenaltyGold cost
         */
    
        /**
         * Constructs a new CDOTAUserMsg_SelectPenaltyGold.
         * @exports CDOTAUserMsg_SelectPenaltyGold
         * @classdesc Represents a CDOTAUserMsg_SelectPenaltyGold.
         * @implements ICDOTAUserMsg_SelectPenaltyGold
         * @constructor
         * @param {ICDOTAUserMsg_SelectPenaltyGold=} [properties] Properties to set
         */
        function CDOTAUserMsg_SelectPenaltyGold(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_SelectPenaltyGold player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_SelectPenaltyGold
         * @instance
         */
        CDOTAUserMsg_SelectPenaltyGold.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_SelectPenaltyGold cost.
         * @member {number} cost
         * @memberof CDOTAUserMsg_SelectPenaltyGold
         * @instance
         */
        CDOTAUserMsg_SelectPenaltyGold.prototype.cost = 0;
    
        /**
         * Creates a new CDOTAUserMsg_SelectPenaltyGold instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_SelectPenaltyGold
         * @static
         * @param {ICDOTAUserMsg_SelectPenaltyGold=} [properties] Properties to set
         * @returns {CDOTAUserMsg_SelectPenaltyGold} CDOTAUserMsg_SelectPenaltyGold instance
         */
        CDOTAUserMsg_SelectPenaltyGold.create = function create(properties) {
            return new CDOTAUserMsg_SelectPenaltyGold(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SelectPenaltyGold message. Does not implicitly {@link CDOTAUserMsg_SelectPenaltyGold.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_SelectPenaltyGold
         * @static
         * @param {ICDOTAUserMsg_SelectPenaltyGold} message CDOTAUserMsg_SelectPenaltyGold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SelectPenaltyGold.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.cost != null && Object.hasOwnProperty.call(message, "cost"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.cost);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SelectPenaltyGold message, length delimited. Does not implicitly {@link CDOTAUserMsg_SelectPenaltyGold.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_SelectPenaltyGold
         * @static
         * @param {ICDOTAUserMsg_SelectPenaltyGold} message CDOTAUserMsg_SelectPenaltyGold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SelectPenaltyGold.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_SelectPenaltyGold message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_SelectPenaltyGold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_SelectPenaltyGold} CDOTAUserMsg_SelectPenaltyGold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SelectPenaltyGold.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_SelectPenaltyGold();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.cost = reader.sint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("player_id"))
                throw $util.ProtocolError("missing required 'player_id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_SelectPenaltyGold message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_SelectPenaltyGold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_SelectPenaltyGold} CDOTAUserMsg_SelectPenaltyGold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SelectPenaltyGold.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_SelectPenaltyGold message.
         * @function verify
         * @memberof CDOTAUserMsg_SelectPenaltyGold
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_SelectPenaltyGold.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.player_id))
                return "player_id: integer expected";
            if (message.cost != null && message.hasOwnProperty("cost"))
                if (!$util.isInteger(message.cost))
                    return "cost: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_SelectPenaltyGold message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_SelectPenaltyGold
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_SelectPenaltyGold} CDOTAUserMsg_SelectPenaltyGold
         */
        CDOTAUserMsg_SelectPenaltyGold.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_SelectPenaltyGold)
                return object;
            var message = new $root.CDOTAUserMsg_SelectPenaltyGold();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.cost != null)
                message.cost = object.cost | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_SelectPenaltyGold message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_SelectPenaltyGold
         * @static
         * @param {CDOTAUserMsg_SelectPenaltyGold} message CDOTAUserMsg_SelectPenaltyGold
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_SelectPenaltyGold.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.cost = 0;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.cost != null && message.hasOwnProperty("cost"))
                object.cost = message.cost;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_SelectPenaltyGold to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_SelectPenaltyGold
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_SelectPenaltyGold.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_SelectPenaltyGold;
    })();
    
    $root.CDOTAUserMsg_RollDiceResult = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_RollDiceResult.
         * @exports ICDOTAUserMsg_RollDiceResult
         * @interface ICDOTAUserMsg_RollDiceResult
         * @property {number|null} [player_id] CDOTAUserMsg_RollDiceResult player_id
         * @property {number|null} [channel_type] CDOTAUserMsg_RollDiceResult channel_type
         * @property {number|null} [roll_min] CDOTAUserMsg_RollDiceResult roll_min
         * @property {number|null} [roll_max] CDOTAUserMsg_RollDiceResult roll_max
         * @property {number|null} [result] CDOTAUserMsg_RollDiceResult result
         */
    
        /**
         * Constructs a new CDOTAUserMsg_RollDiceResult.
         * @exports CDOTAUserMsg_RollDiceResult
         * @classdesc Represents a CDOTAUserMsg_RollDiceResult.
         * @implements ICDOTAUserMsg_RollDiceResult
         * @constructor
         * @param {ICDOTAUserMsg_RollDiceResult=} [properties] Properties to set
         */
        function CDOTAUserMsg_RollDiceResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_RollDiceResult player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_RollDiceResult
         * @instance
         */
        CDOTAUserMsg_RollDiceResult.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_RollDiceResult channel_type.
         * @member {number} channel_type
         * @memberof CDOTAUserMsg_RollDiceResult
         * @instance
         */
        CDOTAUserMsg_RollDiceResult.prototype.channel_type = 0;
    
        /**
         * CDOTAUserMsg_RollDiceResult roll_min.
         * @member {number} roll_min
         * @memberof CDOTAUserMsg_RollDiceResult
         * @instance
         */
        CDOTAUserMsg_RollDiceResult.prototype.roll_min = 0;
    
        /**
         * CDOTAUserMsg_RollDiceResult roll_max.
         * @member {number} roll_max
         * @memberof CDOTAUserMsg_RollDiceResult
         * @instance
         */
        CDOTAUserMsg_RollDiceResult.prototype.roll_max = 0;
    
        /**
         * CDOTAUserMsg_RollDiceResult result.
         * @member {number} result
         * @memberof CDOTAUserMsg_RollDiceResult
         * @instance
         */
        CDOTAUserMsg_RollDiceResult.prototype.result = 0;
    
        /**
         * Creates a new CDOTAUserMsg_RollDiceResult instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_RollDiceResult
         * @static
         * @param {ICDOTAUserMsg_RollDiceResult=} [properties] Properties to set
         * @returns {CDOTAUserMsg_RollDiceResult} CDOTAUserMsg_RollDiceResult instance
         */
        CDOTAUserMsg_RollDiceResult.create = function create(properties) {
            return new CDOTAUserMsg_RollDiceResult(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_RollDiceResult message. Does not implicitly {@link CDOTAUserMsg_RollDiceResult.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_RollDiceResult
         * @static
         * @param {ICDOTAUserMsg_RollDiceResult} message CDOTAUserMsg_RollDiceResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_RollDiceResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.channel_type != null && Object.hasOwnProperty.call(message, "channel_type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.channel_type);
            if (message.roll_min != null && Object.hasOwnProperty.call(message, "roll_min"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.roll_min);
            if (message.roll_max != null && Object.hasOwnProperty.call(message, "roll_max"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.roll_max);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_RollDiceResult message, length delimited. Does not implicitly {@link CDOTAUserMsg_RollDiceResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_RollDiceResult
         * @static
         * @param {ICDOTAUserMsg_RollDiceResult} message CDOTAUserMsg_RollDiceResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_RollDiceResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_RollDiceResult message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_RollDiceResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_RollDiceResult} CDOTAUserMsg_RollDiceResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_RollDiceResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_RollDiceResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.channel_type = reader.uint32();
                    break;
                case 3:
                    message.roll_min = reader.uint32();
                    break;
                case 4:
                    message.roll_max = reader.uint32();
                    break;
                case 5:
                    message.result = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_RollDiceResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_RollDiceResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_RollDiceResult} CDOTAUserMsg_RollDiceResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_RollDiceResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_RollDiceResult message.
         * @function verify
         * @memberof CDOTAUserMsg_RollDiceResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_RollDiceResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.channel_type != null && message.hasOwnProperty("channel_type"))
                if (!$util.isInteger(message.channel_type))
                    return "channel_type: integer expected";
            if (message.roll_min != null && message.hasOwnProperty("roll_min"))
                if (!$util.isInteger(message.roll_min))
                    return "roll_min: integer expected";
            if (message.roll_max != null && message.hasOwnProperty("roll_max"))
                if (!$util.isInteger(message.roll_max))
                    return "roll_max: integer expected";
            if (message.result != null && message.hasOwnProperty("result"))
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_RollDiceResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_RollDiceResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_RollDiceResult} CDOTAUserMsg_RollDiceResult
         */
        CDOTAUserMsg_RollDiceResult.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_RollDiceResult)
                return object;
            var message = new $root.CDOTAUserMsg_RollDiceResult();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.channel_type != null)
                message.channel_type = object.channel_type >>> 0;
            if (object.roll_min != null)
                message.roll_min = object.roll_min >>> 0;
            if (object.roll_max != null)
                message.roll_max = object.roll_max >>> 0;
            if (object.result != null)
                message.result = object.result >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_RollDiceResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_RollDiceResult
         * @static
         * @param {CDOTAUserMsg_RollDiceResult} message CDOTAUserMsg_RollDiceResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_RollDiceResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.channel_type = 0;
                object.roll_min = 0;
                object.roll_max = 0;
                object.result = 0;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.channel_type != null && message.hasOwnProperty("channel_type"))
                object.channel_type = message.channel_type;
            if (message.roll_min != null && message.hasOwnProperty("roll_min"))
                object.roll_min = message.roll_min;
            if (message.roll_max != null && message.hasOwnProperty("roll_max"))
                object.roll_max = message.roll_max;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = message.result;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_RollDiceResult to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_RollDiceResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_RollDiceResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_RollDiceResult;
    })();
    
    $root.CDOTAUserMsg_FlipCoinResult = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_FlipCoinResult.
         * @exports ICDOTAUserMsg_FlipCoinResult
         * @interface ICDOTAUserMsg_FlipCoinResult
         * @property {number|null} [player_id] CDOTAUserMsg_FlipCoinResult player_id
         * @property {number|null} [channel_type] CDOTAUserMsg_FlipCoinResult channel_type
         * @property {boolean|null} [result] CDOTAUserMsg_FlipCoinResult result
         */
    
        /**
         * Constructs a new CDOTAUserMsg_FlipCoinResult.
         * @exports CDOTAUserMsg_FlipCoinResult
         * @classdesc Represents a CDOTAUserMsg_FlipCoinResult.
         * @implements ICDOTAUserMsg_FlipCoinResult
         * @constructor
         * @param {ICDOTAUserMsg_FlipCoinResult=} [properties] Properties to set
         */
        function CDOTAUserMsg_FlipCoinResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_FlipCoinResult player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_FlipCoinResult
         * @instance
         */
        CDOTAUserMsg_FlipCoinResult.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_FlipCoinResult channel_type.
         * @member {number} channel_type
         * @memberof CDOTAUserMsg_FlipCoinResult
         * @instance
         */
        CDOTAUserMsg_FlipCoinResult.prototype.channel_type = 0;
    
        /**
         * CDOTAUserMsg_FlipCoinResult result.
         * @member {boolean} result
         * @memberof CDOTAUserMsg_FlipCoinResult
         * @instance
         */
        CDOTAUserMsg_FlipCoinResult.prototype.result = false;
    
        /**
         * Creates a new CDOTAUserMsg_FlipCoinResult instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_FlipCoinResult
         * @static
         * @param {ICDOTAUserMsg_FlipCoinResult=} [properties] Properties to set
         * @returns {CDOTAUserMsg_FlipCoinResult} CDOTAUserMsg_FlipCoinResult instance
         */
        CDOTAUserMsg_FlipCoinResult.create = function create(properties) {
            return new CDOTAUserMsg_FlipCoinResult(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_FlipCoinResult message. Does not implicitly {@link CDOTAUserMsg_FlipCoinResult.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_FlipCoinResult
         * @static
         * @param {ICDOTAUserMsg_FlipCoinResult} message CDOTAUserMsg_FlipCoinResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_FlipCoinResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.channel_type != null && Object.hasOwnProperty.call(message, "channel_type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.channel_type);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_FlipCoinResult message, length delimited. Does not implicitly {@link CDOTAUserMsg_FlipCoinResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_FlipCoinResult
         * @static
         * @param {ICDOTAUserMsg_FlipCoinResult} message CDOTAUserMsg_FlipCoinResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_FlipCoinResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_FlipCoinResult message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_FlipCoinResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_FlipCoinResult} CDOTAUserMsg_FlipCoinResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_FlipCoinResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_FlipCoinResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.channel_type = reader.uint32();
                    break;
                case 3:
                    message.result = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_FlipCoinResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_FlipCoinResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_FlipCoinResult} CDOTAUserMsg_FlipCoinResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_FlipCoinResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_FlipCoinResult message.
         * @function verify
         * @memberof CDOTAUserMsg_FlipCoinResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_FlipCoinResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.channel_type != null && message.hasOwnProperty("channel_type"))
                if (!$util.isInteger(message.channel_type))
                    return "channel_type: integer expected";
            if (message.result != null && message.hasOwnProperty("result"))
                if (typeof message.result !== "boolean")
                    return "result: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_FlipCoinResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_FlipCoinResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_FlipCoinResult} CDOTAUserMsg_FlipCoinResult
         */
        CDOTAUserMsg_FlipCoinResult.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_FlipCoinResult)
                return object;
            var message = new $root.CDOTAUserMsg_FlipCoinResult();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.channel_type != null)
                message.channel_type = object.channel_type >>> 0;
            if (object.result != null)
                message.result = Boolean(object.result);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_FlipCoinResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_FlipCoinResult
         * @static
         * @param {CDOTAUserMsg_FlipCoinResult} message CDOTAUserMsg_FlipCoinResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_FlipCoinResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.channel_type = 0;
                object.result = false;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.channel_type != null && message.hasOwnProperty("channel_type"))
                object.channel_type = message.channel_type;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = message.result;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_FlipCoinResult to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_FlipCoinResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_FlipCoinResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_FlipCoinResult;
    })();
    
    $root.CDOTAUserMessage_RequestItemSuggestions = (function() {
    
        /**
         * Properties of a CDOTAUserMessage_RequestItemSuggestions.
         * @exports ICDOTAUserMessage_RequestItemSuggestions
         * @interface ICDOTAUserMessage_RequestItemSuggestions
         * @property {number|null} [player_id] CDOTAUserMessage_RequestItemSuggestions player_id
         */
    
        /**
         * Constructs a new CDOTAUserMessage_RequestItemSuggestions.
         * @exports CDOTAUserMessage_RequestItemSuggestions
         * @classdesc Represents a CDOTAUserMessage_RequestItemSuggestions.
         * @implements ICDOTAUserMessage_RequestItemSuggestions
         * @constructor
         * @param {ICDOTAUserMessage_RequestItemSuggestions=} [properties] Properties to set
         */
        function CDOTAUserMessage_RequestItemSuggestions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMessage_RequestItemSuggestions player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMessage_RequestItemSuggestions
         * @instance
         */
        CDOTAUserMessage_RequestItemSuggestions.prototype.player_id = 0;
    
        /**
         * Creates a new CDOTAUserMessage_RequestItemSuggestions instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMessage_RequestItemSuggestions
         * @static
         * @param {ICDOTAUserMessage_RequestItemSuggestions=} [properties] Properties to set
         * @returns {CDOTAUserMessage_RequestItemSuggestions} CDOTAUserMessage_RequestItemSuggestions instance
         */
        CDOTAUserMessage_RequestItemSuggestions.create = function create(properties) {
            return new CDOTAUserMessage_RequestItemSuggestions(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMessage_RequestItemSuggestions message. Does not implicitly {@link CDOTAUserMessage_RequestItemSuggestions.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMessage_RequestItemSuggestions
         * @static
         * @param {ICDOTAUserMessage_RequestItemSuggestions} message CDOTAUserMessage_RequestItemSuggestions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMessage_RequestItemSuggestions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMessage_RequestItemSuggestions message, length delimited. Does not implicitly {@link CDOTAUserMessage_RequestItemSuggestions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMessage_RequestItemSuggestions
         * @static
         * @param {ICDOTAUserMessage_RequestItemSuggestions} message CDOTAUserMessage_RequestItemSuggestions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMessage_RequestItemSuggestions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMessage_RequestItemSuggestions message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMessage_RequestItemSuggestions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMessage_RequestItemSuggestions} CDOTAUserMessage_RequestItemSuggestions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMessage_RequestItemSuggestions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMessage_RequestItemSuggestions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMessage_RequestItemSuggestions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMessage_RequestItemSuggestions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMessage_RequestItemSuggestions} CDOTAUserMessage_RequestItemSuggestions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMessage_RequestItemSuggestions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMessage_RequestItemSuggestions message.
         * @function verify
         * @memberof CDOTAUserMessage_RequestItemSuggestions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMessage_RequestItemSuggestions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMessage_RequestItemSuggestions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMessage_RequestItemSuggestions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMessage_RequestItemSuggestions} CDOTAUserMessage_RequestItemSuggestions
         */
        CDOTAUserMessage_RequestItemSuggestions.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMessage_RequestItemSuggestions)
                return object;
            var message = new $root.CDOTAUserMessage_RequestItemSuggestions();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMessage_RequestItemSuggestions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMessage_RequestItemSuggestions
         * @static
         * @param {CDOTAUserMessage_RequestItemSuggestions} message CDOTAUserMessage_RequestItemSuggestions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMessage_RequestItemSuggestions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.player_id = 0;
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMessage_RequestItemSuggestions to JSON.
         * @function toJSON
         * @memberof CDOTAUserMessage_RequestItemSuggestions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMessage_RequestItemSuggestions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMessage_RequestItemSuggestions;
    })();
    
    $root.CDOTAUserMessage_TeamCaptainChanged = (function() {
    
        /**
         * Properties of a CDOTAUserMessage_TeamCaptainChanged.
         * @exports ICDOTAUserMessage_TeamCaptainChanged
         * @interface ICDOTAUserMessage_TeamCaptainChanged
         * @property {number|null} [team] CDOTAUserMessage_TeamCaptainChanged team
         * @property {number|null} [captain_player_id] CDOTAUserMessage_TeamCaptainChanged captain_player_id
         */
    
        /**
         * Constructs a new CDOTAUserMessage_TeamCaptainChanged.
         * @exports CDOTAUserMessage_TeamCaptainChanged
         * @classdesc Represents a CDOTAUserMessage_TeamCaptainChanged.
         * @implements ICDOTAUserMessage_TeamCaptainChanged
         * @constructor
         * @param {ICDOTAUserMessage_TeamCaptainChanged=} [properties] Properties to set
         */
        function CDOTAUserMessage_TeamCaptainChanged(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMessage_TeamCaptainChanged team.
         * @member {number} team
         * @memberof CDOTAUserMessage_TeamCaptainChanged
         * @instance
         */
        CDOTAUserMessage_TeamCaptainChanged.prototype.team = 0;
    
        /**
         * CDOTAUserMessage_TeamCaptainChanged captain_player_id.
         * @member {number} captain_player_id
         * @memberof CDOTAUserMessage_TeamCaptainChanged
         * @instance
         */
        CDOTAUserMessage_TeamCaptainChanged.prototype.captain_player_id = 0;
    
        /**
         * Creates a new CDOTAUserMessage_TeamCaptainChanged instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMessage_TeamCaptainChanged
         * @static
         * @param {ICDOTAUserMessage_TeamCaptainChanged=} [properties] Properties to set
         * @returns {CDOTAUserMessage_TeamCaptainChanged} CDOTAUserMessage_TeamCaptainChanged instance
         */
        CDOTAUserMessage_TeamCaptainChanged.create = function create(properties) {
            return new CDOTAUserMessage_TeamCaptainChanged(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMessage_TeamCaptainChanged message. Does not implicitly {@link CDOTAUserMessage_TeamCaptainChanged.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMessage_TeamCaptainChanged
         * @static
         * @param {ICDOTAUserMessage_TeamCaptainChanged} message CDOTAUserMessage_TeamCaptainChanged message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMessage_TeamCaptainChanged.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.team != null && Object.hasOwnProperty.call(message, "team"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.team);
            if (message.captain_player_id != null && Object.hasOwnProperty.call(message, "captain_player_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.captain_player_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMessage_TeamCaptainChanged message, length delimited. Does not implicitly {@link CDOTAUserMessage_TeamCaptainChanged.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMessage_TeamCaptainChanged
         * @static
         * @param {ICDOTAUserMessage_TeamCaptainChanged} message CDOTAUserMessage_TeamCaptainChanged message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMessage_TeamCaptainChanged.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMessage_TeamCaptainChanged message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMessage_TeamCaptainChanged
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMessage_TeamCaptainChanged} CDOTAUserMessage_TeamCaptainChanged
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMessage_TeamCaptainChanged.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMessage_TeamCaptainChanged();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.team = reader.uint32();
                    break;
                case 2:
                    message.captain_player_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMessage_TeamCaptainChanged message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMessage_TeamCaptainChanged
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMessage_TeamCaptainChanged} CDOTAUserMessage_TeamCaptainChanged
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMessage_TeamCaptainChanged.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMessage_TeamCaptainChanged message.
         * @function verify
         * @memberof CDOTAUserMessage_TeamCaptainChanged
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMessage_TeamCaptainChanged.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.team != null && message.hasOwnProperty("team"))
                if (!$util.isInteger(message.team))
                    return "team: integer expected";
            if (message.captain_player_id != null && message.hasOwnProperty("captain_player_id"))
                if (!$util.isInteger(message.captain_player_id))
                    return "captain_player_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMessage_TeamCaptainChanged message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMessage_TeamCaptainChanged
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMessage_TeamCaptainChanged} CDOTAUserMessage_TeamCaptainChanged
         */
        CDOTAUserMessage_TeamCaptainChanged.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMessage_TeamCaptainChanged)
                return object;
            var message = new $root.CDOTAUserMessage_TeamCaptainChanged();
            if (object.team != null)
                message.team = object.team >>> 0;
            if (object.captain_player_id != null)
                message.captain_player_id = object.captain_player_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMessage_TeamCaptainChanged message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMessage_TeamCaptainChanged
         * @static
         * @param {CDOTAUserMessage_TeamCaptainChanged} message CDOTAUserMessage_TeamCaptainChanged
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMessage_TeamCaptainChanged.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.team = 0;
                object.captain_player_id = 0;
            }
            if (message.team != null && message.hasOwnProperty("team"))
                object.team = message.team;
            if (message.captain_player_id != null && message.hasOwnProperty("captain_player_id"))
                object.captain_player_id = message.captain_player_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMessage_TeamCaptainChanged to JSON.
         * @function toJSON
         * @memberof CDOTAUserMessage_TeamCaptainChanged
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMessage_TeamCaptainChanged.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMessage_TeamCaptainChanged;
    })();
    
    $root.CDOTAUserMsg_ChatWheelCooldown = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_ChatWheelCooldown.
         * @exports ICDOTAUserMsg_ChatWheelCooldown
         * @interface ICDOTAUserMsg_ChatWheelCooldown
         * @property {number|null} [message_id] CDOTAUserMsg_ChatWheelCooldown message_id
         * @property {number|null} [cooldown_remaining] CDOTAUserMsg_ChatWheelCooldown cooldown_remaining
         */
    
        /**
         * Constructs a new CDOTAUserMsg_ChatWheelCooldown.
         * @exports CDOTAUserMsg_ChatWheelCooldown
         * @classdesc Represents a CDOTAUserMsg_ChatWheelCooldown.
         * @implements ICDOTAUserMsg_ChatWheelCooldown
         * @constructor
         * @param {ICDOTAUserMsg_ChatWheelCooldown=} [properties] Properties to set
         */
        function CDOTAUserMsg_ChatWheelCooldown(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_ChatWheelCooldown message_id.
         * @member {number} message_id
         * @memberof CDOTAUserMsg_ChatWheelCooldown
         * @instance
         */
        CDOTAUserMsg_ChatWheelCooldown.prototype.message_id = 0;
    
        /**
         * CDOTAUserMsg_ChatWheelCooldown cooldown_remaining.
         * @member {number} cooldown_remaining
         * @memberof CDOTAUserMsg_ChatWheelCooldown
         * @instance
         */
        CDOTAUserMsg_ChatWheelCooldown.prototype.cooldown_remaining = 0;
    
        /**
         * Creates a new CDOTAUserMsg_ChatWheelCooldown instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_ChatWheelCooldown
         * @static
         * @param {ICDOTAUserMsg_ChatWheelCooldown=} [properties] Properties to set
         * @returns {CDOTAUserMsg_ChatWheelCooldown} CDOTAUserMsg_ChatWheelCooldown instance
         */
        CDOTAUserMsg_ChatWheelCooldown.create = function create(properties) {
            return new CDOTAUserMsg_ChatWheelCooldown(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ChatWheelCooldown message. Does not implicitly {@link CDOTAUserMsg_ChatWheelCooldown.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_ChatWheelCooldown
         * @static
         * @param {ICDOTAUserMsg_ChatWheelCooldown} message CDOTAUserMsg_ChatWheelCooldown message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ChatWheelCooldown.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.message_id != null && Object.hasOwnProperty.call(message, "message_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.message_id);
            if (message.cooldown_remaining != null && Object.hasOwnProperty.call(message, "cooldown_remaining"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.cooldown_remaining);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ChatWheelCooldown message, length delimited. Does not implicitly {@link CDOTAUserMsg_ChatWheelCooldown.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_ChatWheelCooldown
         * @static
         * @param {ICDOTAUserMsg_ChatWheelCooldown} message CDOTAUserMsg_ChatWheelCooldown message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ChatWheelCooldown.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_ChatWheelCooldown message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_ChatWheelCooldown
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_ChatWheelCooldown} CDOTAUserMsg_ChatWheelCooldown
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ChatWheelCooldown.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_ChatWheelCooldown();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.message_id = reader.uint32();
                    break;
                case 2:
                    message.cooldown_remaining = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_ChatWheelCooldown message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_ChatWheelCooldown
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_ChatWheelCooldown} CDOTAUserMsg_ChatWheelCooldown
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ChatWheelCooldown.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_ChatWheelCooldown message.
         * @function verify
         * @memberof CDOTAUserMsg_ChatWheelCooldown
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_ChatWheelCooldown.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.message_id != null && message.hasOwnProperty("message_id"))
                if (!$util.isInteger(message.message_id))
                    return "message_id: integer expected";
            if (message.cooldown_remaining != null && message.hasOwnProperty("cooldown_remaining"))
                if (typeof message.cooldown_remaining !== "number")
                    return "cooldown_remaining: number expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_ChatWheelCooldown message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_ChatWheelCooldown
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_ChatWheelCooldown} CDOTAUserMsg_ChatWheelCooldown
         */
        CDOTAUserMsg_ChatWheelCooldown.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_ChatWheelCooldown)
                return object;
            var message = new $root.CDOTAUserMsg_ChatWheelCooldown();
            if (object.message_id != null)
                message.message_id = object.message_id >>> 0;
            if (object.cooldown_remaining != null)
                message.cooldown_remaining = Number(object.cooldown_remaining);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_ChatWheelCooldown message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_ChatWheelCooldown
         * @static
         * @param {CDOTAUserMsg_ChatWheelCooldown} message CDOTAUserMsg_ChatWheelCooldown
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_ChatWheelCooldown.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.message_id = 0;
                object.cooldown_remaining = 0;
            }
            if (message.message_id != null && message.hasOwnProperty("message_id"))
                object.message_id = message.message_id;
            if (message.cooldown_remaining != null && message.hasOwnProperty("cooldown_remaining"))
                object.cooldown_remaining = options.json && !isFinite(message.cooldown_remaining) ? String(message.cooldown_remaining) : message.cooldown_remaining;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_ChatWheelCooldown to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_ChatWheelCooldown
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_ChatWheelCooldown.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_ChatWheelCooldown;
    })();
    
    $root.CDOTAUserMsg_HeroRelicProgress = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_HeroRelicProgress.
         * @exports ICDOTAUserMsg_HeroRelicProgress
         * @interface ICDOTAUserMsg_HeroRelicProgress
         * @property {number|null} [hero_relic_type] CDOTAUserMsg_HeroRelicProgress hero_relic_type
         * @property {number|null} [value] CDOTAUserMsg_HeroRelicProgress value
         * @property {number|null} [ehandle] CDOTAUserMsg_HeroRelicProgress ehandle
         * @property {number|null} [event_id] CDOTAUserMsg_HeroRelicProgress event_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_HeroRelicProgress.
         * @exports CDOTAUserMsg_HeroRelicProgress
         * @classdesc Represents a CDOTAUserMsg_HeroRelicProgress.
         * @implements ICDOTAUserMsg_HeroRelicProgress
         * @constructor
         * @param {ICDOTAUserMsg_HeroRelicProgress=} [properties] Properties to set
         */
        function CDOTAUserMsg_HeroRelicProgress(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_HeroRelicProgress hero_relic_type.
         * @member {number} hero_relic_type
         * @memberof CDOTAUserMsg_HeroRelicProgress
         * @instance
         */
        CDOTAUserMsg_HeroRelicProgress.prototype.hero_relic_type = 0;
    
        /**
         * CDOTAUserMsg_HeroRelicProgress value.
         * @member {number} value
         * @memberof CDOTAUserMsg_HeroRelicProgress
         * @instance
         */
        CDOTAUserMsg_HeroRelicProgress.prototype.value = 0;
    
        /**
         * CDOTAUserMsg_HeroRelicProgress ehandle.
         * @member {number} ehandle
         * @memberof CDOTAUserMsg_HeroRelicProgress
         * @instance
         */
        CDOTAUserMsg_HeroRelicProgress.prototype.ehandle = 0;
    
        /**
         * CDOTAUserMsg_HeroRelicProgress event_id.
         * @member {number} event_id
         * @memberof CDOTAUserMsg_HeroRelicProgress
         * @instance
         */
        CDOTAUserMsg_HeroRelicProgress.prototype.event_id = 0;
    
        /**
         * Creates a new CDOTAUserMsg_HeroRelicProgress instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_HeroRelicProgress
         * @static
         * @param {ICDOTAUserMsg_HeroRelicProgress=} [properties] Properties to set
         * @returns {CDOTAUserMsg_HeroRelicProgress} CDOTAUserMsg_HeroRelicProgress instance
         */
        CDOTAUserMsg_HeroRelicProgress.create = function create(properties) {
            return new CDOTAUserMsg_HeroRelicProgress(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_HeroRelicProgress message. Does not implicitly {@link CDOTAUserMsg_HeroRelicProgress.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_HeroRelicProgress
         * @static
         * @param {ICDOTAUserMsg_HeroRelicProgress} message CDOTAUserMsg_HeroRelicProgress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_HeroRelicProgress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hero_relic_type != null && Object.hasOwnProperty.call(message, "hero_relic_type"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.hero_relic_type);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.value);
            if (message.ehandle != null && Object.hasOwnProperty.call(message, "ehandle"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.ehandle);
            if (message.event_id != null && Object.hasOwnProperty.call(message, "event_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.event_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_HeroRelicProgress message, length delimited. Does not implicitly {@link CDOTAUserMsg_HeroRelicProgress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_HeroRelicProgress
         * @static
         * @param {ICDOTAUserMsg_HeroRelicProgress} message CDOTAUserMsg_HeroRelicProgress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_HeroRelicProgress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_HeroRelicProgress message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_HeroRelicProgress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_HeroRelicProgress} CDOTAUserMsg_HeroRelicProgress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_HeroRelicProgress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_HeroRelicProgress();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hero_relic_type = reader.uint32();
                    break;
                case 2:
                    message.value = reader.uint32();
                    break;
                case 3:
                    message.ehandle = reader.uint32();
                    break;
                case 4:
                    message.event_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_HeroRelicProgress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_HeroRelicProgress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_HeroRelicProgress} CDOTAUserMsg_HeroRelicProgress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_HeroRelicProgress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_HeroRelicProgress message.
         * @function verify
         * @memberof CDOTAUserMsg_HeroRelicProgress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_HeroRelicProgress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hero_relic_type != null && message.hasOwnProperty("hero_relic_type"))
                if (!$util.isInteger(message.hero_relic_type))
                    return "hero_relic_type: integer expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value))
                    return "value: integer expected";
            if (message.ehandle != null && message.hasOwnProperty("ehandle"))
                if (!$util.isInteger(message.ehandle))
                    return "ehandle: integer expected";
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                if (!$util.isInteger(message.event_id))
                    return "event_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_HeroRelicProgress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_HeroRelicProgress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_HeroRelicProgress} CDOTAUserMsg_HeroRelicProgress
         */
        CDOTAUserMsg_HeroRelicProgress.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_HeroRelicProgress)
                return object;
            var message = new $root.CDOTAUserMsg_HeroRelicProgress();
            if (object.hero_relic_type != null)
                message.hero_relic_type = object.hero_relic_type >>> 0;
            if (object.value != null)
                message.value = object.value >>> 0;
            if (object.ehandle != null)
                message.ehandle = object.ehandle >>> 0;
            if (object.event_id != null)
                message.event_id = object.event_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_HeroRelicProgress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_HeroRelicProgress
         * @static
         * @param {CDOTAUserMsg_HeroRelicProgress} message CDOTAUserMsg_HeroRelicProgress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_HeroRelicProgress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.hero_relic_type = 0;
                object.value = 0;
                object.ehandle = 0;
                object.event_id = 0;
            }
            if (message.hero_relic_type != null && message.hasOwnProperty("hero_relic_type"))
                object.hero_relic_type = message.hero_relic_type;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.ehandle != null && message.hasOwnProperty("ehandle"))
                object.ehandle = message.ehandle;
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                object.event_id = message.event_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_HeroRelicProgress to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_HeroRelicProgress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_HeroRelicProgress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_HeroRelicProgress;
    })();
    
    $root.CDOTAUserMsg_AbilityDraftRequestAbility = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_AbilityDraftRequestAbility.
         * @exports ICDOTAUserMsg_AbilityDraftRequestAbility
         * @interface ICDOTAUserMsg_AbilityDraftRequestAbility
         * @property {number|null} [player_id] CDOTAUserMsg_AbilityDraftRequestAbility player_id
         * @property {number|null} [requested_ability_id] CDOTAUserMsg_AbilityDraftRequestAbility requested_ability_id
         * @property {boolean|null} [ctrl_is_down] CDOTAUserMsg_AbilityDraftRequestAbility ctrl_is_down
         */
    
        /**
         * Constructs a new CDOTAUserMsg_AbilityDraftRequestAbility.
         * @exports CDOTAUserMsg_AbilityDraftRequestAbility
         * @classdesc Represents a CDOTAUserMsg_AbilityDraftRequestAbility.
         * @implements ICDOTAUserMsg_AbilityDraftRequestAbility
         * @constructor
         * @param {ICDOTAUserMsg_AbilityDraftRequestAbility=} [properties] Properties to set
         */
        function CDOTAUserMsg_AbilityDraftRequestAbility(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_AbilityDraftRequestAbility player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_AbilityDraftRequestAbility
         * @instance
         */
        CDOTAUserMsg_AbilityDraftRequestAbility.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_AbilityDraftRequestAbility requested_ability_id.
         * @member {number} requested_ability_id
         * @memberof CDOTAUserMsg_AbilityDraftRequestAbility
         * @instance
         */
        CDOTAUserMsg_AbilityDraftRequestAbility.prototype.requested_ability_id = 0;
    
        /**
         * CDOTAUserMsg_AbilityDraftRequestAbility ctrl_is_down.
         * @member {boolean} ctrl_is_down
         * @memberof CDOTAUserMsg_AbilityDraftRequestAbility
         * @instance
         */
        CDOTAUserMsg_AbilityDraftRequestAbility.prototype.ctrl_is_down = false;
    
        /**
         * Creates a new CDOTAUserMsg_AbilityDraftRequestAbility instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_AbilityDraftRequestAbility
         * @static
         * @param {ICDOTAUserMsg_AbilityDraftRequestAbility=} [properties] Properties to set
         * @returns {CDOTAUserMsg_AbilityDraftRequestAbility} CDOTAUserMsg_AbilityDraftRequestAbility instance
         */
        CDOTAUserMsg_AbilityDraftRequestAbility.create = function create(properties) {
            return new CDOTAUserMsg_AbilityDraftRequestAbility(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_AbilityDraftRequestAbility message. Does not implicitly {@link CDOTAUserMsg_AbilityDraftRequestAbility.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_AbilityDraftRequestAbility
         * @static
         * @param {ICDOTAUserMsg_AbilityDraftRequestAbility} message CDOTAUserMsg_AbilityDraftRequestAbility message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_AbilityDraftRequestAbility.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.requested_ability_id != null && Object.hasOwnProperty.call(message, "requested_ability_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.requested_ability_id);
            if (message.ctrl_is_down != null && Object.hasOwnProperty.call(message, "ctrl_is_down"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.ctrl_is_down);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_AbilityDraftRequestAbility message, length delimited. Does not implicitly {@link CDOTAUserMsg_AbilityDraftRequestAbility.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_AbilityDraftRequestAbility
         * @static
         * @param {ICDOTAUserMsg_AbilityDraftRequestAbility} message CDOTAUserMsg_AbilityDraftRequestAbility message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_AbilityDraftRequestAbility.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_AbilityDraftRequestAbility message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_AbilityDraftRequestAbility
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_AbilityDraftRequestAbility} CDOTAUserMsg_AbilityDraftRequestAbility
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_AbilityDraftRequestAbility.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_AbilityDraftRequestAbility();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.requested_ability_id = reader.uint32();
                    break;
                case 3:
                    message.ctrl_is_down = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_AbilityDraftRequestAbility message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_AbilityDraftRequestAbility
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_AbilityDraftRequestAbility} CDOTAUserMsg_AbilityDraftRequestAbility
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_AbilityDraftRequestAbility.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_AbilityDraftRequestAbility message.
         * @function verify
         * @memberof CDOTAUserMsg_AbilityDraftRequestAbility
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_AbilityDraftRequestAbility.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.requested_ability_id != null && message.hasOwnProperty("requested_ability_id"))
                if (!$util.isInteger(message.requested_ability_id))
                    return "requested_ability_id: integer expected";
            if (message.ctrl_is_down != null && message.hasOwnProperty("ctrl_is_down"))
                if (typeof message.ctrl_is_down !== "boolean")
                    return "ctrl_is_down: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_AbilityDraftRequestAbility message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_AbilityDraftRequestAbility
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_AbilityDraftRequestAbility} CDOTAUserMsg_AbilityDraftRequestAbility
         */
        CDOTAUserMsg_AbilityDraftRequestAbility.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_AbilityDraftRequestAbility)
                return object;
            var message = new $root.CDOTAUserMsg_AbilityDraftRequestAbility();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.requested_ability_id != null)
                message.requested_ability_id = object.requested_ability_id >>> 0;
            if (object.ctrl_is_down != null)
                message.ctrl_is_down = Boolean(object.ctrl_is_down);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_AbilityDraftRequestAbility message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_AbilityDraftRequestAbility
         * @static
         * @param {CDOTAUserMsg_AbilityDraftRequestAbility} message CDOTAUserMsg_AbilityDraftRequestAbility
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_AbilityDraftRequestAbility.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.requested_ability_id = 0;
                object.ctrl_is_down = false;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.requested_ability_id != null && message.hasOwnProperty("requested_ability_id"))
                object.requested_ability_id = message.requested_ability_id;
            if (message.ctrl_is_down != null && message.hasOwnProperty("ctrl_is_down"))
                object.ctrl_is_down = message.ctrl_is_down;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_AbilityDraftRequestAbility to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_AbilityDraftRequestAbility
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_AbilityDraftRequestAbility.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_AbilityDraftRequestAbility;
    })();
    
    $root.CDOTAUserMsg_DamageReport = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_DamageReport.
         * @exports ICDOTAUserMsg_DamageReport
         * @interface ICDOTAUserMsg_DamageReport
         * @property {number|null} [player_id] CDOTAUserMsg_DamageReport player_id
         * @property {number|null} [target_hero_id] CDOTAUserMsg_DamageReport target_hero_id
         * @property {number|null} [source_hero_id] CDOTAUserMsg_DamageReport source_hero_id
         * @property {number|null} [damage_amount] CDOTAUserMsg_DamageReport damage_amount
         * @property {boolean|null} [broadcast] CDOTAUserMsg_DamageReport broadcast
         */
    
        /**
         * Constructs a new CDOTAUserMsg_DamageReport.
         * @exports CDOTAUserMsg_DamageReport
         * @classdesc Represents a CDOTAUserMsg_DamageReport.
         * @implements ICDOTAUserMsg_DamageReport
         * @constructor
         * @param {ICDOTAUserMsg_DamageReport=} [properties] Properties to set
         */
        function CDOTAUserMsg_DamageReport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_DamageReport player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_DamageReport
         * @instance
         */
        CDOTAUserMsg_DamageReport.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_DamageReport target_hero_id.
         * @member {number} target_hero_id
         * @memberof CDOTAUserMsg_DamageReport
         * @instance
         */
        CDOTAUserMsg_DamageReport.prototype.target_hero_id = 0;
    
        /**
         * CDOTAUserMsg_DamageReport source_hero_id.
         * @member {number} source_hero_id
         * @memberof CDOTAUserMsg_DamageReport
         * @instance
         */
        CDOTAUserMsg_DamageReport.prototype.source_hero_id = 0;
    
        /**
         * CDOTAUserMsg_DamageReport damage_amount.
         * @member {number} damage_amount
         * @memberof CDOTAUserMsg_DamageReport
         * @instance
         */
        CDOTAUserMsg_DamageReport.prototype.damage_amount = 0;
    
        /**
         * CDOTAUserMsg_DamageReport broadcast.
         * @member {boolean} broadcast
         * @memberof CDOTAUserMsg_DamageReport
         * @instance
         */
        CDOTAUserMsg_DamageReport.prototype.broadcast = false;
    
        /**
         * Creates a new CDOTAUserMsg_DamageReport instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_DamageReport
         * @static
         * @param {ICDOTAUserMsg_DamageReport=} [properties] Properties to set
         * @returns {CDOTAUserMsg_DamageReport} CDOTAUserMsg_DamageReport instance
         */
        CDOTAUserMsg_DamageReport.create = function create(properties) {
            return new CDOTAUserMsg_DamageReport(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_DamageReport message. Does not implicitly {@link CDOTAUserMsg_DamageReport.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_DamageReport
         * @static
         * @param {ICDOTAUserMsg_DamageReport} message CDOTAUserMsg_DamageReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_DamageReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.target_hero_id != null && Object.hasOwnProperty.call(message, "target_hero_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.target_hero_id);
            if (message.source_hero_id != null && Object.hasOwnProperty.call(message, "source_hero_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.source_hero_id);
            if (message.damage_amount != null && Object.hasOwnProperty.call(message, "damage_amount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.damage_amount);
            if (message.broadcast != null && Object.hasOwnProperty.call(message, "broadcast"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.broadcast);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_DamageReport message, length delimited. Does not implicitly {@link CDOTAUserMsg_DamageReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_DamageReport
         * @static
         * @param {ICDOTAUserMsg_DamageReport} message CDOTAUserMsg_DamageReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_DamageReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_DamageReport message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_DamageReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_DamageReport} CDOTAUserMsg_DamageReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_DamageReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_DamageReport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.target_hero_id = reader.uint32();
                    break;
                case 3:
                    message.source_hero_id = reader.uint32();
                    break;
                case 4:
                    message.damage_amount = reader.int32();
                    break;
                case 5:
                    message.broadcast = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_DamageReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_DamageReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_DamageReport} CDOTAUserMsg_DamageReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_DamageReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_DamageReport message.
         * @function verify
         * @memberof CDOTAUserMsg_DamageReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_DamageReport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.target_hero_id != null && message.hasOwnProperty("target_hero_id"))
                if (!$util.isInteger(message.target_hero_id))
                    return "target_hero_id: integer expected";
            if (message.source_hero_id != null && message.hasOwnProperty("source_hero_id"))
                if (!$util.isInteger(message.source_hero_id))
                    return "source_hero_id: integer expected";
            if (message.damage_amount != null && message.hasOwnProperty("damage_amount"))
                if (!$util.isInteger(message.damage_amount))
                    return "damage_amount: integer expected";
            if (message.broadcast != null && message.hasOwnProperty("broadcast"))
                if (typeof message.broadcast !== "boolean")
                    return "broadcast: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_DamageReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_DamageReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_DamageReport} CDOTAUserMsg_DamageReport
         */
        CDOTAUserMsg_DamageReport.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_DamageReport)
                return object;
            var message = new $root.CDOTAUserMsg_DamageReport();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.target_hero_id != null)
                message.target_hero_id = object.target_hero_id >>> 0;
            if (object.source_hero_id != null)
                message.source_hero_id = object.source_hero_id >>> 0;
            if (object.damage_amount != null)
                message.damage_amount = object.damage_amount | 0;
            if (object.broadcast != null)
                message.broadcast = Boolean(object.broadcast);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_DamageReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_DamageReport
         * @static
         * @param {CDOTAUserMsg_DamageReport} message CDOTAUserMsg_DamageReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_DamageReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.target_hero_id = 0;
                object.source_hero_id = 0;
                object.damage_amount = 0;
                object.broadcast = false;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.target_hero_id != null && message.hasOwnProperty("target_hero_id"))
                object.target_hero_id = message.target_hero_id;
            if (message.source_hero_id != null && message.hasOwnProperty("source_hero_id"))
                object.source_hero_id = message.source_hero_id;
            if (message.damage_amount != null && message.hasOwnProperty("damage_amount"))
                object.damage_amount = message.damage_amount;
            if (message.broadcast != null && message.hasOwnProperty("broadcast"))
                object.broadcast = message.broadcast;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_DamageReport to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_DamageReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_DamageReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_DamageReport;
    })();
    
    $root.CDOTAUserMsg_SalutePlayer = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_SalutePlayer.
         * @exports ICDOTAUserMsg_SalutePlayer
         * @interface ICDOTAUserMsg_SalutePlayer
         * @property {number|null} [source_player_id] CDOTAUserMsg_SalutePlayer source_player_id
         * @property {number|null} [target_player_id] CDOTAUserMsg_SalutePlayer target_player_id
         * @property {number|null} [tip_amount] CDOTAUserMsg_SalutePlayer tip_amount
         * @property {number|null} [event_id] CDOTAUserMsg_SalutePlayer event_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_SalutePlayer.
         * @exports CDOTAUserMsg_SalutePlayer
         * @classdesc Represents a CDOTAUserMsg_SalutePlayer.
         * @implements ICDOTAUserMsg_SalutePlayer
         * @constructor
         * @param {ICDOTAUserMsg_SalutePlayer=} [properties] Properties to set
         */
        function CDOTAUserMsg_SalutePlayer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_SalutePlayer source_player_id.
         * @member {number} source_player_id
         * @memberof CDOTAUserMsg_SalutePlayer
         * @instance
         */
        CDOTAUserMsg_SalutePlayer.prototype.source_player_id = 0;
    
        /**
         * CDOTAUserMsg_SalutePlayer target_player_id.
         * @member {number} target_player_id
         * @memberof CDOTAUserMsg_SalutePlayer
         * @instance
         */
        CDOTAUserMsg_SalutePlayer.prototype.target_player_id = 0;
    
        /**
         * CDOTAUserMsg_SalutePlayer tip_amount.
         * @member {number} tip_amount
         * @memberof CDOTAUserMsg_SalutePlayer
         * @instance
         */
        CDOTAUserMsg_SalutePlayer.prototype.tip_amount = 0;
    
        /**
         * CDOTAUserMsg_SalutePlayer event_id.
         * @member {number} event_id
         * @memberof CDOTAUserMsg_SalutePlayer
         * @instance
         */
        CDOTAUserMsg_SalutePlayer.prototype.event_id = 0;
    
        /**
         * Creates a new CDOTAUserMsg_SalutePlayer instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_SalutePlayer
         * @static
         * @param {ICDOTAUserMsg_SalutePlayer=} [properties] Properties to set
         * @returns {CDOTAUserMsg_SalutePlayer} CDOTAUserMsg_SalutePlayer instance
         */
        CDOTAUserMsg_SalutePlayer.create = function create(properties) {
            return new CDOTAUserMsg_SalutePlayer(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SalutePlayer message. Does not implicitly {@link CDOTAUserMsg_SalutePlayer.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_SalutePlayer
         * @static
         * @param {ICDOTAUserMsg_SalutePlayer} message CDOTAUserMsg_SalutePlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SalutePlayer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.source_player_id != null && Object.hasOwnProperty.call(message, "source_player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.source_player_id);
            if (message.target_player_id != null && Object.hasOwnProperty.call(message, "target_player_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.target_player_id);
            if (message.tip_amount != null && Object.hasOwnProperty.call(message, "tip_amount"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.tip_amount);
            if (message.event_id != null && Object.hasOwnProperty.call(message, "event_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.event_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_SalutePlayer message, length delimited. Does not implicitly {@link CDOTAUserMsg_SalutePlayer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_SalutePlayer
         * @static
         * @param {ICDOTAUserMsg_SalutePlayer} message CDOTAUserMsg_SalutePlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_SalutePlayer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_SalutePlayer message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_SalutePlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_SalutePlayer} CDOTAUserMsg_SalutePlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SalutePlayer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_SalutePlayer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.source_player_id = reader.int32();
                    break;
                case 2:
                    message.target_player_id = reader.int32();
                    break;
                case 3:
                    message.tip_amount = reader.uint32();
                    break;
                case 4:
                    message.event_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_SalutePlayer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_SalutePlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_SalutePlayer} CDOTAUserMsg_SalutePlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_SalutePlayer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_SalutePlayer message.
         * @function verify
         * @memberof CDOTAUserMsg_SalutePlayer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_SalutePlayer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.source_player_id != null && message.hasOwnProperty("source_player_id"))
                if (!$util.isInteger(message.source_player_id))
                    return "source_player_id: integer expected";
            if (message.target_player_id != null && message.hasOwnProperty("target_player_id"))
                if (!$util.isInteger(message.target_player_id))
                    return "target_player_id: integer expected";
            if (message.tip_amount != null && message.hasOwnProperty("tip_amount"))
                if (!$util.isInteger(message.tip_amount))
                    return "tip_amount: integer expected";
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                if (!$util.isInteger(message.event_id))
                    return "event_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_SalutePlayer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_SalutePlayer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_SalutePlayer} CDOTAUserMsg_SalutePlayer
         */
        CDOTAUserMsg_SalutePlayer.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_SalutePlayer)
                return object;
            var message = new $root.CDOTAUserMsg_SalutePlayer();
            if (object.source_player_id != null)
                message.source_player_id = object.source_player_id | 0;
            if (object.target_player_id != null)
                message.target_player_id = object.target_player_id | 0;
            if (object.tip_amount != null)
                message.tip_amount = object.tip_amount >>> 0;
            if (object.event_id != null)
                message.event_id = object.event_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_SalutePlayer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_SalutePlayer
         * @static
         * @param {CDOTAUserMsg_SalutePlayer} message CDOTAUserMsg_SalutePlayer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_SalutePlayer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.source_player_id = 0;
                object.target_player_id = 0;
                object.tip_amount = 0;
                object.event_id = 0;
            }
            if (message.source_player_id != null && message.hasOwnProperty("source_player_id"))
                object.source_player_id = message.source_player_id;
            if (message.target_player_id != null && message.hasOwnProperty("target_player_id"))
                object.target_player_id = message.target_player_id;
            if (message.tip_amount != null && message.hasOwnProperty("tip_amount"))
                object.tip_amount = message.tip_amount;
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                object.event_id = message.event_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_SalutePlayer to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_SalutePlayer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_SalutePlayer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_SalutePlayer;
    })();
    
    $root.CDOTAUserMsg_TipAlert = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_TipAlert.
         * @exports ICDOTAUserMsg_TipAlert
         * @interface ICDOTAUserMsg_TipAlert
         * @property {number|null} [player_id] CDOTAUserMsg_TipAlert player_id
         * @property {string|null} [tip_text] CDOTAUserMsg_TipAlert tip_text
         */
    
        /**
         * Constructs a new CDOTAUserMsg_TipAlert.
         * @exports CDOTAUserMsg_TipAlert
         * @classdesc Represents a CDOTAUserMsg_TipAlert.
         * @implements ICDOTAUserMsg_TipAlert
         * @constructor
         * @param {ICDOTAUserMsg_TipAlert=} [properties] Properties to set
         */
        function CDOTAUserMsg_TipAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_TipAlert player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_TipAlert
         * @instance
         */
        CDOTAUserMsg_TipAlert.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_TipAlert tip_text.
         * @member {string} tip_text
         * @memberof CDOTAUserMsg_TipAlert
         * @instance
         */
        CDOTAUserMsg_TipAlert.prototype.tip_text = "";
    
        /**
         * Creates a new CDOTAUserMsg_TipAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_TipAlert
         * @static
         * @param {ICDOTAUserMsg_TipAlert=} [properties] Properties to set
         * @returns {CDOTAUserMsg_TipAlert} CDOTAUserMsg_TipAlert instance
         */
        CDOTAUserMsg_TipAlert.create = function create(properties) {
            return new CDOTAUserMsg_TipAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TipAlert message. Does not implicitly {@link CDOTAUserMsg_TipAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_TipAlert
         * @static
         * @param {ICDOTAUserMsg_TipAlert} message CDOTAUserMsg_TipAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TipAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.tip_text != null && Object.hasOwnProperty.call(message, "tip_text"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.tip_text);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_TipAlert message, length delimited. Does not implicitly {@link CDOTAUserMsg_TipAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_TipAlert
         * @static
         * @param {ICDOTAUserMsg_TipAlert} message CDOTAUserMsg_TipAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_TipAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_TipAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_TipAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_TipAlert} CDOTAUserMsg_TipAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TipAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_TipAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.tip_text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_TipAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_TipAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_TipAlert} CDOTAUserMsg_TipAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_TipAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_TipAlert message.
         * @function verify
         * @memberof CDOTAUserMsg_TipAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_TipAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.tip_text != null && message.hasOwnProperty("tip_text"))
                if (!$util.isString(message.tip_text))
                    return "tip_text: string expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_TipAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_TipAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_TipAlert} CDOTAUserMsg_TipAlert
         */
        CDOTAUserMsg_TipAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_TipAlert)
                return object;
            var message = new $root.CDOTAUserMsg_TipAlert();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.tip_text != null)
                message.tip_text = String(object.tip_text);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_TipAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_TipAlert
         * @static
         * @param {CDOTAUserMsg_TipAlert} message CDOTAUserMsg_TipAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_TipAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.tip_text = "";
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.tip_text != null && message.hasOwnProperty("tip_text"))
                object.tip_text = message.tip_text;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_TipAlert to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_TipAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_TipAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_TipAlert;
    })();
    
    $root.CDOTAUserMsg_ReplaceQueryUnit = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_ReplaceQueryUnit.
         * @exports ICDOTAUserMsg_ReplaceQueryUnit
         * @interface ICDOTAUserMsg_ReplaceQueryUnit
         * @property {number} player_id CDOTAUserMsg_ReplaceQueryUnit player_id
         * @property {number|null} [source_entindex] CDOTAUserMsg_ReplaceQueryUnit source_entindex
         * @property {number|null} [target_entindex] CDOTAUserMsg_ReplaceQueryUnit target_entindex
         */
    
        /**
         * Constructs a new CDOTAUserMsg_ReplaceQueryUnit.
         * @exports CDOTAUserMsg_ReplaceQueryUnit
         * @classdesc Represents a CDOTAUserMsg_ReplaceQueryUnit.
         * @implements ICDOTAUserMsg_ReplaceQueryUnit
         * @constructor
         * @param {ICDOTAUserMsg_ReplaceQueryUnit=} [properties] Properties to set
         */
        function CDOTAUserMsg_ReplaceQueryUnit(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_ReplaceQueryUnit player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_ReplaceQueryUnit
         * @instance
         */
        CDOTAUserMsg_ReplaceQueryUnit.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_ReplaceQueryUnit source_entindex.
         * @member {number} source_entindex
         * @memberof CDOTAUserMsg_ReplaceQueryUnit
         * @instance
         */
        CDOTAUserMsg_ReplaceQueryUnit.prototype.source_entindex = 0;
    
        /**
         * CDOTAUserMsg_ReplaceQueryUnit target_entindex.
         * @member {number} target_entindex
         * @memberof CDOTAUserMsg_ReplaceQueryUnit
         * @instance
         */
        CDOTAUserMsg_ReplaceQueryUnit.prototype.target_entindex = 0;
    
        /**
         * Creates a new CDOTAUserMsg_ReplaceQueryUnit instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_ReplaceQueryUnit
         * @static
         * @param {ICDOTAUserMsg_ReplaceQueryUnit=} [properties] Properties to set
         * @returns {CDOTAUserMsg_ReplaceQueryUnit} CDOTAUserMsg_ReplaceQueryUnit instance
         */
        CDOTAUserMsg_ReplaceQueryUnit.create = function create(properties) {
            return new CDOTAUserMsg_ReplaceQueryUnit(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ReplaceQueryUnit message. Does not implicitly {@link CDOTAUserMsg_ReplaceQueryUnit.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_ReplaceQueryUnit
         * @static
         * @param {ICDOTAUserMsg_ReplaceQueryUnit} message CDOTAUserMsg_ReplaceQueryUnit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ReplaceQueryUnit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.source_entindex != null && Object.hasOwnProperty.call(message, "source_entindex"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.source_entindex);
            if (message.target_entindex != null && Object.hasOwnProperty.call(message, "target_entindex"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.target_entindex);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ReplaceQueryUnit message, length delimited. Does not implicitly {@link CDOTAUserMsg_ReplaceQueryUnit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_ReplaceQueryUnit
         * @static
         * @param {ICDOTAUserMsg_ReplaceQueryUnit} message CDOTAUserMsg_ReplaceQueryUnit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ReplaceQueryUnit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_ReplaceQueryUnit message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_ReplaceQueryUnit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_ReplaceQueryUnit} CDOTAUserMsg_ReplaceQueryUnit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ReplaceQueryUnit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_ReplaceQueryUnit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.source_entindex = reader.uint32();
                    break;
                case 3:
                    message.target_entindex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("player_id"))
                throw $util.ProtocolError("missing required 'player_id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_ReplaceQueryUnit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_ReplaceQueryUnit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_ReplaceQueryUnit} CDOTAUserMsg_ReplaceQueryUnit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ReplaceQueryUnit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_ReplaceQueryUnit message.
         * @function verify
         * @memberof CDOTAUserMsg_ReplaceQueryUnit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_ReplaceQueryUnit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.player_id))
                return "player_id: integer expected";
            if (message.source_entindex != null && message.hasOwnProperty("source_entindex"))
                if (!$util.isInteger(message.source_entindex))
                    return "source_entindex: integer expected";
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                if (!$util.isInteger(message.target_entindex))
                    return "target_entindex: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_ReplaceQueryUnit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_ReplaceQueryUnit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_ReplaceQueryUnit} CDOTAUserMsg_ReplaceQueryUnit
         */
        CDOTAUserMsg_ReplaceQueryUnit.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_ReplaceQueryUnit)
                return object;
            var message = new $root.CDOTAUserMsg_ReplaceQueryUnit();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.source_entindex != null)
                message.source_entindex = object.source_entindex >>> 0;
            if (object.target_entindex != null)
                message.target_entindex = object.target_entindex >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_ReplaceQueryUnit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_ReplaceQueryUnit
         * @static
         * @param {CDOTAUserMsg_ReplaceQueryUnit} message CDOTAUserMsg_ReplaceQueryUnit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_ReplaceQueryUnit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.source_entindex = 0;
                object.target_entindex = 0;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.source_entindex != null && message.hasOwnProperty("source_entindex"))
                object.source_entindex = message.source_entindex;
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                object.target_entindex = message.target_entindex;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_ReplaceQueryUnit to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_ReplaceQueryUnit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_ReplaceQueryUnit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_ReplaceQueryUnit;
    })();
    
    $root.CDOTAUserMsg_ESArcanaCombo = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_ESArcanaCombo.
         * @exports ICDOTAUserMsg_ESArcanaCombo
         * @interface ICDOTAUserMsg_ESArcanaCombo
         * @property {number|null} [ehandle] CDOTAUserMsg_ESArcanaCombo ehandle
         * @property {number|null} [combo_count] CDOTAUserMsg_ESArcanaCombo combo_count
         * @property {number|null} [arcana_level] CDOTAUserMsg_ESArcanaCombo arcana_level
         */
    
        /**
         * Constructs a new CDOTAUserMsg_ESArcanaCombo.
         * @exports CDOTAUserMsg_ESArcanaCombo
         * @classdesc Represents a CDOTAUserMsg_ESArcanaCombo.
         * @implements ICDOTAUserMsg_ESArcanaCombo
         * @constructor
         * @param {ICDOTAUserMsg_ESArcanaCombo=} [properties] Properties to set
         */
        function CDOTAUserMsg_ESArcanaCombo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_ESArcanaCombo ehandle.
         * @member {number} ehandle
         * @memberof CDOTAUserMsg_ESArcanaCombo
         * @instance
         */
        CDOTAUserMsg_ESArcanaCombo.prototype.ehandle = 0;
    
        /**
         * CDOTAUserMsg_ESArcanaCombo combo_count.
         * @member {number} combo_count
         * @memberof CDOTAUserMsg_ESArcanaCombo
         * @instance
         */
        CDOTAUserMsg_ESArcanaCombo.prototype.combo_count = 0;
    
        /**
         * CDOTAUserMsg_ESArcanaCombo arcana_level.
         * @member {number} arcana_level
         * @memberof CDOTAUserMsg_ESArcanaCombo
         * @instance
         */
        CDOTAUserMsg_ESArcanaCombo.prototype.arcana_level = 0;
    
        /**
         * Creates a new CDOTAUserMsg_ESArcanaCombo instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_ESArcanaCombo
         * @static
         * @param {ICDOTAUserMsg_ESArcanaCombo=} [properties] Properties to set
         * @returns {CDOTAUserMsg_ESArcanaCombo} CDOTAUserMsg_ESArcanaCombo instance
         */
        CDOTAUserMsg_ESArcanaCombo.create = function create(properties) {
            return new CDOTAUserMsg_ESArcanaCombo(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ESArcanaCombo message. Does not implicitly {@link CDOTAUserMsg_ESArcanaCombo.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_ESArcanaCombo
         * @static
         * @param {ICDOTAUserMsg_ESArcanaCombo} message CDOTAUserMsg_ESArcanaCombo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ESArcanaCombo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ehandle != null && Object.hasOwnProperty.call(message, "ehandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ehandle);
            if (message.combo_count != null && Object.hasOwnProperty.call(message, "combo_count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.combo_count);
            if (message.arcana_level != null && Object.hasOwnProperty.call(message, "arcana_level"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.arcana_level);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ESArcanaCombo message, length delimited. Does not implicitly {@link CDOTAUserMsg_ESArcanaCombo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_ESArcanaCombo
         * @static
         * @param {ICDOTAUserMsg_ESArcanaCombo} message CDOTAUserMsg_ESArcanaCombo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ESArcanaCombo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_ESArcanaCombo message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_ESArcanaCombo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_ESArcanaCombo} CDOTAUserMsg_ESArcanaCombo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ESArcanaCombo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_ESArcanaCombo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ehandle = reader.uint32();
                    break;
                case 2:
                    message.combo_count = reader.uint32();
                    break;
                case 3:
                    message.arcana_level = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_ESArcanaCombo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_ESArcanaCombo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_ESArcanaCombo} CDOTAUserMsg_ESArcanaCombo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ESArcanaCombo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_ESArcanaCombo message.
         * @function verify
         * @memberof CDOTAUserMsg_ESArcanaCombo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_ESArcanaCombo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ehandle != null && message.hasOwnProperty("ehandle"))
                if (!$util.isInteger(message.ehandle))
                    return "ehandle: integer expected";
            if (message.combo_count != null && message.hasOwnProperty("combo_count"))
                if (!$util.isInteger(message.combo_count))
                    return "combo_count: integer expected";
            if (message.arcana_level != null && message.hasOwnProperty("arcana_level"))
                if (!$util.isInteger(message.arcana_level))
                    return "arcana_level: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_ESArcanaCombo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_ESArcanaCombo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_ESArcanaCombo} CDOTAUserMsg_ESArcanaCombo
         */
        CDOTAUserMsg_ESArcanaCombo.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_ESArcanaCombo)
                return object;
            var message = new $root.CDOTAUserMsg_ESArcanaCombo();
            if (object.ehandle != null)
                message.ehandle = object.ehandle >>> 0;
            if (object.combo_count != null)
                message.combo_count = object.combo_count >>> 0;
            if (object.arcana_level != null)
                message.arcana_level = object.arcana_level >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_ESArcanaCombo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_ESArcanaCombo
         * @static
         * @param {CDOTAUserMsg_ESArcanaCombo} message CDOTAUserMsg_ESArcanaCombo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_ESArcanaCombo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ehandle = 0;
                object.combo_count = 0;
                object.arcana_level = 0;
            }
            if (message.ehandle != null && message.hasOwnProperty("ehandle"))
                object.ehandle = message.ehandle;
            if (message.combo_count != null && message.hasOwnProperty("combo_count"))
                object.combo_count = message.combo_count;
            if (message.arcana_level != null && message.hasOwnProperty("arcana_level"))
                object.arcana_level = message.arcana_level;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_ESArcanaCombo to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_ESArcanaCombo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_ESArcanaCombo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_ESArcanaCombo;
    })();
    
    $root.CDOTAUserMsg_ESArcanaComboSummary = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_ESArcanaComboSummary.
         * @exports ICDOTAUserMsg_ESArcanaComboSummary
         * @interface ICDOTAUserMsg_ESArcanaComboSummary
         * @property {number|null} [ehandle] CDOTAUserMsg_ESArcanaComboSummary ehandle
         * @property {number|null} [combo_count] CDOTAUserMsg_ESArcanaComboSummary combo_count
         * @property {number|null} [damage_amount] CDOTAUserMsg_ESArcanaComboSummary damage_amount
         */
    
        /**
         * Constructs a new CDOTAUserMsg_ESArcanaComboSummary.
         * @exports CDOTAUserMsg_ESArcanaComboSummary
         * @classdesc Represents a CDOTAUserMsg_ESArcanaComboSummary.
         * @implements ICDOTAUserMsg_ESArcanaComboSummary
         * @constructor
         * @param {ICDOTAUserMsg_ESArcanaComboSummary=} [properties] Properties to set
         */
        function CDOTAUserMsg_ESArcanaComboSummary(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_ESArcanaComboSummary ehandle.
         * @member {number} ehandle
         * @memberof CDOTAUserMsg_ESArcanaComboSummary
         * @instance
         */
        CDOTAUserMsg_ESArcanaComboSummary.prototype.ehandle = 0;
    
        /**
         * CDOTAUserMsg_ESArcanaComboSummary combo_count.
         * @member {number} combo_count
         * @memberof CDOTAUserMsg_ESArcanaComboSummary
         * @instance
         */
        CDOTAUserMsg_ESArcanaComboSummary.prototype.combo_count = 0;
    
        /**
         * CDOTAUserMsg_ESArcanaComboSummary damage_amount.
         * @member {number} damage_amount
         * @memberof CDOTAUserMsg_ESArcanaComboSummary
         * @instance
         */
        CDOTAUserMsg_ESArcanaComboSummary.prototype.damage_amount = 0;
    
        /**
         * Creates a new CDOTAUserMsg_ESArcanaComboSummary instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_ESArcanaComboSummary
         * @static
         * @param {ICDOTAUserMsg_ESArcanaComboSummary=} [properties] Properties to set
         * @returns {CDOTAUserMsg_ESArcanaComboSummary} CDOTAUserMsg_ESArcanaComboSummary instance
         */
        CDOTAUserMsg_ESArcanaComboSummary.create = function create(properties) {
            return new CDOTAUserMsg_ESArcanaComboSummary(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ESArcanaComboSummary message. Does not implicitly {@link CDOTAUserMsg_ESArcanaComboSummary.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_ESArcanaComboSummary
         * @static
         * @param {ICDOTAUserMsg_ESArcanaComboSummary} message CDOTAUserMsg_ESArcanaComboSummary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ESArcanaComboSummary.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ehandle != null && Object.hasOwnProperty.call(message, "ehandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ehandle);
            if (message.combo_count != null && Object.hasOwnProperty.call(message, "combo_count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.combo_count);
            if (message.damage_amount != null && Object.hasOwnProperty.call(message, "damage_amount"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.damage_amount);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ESArcanaComboSummary message, length delimited. Does not implicitly {@link CDOTAUserMsg_ESArcanaComboSummary.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_ESArcanaComboSummary
         * @static
         * @param {ICDOTAUserMsg_ESArcanaComboSummary} message CDOTAUserMsg_ESArcanaComboSummary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ESArcanaComboSummary.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_ESArcanaComboSummary message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_ESArcanaComboSummary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_ESArcanaComboSummary} CDOTAUserMsg_ESArcanaComboSummary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ESArcanaComboSummary.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_ESArcanaComboSummary();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ehandle = reader.uint32();
                    break;
                case 2:
                    message.combo_count = reader.uint32();
                    break;
                case 3:
                    message.damage_amount = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_ESArcanaComboSummary message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_ESArcanaComboSummary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_ESArcanaComboSummary} CDOTAUserMsg_ESArcanaComboSummary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ESArcanaComboSummary.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_ESArcanaComboSummary message.
         * @function verify
         * @memberof CDOTAUserMsg_ESArcanaComboSummary
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_ESArcanaComboSummary.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ehandle != null && message.hasOwnProperty("ehandle"))
                if (!$util.isInteger(message.ehandle))
                    return "ehandle: integer expected";
            if (message.combo_count != null && message.hasOwnProperty("combo_count"))
                if (!$util.isInteger(message.combo_count))
                    return "combo_count: integer expected";
            if (message.damage_amount != null && message.hasOwnProperty("damage_amount"))
                if (!$util.isInteger(message.damage_amount))
                    return "damage_amount: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_ESArcanaComboSummary message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_ESArcanaComboSummary
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_ESArcanaComboSummary} CDOTAUserMsg_ESArcanaComboSummary
         */
        CDOTAUserMsg_ESArcanaComboSummary.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_ESArcanaComboSummary)
                return object;
            var message = new $root.CDOTAUserMsg_ESArcanaComboSummary();
            if (object.ehandle != null)
                message.ehandle = object.ehandle >>> 0;
            if (object.combo_count != null)
                message.combo_count = object.combo_count >>> 0;
            if (object.damage_amount != null)
                message.damage_amount = object.damage_amount >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_ESArcanaComboSummary message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_ESArcanaComboSummary
         * @static
         * @param {CDOTAUserMsg_ESArcanaComboSummary} message CDOTAUserMsg_ESArcanaComboSummary
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_ESArcanaComboSummary.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ehandle = 0;
                object.combo_count = 0;
                object.damage_amount = 0;
            }
            if (message.ehandle != null && message.hasOwnProperty("ehandle"))
                object.ehandle = message.ehandle;
            if (message.combo_count != null && message.hasOwnProperty("combo_count"))
                object.combo_count = message.combo_count;
            if (message.damage_amount != null && message.hasOwnProperty("damage_amount"))
                object.damage_amount = message.damage_amount;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_ESArcanaComboSummary to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_ESArcanaComboSummary
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_ESArcanaComboSummary.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_ESArcanaComboSummary;
    })();
    
    $root.CDOTAUserMsg_OMArcanaCombo = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_OMArcanaCombo.
         * @exports ICDOTAUserMsg_OMArcanaCombo
         * @interface ICDOTAUserMsg_OMArcanaCombo
         * @property {number|null} [ehandle] CDOTAUserMsg_OMArcanaCombo ehandle
         * @property {number|null} [multicast_amount] CDOTAUserMsg_OMArcanaCombo multicast_amount
         * @property {number|null} [arcana_level] CDOTAUserMsg_OMArcanaCombo arcana_level
         * @property {number|null} [multicast_chance] CDOTAUserMsg_OMArcanaCombo multicast_chance
         */
    
        /**
         * Constructs a new CDOTAUserMsg_OMArcanaCombo.
         * @exports CDOTAUserMsg_OMArcanaCombo
         * @classdesc Represents a CDOTAUserMsg_OMArcanaCombo.
         * @implements ICDOTAUserMsg_OMArcanaCombo
         * @constructor
         * @param {ICDOTAUserMsg_OMArcanaCombo=} [properties] Properties to set
         */
        function CDOTAUserMsg_OMArcanaCombo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_OMArcanaCombo ehandle.
         * @member {number} ehandle
         * @memberof CDOTAUserMsg_OMArcanaCombo
         * @instance
         */
        CDOTAUserMsg_OMArcanaCombo.prototype.ehandle = 0;
    
        /**
         * CDOTAUserMsg_OMArcanaCombo multicast_amount.
         * @member {number} multicast_amount
         * @memberof CDOTAUserMsg_OMArcanaCombo
         * @instance
         */
        CDOTAUserMsg_OMArcanaCombo.prototype.multicast_amount = 0;
    
        /**
         * CDOTAUserMsg_OMArcanaCombo arcana_level.
         * @member {number} arcana_level
         * @memberof CDOTAUserMsg_OMArcanaCombo
         * @instance
         */
        CDOTAUserMsg_OMArcanaCombo.prototype.arcana_level = 0;
    
        /**
         * CDOTAUserMsg_OMArcanaCombo multicast_chance.
         * @member {number} multicast_chance
         * @memberof CDOTAUserMsg_OMArcanaCombo
         * @instance
         */
        CDOTAUserMsg_OMArcanaCombo.prototype.multicast_chance = 0;
    
        /**
         * Creates a new CDOTAUserMsg_OMArcanaCombo instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_OMArcanaCombo
         * @static
         * @param {ICDOTAUserMsg_OMArcanaCombo=} [properties] Properties to set
         * @returns {CDOTAUserMsg_OMArcanaCombo} CDOTAUserMsg_OMArcanaCombo instance
         */
        CDOTAUserMsg_OMArcanaCombo.create = function create(properties) {
            return new CDOTAUserMsg_OMArcanaCombo(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_OMArcanaCombo message. Does not implicitly {@link CDOTAUserMsg_OMArcanaCombo.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_OMArcanaCombo
         * @static
         * @param {ICDOTAUserMsg_OMArcanaCombo} message CDOTAUserMsg_OMArcanaCombo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_OMArcanaCombo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ehandle != null && Object.hasOwnProperty.call(message, "ehandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ehandle);
            if (message.multicast_amount != null && Object.hasOwnProperty.call(message, "multicast_amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.multicast_amount);
            if (message.arcana_level != null && Object.hasOwnProperty.call(message, "arcana_level"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.arcana_level);
            if (message.multicast_chance != null && Object.hasOwnProperty.call(message, "multicast_chance"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.multicast_chance);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_OMArcanaCombo message, length delimited. Does not implicitly {@link CDOTAUserMsg_OMArcanaCombo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_OMArcanaCombo
         * @static
         * @param {ICDOTAUserMsg_OMArcanaCombo} message CDOTAUserMsg_OMArcanaCombo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_OMArcanaCombo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_OMArcanaCombo message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_OMArcanaCombo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_OMArcanaCombo} CDOTAUserMsg_OMArcanaCombo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_OMArcanaCombo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_OMArcanaCombo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ehandle = reader.uint32();
                    break;
                case 2:
                    message.multicast_amount = reader.uint32();
                    break;
                case 3:
                    message.arcana_level = reader.uint32();
                    break;
                case 4:
                    message.multicast_chance = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_OMArcanaCombo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_OMArcanaCombo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_OMArcanaCombo} CDOTAUserMsg_OMArcanaCombo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_OMArcanaCombo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_OMArcanaCombo message.
         * @function verify
         * @memberof CDOTAUserMsg_OMArcanaCombo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_OMArcanaCombo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ehandle != null && message.hasOwnProperty("ehandle"))
                if (!$util.isInteger(message.ehandle))
                    return "ehandle: integer expected";
            if (message.multicast_amount != null && message.hasOwnProperty("multicast_amount"))
                if (!$util.isInteger(message.multicast_amount))
                    return "multicast_amount: integer expected";
            if (message.arcana_level != null && message.hasOwnProperty("arcana_level"))
                if (!$util.isInteger(message.arcana_level))
                    return "arcana_level: integer expected";
            if (message.multicast_chance != null && message.hasOwnProperty("multicast_chance"))
                if (!$util.isInteger(message.multicast_chance))
                    return "multicast_chance: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_OMArcanaCombo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_OMArcanaCombo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_OMArcanaCombo} CDOTAUserMsg_OMArcanaCombo
         */
        CDOTAUserMsg_OMArcanaCombo.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_OMArcanaCombo)
                return object;
            var message = new $root.CDOTAUserMsg_OMArcanaCombo();
            if (object.ehandle != null)
                message.ehandle = object.ehandle >>> 0;
            if (object.multicast_amount != null)
                message.multicast_amount = object.multicast_amount >>> 0;
            if (object.arcana_level != null)
                message.arcana_level = object.arcana_level >>> 0;
            if (object.multicast_chance != null)
                message.multicast_chance = object.multicast_chance >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_OMArcanaCombo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_OMArcanaCombo
         * @static
         * @param {CDOTAUserMsg_OMArcanaCombo} message CDOTAUserMsg_OMArcanaCombo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_OMArcanaCombo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ehandle = 0;
                object.multicast_amount = 0;
                object.arcana_level = 0;
                object.multicast_chance = 0;
            }
            if (message.ehandle != null && message.hasOwnProperty("ehandle"))
                object.ehandle = message.ehandle;
            if (message.multicast_amount != null && message.hasOwnProperty("multicast_amount"))
                object.multicast_amount = message.multicast_amount;
            if (message.arcana_level != null && message.hasOwnProperty("arcana_level"))
                object.arcana_level = message.arcana_level;
            if (message.multicast_chance != null && message.hasOwnProperty("multicast_chance"))
                object.multicast_chance = message.multicast_chance;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_OMArcanaCombo to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_OMArcanaCombo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_OMArcanaCombo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_OMArcanaCombo;
    })();
    
    $root.CDOTAUserMsg_HighFiveCompleted = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_HighFiveCompleted.
         * @exports ICDOTAUserMsg_HighFiveCompleted
         * @interface ICDOTAUserMsg_HighFiveCompleted
         * @property {number|null} [player_id_1] CDOTAUserMsg_HighFiveCompleted player_id_1
         * @property {number|null} [player_id_2] CDOTAUserMsg_HighFiveCompleted player_id_2
         */
    
        /**
         * Constructs a new CDOTAUserMsg_HighFiveCompleted.
         * @exports CDOTAUserMsg_HighFiveCompleted
         * @classdesc Represents a CDOTAUserMsg_HighFiveCompleted.
         * @implements ICDOTAUserMsg_HighFiveCompleted
         * @constructor
         * @param {ICDOTAUserMsg_HighFiveCompleted=} [properties] Properties to set
         */
        function CDOTAUserMsg_HighFiveCompleted(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_HighFiveCompleted player_id_1.
         * @member {number} player_id_1
         * @memberof CDOTAUserMsg_HighFiveCompleted
         * @instance
         */
        CDOTAUserMsg_HighFiveCompleted.prototype.player_id_1 = 0;
    
        /**
         * CDOTAUserMsg_HighFiveCompleted player_id_2.
         * @member {number} player_id_2
         * @memberof CDOTAUserMsg_HighFiveCompleted
         * @instance
         */
        CDOTAUserMsg_HighFiveCompleted.prototype.player_id_2 = 0;
    
        /**
         * Creates a new CDOTAUserMsg_HighFiveCompleted instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_HighFiveCompleted
         * @static
         * @param {ICDOTAUserMsg_HighFiveCompleted=} [properties] Properties to set
         * @returns {CDOTAUserMsg_HighFiveCompleted} CDOTAUserMsg_HighFiveCompleted instance
         */
        CDOTAUserMsg_HighFiveCompleted.create = function create(properties) {
            return new CDOTAUserMsg_HighFiveCompleted(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_HighFiveCompleted message. Does not implicitly {@link CDOTAUserMsg_HighFiveCompleted.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_HighFiveCompleted
         * @static
         * @param {ICDOTAUserMsg_HighFiveCompleted} message CDOTAUserMsg_HighFiveCompleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_HighFiveCompleted.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id_1 != null && Object.hasOwnProperty.call(message, "player_id_1"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id_1);
            if (message.player_id_2 != null && Object.hasOwnProperty.call(message, "player_id_2"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.player_id_2);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_HighFiveCompleted message, length delimited. Does not implicitly {@link CDOTAUserMsg_HighFiveCompleted.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_HighFiveCompleted
         * @static
         * @param {ICDOTAUserMsg_HighFiveCompleted} message CDOTAUserMsg_HighFiveCompleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_HighFiveCompleted.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_HighFiveCompleted message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_HighFiveCompleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_HighFiveCompleted} CDOTAUserMsg_HighFiveCompleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_HighFiveCompleted.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_HighFiveCompleted();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id_1 = reader.uint32();
                    break;
                case 2:
                    message.player_id_2 = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_HighFiveCompleted message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_HighFiveCompleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_HighFiveCompleted} CDOTAUserMsg_HighFiveCompleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_HighFiveCompleted.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_HighFiveCompleted message.
         * @function verify
         * @memberof CDOTAUserMsg_HighFiveCompleted
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_HighFiveCompleted.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id_1 != null && message.hasOwnProperty("player_id_1"))
                if (!$util.isInteger(message.player_id_1))
                    return "player_id_1: integer expected";
            if (message.player_id_2 != null && message.hasOwnProperty("player_id_2"))
                if (!$util.isInteger(message.player_id_2))
                    return "player_id_2: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_HighFiveCompleted message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_HighFiveCompleted
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_HighFiveCompleted} CDOTAUserMsg_HighFiveCompleted
         */
        CDOTAUserMsg_HighFiveCompleted.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_HighFiveCompleted)
                return object;
            var message = new $root.CDOTAUserMsg_HighFiveCompleted();
            if (object.player_id_1 != null)
                message.player_id_1 = object.player_id_1 >>> 0;
            if (object.player_id_2 != null)
                message.player_id_2 = object.player_id_2 >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_HighFiveCompleted message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_HighFiveCompleted
         * @static
         * @param {CDOTAUserMsg_HighFiveCompleted} message CDOTAUserMsg_HighFiveCompleted
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_HighFiveCompleted.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id_1 = 0;
                object.player_id_2 = 0;
            }
            if (message.player_id_1 != null && message.hasOwnProperty("player_id_1"))
                object.player_id_1 = message.player_id_1;
            if (message.player_id_2 != null && message.hasOwnProperty("player_id_2"))
                object.player_id_2 = message.player_id_2;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_HighFiveCompleted to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_HighFiveCompleted
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_HighFiveCompleted.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_HighFiveCompleted;
    })();
    
    $root.CDOTAUserMsg_HighFiveLeftHanging = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_HighFiveLeftHanging.
         * @exports ICDOTAUserMsg_HighFiveLeftHanging
         * @interface ICDOTAUserMsg_HighFiveLeftHanging
         * @property {number|null} [player_id] CDOTAUserMsg_HighFiveLeftHanging player_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_HighFiveLeftHanging.
         * @exports CDOTAUserMsg_HighFiveLeftHanging
         * @classdesc Represents a CDOTAUserMsg_HighFiveLeftHanging.
         * @implements ICDOTAUserMsg_HighFiveLeftHanging
         * @constructor
         * @param {ICDOTAUserMsg_HighFiveLeftHanging=} [properties] Properties to set
         */
        function CDOTAUserMsg_HighFiveLeftHanging(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_HighFiveLeftHanging player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_HighFiveLeftHanging
         * @instance
         */
        CDOTAUserMsg_HighFiveLeftHanging.prototype.player_id = 0;
    
        /**
         * Creates a new CDOTAUserMsg_HighFiveLeftHanging instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_HighFiveLeftHanging
         * @static
         * @param {ICDOTAUserMsg_HighFiveLeftHanging=} [properties] Properties to set
         * @returns {CDOTAUserMsg_HighFiveLeftHanging} CDOTAUserMsg_HighFiveLeftHanging instance
         */
        CDOTAUserMsg_HighFiveLeftHanging.create = function create(properties) {
            return new CDOTAUserMsg_HighFiveLeftHanging(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_HighFiveLeftHanging message. Does not implicitly {@link CDOTAUserMsg_HighFiveLeftHanging.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_HighFiveLeftHanging
         * @static
         * @param {ICDOTAUserMsg_HighFiveLeftHanging} message CDOTAUserMsg_HighFiveLeftHanging message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_HighFiveLeftHanging.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_HighFiveLeftHanging message, length delimited. Does not implicitly {@link CDOTAUserMsg_HighFiveLeftHanging.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_HighFiveLeftHanging
         * @static
         * @param {ICDOTAUserMsg_HighFiveLeftHanging} message CDOTAUserMsg_HighFiveLeftHanging message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_HighFiveLeftHanging.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_HighFiveLeftHanging message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_HighFiveLeftHanging
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_HighFiveLeftHanging} CDOTAUserMsg_HighFiveLeftHanging
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_HighFiveLeftHanging.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_HighFiveLeftHanging();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_HighFiveLeftHanging message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_HighFiveLeftHanging
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_HighFiveLeftHanging} CDOTAUserMsg_HighFiveLeftHanging
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_HighFiveLeftHanging.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_HighFiveLeftHanging message.
         * @function verify
         * @memberof CDOTAUserMsg_HighFiveLeftHanging
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_HighFiveLeftHanging.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_HighFiveLeftHanging message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_HighFiveLeftHanging
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_HighFiveLeftHanging} CDOTAUserMsg_HighFiveLeftHanging
         */
        CDOTAUserMsg_HighFiveLeftHanging.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_HighFiveLeftHanging)
                return object;
            var message = new $root.CDOTAUserMsg_HighFiveLeftHanging();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_HighFiveLeftHanging message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_HighFiveLeftHanging
         * @static
         * @param {CDOTAUserMsg_HighFiveLeftHanging} message CDOTAUserMsg_HighFiveLeftHanging
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_HighFiveLeftHanging.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.player_id = 0;
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_HighFiveLeftHanging to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_HighFiveLeftHanging
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_HighFiveLeftHanging.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_HighFiveLeftHanging;
    })();
    
    $root.CDOTAUserMsg_ShovelUnearth = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_ShovelUnearth.
         * @exports ICDOTAUserMsg_ShovelUnearth
         * @interface ICDOTAUserMsg_ShovelUnearth
         * @property {number|null} [player_id] CDOTAUserMsg_ShovelUnearth player_id
         * @property {boolean|null} [all_chat] CDOTAUserMsg_ShovelUnearth all_chat
         * @property {string|null} [locstring] CDOTAUserMsg_ShovelUnearth locstring
         * @property {number|null} [quantity] CDOTAUserMsg_ShovelUnearth quantity
         */
    
        /**
         * Constructs a new CDOTAUserMsg_ShovelUnearth.
         * @exports CDOTAUserMsg_ShovelUnearth
         * @classdesc Represents a CDOTAUserMsg_ShovelUnearth.
         * @implements ICDOTAUserMsg_ShovelUnearth
         * @constructor
         * @param {ICDOTAUserMsg_ShovelUnearth=} [properties] Properties to set
         */
        function CDOTAUserMsg_ShovelUnearth(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_ShovelUnearth player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_ShovelUnearth
         * @instance
         */
        CDOTAUserMsg_ShovelUnearth.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_ShovelUnearth all_chat.
         * @member {boolean} all_chat
         * @memberof CDOTAUserMsg_ShovelUnearth
         * @instance
         */
        CDOTAUserMsg_ShovelUnearth.prototype.all_chat = false;
    
        /**
         * CDOTAUserMsg_ShovelUnearth locstring.
         * @member {string} locstring
         * @memberof CDOTAUserMsg_ShovelUnearth
         * @instance
         */
        CDOTAUserMsg_ShovelUnearth.prototype.locstring = "";
    
        /**
         * CDOTAUserMsg_ShovelUnearth quantity.
         * @member {number} quantity
         * @memberof CDOTAUserMsg_ShovelUnearth
         * @instance
         */
        CDOTAUserMsg_ShovelUnearth.prototype.quantity = 0;
    
        /**
         * Creates a new CDOTAUserMsg_ShovelUnearth instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_ShovelUnearth
         * @static
         * @param {ICDOTAUserMsg_ShovelUnearth=} [properties] Properties to set
         * @returns {CDOTAUserMsg_ShovelUnearth} CDOTAUserMsg_ShovelUnearth instance
         */
        CDOTAUserMsg_ShovelUnearth.create = function create(properties) {
            return new CDOTAUserMsg_ShovelUnearth(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ShovelUnearth message. Does not implicitly {@link CDOTAUserMsg_ShovelUnearth.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_ShovelUnearth
         * @static
         * @param {ICDOTAUserMsg_ShovelUnearth} message CDOTAUserMsg_ShovelUnearth message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ShovelUnearth.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.all_chat != null && Object.hasOwnProperty.call(message, "all_chat"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.all_chat);
            if (message.locstring != null && Object.hasOwnProperty.call(message, "locstring"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.locstring);
            if (message.quantity != null && Object.hasOwnProperty.call(message, "quantity"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.quantity);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_ShovelUnearth message, length delimited. Does not implicitly {@link CDOTAUserMsg_ShovelUnearth.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_ShovelUnearth
         * @static
         * @param {ICDOTAUserMsg_ShovelUnearth} message CDOTAUserMsg_ShovelUnearth message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_ShovelUnearth.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_ShovelUnearth message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_ShovelUnearth
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_ShovelUnearth} CDOTAUserMsg_ShovelUnearth
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ShovelUnearth.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_ShovelUnearth();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.all_chat = reader.bool();
                    break;
                case 3:
                    message.locstring = reader.string();
                    break;
                case 4:
                    message.quantity = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_ShovelUnearth message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_ShovelUnearth
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_ShovelUnearth} CDOTAUserMsg_ShovelUnearth
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_ShovelUnearth.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_ShovelUnearth message.
         * @function verify
         * @memberof CDOTAUserMsg_ShovelUnearth
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_ShovelUnearth.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.all_chat != null && message.hasOwnProperty("all_chat"))
                if (typeof message.all_chat !== "boolean")
                    return "all_chat: boolean expected";
            if (message.locstring != null && message.hasOwnProperty("locstring"))
                if (!$util.isString(message.locstring))
                    return "locstring: string expected";
            if (message.quantity != null && message.hasOwnProperty("quantity"))
                if (!$util.isInteger(message.quantity))
                    return "quantity: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_ShovelUnearth message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_ShovelUnearth
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_ShovelUnearth} CDOTAUserMsg_ShovelUnearth
         */
        CDOTAUserMsg_ShovelUnearth.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_ShovelUnearth)
                return object;
            var message = new $root.CDOTAUserMsg_ShovelUnearth();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.all_chat != null)
                message.all_chat = Boolean(object.all_chat);
            if (object.locstring != null)
                message.locstring = String(object.locstring);
            if (object.quantity != null)
                message.quantity = object.quantity >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_ShovelUnearth message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_ShovelUnearth
         * @static
         * @param {CDOTAUserMsg_ShovelUnearth} message CDOTAUserMsg_ShovelUnearth
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_ShovelUnearth.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.all_chat = false;
                object.locstring = "";
                object.quantity = 0;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.all_chat != null && message.hasOwnProperty("all_chat"))
                object.all_chat = message.all_chat;
            if (message.locstring != null && message.hasOwnProperty("locstring"))
                object.locstring = message.locstring;
            if (message.quantity != null && message.hasOwnProperty("quantity"))
                object.quantity = message.quantity;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_ShovelUnearth to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_ShovelUnearth
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_ShovelUnearth.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_ShovelUnearth;
    })();
    
    $root.CDOTAUserMsg_AllStarEvent = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_AllStarEvent.
         * @exports ICDOTAUserMsg_AllStarEvent
         * @interface ICDOTAUserMsg_AllStarEvent
         * @property {number|null} [source_player_id] CDOTAUserMsg_AllStarEvent source_player_id
         * @property {number|null} [target_player_id] CDOTAUserMsg_AllStarEvent target_player_id
         * @property {number|null} [point_amount] CDOTAUserMsg_AllStarEvent point_amount
         * @property {number|null} [event_id] CDOTAUserMsg_AllStarEvent event_id
         * @property {Array.<CDOTAUserMsg_AllStarEvent.IPlayerScore>|null} [player_scores] CDOTAUserMsg_AllStarEvent player_scores
         */
    
        /**
         * Constructs a new CDOTAUserMsg_AllStarEvent.
         * @exports CDOTAUserMsg_AllStarEvent
         * @classdesc Represents a CDOTAUserMsg_AllStarEvent.
         * @implements ICDOTAUserMsg_AllStarEvent
         * @constructor
         * @param {ICDOTAUserMsg_AllStarEvent=} [properties] Properties to set
         */
        function CDOTAUserMsg_AllStarEvent(properties) {
            this.player_scores = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_AllStarEvent source_player_id.
         * @member {number} source_player_id
         * @memberof CDOTAUserMsg_AllStarEvent
         * @instance
         */
        CDOTAUserMsg_AllStarEvent.prototype.source_player_id = 0;
    
        /**
         * CDOTAUserMsg_AllStarEvent target_player_id.
         * @member {number} target_player_id
         * @memberof CDOTAUserMsg_AllStarEvent
         * @instance
         */
        CDOTAUserMsg_AllStarEvent.prototype.target_player_id = 0;
    
        /**
         * CDOTAUserMsg_AllStarEvent point_amount.
         * @member {number} point_amount
         * @memberof CDOTAUserMsg_AllStarEvent
         * @instance
         */
        CDOTAUserMsg_AllStarEvent.prototype.point_amount = 0;
    
        /**
         * CDOTAUserMsg_AllStarEvent event_id.
         * @member {number} event_id
         * @memberof CDOTAUserMsg_AllStarEvent
         * @instance
         */
        CDOTAUserMsg_AllStarEvent.prototype.event_id = 0;
    
        /**
         * CDOTAUserMsg_AllStarEvent player_scores.
         * @member {Array.<CDOTAUserMsg_AllStarEvent.IPlayerScore>} player_scores
         * @memberof CDOTAUserMsg_AllStarEvent
         * @instance
         */
        CDOTAUserMsg_AllStarEvent.prototype.player_scores = $util.emptyArray;
    
        /**
         * Creates a new CDOTAUserMsg_AllStarEvent instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_AllStarEvent
         * @static
         * @param {ICDOTAUserMsg_AllStarEvent=} [properties] Properties to set
         * @returns {CDOTAUserMsg_AllStarEvent} CDOTAUserMsg_AllStarEvent instance
         */
        CDOTAUserMsg_AllStarEvent.create = function create(properties) {
            return new CDOTAUserMsg_AllStarEvent(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_AllStarEvent message. Does not implicitly {@link CDOTAUserMsg_AllStarEvent.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_AllStarEvent
         * @static
         * @param {ICDOTAUserMsg_AllStarEvent} message CDOTAUserMsg_AllStarEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_AllStarEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.source_player_id != null && Object.hasOwnProperty.call(message, "source_player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.source_player_id);
            if (message.target_player_id != null && Object.hasOwnProperty.call(message, "target_player_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.target_player_id);
            if (message.point_amount != null && Object.hasOwnProperty.call(message, "point_amount"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.point_amount);
            if (message.event_id != null && Object.hasOwnProperty.call(message, "event_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.event_id);
            if (message.player_scores != null && message.player_scores.length)
                for (var i = 0; i < message.player_scores.length; ++i)
                    $root.CDOTAUserMsg_AllStarEvent.PlayerScore.encode(message.player_scores[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_AllStarEvent message, length delimited. Does not implicitly {@link CDOTAUserMsg_AllStarEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_AllStarEvent
         * @static
         * @param {ICDOTAUserMsg_AllStarEvent} message CDOTAUserMsg_AllStarEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_AllStarEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_AllStarEvent message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_AllStarEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_AllStarEvent} CDOTAUserMsg_AllStarEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_AllStarEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_AllStarEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.source_player_id = reader.int32();
                    break;
                case 2:
                    message.target_player_id = reader.int32();
                    break;
                case 3:
                    message.point_amount = reader.uint32();
                    break;
                case 4:
                    message.event_id = reader.uint32();
                    break;
                case 5:
                    if (!(message.player_scores && message.player_scores.length))
                        message.player_scores = [];
                    message.player_scores.push($root.CDOTAUserMsg_AllStarEvent.PlayerScore.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_AllStarEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_AllStarEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_AllStarEvent} CDOTAUserMsg_AllStarEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_AllStarEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_AllStarEvent message.
         * @function verify
         * @memberof CDOTAUserMsg_AllStarEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_AllStarEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.source_player_id != null && message.hasOwnProperty("source_player_id"))
                if (!$util.isInteger(message.source_player_id))
                    return "source_player_id: integer expected";
            if (message.target_player_id != null && message.hasOwnProperty("target_player_id"))
                if (!$util.isInteger(message.target_player_id))
                    return "target_player_id: integer expected";
            if (message.point_amount != null && message.hasOwnProperty("point_amount"))
                if (!$util.isInteger(message.point_amount))
                    return "point_amount: integer expected";
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                if (!$util.isInteger(message.event_id))
                    return "event_id: integer expected";
            if (message.player_scores != null && message.hasOwnProperty("player_scores")) {
                if (!Array.isArray(message.player_scores))
                    return "player_scores: array expected";
                for (var i = 0; i < message.player_scores.length; ++i) {
                    var error = $root.CDOTAUserMsg_AllStarEvent.PlayerScore.verify(message.player_scores[i]);
                    if (error)
                        return "player_scores." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_AllStarEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_AllStarEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_AllStarEvent} CDOTAUserMsg_AllStarEvent
         */
        CDOTAUserMsg_AllStarEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_AllStarEvent)
                return object;
            var message = new $root.CDOTAUserMsg_AllStarEvent();
            if (object.source_player_id != null)
                message.source_player_id = object.source_player_id | 0;
            if (object.target_player_id != null)
                message.target_player_id = object.target_player_id | 0;
            if (object.point_amount != null)
                message.point_amount = object.point_amount >>> 0;
            if (object.event_id != null)
                message.event_id = object.event_id >>> 0;
            if (object.player_scores) {
                if (!Array.isArray(object.player_scores))
                    throw TypeError(".CDOTAUserMsg_AllStarEvent.player_scores: array expected");
                message.player_scores = [];
                for (var i = 0; i < object.player_scores.length; ++i) {
                    if (typeof object.player_scores[i] !== "object")
                        throw TypeError(".CDOTAUserMsg_AllStarEvent.player_scores: object expected");
                    message.player_scores[i] = $root.CDOTAUserMsg_AllStarEvent.PlayerScore.fromObject(object.player_scores[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_AllStarEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_AllStarEvent
         * @static
         * @param {CDOTAUserMsg_AllStarEvent} message CDOTAUserMsg_AllStarEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_AllStarEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.player_scores = [];
            if (options.defaults) {
                object.source_player_id = 0;
                object.target_player_id = 0;
                object.point_amount = 0;
                object.event_id = 0;
            }
            if (message.source_player_id != null && message.hasOwnProperty("source_player_id"))
                object.source_player_id = message.source_player_id;
            if (message.target_player_id != null && message.hasOwnProperty("target_player_id"))
                object.target_player_id = message.target_player_id;
            if (message.point_amount != null && message.hasOwnProperty("point_amount"))
                object.point_amount = message.point_amount;
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                object.event_id = message.event_id;
            if (message.player_scores && message.player_scores.length) {
                object.player_scores = [];
                for (var j = 0; j < message.player_scores.length; ++j)
                    object.player_scores[j] = $root.CDOTAUserMsg_AllStarEvent.PlayerScore.toObject(message.player_scores[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_AllStarEvent to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_AllStarEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_AllStarEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CDOTAUserMsg_AllStarEvent.PlayerScore = (function() {
    
            /**
             * Properties of a PlayerScore.
             * @memberof CDOTAUserMsg_AllStarEvent
             * @interface IPlayerScore
             * @property {number|null} [player_id] PlayerScore player_id
             * @property {number|null} [score_sans_kda] PlayerScore score_sans_kda
             */
    
            /**
             * Constructs a new PlayerScore.
             * @memberof CDOTAUserMsg_AllStarEvent
             * @classdesc Represents a PlayerScore.
             * @implements IPlayerScore
             * @constructor
             * @param {CDOTAUserMsg_AllStarEvent.IPlayerScore=} [properties] Properties to set
             */
            function PlayerScore(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PlayerScore player_id.
             * @member {number} player_id
             * @memberof CDOTAUserMsg_AllStarEvent.PlayerScore
             * @instance
             */
            PlayerScore.prototype.player_id = 0;
    
            /**
             * PlayerScore score_sans_kda.
             * @member {number} score_sans_kda
             * @memberof CDOTAUserMsg_AllStarEvent.PlayerScore
             * @instance
             */
            PlayerScore.prototype.score_sans_kda = 0;
    
            /**
             * Creates a new PlayerScore instance using the specified properties.
             * @function create
             * @memberof CDOTAUserMsg_AllStarEvent.PlayerScore
             * @static
             * @param {CDOTAUserMsg_AllStarEvent.IPlayerScore=} [properties] Properties to set
             * @returns {CDOTAUserMsg_AllStarEvent.PlayerScore} PlayerScore instance
             */
            PlayerScore.create = function create(properties) {
                return new PlayerScore(properties);
            };
    
            /**
             * Encodes the specified PlayerScore message. Does not implicitly {@link CDOTAUserMsg_AllStarEvent.PlayerScore.verify|verify} messages.
             * @function encode
             * @memberof CDOTAUserMsg_AllStarEvent.PlayerScore
             * @static
             * @param {CDOTAUserMsg_AllStarEvent.IPlayerScore} message PlayerScore message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayerScore.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.player_id);
                if (message.score_sans_kda != null && Object.hasOwnProperty.call(message, "score_sans_kda"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.score_sans_kda);
                return writer;
            };
    
            /**
             * Encodes the specified PlayerScore message, length delimited. Does not implicitly {@link CDOTAUserMsg_AllStarEvent.PlayerScore.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTAUserMsg_AllStarEvent.PlayerScore
             * @static
             * @param {CDOTAUserMsg_AllStarEvent.IPlayerScore} message PlayerScore message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayerScore.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PlayerScore message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTAUserMsg_AllStarEvent.PlayerScore
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTAUserMsg_AllStarEvent.PlayerScore} PlayerScore
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayerScore.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_AllStarEvent.PlayerScore();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.player_id = reader.int32();
                        break;
                    case 2:
                        message.score_sans_kda = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PlayerScore message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTAUserMsg_AllStarEvent.PlayerScore
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTAUserMsg_AllStarEvent.PlayerScore} PlayerScore
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayerScore.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PlayerScore message.
             * @function verify
             * @memberof CDOTAUserMsg_AllStarEvent.PlayerScore
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PlayerScore.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.player_id != null && message.hasOwnProperty("player_id"))
                    if (!$util.isInteger(message.player_id))
                        return "player_id: integer expected";
                if (message.score_sans_kda != null && message.hasOwnProperty("score_sans_kda"))
                    if (!$util.isInteger(message.score_sans_kda))
                        return "score_sans_kda: integer expected";
                return null;
            };
    
            /**
             * Creates a PlayerScore message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTAUserMsg_AllStarEvent.PlayerScore
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTAUserMsg_AllStarEvent.PlayerScore} PlayerScore
             */
            PlayerScore.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTAUserMsg_AllStarEvent.PlayerScore)
                    return object;
                var message = new $root.CDOTAUserMsg_AllStarEvent.PlayerScore();
                if (object.player_id != null)
                    message.player_id = object.player_id | 0;
                if (object.score_sans_kda != null)
                    message.score_sans_kda = object.score_sans_kda >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a PlayerScore message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTAUserMsg_AllStarEvent.PlayerScore
             * @static
             * @param {CDOTAUserMsg_AllStarEvent.PlayerScore} message PlayerScore
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PlayerScore.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.player_id = 0;
                    object.score_sans_kda = 0;
                }
                if (message.player_id != null && message.hasOwnProperty("player_id"))
                    object.player_id = message.player_id;
                if (message.score_sans_kda != null && message.hasOwnProperty("score_sans_kda"))
                    object.score_sans_kda = message.score_sans_kda;
                return object;
            };
    
            /**
             * Converts this PlayerScore to JSON.
             * @function toJSON
             * @memberof CDOTAUserMsg_AllStarEvent.PlayerScore
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PlayerScore.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PlayerScore;
        })();
    
        return CDOTAUserMsg_AllStarEvent;
    })();
    
    $root.CDOTAUserMsg_QueuedOrderRemoved = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_QueuedOrderRemoved.
         * @exports ICDOTAUserMsg_QueuedOrderRemoved
         * @interface ICDOTAUserMsg_QueuedOrderRemoved
         * @property {Array.<number>|null} [unit_order_sequence] CDOTAUserMsg_QueuedOrderRemoved unit_order_sequence
         */
    
        /**
         * Constructs a new CDOTAUserMsg_QueuedOrderRemoved.
         * @exports CDOTAUserMsg_QueuedOrderRemoved
         * @classdesc Represents a CDOTAUserMsg_QueuedOrderRemoved.
         * @implements ICDOTAUserMsg_QueuedOrderRemoved
         * @constructor
         * @param {ICDOTAUserMsg_QueuedOrderRemoved=} [properties] Properties to set
         */
        function CDOTAUserMsg_QueuedOrderRemoved(properties) {
            this.unit_order_sequence = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_QueuedOrderRemoved unit_order_sequence.
         * @member {Array.<number>} unit_order_sequence
         * @memberof CDOTAUserMsg_QueuedOrderRemoved
         * @instance
         */
        CDOTAUserMsg_QueuedOrderRemoved.prototype.unit_order_sequence = $util.emptyArray;
    
        /**
         * Creates a new CDOTAUserMsg_QueuedOrderRemoved instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_QueuedOrderRemoved
         * @static
         * @param {ICDOTAUserMsg_QueuedOrderRemoved=} [properties] Properties to set
         * @returns {CDOTAUserMsg_QueuedOrderRemoved} CDOTAUserMsg_QueuedOrderRemoved instance
         */
        CDOTAUserMsg_QueuedOrderRemoved.create = function create(properties) {
            return new CDOTAUserMsg_QueuedOrderRemoved(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_QueuedOrderRemoved message. Does not implicitly {@link CDOTAUserMsg_QueuedOrderRemoved.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_QueuedOrderRemoved
         * @static
         * @param {ICDOTAUserMsg_QueuedOrderRemoved} message CDOTAUserMsg_QueuedOrderRemoved message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_QueuedOrderRemoved.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.unit_order_sequence != null && message.unit_order_sequence.length)
                for (var i = 0; i < message.unit_order_sequence.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.unit_order_sequence[i]);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_QueuedOrderRemoved message, length delimited. Does not implicitly {@link CDOTAUserMsg_QueuedOrderRemoved.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_QueuedOrderRemoved
         * @static
         * @param {ICDOTAUserMsg_QueuedOrderRemoved} message CDOTAUserMsg_QueuedOrderRemoved message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_QueuedOrderRemoved.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_QueuedOrderRemoved message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_QueuedOrderRemoved
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_QueuedOrderRemoved} CDOTAUserMsg_QueuedOrderRemoved
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_QueuedOrderRemoved.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_QueuedOrderRemoved();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.unit_order_sequence && message.unit_order_sequence.length))
                        message.unit_order_sequence = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.unit_order_sequence.push(reader.uint32());
                    } else
                        message.unit_order_sequence.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_QueuedOrderRemoved message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_QueuedOrderRemoved
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_QueuedOrderRemoved} CDOTAUserMsg_QueuedOrderRemoved
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_QueuedOrderRemoved.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_QueuedOrderRemoved message.
         * @function verify
         * @memberof CDOTAUserMsg_QueuedOrderRemoved
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_QueuedOrderRemoved.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.unit_order_sequence != null && message.hasOwnProperty("unit_order_sequence")) {
                if (!Array.isArray(message.unit_order_sequence))
                    return "unit_order_sequence: array expected";
                for (var i = 0; i < message.unit_order_sequence.length; ++i)
                    if (!$util.isInteger(message.unit_order_sequence[i]))
                        return "unit_order_sequence: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_QueuedOrderRemoved message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_QueuedOrderRemoved
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_QueuedOrderRemoved} CDOTAUserMsg_QueuedOrderRemoved
         */
        CDOTAUserMsg_QueuedOrderRemoved.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_QueuedOrderRemoved)
                return object;
            var message = new $root.CDOTAUserMsg_QueuedOrderRemoved();
            if (object.unit_order_sequence) {
                if (!Array.isArray(object.unit_order_sequence))
                    throw TypeError(".CDOTAUserMsg_QueuedOrderRemoved.unit_order_sequence: array expected");
                message.unit_order_sequence = [];
                for (var i = 0; i < object.unit_order_sequence.length; ++i)
                    message.unit_order_sequence[i] = object.unit_order_sequence[i] >>> 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_QueuedOrderRemoved message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_QueuedOrderRemoved
         * @static
         * @param {CDOTAUserMsg_QueuedOrderRemoved} message CDOTAUserMsg_QueuedOrderRemoved
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_QueuedOrderRemoved.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.unit_order_sequence = [];
            if (message.unit_order_sequence && message.unit_order_sequence.length) {
                object.unit_order_sequence = [];
                for (var j = 0; j < message.unit_order_sequence.length; ++j)
                    object.unit_order_sequence[j] = message.unit_order_sequence[j];
            }
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_QueuedOrderRemoved to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_QueuedOrderRemoved
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_QueuedOrderRemoved.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_QueuedOrderRemoved;
    })();
    
    $root.CDOTAUserMsg_DebugChallenge = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_DebugChallenge.
         * @exports ICDOTAUserMsg_DebugChallenge
         * @interface ICDOTAUserMsg_DebugChallenge
         * @property {number} challenge_type CDOTAUserMsg_DebugChallenge challenge_type
         * @property {number} challenge_query_id CDOTAUserMsg_DebugChallenge challenge_query_id
         * @property {number} event_id CDOTAUserMsg_DebugChallenge event_id
         * @property {number|null} [instance_id] CDOTAUserMsg_DebugChallenge instance_id
         * @property {number|null} [challenge_var_0] CDOTAUserMsg_DebugChallenge challenge_var_0
         * @property {number|null} [challenge_var_1] CDOTAUserMsg_DebugChallenge challenge_var_1
         * @property {number|null} [challenge_max_rank] CDOTAUserMsg_DebugChallenge challenge_max_rank
         */
    
        /**
         * Constructs a new CDOTAUserMsg_DebugChallenge.
         * @exports CDOTAUserMsg_DebugChallenge
         * @classdesc Represents a CDOTAUserMsg_DebugChallenge.
         * @implements ICDOTAUserMsg_DebugChallenge
         * @constructor
         * @param {ICDOTAUserMsg_DebugChallenge=} [properties] Properties to set
         */
        function CDOTAUserMsg_DebugChallenge(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_DebugChallenge challenge_type.
         * @member {number} challenge_type
         * @memberof CDOTAUserMsg_DebugChallenge
         * @instance
         */
        CDOTAUserMsg_DebugChallenge.prototype.challenge_type = 0;
    
        /**
         * CDOTAUserMsg_DebugChallenge challenge_query_id.
         * @member {number} challenge_query_id
         * @memberof CDOTAUserMsg_DebugChallenge
         * @instance
         */
        CDOTAUserMsg_DebugChallenge.prototype.challenge_query_id = 0;
    
        /**
         * CDOTAUserMsg_DebugChallenge event_id.
         * @member {number} event_id
         * @memberof CDOTAUserMsg_DebugChallenge
         * @instance
         */
        CDOTAUserMsg_DebugChallenge.prototype.event_id = 0;
    
        /**
         * CDOTAUserMsg_DebugChallenge instance_id.
         * @member {number} instance_id
         * @memberof CDOTAUserMsg_DebugChallenge
         * @instance
         */
        CDOTAUserMsg_DebugChallenge.prototype.instance_id = 0;
    
        /**
         * CDOTAUserMsg_DebugChallenge challenge_var_0.
         * @member {number} challenge_var_0
         * @memberof CDOTAUserMsg_DebugChallenge
         * @instance
         */
        CDOTAUserMsg_DebugChallenge.prototype.challenge_var_0 = 0;
    
        /**
         * CDOTAUserMsg_DebugChallenge challenge_var_1.
         * @member {number} challenge_var_1
         * @memberof CDOTAUserMsg_DebugChallenge
         * @instance
         */
        CDOTAUserMsg_DebugChallenge.prototype.challenge_var_1 = 0;
    
        /**
         * CDOTAUserMsg_DebugChallenge challenge_max_rank.
         * @member {number} challenge_max_rank
         * @memberof CDOTAUserMsg_DebugChallenge
         * @instance
         */
        CDOTAUserMsg_DebugChallenge.prototype.challenge_max_rank = 0;
    
        /**
         * Creates a new CDOTAUserMsg_DebugChallenge instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_DebugChallenge
         * @static
         * @param {ICDOTAUserMsg_DebugChallenge=} [properties] Properties to set
         * @returns {CDOTAUserMsg_DebugChallenge} CDOTAUserMsg_DebugChallenge instance
         */
        CDOTAUserMsg_DebugChallenge.create = function create(properties) {
            return new CDOTAUserMsg_DebugChallenge(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_DebugChallenge message. Does not implicitly {@link CDOTAUserMsg_DebugChallenge.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_DebugChallenge
         * @static
         * @param {ICDOTAUserMsg_DebugChallenge} message CDOTAUserMsg_DebugChallenge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_DebugChallenge.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.challenge_type);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.challenge_query_id);
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.event_id);
            if (message.instance_id != null && Object.hasOwnProperty.call(message, "instance_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.instance_id);
            if (message.challenge_var_0 != null && Object.hasOwnProperty.call(message, "challenge_var_0"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.challenge_var_0);
            if (message.challenge_var_1 != null && Object.hasOwnProperty.call(message, "challenge_var_1"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.challenge_var_1);
            if (message.challenge_max_rank != null && Object.hasOwnProperty.call(message, "challenge_max_rank"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.challenge_max_rank);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_DebugChallenge message, length delimited. Does not implicitly {@link CDOTAUserMsg_DebugChallenge.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_DebugChallenge
         * @static
         * @param {ICDOTAUserMsg_DebugChallenge} message CDOTAUserMsg_DebugChallenge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_DebugChallenge.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_DebugChallenge message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_DebugChallenge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_DebugChallenge} CDOTAUserMsg_DebugChallenge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_DebugChallenge.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_DebugChallenge();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.challenge_type = reader.uint32();
                    break;
                case 2:
                    message.challenge_query_id = reader.uint32();
                    break;
                case 3:
                    message.event_id = reader.uint32();
                    break;
                case 4:
                    message.instance_id = reader.uint32();
                    break;
                case 5:
                    message.challenge_var_0 = reader.uint32();
                    break;
                case 6:
                    message.challenge_var_1 = reader.uint32();
                    break;
                case 7:
                    message.challenge_max_rank = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("challenge_type"))
                throw $util.ProtocolError("missing required 'challenge_type'", { instance: message });
            if (!message.hasOwnProperty("challenge_query_id"))
                throw $util.ProtocolError("missing required 'challenge_query_id'", { instance: message });
            if (!message.hasOwnProperty("event_id"))
                throw $util.ProtocolError("missing required 'event_id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_DebugChallenge message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_DebugChallenge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_DebugChallenge} CDOTAUserMsg_DebugChallenge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_DebugChallenge.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_DebugChallenge message.
         * @function verify
         * @memberof CDOTAUserMsg_DebugChallenge
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_DebugChallenge.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.challenge_type))
                return "challenge_type: integer expected";
            if (!$util.isInteger(message.challenge_query_id))
                return "challenge_query_id: integer expected";
            if (!$util.isInteger(message.event_id))
                return "event_id: integer expected";
            if (message.instance_id != null && message.hasOwnProperty("instance_id"))
                if (!$util.isInteger(message.instance_id))
                    return "instance_id: integer expected";
            if (message.challenge_var_0 != null && message.hasOwnProperty("challenge_var_0"))
                if (!$util.isInteger(message.challenge_var_0))
                    return "challenge_var_0: integer expected";
            if (message.challenge_var_1 != null && message.hasOwnProperty("challenge_var_1"))
                if (!$util.isInteger(message.challenge_var_1))
                    return "challenge_var_1: integer expected";
            if (message.challenge_max_rank != null && message.hasOwnProperty("challenge_max_rank"))
                if (!$util.isInteger(message.challenge_max_rank))
                    return "challenge_max_rank: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_DebugChallenge message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_DebugChallenge
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_DebugChallenge} CDOTAUserMsg_DebugChallenge
         */
        CDOTAUserMsg_DebugChallenge.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_DebugChallenge)
                return object;
            var message = new $root.CDOTAUserMsg_DebugChallenge();
            if (object.challenge_type != null)
                message.challenge_type = object.challenge_type >>> 0;
            if (object.challenge_query_id != null)
                message.challenge_query_id = object.challenge_query_id >>> 0;
            if (object.event_id != null)
                message.event_id = object.event_id >>> 0;
            if (object.instance_id != null)
                message.instance_id = object.instance_id >>> 0;
            if (object.challenge_var_0 != null)
                message.challenge_var_0 = object.challenge_var_0 >>> 0;
            if (object.challenge_var_1 != null)
                message.challenge_var_1 = object.challenge_var_1 >>> 0;
            if (object.challenge_max_rank != null)
                message.challenge_max_rank = object.challenge_max_rank >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_DebugChallenge message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_DebugChallenge
         * @static
         * @param {CDOTAUserMsg_DebugChallenge} message CDOTAUserMsg_DebugChallenge
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_DebugChallenge.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.challenge_type = 0;
                object.challenge_query_id = 0;
                object.event_id = 0;
                object.instance_id = 0;
                object.challenge_var_0 = 0;
                object.challenge_var_1 = 0;
                object.challenge_max_rank = 0;
            }
            if (message.challenge_type != null && message.hasOwnProperty("challenge_type"))
                object.challenge_type = message.challenge_type;
            if (message.challenge_query_id != null && message.hasOwnProperty("challenge_query_id"))
                object.challenge_query_id = message.challenge_query_id;
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                object.event_id = message.event_id;
            if (message.instance_id != null && message.hasOwnProperty("instance_id"))
                object.instance_id = message.instance_id;
            if (message.challenge_var_0 != null && message.hasOwnProperty("challenge_var_0"))
                object.challenge_var_0 = message.challenge_var_0;
            if (message.challenge_var_1 != null && message.hasOwnProperty("challenge_var_1"))
                object.challenge_var_1 = message.challenge_var_1;
            if (message.challenge_max_rank != null && message.hasOwnProperty("challenge_max_rank"))
                object.challenge_max_rank = message.challenge_max_rank;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_DebugChallenge to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_DebugChallenge
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_DebugChallenge.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_DebugChallenge;
    })();
    
    $root.CDOTAUserMsg_FoundNeutralItem = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_FoundNeutralItem.
         * @exports ICDOTAUserMsg_FoundNeutralItem
         * @interface ICDOTAUserMsg_FoundNeutralItem
         * @property {number|null} [player_id] CDOTAUserMsg_FoundNeutralItem player_id
         * @property {number|null} [item_ability_id] CDOTAUserMsg_FoundNeutralItem item_ability_id
         * @property {number|null} [item_tier] CDOTAUserMsg_FoundNeutralItem item_tier
         * @property {number|null} [tier_item_count] CDOTAUserMsg_FoundNeutralItem tier_item_count
         */
    
        /**
         * Constructs a new CDOTAUserMsg_FoundNeutralItem.
         * @exports CDOTAUserMsg_FoundNeutralItem
         * @classdesc Represents a CDOTAUserMsg_FoundNeutralItem.
         * @implements ICDOTAUserMsg_FoundNeutralItem
         * @constructor
         * @param {ICDOTAUserMsg_FoundNeutralItem=} [properties] Properties to set
         */
        function CDOTAUserMsg_FoundNeutralItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_FoundNeutralItem player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_FoundNeutralItem
         * @instance
         */
        CDOTAUserMsg_FoundNeutralItem.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_FoundNeutralItem item_ability_id.
         * @member {number} item_ability_id
         * @memberof CDOTAUserMsg_FoundNeutralItem
         * @instance
         */
        CDOTAUserMsg_FoundNeutralItem.prototype.item_ability_id = 0;
    
        /**
         * CDOTAUserMsg_FoundNeutralItem item_tier.
         * @member {number} item_tier
         * @memberof CDOTAUserMsg_FoundNeutralItem
         * @instance
         */
        CDOTAUserMsg_FoundNeutralItem.prototype.item_tier = 0;
    
        /**
         * CDOTAUserMsg_FoundNeutralItem tier_item_count.
         * @member {number} tier_item_count
         * @memberof CDOTAUserMsg_FoundNeutralItem
         * @instance
         */
        CDOTAUserMsg_FoundNeutralItem.prototype.tier_item_count = 0;
    
        /**
         * Creates a new CDOTAUserMsg_FoundNeutralItem instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_FoundNeutralItem
         * @static
         * @param {ICDOTAUserMsg_FoundNeutralItem=} [properties] Properties to set
         * @returns {CDOTAUserMsg_FoundNeutralItem} CDOTAUserMsg_FoundNeutralItem instance
         */
        CDOTAUserMsg_FoundNeutralItem.create = function create(properties) {
            return new CDOTAUserMsg_FoundNeutralItem(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_FoundNeutralItem message. Does not implicitly {@link CDOTAUserMsg_FoundNeutralItem.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_FoundNeutralItem
         * @static
         * @param {ICDOTAUserMsg_FoundNeutralItem} message CDOTAUserMsg_FoundNeutralItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_FoundNeutralItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.item_ability_id != null && Object.hasOwnProperty.call(message, "item_ability_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.item_ability_id);
            if (message.item_tier != null && Object.hasOwnProperty.call(message, "item_tier"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.item_tier);
            if (message.tier_item_count != null && Object.hasOwnProperty.call(message, "tier_item_count"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.tier_item_count);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_FoundNeutralItem message, length delimited. Does not implicitly {@link CDOTAUserMsg_FoundNeutralItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_FoundNeutralItem
         * @static
         * @param {ICDOTAUserMsg_FoundNeutralItem} message CDOTAUserMsg_FoundNeutralItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_FoundNeutralItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_FoundNeutralItem message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_FoundNeutralItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_FoundNeutralItem} CDOTAUserMsg_FoundNeutralItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_FoundNeutralItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_FoundNeutralItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.item_ability_id = reader.uint32();
                    break;
                case 3:
                    message.item_tier = reader.uint32();
                    break;
                case 4:
                    message.tier_item_count = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_FoundNeutralItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_FoundNeutralItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_FoundNeutralItem} CDOTAUserMsg_FoundNeutralItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_FoundNeutralItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_FoundNeutralItem message.
         * @function verify
         * @memberof CDOTAUserMsg_FoundNeutralItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_FoundNeutralItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                if (!$util.isInteger(message.item_ability_id))
                    return "item_ability_id: integer expected";
            if (message.item_tier != null && message.hasOwnProperty("item_tier"))
                if (!$util.isInteger(message.item_tier))
                    return "item_tier: integer expected";
            if (message.tier_item_count != null && message.hasOwnProperty("tier_item_count"))
                if (!$util.isInteger(message.tier_item_count))
                    return "tier_item_count: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_FoundNeutralItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_FoundNeutralItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_FoundNeutralItem} CDOTAUserMsg_FoundNeutralItem
         */
        CDOTAUserMsg_FoundNeutralItem.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_FoundNeutralItem)
                return object;
            var message = new $root.CDOTAUserMsg_FoundNeutralItem();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            if (object.item_ability_id != null)
                message.item_ability_id = object.item_ability_id >>> 0;
            if (object.item_tier != null)
                message.item_tier = object.item_tier >>> 0;
            if (object.tier_item_count != null)
                message.tier_item_count = object.tier_item_count >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_FoundNeutralItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_FoundNeutralItem
         * @static
         * @param {CDOTAUserMsg_FoundNeutralItem} message CDOTAUserMsg_FoundNeutralItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_FoundNeutralItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.item_ability_id = 0;
                object.item_tier = 0;
                object.tier_item_count = 0;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                object.item_ability_id = message.item_ability_id;
            if (message.item_tier != null && message.hasOwnProperty("item_tier"))
                object.item_tier = message.item_tier;
            if (message.tier_item_count != null && message.hasOwnProperty("tier_item_count"))
                object.tier_item_count = message.tier_item_count;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_FoundNeutralItem to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_FoundNeutralItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_FoundNeutralItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_FoundNeutralItem;
    })();
    
    $root.CDOTAUserMsg_OutpostCaptured = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_OutpostCaptured.
         * @exports ICDOTAUserMsg_OutpostCaptured
         * @interface ICDOTAUserMsg_OutpostCaptured
         * @property {number|null} [outpost_entindex] CDOTAUserMsg_OutpostCaptured outpost_entindex
         * @property {number|null} [team_id] CDOTAUserMsg_OutpostCaptured team_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_OutpostCaptured.
         * @exports CDOTAUserMsg_OutpostCaptured
         * @classdesc Represents a CDOTAUserMsg_OutpostCaptured.
         * @implements ICDOTAUserMsg_OutpostCaptured
         * @constructor
         * @param {ICDOTAUserMsg_OutpostCaptured=} [properties] Properties to set
         */
        function CDOTAUserMsg_OutpostCaptured(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_OutpostCaptured outpost_entindex.
         * @member {number} outpost_entindex
         * @memberof CDOTAUserMsg_OutpostCaptured
         * @instance
         */
        CDOTAUserMsg_OutpostCaptured.prototype.outpost_entindex = 0;
    
        /**
         * CDOTAUserMsg_OutpostCaptured team_id.
         * @member {number} team_id
         * @memberof CDOTAUserMsg_OutpostCaptured
         * @instance
         */
        CDOTAUserMsg_OutpostCaptured.prototype.team_id = 0;
    
        /**
         * Creates a new CDOTAUserMsg_OutpostCaptured instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_OutpostCaptured
         * @static
         * @param {ICDOTAUserMsg_OutpostCaptured=} [properties] Properties to set
         * @returns {CDOTAUserMsg_OutpostCaptured} CDOTAUserMsg_OutpostCaptured instance
         */
        CDOTAUserMsg_OutpostCaptured.create = function create(properties) {
            return new CDOTAUserMsg_OutpostCaptured(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_OutpostCaptured message. Does not implicitly {@link CDOTAUserMsg_OutpostCaptured.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_OutpostCaptured
         * @static
         * @param {ICDOTAUserMsg_OutpostCaptured} message CDOTAUserMsg_OutpostCaptured message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_OutpostCaptured.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.outpost_entindex != null && Object.hasOwnProperty.call(message, "outpost_entindex"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.outpost_entindex);
            if (message.team_id != null && Object.hasOwnProperty.call(message, "team_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.team_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_OutpostCaptured message, length delimited. Does not implicitly {@link CDOTAUserMsg_OutpostCaptured.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_OutpostCaptured
         * @static
         * @param {ICDOTAUserMsg_OutpostCaptured} message CDOTAUserMsg_OutpostCaptured message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_OutpostCaptured.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_OutpostCaptured message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_OutpostCaptured
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_OutpostCaptured} CDOTAUserMsg_OutpostCaptured
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_OutpostCaptured.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_OutpostCaptured();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.outpost_entindex = reader.uint32();
                    break;
                case 2:
                    message.team_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_OutpostCaptured message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_OutpostCaptured
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_OutpostCaptured} CDOTAUserMsg_OutpostCaptured
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_OutpostCaptured.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_OutpostCaptured message.
         * @function verify
         * @memberof CDOTAUserMsg_OutpostCaptured
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_OutpostCaptured.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.outpost_entindex != null && message.hasOwnProperty("outpost_entindex"))
                if (!$util.isInteger(message.outpost_entindex))
                    return "outpost_entindex: integer expected";
            if (message.team_id != null && message.hasOwnProperty("team_id"))
                if (!$util.isInteger(message.team_id))
                    return "team_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_OutpostCaptured message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_OutpostCaptured
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_OutpostCaptured} CDOTAUserMsg_OutpostCaptured
         */
        CDOTAUserMsg_OutpostCaptured.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_OutpostCaptured)
                return object;
            var message = new $root.CDOTAUserMsg_OutpostCaptured();
            if (object.outpost_entindex != null)
                message.outpost_entindex = object.outpost_entindex >>> 0;
            if (object.team_id != null)
                message.team_id = object.team_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_OutpostCaptured message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_OutpostCaptured
         * @static
         * @param {CDOTAUserMsg_OutpostCaptured} message CDOTAUserMsg_OutpostCaptured
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_OutpostCaptured.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.outpost_entindex = 0;
                object.team_id = 0;
            }
            if (message.outpost_entindex != null && message.hasOwnProperty("outpost_entindex"))
                object.outpost_entindex = message.outpost_entindex;
            if (message.team_id != null && message.hasOwnProperty("team_id"))
                object.team_id = message.team_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_OutpostCaptured to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_OutpostCaptured
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_OutpostCaptured.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_OutpostCaptured;
    })();
    
    $root.CDOTAUserMsg_OutpostGrantedXP = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_OutpostGrantedXP.
         * @exports ICDOTAUserMsg_OutpostGrantedXP
         * @interface ICDOTAUserMsg_OutpostGrantedXP
         * @property {number|null} [team_id] CDOTAUserMsg_OutpostGrantedXP team_id
         * @property {number|null} [xp_amount] CDOTAUserMsg_OutpostGrantedXP xp_amount
         */
    
        /**
         * Constructs a new CDOTAUserMsg_OutpostGrantedXP.
         * @exports CDOTAUserMsg_OutpostGrantedXP
         * @classdesc Represents a CDOTAUserMsg_OutpostGrantedXP.
         * @implements ICDOTAUserMsg_OutpostGrantedXP
         * @constructor
         * @param {ICDOTAUserMsg_OutpostGrantedXP=} [properties] Properties to set
         */
        function CDOTAUserMsg_OutpostGrantedXP(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_OutpostGrantedXP team_id.
         * @member {number} team_id
         * @memberof CDOTAUserMsg_OutpostGrantedXP
         * @instance
         */
        CDOTAUserMsg_OutpostGrantedXP.prototype.team_id = 0;
    
        /**
         * CDOTAUserMsg_OutpostGrantedXP xp_amount.
         * @member {number} xp_amount
         * @memberof CDOTAUserMsg_OutpostGrantedXP
         * @instance
         */
        CDOTAUserMsg_OutpostGrantedXP.prototype.xp_amount = 0;
    
        /**
         * Creates a new CDOTAUserMsg_OutpostGrantedXP instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_OutpostGrantedXP
         * @static
         * @param {ICDOTAUserMsg_OutpostGrantedXP=} [properties] Properties to set
         * @returns {CDOTAUserMsg_OutpostGrantedXP} CDOTAUserMsg_OutpostGrantedXP instance
         */
        CDOTAUserMsg_OutpostGrantedXP.create = function create(properties) {
            return new CDOTAUserMsg_OutpostGrantedXP(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_OutpostGrantedXP message. Does not implicitly {@link CDOTAUserMsg_OutpostGrantedXP.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_OutpostGrantedXP
         * @static
         * @param {ICDOTAUserMsg_OutpostGrantedXP} message CDOTAUserMsg_OutpostGrantedXP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_OutpostGrantedXP.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.team_id != null && Object.hasOwnProperty.call(message, "team_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.team_id);
            if (message.xp_amount != null && Object.hasOwnProperty.call(message, "xp_amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.xp_amount);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_OutpostGrantedXP message, length delimited. Does not implicitly {@link CDOTAUserMsg_OutpostGrantedXP.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_OutpostGrantedXP
         * @static
         * @param {ICDOTAUserMsg_OutpostGrantedXP} message CDOTAUserMsg_OutpostGrantedXP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_OutpostGrantedXP.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_OutpostGrantedXP message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_OutpostGrantedXP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_OutpostGrantedXP} CDOTAUserMsg_OutpostGrantedXP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_OutpostGrantedXP.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_OutpostGrantedXP();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.team_id = reader.uint32();
                    break;
                case 2:
                    message.xp_amount = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_OutpostGrantedXP message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_OutpostGrantedXP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_OutpostGrantedXP} CDOTAUserMsg_OutpostGrantedXP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_OutpostGrantedXP.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_OutpostGrantedXP message.
         * @function verify
         * @memberof CDOTAUserMsg_OutpostGrantedXP
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_OutpostGrantedXP.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.team_id != null && message.hasOwnProperty("team_id"))
                if (!$util.isInteger(message.team_id))
                    return "team_id: integer expected";
            if (message.xp_amount != null && message.hasOwnProperty("xp_amount"))
                if (!$util.isInteger(message.xp_amount))
                    return "xp_amount: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_OutpostGrantedXP message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_OutpostGrantedXP
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_OutpostGrantedXP} CDOTAUserMsg_OutpostGrantedXP
         */
        CDOTAUserMsg_OutpostGrantedXP.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_OutpostGrantedXP)
                return object;
            var message = new $root.CDOTAUserMsg_OutpostGrantedXP();
            if (object.team_id != null)
                message.team_id = object.team_id >>> 0;
            if (object.xp_amount != null)
                message.xp_amount = object.xp_amount >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_OutpostGrantedXP message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_OutpostGrantedXP
         * @static
         * @param {CDOTAUserMsg_OutpostGrantedXP} message CDOTAUserMsg_OutpostGrantedXP
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_OutpostGrantedXP.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.team_id = 0;
                object.xp_amount = 0;
            }
            if (message.team_id != null && message.hasOwnProperty("team_id"))
                object.team_id = message.team_id;
            if (message.xp_amount != null && message.hasOwnProperty("xp_amount"))
                object.xp_amount = message.xp_amount;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_OutpostGrantedXP to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_OutpostGrantedXP
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_OutpostGrantedXP.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_OutpostGrantedXP;
    })();
    
    $root.CDOTAUserMsg_MoveCameraToUnit = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_MoveCameraToUnit.
         * @exports ICDOTAUserMsg_MoveCameraToUnit
         * @interface ICDOTAUserMsg_MoveCameraToUnit
         * @property {number|null} [unit_ehandle] CDOTAUserMsg_MoveCameraToUnit unit_ehandle
         */
    
        /**
         * Constructs a new CDOTAUserMsg_MoveCameraToUnit.
         * @exports CDOTAUserMsg_MoveCameraToUnit
         * @classdesc Represents a CDOTAUserMsg_MoveCameraToUnit.
         * @implements ICDOTAUserMsg_MoveCameraToUnit
         * @constructor
         * @param {ICDOTAUserMsg_MoveCameraToUnit=} [properties] Properties to set
         */
        function CDOTAUserMsg_MoveCameraToUnit(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_MoveCameraToUnit unit_ehandle.
         * @member {number} unit_ehandle
         * @memberof CDOTAUserMsg_MoveCameraToUnit
         * @instance
         */
        CDOTAUserMsg_MoveCameraToUnit.prototype.unit_ehandle = 0;
    
        /**
         * Creates a new CDOTAUserMsg_MoveCameraToUnit instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_MoveCameraToUnit
         * @static
         * @param {ICDOTAUserMsg_MoveCameraToUnit=} [properties] Properties to set
         * @returns {CDOTAUserMsg_MoveCameraToUnit} CDOTAUserMsg_MoveCameraToUnit instance
         */
        CDOTAUserMsg_MoveCameraToUnit.create = function create(properties) {
            return new CDOTAUserMsg_MoveCameraToUnit(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_MoveCameraToUnit message. Does not implicitly {@link CDOTAUserMsg_MoveCameraToUnit.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_MoveCameraToUnit
         * @static
         * @param {ICDOTAUserMsg_MoveCameraToUnit} message CDOTAUserMsg_MoveCameraToUnit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_MoveCameraToUnit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.unit_ehandle != null && Object.hasOwnProperty.call(message, "unit_ehandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.unit_ehandle);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_MoveCameraToUnit message, length delimited. Does not implicitly {@link CDOTAUserMsg_MoveCameraToUnit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_MoveCameraToUnit
         * @static
         * @param {ICDOTAUserMsg_MoveCameraToUnit} message CDOTAUserMsg_MoveCameraToUnit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_MoveCameraToUnit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_MoveCameraToUnit message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_MoveCameraToUnit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_MoveCameraToUnit} CDOTAUserMsg_MoveCameraToUnit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_MoveCameraToUnit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_MoveCameraToUnit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.unit_ehandle = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_MoveCameraToUnit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_MoveCameraToUnit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_MoveCameraToUnit} CDOTAUserMsg_MoveCameraToUnit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_MoveCameraToUnit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_MoveCameraToUnit message.
         * @function verify
         * @memberof CDOTAUserMsg_MoveCameraToUnit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_MoveCameraToUnit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.unit_ehandle != null && message.hasOwnProperty("unit_ehandle"))
                if (!$util.isInteger(message.unit_ehandle))
                    return "unit_ehandle: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_MoveCameraToUnit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_MoveCameraToUnit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_MoveCameraToUnit} CDOTAUserMsg_MoveCameraToUnit
         */
        CDOTAUserMsg_MoveCameraToUnit.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_MoveCameraToUnit)
                return object;
            var message = new $root.CDOTAUserMsg_MoveCameraToUnit();
            if (object.unit_ehandle != null)
                message.unit_ehandle = object.unit_ehandle | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_MoveCameraToUnit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_MoveCameraToUnit
         * @static
         * @param {CDOTAUserMsg_MoveCameraToUnit} message CDOTAUserMsg_MoveCameraToUnit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_MoveCameraToUnit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.unit_ehandle = 0;
            if (message.unit_ehandle != null && message.hasOwnProperty("unit_ehandle"))
                object.unit_ehandle = message.unit_ehandle;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_MoveCameraToUnit to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_MoveCameraToUnit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_MoveCameraToUnit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_MoveCameraToUnit;
    })();
    
    $root.CDOTAUserMsg_PauseMinigameData = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_PauseMinigameData.
         * @exports ICDOTAUserMsg_PauseMinigameData
         * @interface ICDOTAUserMsg_PauseMinigameData
         * @property {Array.<CDOTAUserMsg_PauseMinigameData.IDataBit>|null} [data_bits] CDOTAUserMsg_PauseMinigameData data_bits
         */
    
        /**
         * Constructs a new CDOTAUserMsg_PauseMinigameData.
         * @exports CDOTAUserMsg_PauseMinigameData
         * @classdesc Represents a CDOTAUserMsg_PauseMinigameData.
         * @implements ICDOTAUserMsg_PauseMinigameData
         * @constructor
         * @param {ICDOTAUserMsg_PauseMinigameData=} [properties] Properties to set
         */
        function CDOTAUserMsg_PauseMinigameData(properties) {
            this.data_bits = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_PauseMinigameData data_bits.
         * @member {Array.<CDOTAUserMsg_PauseMinigameData.IDataBit>} data_bits
         * @memberof CDOTAUserMsg_PauseMinigameData
         * @instance
         */
        CDOTAUserMsg_PauseMinigameData.prototype.data_bits = $util.emptyArray;
    
        /**
         * Creates a new CDOTAUserMsg_PauseMinigameData instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_PauseMinigameData
         * @static
         * @param {ICDOTAUserMsg_PauseMinigameData=} [properties] Properties to set
         * @returns {CDOTAUserMsg_PauseMinigameData} CDOTAUserMsg_PauseMinigameData instance
         */
        CDOTAUserMsg_PauseMinigameData.create = function create(properties) {
            return new CDOTAUserMsg_PauseMinigameData(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_PauseMinigameData message. Does not implicitly {@link CDOTAUserMsg_PauseMinigameData.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_PauseMinigameData
         * @static
         * @param {ICDOTAUserMsg_PauseMinigameData} message CDOTAUserMsg_PauseMinigameData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_PauseMinigameData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data_bits != null && message.data_bits.length)
                for (var i = 0; i < message.data_bits.length; ++i)
                    $root.CDOTAUserMsg_PauseMinigameData.DataBit.encode(message.data_bits[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_PauseMinigameData message, length delimited. Does not implicitly {@link CDOTAUserMsg_PauseMinigameData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_PauseMinigameData
         * @static
         * @param {ICDOTAUserMsg_PauseMinigameData} message CDOTAUserMsg_PauseMinigameData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_PauseMinigameData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_PauseMinigameData message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_PauseMinigameData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_PauseMinigameData} CDOTAUserMsg_PauseMinigameData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_PauseMinigameData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_PauseMinigameData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.data_bits && message.data_bits.length))
                        message.data_bits = [];
                    message.data_bits.push($root.CDOTAUserMsg_PauseMinigameData.DataBit.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_PauseMinigameData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_PauseMinigameData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_PauseMinigameData} CDOTAUserMsg_PauseMinigameData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_PauseMinigameData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_PauseMinigameData message.
         * @function verify
         * @memberof CDOTAUserMsg_PauseMinigameData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_PauseMinigameData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data_bits != null && message.hasOwnProperty("data_bits")) {
                if (!Array.isArray(message.data_bits))
                    return "data_bits: array expected";
                for (var i = 0; i < message.data_bits.length; ++i) {
                    var error = $root.CDOTAUserMsg_PauseMinigameData.DataBit.verify(message.data_bits[i]);
                    if (error)
                        return "data_bits." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_PauseMinigameData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_PauseMinigameData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_PauseMinigameData} CDOTAUserMsg_PauseMinigameData
         */
        CDOTAUserMsg_PauseMinigameData.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_PauseMinigameData)
                return object;
            var message = new $root.CDOTAUserMsg_PauseMinigameData();
            if (object.data_bits) {
                if (!Array.isArray(object.data_bits))
                    throw TypeError(".CDOTAUserMsg_PauseMinigameData.data_bits: array expected");
                message.data_bits = [];
                for (var i = 0; i < object.data_bits.length; ++i) {
                    if (typeof object.data_bits[i] !== "object")
                        throw TypeError(".CDOTAUserMsg_PauseMinigameData.data_bits: object expected");
                    message.data_bits[i] = $root.CDOTAUserMsg_PauseMinigameData.DataBit.fromObject(object.data_bits[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_PauseMinigameData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_PauseMinigameData
         * @static
         * @param {CDOTAUserMsg_PauseMinigameData} message CDOTAUserMsg_PauseMinigameData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_PauseMinigameData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.data_bits = [];
            if (message.data_bits && message.data_bits.length) {
                object.data_bits = [];
                for (var j = 0; j < message.data_bits.length; ++j)
                    object.data_bits[j] = $root.CDOTAUserMsg_PauseMinigameData.DataBit.toObject(message.data_bits[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_PauseMinigameData to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_PauseMinigameData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_PauseMinigameData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CDOTAUserMsg_PauseMinigameData.DataBit = (function() {
    
            /**
             * Properties of a DataBit.
             * @memberof CDOTAUserMsg_PauseMinigameData
             * @interface IDataBit
             * @property {number|null} [index] DataBit index
             * @property {number|null} [data] DataBit data
             * @property {number|Long|null} [data_extra] DataBit data_extra
             */
    
            /**
             * Constructs a new DataBit.
             * @memberof CDOTAUserMsg_PauseMinigameData
             * @classdesc Represents a DataBit.
             * @implements IDataBit
             * @constructor
             * @param {CDOTAUserMsg_PauseMinigameData.IDataBit=} [properties] Properties to set
             */
            function DataBit(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DataBit index.
             * @member {number} index
             * @memberof CDOTAUserMsg_PauseMinigameData.DataBit
             * @instance
             */
            DataBit.prototype.index = 0;
    
            /**
             * DataBit data.
             * @member {number} data
             * @memberof CDOTAUserMsg_PauseMinigameData.DataBit
             * @instance
             */
            DataBit.prototype.data = 0;
    
            /**
             * DataBit data_extra.
             * @member {number|Long} data_extra
             * @memberof CDOTAUserMsg_PauseMinigameData.DataBit
             * @instance
             */
            DataBit.prototype.data_extra = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new DataBit instance using the specified properties.
             * @function create
             * @memberof CDOTAUserMsg_PauseMinigameData.DataBit
             * @static
             * @param {CDOTAUserMsg_PauseMinigameData.IDataBit=} [properties] Properties to set
             * @returns {CDOTAUserMsg_PauseMinigameData.DataBit} DataBit instance
             */
            DataBit.create = function create(properties) {
                return new DataBit(properties);
            };
    
            /**
             * Encodes the specified DataBit message. Does not implicitly {@link CDOTAUserMsg_PauseMinigameData.DataBit.verify|verify} messages.
             * @function encode
             * @memberof CDOTAUserMsg_PauseMinigameData.DataBit
             * @static
             * @param {CDOTAUserMsg_PauseMinigameData.IDataBit} message DataBit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataBit.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.data);
                if (message.data_extra != null && Object.hasOwnProperty.call(message, "data_extra"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.data_extra);
                return writer;
            };
    
            /**
             * Encodes the specified DataBit message, length delimited. Does not implicitly {@link CDOTAUserMsg_PauseMinigameData.DataBit.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTAUserMsg_PauseMinigameData.DataBit
             * @static
             * @param {CDOTAUserMsg_PauseMinigameData.IDataBit} message DataBit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataBit.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DataBit message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTAUserMsg_PauseMinigameData.DataBit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTAUserMsg_PauseMinigameData.DataBit} DataBit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataBit.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_PauseMinigameData.DataBit();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.index = reader.uint32();
                        break;
                    case 2:
                        message.data = reader.int32();
                        break;
                    case 3:
                        message.data_extra = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DataBit message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTAUserMsg_PauseMinigameData.DataBit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTAUserMsg_PauseMinigameData.DataBit} DataBit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataBit.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DataBit message.
             * @function verify
             * @memberof CDOTAUserMsg_PauseMinigameData.DataBit
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DataBit.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.index != null && message.hasOwnProperty("index"))
                    if (!$util.isInteger(message.index))
                        return "index: integer expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!$util.isInteger(message.data))
                        return "data: integer expected";
                if (message.data_extra != null && message.hasOwnProperty("data_extra"))
                    if (!$util.isInteger(message.data_extra) && !(message.data_extra && $util.isInteger(message.data_extra.low) && $util.isInteger(message.data_extra.high)))
                        return "data_extra: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a DataBit message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTAUserMsg_PauseMinigameData.DataBit
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTAUserMsg_PauseMinigameData.DataBit} DataBit
             */
            DataBit.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTAUserMsg_PauseMinigameData.DataBit)
                    return object;
                var message = new $root.CDOTAUserMsg_PauseMinigameData.DataBit();
                if (object.index != null)
                    message.index = object.index >>> 0;
                if (object.data != null)
                    message.data = object.data | 0;
                if (object.data_extra != null)
                    if ($util.Long)
                        (message.data_extra = $util.Long.fromValue(object.data_extra)).unsigned = false;
                    else if (typeof object.data_extra === "string")
                        message.data_extra = parseInt(object.data_extra, 10);
                    else if (typeof object.data_extra === "number")
                        message.data_extra = object.data_extra;
                    else if (typeof object.data_extra === "object")
                        message.data_extra = new $util.LongBits(object.data_extra.low >>> 0, object.data_extra.high >>> 0).toNumber();
                return message;
            };
    
            /**
             * Creates a plain object from a DataBit message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTAUserMsg_PauseMinigameData.DataBit
             * @static
             * @param {CDOTAUserMsg_PauseMinigameData.DataBit} message DataBit
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DataBit.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.index = 0;
                    object.data = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.data_extra = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.data_extra = options.longs === String ? "0" : 0;
                }
                if (message.index != null && message.hasOwnProperty("index"))
                    object.index = message.index;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = message.data;
                if (message.data_extra != null && message.hasOwnProperty("data_extra"))
                    if (typeof message.data_extra === "number")
                        object.data_extra = options.longs === String ? String(message.data_extra) : message.data_extra;
                    else
                        object.data_extra = options.longs === String ? $util.Long.prototype.toString.call(message.data_extra) : options.longs === Number ? new $util.LongBits(message.data_extra.low >>> 0, message.data_extra.high >>> 0).toNumber() : message.data_extra;
                return object;
            };
    
            /**
             * Converts this DataBit to JSON.
             * @function toJSON
             * @memberof CDOTAUserMsg_PauseMinigameData.DataBit
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DataBit.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DataBit;
        })();
    
        return CDOTAUserMsg_PauseMinigameData;
    })();
    
    $root.CDOTAUserMsg_VersusScene_PlayerBehavior = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_VersusScene_PlayerBehavior.
         * @exports ICDOTAUserMsg_VersusScene_PlayerBehavior
         * @interface ICDOTAUserMsg_VersusScene_PlayerBehavior
         * @property {number|null} [player_id] CDOTAUserMsg_VersusScene_PlayerBehavior player_id
         * @property {EDOTAVersusScenePlayerBehavior|null} [behavior] CDOTAUserMsg_VersusScene_PlayerBehavior behavior
         * @property {IVersusScene_PlayActivity|null} [play_activity] CDOTAUserMsg_VersusScene_PlayerBehavior play_activity
         * @property {IVersusScene_ChatWheel|null} [chat_wheel] CDOTAUserMsg_VersusScene_PlayerBehavior chat_wheel
         * @property {IVersusScene_PlaybackRate|null} [playback_rate] CDOTAUserMsg_VersusScene_PlayerBehavior playback_rate
         */
    
        /**
         * Constructs a new CDOTAUserMsg_VersusScene_PlayerBehavior.
         * @exports CDOTAUserMsg_VersusScene_PlayerBehavior
         * @classdesc Represents a CDOTAUserMsg_VersusScene_PlayerBehavior.
         * @implements ICDOTAUserMsg_VersusScene_PlayerBehavior
         * @constructor
         * @param {ICDOTAUserMsg_VersusScene_PlayerBehavior=} [properties] Properties to set
         */
        function CDOTAUserMsg_VersusScene_PlayerBehavior(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_VersusScene_PlayerBehavior player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_VersusScene_PlayerBehavior
         * @instance
         */
        CDOTAUserMsg_VersusScene_PlayerBehavior.prototype.player_id = 0;
    
        /**
         * CDOTAUserMsg_VersusScene_PlayerBehavior behavior.
         * @member {EDOTAVersusScenePlayerBehavior} behavior
         * @memberof CDOTAUserMsg_VersusScene_PlayerBehavior
         * @instance
         */
        CDOTAUserMsg_VersusScene_PlayerBehavior.prototype.behavior = 1;
    
        /**
         * CDOTAUserMsg_VersusScene_PlayerBehavior play_activity.
         * @member {IVersusScene_PlayActivity|null|undefined} play_activity
         * @memberof CDOTAUserMsg_VersusScene_PlayerBehavior
         * @instance
         */
        CDOTAUserMsg_VersusScene_PlayerBehavior.prototype.play_activity = null;
    
        /**
         * CDOTAUserMsg_VersusScene_PlayerBehavior chat_wheel.
         * @member {IVersusScene_ChatWheel|null|undefined} chat_wheel
         * @memberof CDOTAUserMsg_VersusScene_PlayerBehavior
         * @instance
         */
        CDOTAUserMsg_VersusScene_PlayerBehavior.prototype.chat_wheel = null;
    
        /**
         * CDOTAUserMsg_VersusScene_PlayerBehavior playback_rate.
         * @member {IVersusScene_PlaybackRate|null|undefined} playback_rate
         * @memberof CDOTAUserMsg_VersusScene_PlayerBehavior
         * @instance
         */
        CDOTAUserMsg_VersusScene_PlayerBehavior.prototype.playback_rate = null;
    
        /**
         * Creates a new CDOTAUserMsg_VersusScene_PlayerBehavior instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_VersusScene_PlayerBehavior
         * @static
         * @param {ICDOTAUserMsg_VersusScene_PlayerBehavior=} [properties] Properties to set
         * @returns {CDOTAUserMsg_VersusScene_PlayerBehavior} CDOTAUserMsg_VersusScene_PlayerBehavior instance
         */
        CDOTAUserMsg_VersusScene_PlayerBehavior.create = function create(properties) {
            return new CDOTAUserMsg_VersusScene_PlayerBehavior(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_VersusScene_PlayerBehavior message. Does not implicitly {@link CDOTAUserMsg_VersusScene_PlayerBehavior.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_VersusScene_PlayerBehavior
         * @static
         * @param {ICDOTAUserMsg_VersusScene_PlayerBehavior} message CDOTAUserMsg_VersusScene_PlayerBehavior message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_VersusScene_PlayerBehavior.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            if (message.behavior != null && Object.hasOwnProperty.call(message, "behavior"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.behavior);
            if (message.play_activity != null && Object.hasOwnProperty.call(message, "play_activity"))
                $root.VersusScene_PlayActivity.encode(message.play_activity, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.chat_wheel != null && Object.hasOwnProperty.call(message, "chat_wheel"))
                $root.VersusScene_ChatWheel.encode(message.chat_wheel, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.playback_rate != null && Object.hasOwnProperty.call(message, "playback_rate"))
                $root.VersusScene_PlaybackRate.encode(message.playback_rate, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_VersusScene_PlayerBehavior message, length delimited. Does not implicitly {@link CDOTAUserMsg_VersusScene_PlayerBehavior.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_VersusScene_PlayerBehavior
         * @static
         * @param {ICDOTAUserMsg_VersusScene_PlayerBehavior} message CDOTAUserMsg_VersusScene_PlayerBehavior message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_VersusScene_PlayerBehavior.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_VersusScene_PlayerBehavior message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_VersusScene_PlayerBehavior
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_VersusScene_PlayerBehavior} CDOTAUserMsg_VersusScene_PlayerBehavior
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_VersusScene_PlayerBehavior.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_VersusScene_PlayerBehavior();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                case 2:
                    message.behavior = reader.int32();
                    break;
                case 3:
                    message.play_activity = $root.VersusScene_PlayActivity.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.chat_wheel = $root.VersusScene_ChatWheel.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.playback_rate = $root.VersusScene_PlaybackRate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_VersusScene_PlayerBehavior message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_VersusScene_PlayerBehavior
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_VersusScene_PlayerBehavior} CDOTAUserMsg_VersusScene_PlayerBehavior
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_VersusScene_PlayerBehavior.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_VersusScene_PlayerBehavior message.
         * @function verify
         * @memberof CDOTAUserMsg_VersusScene_PlayerBehavior
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_VersusScene_PlayerBehavior.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            if (message.behavior != null && message.hasOwnProperty("behavior"))
                switch (message.behavior) {
                default:
                    return "behavior: enum value expected";
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.play_activity != null && message.hasOwnProperty("play_activity")) {
                var error = $root.VersusScene_PlayActivity.verify(message.play_activity);
                if (error)
                    return "play_activity." + error;
            }
            if (message.chat_wheel != null && message.hasOwnProperty("chat_wheel")) {
                var error = $root.VersusScene_ChatWheel.verify(message.chat_wheel);
                if (error)
                    return "chat_wheel." + error;
            }
            if (message.playback_rate != null && message.hasOwnProperty("playback_rate")) {
                var error = $root.VersusScene_PlaybackRate.verify(message.playback_rate);
                if (error)
                    return "playback_rate." + error;
            }
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_VersusScene_PlayerBehavior message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_VersusScene_PlayerBehavior
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_VersusScene_PlayerBehavior} CDOTAUserMsg_VersusScene_PlayerBehavior
         */
        CDOTAUserMsg_VersusScene_PlayerBehavior.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_VersusScene_PlayerBehavior)
                return object;
            var message = new $root.CDOTAUserMsg_VersusScene_PlayerBehavior();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            switch (object.behavior) {
            case "VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY":
            case 1:
                message.behavior = 1;
                break;
            case "VS_PLAYER_BEHAVIOR_CHAT_WHEEL":
            case 2:
                message.behavior = 2;
                break;
            case "VS_PLAYER_BEHAVIOR_PLAYBACK_RATE":
            case 3:
                message.behavior = 3;
                break;
            }
            if (object.play_activity != null) {
                if (typeof object.play_activity !== "object")
                    throw TypeError(".CDOTAUserMsg_VersusScene_PlayerBehavior.play_activity: object expected");
                message.play_activity = $root.VersusScene_PlayActivity.fromObject(object.play_activity);
            }
            if (object.chat_wheel != null) {
                if (typeof object.chat_wheel !== "object")
                    throw TypeError(".CDOTAUserMsg_VersusScene_PlayerBehavior.chat_wheel: object expected");
                message.chat_wheel = $root.VersusScene_ChatWheel.fromObject(object.chat_wheel);
            }
            if (object.playback_rate != null) {
                if (typeof object.playback_rate !== "object")
                    throw TypeError(".CDOTAUserMsg_VersusScene_PlayerBehavior.playback_rate: object expected");
                message.playback_rate = $root.VersusScene_PlaybackRate.fromObject(object.playback_rate);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_VersusScene_PlayerBehavior message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_VersusScene_PlayerBehavior
         * @static
         * @param {CDOTAUserMsg_VersusScene_PlayerBehavior} message CDOTAUserMsg_VersusScene_PlayerBehavior
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_VersusScene_PlayerBehavior.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id = 0;
                object.behavior = options.enums === String ? "VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY" : 1;
                object.play_activity = null;
                object.chat_wheel = null;
                object.playback_rate = null;
            }
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            if (message.behavior != null && message.hasOwnProperty("behavior"))
                object.behavior = options.enums === String ? $root.EDOTAVersusScenePlayerBehavior[message.behavior] : message.behavior;
            if (message.play_activity != null && message.hasOwnProperty("play_activity"))
                object.play_activity = $root.VersusScene_PlayActivity.toObject(message.play_activity, options);
            if (message.chat_wheel != null && message.hasOwnProperty("chat_wheel"))
                object.chat_wheel = $root.VersusScene_ChatWheel.toObject(message.chat_wheel, options);
            if (message.playback_rate != null && message.hasOwnProperty("playback_rate"))
                object.playback_rate = $root.VersusScene_PlaybackRate.toObject(message.playback_rate, options);
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_VersusScene_PlayerBehavior to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_VersusScene_PlayerBehavior
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_VersusScene_PlayerBehavior.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_VersusScene_PlayerBehavior;
    })();
    
    $root.CDOTAUserMsg_QoP_ArcanaSummary = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_QoP_ArcanaSummary.
         * @exports ICDOTAUserMsg_QoP_ArcanaSummary
         * @interface ICDOTAUserMsg_QoP_ArcanaSummary
         * @property {number|null} [ehandle] CDOTAUserMsg_QoP_ArcanaSummary ehandle
         * @property {number|null} [arcana_level] CDOTAUserMsg_QoP_ArcanaSummary arcana_level
         * @property {number|null} [players_hit] CDOTAUserMsg_QoP_ArcanaSummary players_hit
         * @property {number|null} [players_killed] CDOTAUserMsg_QoP_ArcanaSummary players_killed
         */
    
        /**
         * Constructs a new CDOTAUserMsg_QoP_ArcanaSummary.
         * @exports CDOTAUserMsg_QoP_ArcanaSummary
         * @classdesc Represents a CDOTAUserMsg_QoP_ArcanaSummary.
         * @implements ICDOTAUserMsg_QoP_ArcanaSummary
         * @constructor
         * @param {ICDOTAUserMsg_QoP_ArcanaSummary=} [properties] Properties to set
         */
        function CDOTAUserMsg_QoP_ArcanaSummary(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_QoP_ArcanaSummary ehandle.
         * @member {number} ehandle
         * @memberof CDOTAUserMsg_QoP_ArcanaSummary
         * @instance
         */
        CDOTAUserMsg_QoP_ArcanaSummary.prototype.ehandle = 0;
    
        /**
         * CDOTAUserMsg_QoP_ArcanaSummary arcana_level.
         * @member {number} arcana_level
         * @memberof CDOTAUserMsg_QoP_ArcanaSummary
         * @instance
         */
        CDOTAUserMsg_QoP_ArcanaSummary.prototype.arcana_level = 0;
    
        /**
         * CDOTAUserMsg_QoP_ArcanaSummary players_hit.
         * @member {number} players_hit
         * @memberof CDOTAUserMsg_QoP_ArcanaSummary
         * @instance
         */
        CDOTAUserMsg_QoP_ArcanaSummary.prototype.players_hit = 0;
    
        /**
         * CDOTAUserMsg_QoP_ArcanaSummary players_killed.
         * @member {number} players_killed
         * @memberof CDOTAUserMsg_QoP_ArcanaSummary
         * @instance
         */
        CDOTAUserMsg_QoP_ArcanaSummary.prototype.players_killed = 0;
    
        /**
         * Creates a new CDOTAUserMsg_QoP_ArcanaSummary instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_QoP_ArcanaSummary
         * @static
         * @param {ICDOTAUserMsg_QoP_ArcanaSummary=} [properties] Properties to set
         * @returns {CDOTAUserMsg_QoP_ArcanaSummary} CDOTAUserMsg_QoP_ArcanaSummary instance
         */
        CDOTAUserMsg_QoP_ArcanaSummary.create = function create(properties) {
            return new CDOTAUserMsg_QoP_ArcanaSummary(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_QoP_ArcanaSummary message. Does not implicitly {@link CDOTAUserMsg_QoP_ArcanaSummary.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_QoP_ArcanaSummary
         * @static
         * @param {ICDOTAUserMsg_QoP_ArcanaSummary} message CDOTAUserMsg_QoP_ArcanaSummary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_QoP_ArcanaSummary.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ehandle != null && Object.hasOwnProperty.call(message, "ehandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ehandle);
            if (message.arcana_level != null && Object.hasOwnProperty.call(message, "arcana_level"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.arcana_level);
            if (message.players_hit != null && Object.hasOwnProperty.call(message, "players_hit"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.players_hit);
            if (message.players_killed != null && Object.hasOwnProperty.call(message, "players_killed"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.players_killed);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_QoP_ArcanaSummary message, length delimited. Does not implicitly {@link CDOTAUserMsg_QoP_ArcanaSummary.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_QoP_ArcanaSummary
         * @static
         * @param {ICDOTAUserMsg_QoP_ArcanaSummary} message CDOTAUserMsg_QoP_ArcanaSummary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_QoP_ArcanaSummary.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_QoP_ArcanaSummary message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_QoP_ArcanaSummary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_QoP_ArcanaSummary} CDOTAUserMsg_QoP_ArcanaSummary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_QoP_ArcanaSummary.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_QoP_ArcanaSummary();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ehandle = reader.uint32();
                    break;
                case 2:
                    message.arcana_level = reader.uint32();
                    break;
                case 3:
                    message.players_hit = reader.uint32();
                    break;
                case 4:
                    message.players_killed = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_QoP_ArcanaSummary message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_QoP_ArcanaSummary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_QoP_ArcanaSummary} CDOTAUserMsg_QoP_ArcanaSummary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_QoP_ArcanaSummary.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_QoP_ArcanaSummary message.
         * @function verify
         * @memberof CDOTAUserMsg_QoP_ArcanaSummary
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_QoP_ArcanaSummary.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ehandle != null && message.hasOwnProperty("ehandle"))
                if (!$util.isInteger(message.ehandle))
                    return "ehandle: integer expected";
            if (message.arcana_level != null && message.hasOwnProperty("arcana_level"))
                if (!$util.isInteger(message.arcana_level))
                    return "arcana_level: integer expected";
            if (message.players_hit != null && message.hasOwnProperty("players_hit"))
                if (!$util.isInteger(message.players_hit))
                    return "players_hit: integer expected";
            if (message.players_killed != null && message.hasOwnProperty("players_killed"))
                if (!$util.isInteger(message.players_killed))
                    return "players_killed: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_QoP_ArcanaSummary message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_QoP_ArcanaSummary
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_QoP_ArcanaSummary} CDOTAUserMsg_QoP_ArcanaSummary
         */
        CDOTAUserMsg_QoP_ArcanaSummary.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_QoP_ArcanaSummary)
                return object;
            var message = new $root.CDOTAUserMsg_QoP_ArcanaSummary();
            if (object.ehandle != null)
                message.ehandle = object.ehandle >>> 0;
            if (object.arcana_level != null)
                message.arcana_level = object.arcana_level >>> 0;
            if (object.players_hit != null)
                message.players_hit = object.players_hit >>> 0;
            if (object.players_killed != null)
                message.players_killed = object.players_killed >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_QoP_ArcanaSummary message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_QoP_ArcanaSummary
         * @static
         * @param {CDOTAUserMsg_QoP_ArcanaSummary} message CDOTAUserMsg_QoP_ArcanaSummary
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_QoP_ArcanaSummary.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ehandle = 0;
                object.arcana_level = 0;
                object.players_hit = 0;
                object.players_killed = 0;
            }
            if (message.ehandle != null && message.hasOwnProperty("ehandle"))
                object.ehandle = message.ehandle;
            if (message.arcana_level != null && message.hasOwnProperty("arcana_level"))
                object.arcana_level = message.arcana_level;
            if (message.players_hit != null && message.hasOwnProperty("players_hit"))
                object.players_hit = message.players_hit;
            if (message.players_killed != null && message.hasOwnProperty("players_killed"))
                object.players_killed = message.players_killed;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_QoP_ArcanaSummary to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_QoP_ArcanaSummary
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_QoP_ArcanaSummary.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_QoP_ArcanaSummary;
    })();
    
    $root.CDOTAUserMsg_HotPotato_Created = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_HotPotato_Created.
         * @exports ICDOTAUserMsg_HotPotato_Created
         * @interface ICDOTAUserMsg_HotPotato_Created
         * @property {number|null} [player_id_1] CDOTAUserMsg_HotPotato_Created player_id_1
         * @property {number|null} [player_id_2] CDOTAUserMsg_HotPotato_Created player_id_2
         */
    
        /**
         * Constructs a new CDOTAUserMsg_HotPotato_Created.
         * @exports CDOTAUserMsg_HotPotato_Created
         * @classdesc Represents a CDOTAUserMsg_HotPotato_Created.
         * @implements ICDOTAUserMsg_HotPotato_Created
         * @constructor
         * @param {ICDOTAUserMsg_HotPotato_Created=} [properties] Properties to set
         */
        function CDOTAUserMsg_HotPotato_Created(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_HotPotato_Created player_id_1.
         * @member {number} player_id_1
         * @memberof CDOTAUserMsg_HotPotato_Created
         * @instance
         */
        CDOTAUserMsg_HotPotato_Created.prototype.player_id_1 = 0;
    
        /**
         * CDOTAUserMsg_HotPotato_Created player_id_2.
         * @member {number} player_id_2
         * @memberof CDOTAUserMsg_HotPotato_Created
         * @instance
         */
        CDOTAUserMsg_HotPotato_Created.prototype.player_id_2 = 0;
    
        /**
         * Creates a new CDOTAUserMsg_HotPotato_Created instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_HotPotato_Created
         * @static
         * @param {ICDOTAUserMsg_HotPotato_Created=} [properties] Properties to set
         * @returns {CDOTAUserMsg_HotPotato_Created} CDOTAUserMsg_HotPotato_Created instance
         */
        CDOTAUserMsg_HotPotato_Created.create = function create(properties) {
            return new CDOTAUserMsg_HotPotato_Created(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_HotPotato_Created message. Does not implicitly {@link CDOTAUserMsg_HotPotato_Created.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_HotPotato_Created
         * @static
         * @param {ICDOTAUserMsg_HotPotato_Created} message CDOTAUserMsg_HotPotato_Created message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_HotPotato_Created.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id_1 != null && Object.hasOwnProperty.call(message, "player_id_1"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id_1);
            if (message.player_id_2 != null && Object.hasOwnProperty.call(message, "player_id_2"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.player_id_2);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_HotPotato_Created message, length delimited. Does not implicitly {@link CDOTAUserMsg_HotPotato_Created.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_HotPotato_Created
         * @static
         * @param {ICDOTAUserMsg_HotPotato_Created} message CDOTAUserMsg_HotPotato_Created message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_HotPotato_Created.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_HotPotato_Created message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_HotPotato_Created
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_HotPotato_Created} CDOTAUserMsg_HotPotato_Created
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_HotPotato_Created.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_HotPotato_Created();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id_1 = reader.uint32();
                    break;
                case 2:
                    message.player_id_2 = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_HotPotato_Created message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_HotPotato_Created
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_HotPotato_Created} CDOTAUserMsg_HotPotato_Created
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_HotPotato_Created.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_HotPotato_Created message.
         * @function verify
         * @memberof CDOTAUserMsg_HotPotato_Created
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_HotPotato_Created.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id_1 != null && message.hasOwnProperty("player_id_1"))
                if (!$util.isInteger(message.player_id_1))
                    return "player_id_1: integer expected";
            if (message.player_id_2 != null && message.hasOwnProperty("player_id_2"))
                if (!$util.isInteger(message.player_id_2))
                    return "player_id_2: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_HotPotato_Created message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_HotPotato_Created
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_HotPotato_Created} CDOTAUserMsg_HotPotato_Created
         */
        CDOTAUserMsg_HotPotato_Created.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_HotPotato_Created)
                return object;
            var message = new $root.CDOTAUserMsg_HotPotato_Created();
            if (object.player_id_1 != null)
                message.player_id_1 = object.player_id_1 >>> 0;
            if (object.player_id_2 != null)
                message.player_id_2 = object.player_id_2 >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_HotPotato_Created message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_HotPotato_Created
         * @static
         * @param {CDOTAUserMsg_HotPotato_Created} message CDOTAUserMsg_HotPotato_Created
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_HotPotato_Created.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_id_1 = 0;
                object.player_id_2 = 0;
            }
            if (message.player_id_1 != null && message.hasOwnProperty("player_id_1"))
                object.player_id_1 = message.player_id_1;
            if (message.player_id_2 != null && message.hasOwnProperty("player_id_2"))
                object.player_id_2 = message.player_id_2;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_HotPotato_Created to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_HotPotato_Created
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_HotPotato_Created.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_HotPotato_Created;
    })();
    
    $root.CDOTAUserMsg_HotPotato_Exploded = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_HotPotato_Exploded.
         * @exports ICDOTAUserMsg_HotPotato_Exploded
         * @interface ICDOTAUserMsg_HotPotato_Exploded
         * @property {number|null} [player_id] CDOTAUserMsg_HotPotato_Exploded player_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_HotPotato_Exploded.
         * @exports CDOTAUserMsg_HotPotato_Exploded
         * @classdesc Represents a CDOTAUserMsg_HotPotato_Exploded.
         * @implements ICDOTAUserMsg_HotPotato_Exploded
         * @constructor
         * @param {ICDOTAUserMsg_HotPotato_Exploded=} [properties] Properties to set
         */
        function CDOTAUserMsg_HotPotato_Exploded(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_HotPotato_Exploded player_id.
         * @member {number} player_id
         * @memberof CDOTAUserMsg_HotPotato_Exploded
         * @instance
         */
        CDOTAUserMsg_HotPotato_Exploded.prototype.player_id = 0;
    
        /**
         * Creates a new CDOTAUserMsg_HotPotato_Exploded instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_HotPotato_Exploded
         * @static
         * @param {ICDOTAUserMsg_HotPotato_Exploded=} [properties] Properties to set
         * @returns {CDOTAUserMsg_HotPotato_Exploded} CDOTAUserMsg_HotPotato_Exploded instance
         */
        CDOTAUserMsg_HotPotato_Exploded.create = function create(properties) {
            return new CDOTAUserMsg_HotPotato_Exploded(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_HotPotato_Exploded message. Does not implicitly {@link CDOTAUserMsg_HotPotato_Exploded.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_HotPotato_Exploded
         * @static
         * @param {ICDOTAUserMsg_HotPotato_Exploded} message CDOTAUserMsg_HotPotato_Exploded message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_HotPotato_Exploded.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_HotPotato_Exploded message, length delimited. Does not implicitly {@link CDOTAUserMsg_HotPotato_Exploded.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_HotPotato_Exploded
         * @static
         * @param {ICDOTAUserMsg_HotPotato_Exploded} message CDOTAUserMsg_HotPotato_Exploded message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_HotPotato_Exploded.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_HotPotato_Exploded message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_HotPotato_Exploded
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_HotPotato_Exploded} CDOTAUserMsg_HotPotato_Exploded
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_HotPotato_Exploded.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_HotPotato_Exploded();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_HotPotato_Exploded message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_HotPotato_Exploded
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_HotPotato_Exploded} CDOTAUserMsg_HotPotato_Exploded
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_HotPotato_Exploded.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_HotPotato_Exploded message.
         * @function verify
         * @memberof CDOTAUserMsg_HotPotato_Exploded
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_HotPotato_Exploded.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_HotPotato_Exploded message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_HotPotato_Exploded
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_HotPotato_Exploded} CDOTAUserMsg_HotPotato_Exploded
         */
        CDOTAUserMsg_HotPotato_Exploded.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_HotPotato_Exploded)
                return object;
            var message = new $root.CDOTAUserMsg_HotPotato_Exploded();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_HotPotato_Exploded message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_HotPotato_Exploded
         * @static
         * @param {CDOTAUserMsg_HotPotato_Exploded} message CDOTAUserMsg_HotPotato_Exploded
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_HotPotato_Exploded.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.player_id = 0;
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_HotPotato_Exploded to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_HotPotato_Exploded
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_HotPotato_Exploded.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_HotPotato_Exploded;
    })();
    
    $root.CDOTAUserMsg_WK_Arcana_Progress = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_WK_Arcana_Progress.
         * @exports ICDOTAUserMsg_WK_Arcana_Progress
         * @interface ICDOTAUserMsg_WK_Arcana_Progress
         * @property {number|null} [ehandle] CDOTAUserMsg_WK_Arcana_Progress ehandle
         * @property {number|null} [arcana_level] CDOTAUserMsg_WK_Arcana_Progress arcana_level
         * @property {number|null} [hero_id] CDOTAUserMsg_WK_Arcana_Progress hero_id
         */
    
        /**
         * Constructs a new CDOTAUserMsg_WK_Arcana_Progress.
         * @exports CDOTAUserMsg_WK_Arcana_Progress
         * @classdesc Represents a CDOTAUserMsg_WK_Arcana_Progress.
         * @implements ICDOTAUserMsg_WK_Arcana_Progress
         * @constructor
         * @param {ICDOTAUserMsg_WK_Arcana_Progress=} [properties] Properties to set
         */
        function CDOTAUserMsg_WK_Arcana_Progress(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_WK_Arcana_Progress ehandle.
         * @member {number} ehandle
         * @memberof CDOTAUserMsg_WK_Arcana_Progress
         * @instance
         */
        CDOTAUserMsg_WK_Arcana_Progress.prototype.ehandle = 0;
    
        /**
         * CDOTAUserMsg_WK_Arcana_Progress arcana_level.
         * @member {number} arcana_level
         * @memberof CDOTAUserMsg_WK_Arcana_Progress
         * @instance
         */
        CDOTAUserMsg_WK_Arcana_Progress.prototype.arcana_level = 0;
    
        /**
         * CDOTAUserMsg_WK_Arcana_Progress hero_id.
         * @member {number} hero_id
         * @memberof CDOTAUserMsg_WK_Arcana_Progress
         * @instance
         */
        CDOTAUserMsg_WK_Arcana_Progress.prototype.hero_id = 0;
    
        /**
         * Creates a new CDOTAUserMsg_WK_Arcana_Progress instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_WK_Arcana_Progress
         * @static
         * @param {ICDOTAUserMsg_WK_Arcana_Progress=} [properties] Properties to set
         * @returns {CDOTAUserMsg_WK_Arcana_Progress} CDOTAUserMsg_WK_Arcana_Progress instance
         */
        CDOTAUserMsg_WK_Arcana_Progress.create = function create(properties) {
            return new CDOTAUserMsg_WK_Arcana_Progress(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_WK_Arcana_Progress message. Does not implicitly {@link CDOTAUserMsg_WK_Arcana_Progress.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_WK_Arcana_Progress
         * @static
         * @param {ICDOTAUserMsg_WK_Arcana_Progress} message CDOTAUserMsg_WK_Arcana_Progress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_WK_Arcana_Progress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ehandle != null && Object.hasOwnProperty.call(message, "ehandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ehandle);
            if (message.arcana_level != null && Object.hasOwnProperty.call(message, "arcana_level"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.arcana_level);
            if (message.hero_id != null && Object.hasOwnProperty.call(message, "hero_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.hero_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_WK_Arcana_Progress message, length delimited. Does not implicitly {@link CDOTAUserMsg_WK_Arcana_Progress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_WK_Arcana_Progress
         * @static
         * @param {ICDOTAUserMsg_WK_Arcana_Progress} message CDOTAUserMsg_WK_Arcana_Progress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_WK_Arcana_Progress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_WK_Arcana_Progress message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_WK_Arcana_Progress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_WK_Arcana_Progress} CDOTAUserMsg_WK_Arcana_Progress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_WK_Arcana_Progress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_WK_Arcana_Progress();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ehandle = reader.uint32();
                    break;
                case 2:
                    message.arcana_level = reader.uint32();
                    break;
                case 3:
                    message.hero_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_WK_Arcana_Progress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_WK_Arcana_Progress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_WK_Arcana_Progress} CDOTAUserMsg_WK_Arcana_Progress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_WK_Arcana_Progress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_WK_Arcana_Progress message.
         * @function verify
         * @memberof CDOTAUserMsg_WK_Arcana_Progress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_WK_Arcana_Progress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ehandle != null && message.hasOwnProperty("ehandle"))
                if (!$util.isInteger(message.ehandle))
                    return "ehandle: integer expected";
            if (message.arcana_level != null && message.hasOwnProperty("arcana_level"))
                if (!$util.isInteger(message.arcana_level))
                    return "arcana_level: integer expected";
            if (message.hero_id != null && message.hasOwnProperty("hero_id"))
                if (!$util.isInteger(message.hero_id))
                    return "hero_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_WK_Arcana_Progress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_WK_Arcana_Progress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_WK_Arcana_Progress} CDOTAUserMsg_WK_Arcana_Progress
         */
        CDOTAUserMsg_WK_Arcana_Progress.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_WK_Arcana_Progress)
                return object;
            var message = new $root.CDOTAUserMsg_WK_Arcana_Progress();
            if (object.ehandle != null)
                message.ehandle = object.ehandle >>> 0;
            if (object.arcana_level != null)
                message.arcana_level = object.arcana_level >>> 0;
            if (object.hero_id != null)
                message.hero_id = object.hero_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_WK_Arcana_Progress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_WK_Arcana_Progress
         * @static
         * @param {CDOTAUserMsg_WK_Arcana_Progress} message CDOTAUserMsg_WK_Arcana_Progress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_WK_Arcana_Progress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ehandle = 0;
                object.arcana_level = 0;
                object.hero_id = 0;
            }
            if (message.ehandle != null && message.hasOwnProperty("ehandle"))
                object.ehandle = message.ehandle;
            if (message.arcana_level != null && message.hasOwnProperty("arcana_level"))
                object.arcana_level = message.arcana_level;
            if (message.hero_id != null && message.hasOwnProperty("hero_id"))
                object.hero_id = message.hero_id;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_WK_Arcana_Progress to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_WK_Arcana_Progress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_WK_Arcana_Progress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_WK_Arcana_Progress;
    })();
    
    $root.CDOTAUserMsg_GuildChallenge_Progress = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_GuildChallenge_Progress.
         * @exports ICDOTAUserMsg_GuildChallenge_Progress
         * @interface ICDOTAUserMsg_GuildChallenge_Progress
         * @property {Array.<CDOTAUserMsg_GuildChallenge_Progress.IPlayerProgress>|null} [player_progress] CDOTAUserMsg_GuildChallenge_Progress player_progress
         * @property {number|null} [guild_id] CDOTAUserMsg_GuildChallenge_Progress guild_id
         * @property {number|null} [challenge_instance_id] CDOTAUserMsg_GuildChallenge_Progress challenge_instance_id
         * @property {number|null} [challenge_parameter] CDOTAUserMsg_GuildChallenge_Progress challenge_parameter
         * @property {CDOTAUserMsg_GuildChallenge_Progress.EChallengeType|null} [challenge_type] CDOTAUserMsg_GuildChallenge_Progress challenge_type
         * @property {number|null} [challenge_progress_at_start] CDOTAUserMsg_GuildChallenge_Progress challenge_progress_at_start
         * @property {boolean|null} [complete] CDOTAUserMsg_GuildChallenge_Progress complete
         */
    
        /**
         * Constructs a new CDOTAUserMsg_GuildChallenge_Progress.
         * @exports CDOTAUserMsg_GuildChallenge_Progress
         * @classdesc Represents a CDOTAUserMsg_GuildChallenge_Progress.
         * @implements ICDOTAUserMsg_GuildChallenge_Progress
         * @constructor
         * @param {ICDOTAUserMsg_GuildChallenge_Progress=} [properties] Properties to set
         */
        function CDOTAUserMsg_GuildChallenge_Progress(properties) {
            this.player_progress = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_GuildChallenge_Progress player_progress.
         * @member {Array.<CDOTAUserMsg_GuildChallenge_Progress.IPlayerProgress>} player_progress
         * @memberof CDOTAUserMsg_GuildChallenge_Progress
         * @instance
         */
        CDOTAUserMsg_GuildChallenge_Progress.prototype.player_progress = $util.emptyArray;
    
        /**
         * CDOTAUserMsg_GuildChallenge_Progress guild_id.
         * @member {number} guild_id
         * @memberof CDOTAUserMsg_GuildChallenge_Progress
         * @instance
         */
        CDOTAUserMsg_GuildChallenge_Progress.prototype.guild_id = 0;
    
        /**
         * CDOTAUserMsg_GuildChallenge_Progress challenge_instance_id.
         * @member {number} challenge_instance_id
         * @memberof CDOTAUserMsg_GuildChallenge_Progress
         * @instance
         */
        CDOTAUserMsg_GuildChallenge_Progress.prototype.challenge_instance_id = 0;
    
        /**
         * CDOTAUserMsg_GuildChallenge_Progress challenge_parameter.
         * @member {number} challenge_parameter
         * @memberof CDOTAUserMsg_GuildChallenge_Progress
         * @instance
         */
        CDOTAUserMsg_GuildChallenge_Progress.prototype.challenge_parameter = 0;
    
        /**
         * CDOTAUserMsg_GuildChallenge_Progress challenge_type.
         * @member {CDOTAUserMsg_GuildChallenge_Progress.EChallengeType} challenge_type
         * @memberof CDOTAUserMsg_GuildChallenge_Progress
         * @instance
         */
        CDOTAUserMsg_GuildChallenge_Progress.prototype.challenge_type = 0;
    
        /**
         * CDOTAUserMsg_GuildChallenge_Progress challenge_progress_at_start.
         * @member {number} challenge_progress_at_start
         * @memberof CDOTAUserMsg_GuildChallenge_Progress
         * @instance
         */
        CDOTAUserMsg_GuildChallenge_Progress.prototype.challenge_progress_at_start = 0;
    
        /**
         * CDOTAUserMsg_GuildChallenge_Progress complete.
         * @member {boolean} complete
         * @memberof CDOTAUserMsg_GuildChallenge_Progress
         * @instance
         */
        CDOTAUserMsg_GuildChallenge_Progress.prototype.complete = false;
    
        /**
         * Creates a new CDOTAUserMsg_GuildChallenge_Progress instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_GuildChallenge_Progress
         * @static
         * @param {ICDOTAUserMsg_GuildChallenge_Progress=} [properties] Properties to set
         * @returns {CDOTAUserMsg_GuildChallenge_Progress} CDOTAUserMsg_GuildChallenge_Progress instance
         */
        CDOTAUserMsg_GuildChallenge_Progress.create = function create(properties) {
            return new CDOTAUserMsg_GuildChallenge_Progress(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_GuildChallenge_Progress message. Does not implicitly {@link CDOTAUserMsg_GuildChallenge_Progress.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_GuildChallenge_Progress
         * @static
         * @param {ICDOTAUserMsg_GuildChallenge_Progress} message CDOTAUserMsg_GuildChallenge_Progress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_GuildChallenge_Progress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_progress != null && message.player_progress.length)
                for (var i = 0; i < message.player_progress.length; ++i)
                    $root.CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress.encode(message.player_progress[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.guild_id != null && Object.hasOwnProperty.call(message, "guild_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.guild_id);
            if (message.challenge_instance_id != null && Object.hasOwnProperty.call(message, "challenge_instance_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.challenge_instance_id);
            if (message.challenge_parameter != null && Object.hasOwnProperty.call(message, "challenge_parameter"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.challenge_parameter);
            if (message.challenge_type != null && Object.hasOwnProperty.call(message, "challenge_type"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.challenge_type);
            if (message.challenge_progress_at_start != null && Object.hasOwnProperty.call(message, "challenge_progress_at_start"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.challenge_progress_at_start);
            if (message.complete != null && Object.hasOwnProperty.call(message, "complete"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.complete);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_GuildChallenge_Progress message, length delimited. Does not implicitly {@link CDOTAUserMsg_GuildChallenge_Progress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_GuildChallenge_Progress
         * @static
         * @param {ICDOTAUserMsg_GuildChallenge_Progress} message CDOTAUserMsg_GuildChallenge_Progress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_GuildChallenge_Progress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_GuildChallenge_Progress message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_GuildChallenge_Progress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_GuildChallenge_Progress} CDOTAUserMsg_GuildChallenge_Progress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_GuildChallenge_Progress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_GuildChallenge_Progress();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.player_progress && message.player_progress.length))
                        message.player_progress = [];
                    message.player_progress.push($root.CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.guild_id = reader.uint32();
                    break;
                case 3:
                    message.challenge_instance_id = reader.uint32();
                    break;
                case 4:
                    message.challenge_parameter = reader.uint32();
                    break;
                case 5:
                    message.challenge_type = reader.int32();
                    break;
                case 7:
                    message.challenge_progress_at_start = reader.uint32();
                    break;
                case 8:
                    message.complete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_GuildChallenge_Progress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_GuildChallenge_Progress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_GuildChallenge_Progress} CDOTAUserMsg_GuildChallenge_Progress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_GuildChallenge_Progress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_GuildChallenge_Progress message.
         * @function verify
         * @memberof CDOTAUserMsg_GuildChallenge_Progress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_GuildChallenge_Progress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_progress != null && message.hasOwnProperty("player_progress")) {
                if (!Array.isArray(message.player_progress))
                    return "player_progress: array expected";
                for (var i = 0; i < message.player_progress.length; ++i) {
                    var error = $root.CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress.verify(message.player_progress[i]);
                    if (error)
                        return "player_progress." + error;
                }
            }
            if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                if (!$util.isInteger(message.guild_id))
                    return "guild_id: integer expected";
            if (message.challenge_instance_id != null && message.hasOwnProperty("challenge_instance_id"))
                if (!$util.isInteger(message.challenge_instance_id))
                    return "challenge_instance_id: integer expected";
            if (message.challenge_parameter != null && message.hasOwnProperty("challenge_parameter"))
                if (!$util.isInteger(message.challenge_parameter))
                    return "challenge_parameter: integer expected";
            if (message.challenge_type != null && message.hasOwnProperty("challenge_type"))
                switch (message.challenge_type) {
                default:
                    return "challenge_type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.challenge_progress_at_start != null && message.hasOwnProperty("challenge_progress_at_start"))
                if (!$util.isInteger(message.challenge_progress_at_start))
                    return "challenge_progress_at_start: integer expected";
            if (message.complete != null && message.hasOwnProperty("complete"))
                if (typeof message.complete !== "boolean")
                    return "complete: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_GuildChallenge_Progress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_GuildChallenge_Progress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_GuildChallenge_Progress} CDOTAUserMsg_GuildChallenge_Progress
         */
        CDOTAUserMsg_GuildChallenge_Progress.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_GuildChallenge_Progress)
                return object;
            var message = new $root.CDOTAUserMsg_GuildChallenge_Progress();
            if (object.player_progress) {
                if (!Array.isArray(object.player_progress))
                    throw TypeError(".CDOTAUserMsg_GuildChallenge_Progress.player_progress: array expected");
                message.player_progress = [];
                for (var i = 0; i < object.player_progress.length; ++i) {
                    if (typeof object.player_progress[i] !== "object")
                        throw TypeError(".CDOTAUserMsg_GuildChallenge_Progress.player_progress: object expected");
                    message.player_progress[i] = $root.CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress.fromObject(object.player_progress[i]);
                }
            }
            if (object.guild_id != null)
                message.guild_id = object.guild_id >>> 0;
            if (object.challenge_instance_id != null)
                message.challenge_instance_id = object.challenge_instance_id >>> 0;
            if (object.challenge_parameter != null)
                message.challenge_parameter = object.challenge_parameter >>> 0;
            switch (object.challenge_type) {
            case "k_EChallengeType_Invalid":
            case 0:
                message.challenge_type = 0;
                break;
            case "k_EChallengeType_Cooperative":
            case 1:
                message.challenge_type = 1;
                break;
            case "k_EChallengeType_Contract":
            case 2:
                message.challenge_type = 2;
                break;
            }
            if (object.challenge_progress_at_start != null)
                message.challenge_progress_at_start = object.challenge_progress_at_start >>> 0;
            if (object.complete != null)
                message.complete = Boolean(object.complete);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_GuildChallenge_Progress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_GuildChallenge_Progress
         * @static
         * @param {CDOTAUserMsg_GuildChallenge_Progress} message CDOTAUserMsg_GuildChallenge_Progress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_GuildChallenge_Progress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.player_progress = [];
            if (options.defaults) {
                object.guild_id = 0;
                object.challenge_instance_id = 0;
                object.challenge_parameter = 0;
                object.challenge_type = options.enums === String ? "k_EChallengeType_Invalid" : 0;
                object.challenge_progress_at_start = 0;
                object.complete = false;
            }
            if (message.player_progress && message.player_progress.length) {
                object.player_progress = [];
                for (var j = 0; j < message.player_progress.length; ++j)
                    object.player_progress[j] = $root.CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress.toObject(message.player_progress[j], options);
            }
            if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                object.guild_id = message.guild_id;
            if (message.challenge_instance_id != null && message.hasOwnProperty("challenge_instance_id"))
                object.challenge_instance_id = message.challenge_instance_id;
            if (message.challenge_parameter != null && message.hasOwnProperty("challenge_parameter"))
                object.challenge_parameter = message.challenge_parameter;
            if (message.challenge_type != null && message.hasOwnProperty("challenge_type"))
                object.challenge_type = options.enums === String ? $root.CDOTAUserMsg_GuildChallenge_Progress.EChallengeType[message.challenge_type] : message.challenge_type;
            if (message.challenge_progress_at_start != null && message.hasOwnProperty("challenge_progress_at_start"))
                object.challenge_progress_at_start = message.challenge_progress_at_start;
            if (message.complete != null && message.hasOwnProperty("complete"))
                object.complete = message.complete;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_GuildChallenge_Progress to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_GuildChallenge_Progress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_GuildChallenge_Progress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress = (function() {
    
            /**
             * Properties of a PlayerProgress.
             * @memberof CDOTAUserMsg_GuildChallenge_Progress
             * @interface IPlayerProgress
             * @property {number|null} [player_id] PlayerProgress player_id
             * @property {number|null} [progress] PlayerProgress progress
             */
    
            /**
             * Constructs a new PlayerProgress.
             * @memberof CDOTAUserMsg_GuildChallenge_Progress
             * @classdesc Represents a PlayerProgress.
             * @implements IPlayerProgress
             * @constructor
             * @param {CDOTAUserMsg_GuildChallenge_Progress.IPlayerProgress=} [properties] Properties to set
             */
            function PlayerProgress(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PlayerProgress player_id.
             * @member {number} player_id
             * @memberof CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress
             * @instance
             */
            PlayerProgress.prototype.player_id = 0;
    
            /**
             * PlayerProgress progress.
             * @member {number} progress
             * @memberof CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress
             * @instance
             */
            PlayerProgress.prototype.progress = 0;
    
            /**
             * Creates a new PlayerProgress instance using the specified properties.
             * @function create
             * @memberof CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress
             * @static
             * @param {CDOTAUserMsg_GuildChallenge_Progress.IPlayerProgress=} [properties] Properties to set
             * @returns {CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress} PlayerProgress instance
             */
            PlayerProgress.create = function create(properties) {
                return new PlayerProgress(properties);
            };
    
            /**
             * Encodes the specified PlayerProgress message. Does not implicitly {@link CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress.verify|verify} messages.
             * @function encode
             * @memberof CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress
             * @static
             * @param {CDOTAUserMsg_GuildChallenge_Progress.IPlayerProgress} message PlayerProgress message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayerProgress.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
                if (message.progress != null && Object.hasOwnProperty.call(message, "progress"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.progress);
                return writer;
            };
    
            /**
             * Encodes the specified PlayerProgress message, length delimited. Does not implicitly {@link CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress
             * @static
             * @param {CDOTAUserMsg_GuildChallenge_Progress.IPlayerProgress} message PlayerProgress message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayerProgress.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PlayerProgress message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress} PlayerProgress
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayerProgress.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.player_id = reader.uint32();
                        break;
                    case 6:
                        message.progress = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PlayerProgress message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress} PlayerProgress
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayerProgress.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PlayerProgress message.
             * @function verify
             * @memberof CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PlayerProgress.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.player_id != null && message.hasOwnProperty("player_id"))
                    if (!$util.isInteger(message.player_id))
                        return "player_id: integer expected";
                if (message.progress != null && message.hasOwnProperty("progress"))
                    if (!$util.isInteger(message.progress))
                        return "progress: integer expected";
                return null;
            };
    
            /**
             * Creates a PlayerProgress message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress} PlayerProgress
             */
            PlayerProgress.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress)
                    return object;
                var message = new $root.CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress();
                if (object.player_id != null)
                    message.player_id = object.player_id >>> 0;
                if (object.progress != null)
                    message.progress = object.progress >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a PlayerProgress message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress
             * @static
             * @param {CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress} message PlayerProgress
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PlayerProgress.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.player_id = 0;
                    object.progress = 0;
                }
                if (message.player_id != null && message.hasOwnProperty("player_id"))
                    object.player_id = message.player_id;
                if (message.progress != null && message.hasOwnProperty("progress"))
                    object.progress = message.progress;
                return object;
            };
    
            /**
             * Converts this PlayerProgress to JSON.
             * @function toJSON
             * @memberof CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PlayerProgress.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PlayerProgress;
        })();
    
        /**
         * EChallengeType enum.
         * @name CDOTAUserMsg_GuildChallenge_Progress.EChallengeType
         * @enum {number}
         * @property {number} k_EChallengeType_Invalid=0 k_EChallengeType_Invalid value
         * @property {number} k_EChallengeType_Cooperative=1 k_EChallengeType_Cooperative value
         * @property {number} k_EChallengeType_Contract=2 k_EChallengeType_Contract value
         */
        CDOTAUserMsg_GuildChallenge_Progress.EChallengeType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "k_EChallengeType_Invalid"] = 0;
            values[valuesById[1] = "k_EChallengeType_Cooperative"] = 1;
            values[valuesById[2] = "k_EChallengeType_Contract"] = 2;
            return values;
        })();
    
        return CDOTAUserMsg_GuildChallenge_Progress;
    })();
    
    $root.CDOTAUserMsg_WRArcanaProgress = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_WRArcanaProgress.
         * @exports ICDOTAUserMsg_WRArcanaProgress
         * @interface ICDOTAUserMsg_WRArcanaProgress
         * @property {number|null} [ehandle] CDOTAUserMsg_WRArcanaProgress ehandle
         * @property {number|null} [target_ehandle] CDOTAUserMsg_WRArcanaProgress target_ehandle
         * @property {number|null} [arrows_landed] CDOTAUserMsg_WRArcanaProgress arrows_landed
         * @property {number|null} [damage_dealt] CDOTAUserMsg_WRArcanaProgress damage_dealt
         * @property {number|null} [target_hp] CDOTAUserMsg_WRArcanaProgress target_hp
         * @property {number|null} [target_max_hp] CDOTAUserMsg_WRArcanaProgress target_max_hp
         * @property {number|null} [arcana_level] CDOTAUserMsg_WRArcanaProgress arcana_level
         */
    
        /**
         * Constructs a new CDOTAUserMsg_WRArcanaProgress.
         * @exports CDOTAUserMsg_WRArcanaProgress
         * @classdesc Represents a CDOTAUserMsg_WRArcanaProgress.
         * @implements ICDOTAUserMsg_WRArcanaProgress
         * @constructor
         * @param {ICDOTAUserMsg_WRArcanaProgress=} [properties] Properties to set
         */
        function CDOTAUserMsg_WRArcanaProgress(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_WRArcanaProgress ehandle.
         * @member {number} ehandle
         * @memberof CDOTAUserMsg_WRArcanaProgress
         * @instance
         */
        CDOTAUserMsg_WRArcanaProgress.prototype.ehandle = 0;
    
        /**
         * CDOTAUserMsg_WRArcanaProgress target_ehandle.
         * @member {number} target_ehandle
         * @memberof CDOTAUserMsg_WRArcanaProgress
         * @instance
         */
        CDOTAUserMsg_WRArcanaProgress.prototype.target_ehandle = 0;
    
        /**
         * CDOTAUserMsg_WRArcanaProgress arrows_landed.
         * @member {number} arrows_landed
         * @memberof CDOTAUserMsg_WRArcanaProgress
         * @instance
         */
        CDOTAUserMsg_WRArcanaProgress.prototype.arrows_landed = 0;
    
        /**
         * CDOTAUserMsg_WRArcanaProgress damage_dealt.
         * @member {number} damage_dealt
         * @memberof CDOTAUserMsg_WRArcanaProgress
         * @instance
         */
        CDOTAUserMsg_WRArcanaProgress.prototype.damage_dealt = 0;
    
        /**
         * CDOTAUserMsg_WRArcanaProgress target_hp.
         * @member {number} target_hp
         * @memberof CDOTAUserMsg_WRArcanaProgress
         * @instance
         */
        CDOTAUserMsg_WRArcanaProgress.prototype.target_hp = 0;
    
        /**
         * CDOTAUserMsg_WRArcanaProgress target_max_hp.
         * @member {number} target_max_hp
         * @memberof CDOTAUserMsg_WRArcanaProgress
         * @instance
         */
        CDOTAUserMsg_WRArcanaProgress.prototype.target_max_hp = 0;
    
        /**
         * CDOTAUserMsg_WRArcanaProgress arcana_level.
         * @member {number} arcana_level
         * @memberof CDOTAUserMsg_WRArcanaProgress
         * @instance
         */
        CDOTAUserMsg_WRArcanaProgress.prototype.arcana_level = 0;
    
        /**
         * Creates a new CDOTAUserMsg_WRArcanaProgress instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_WRArcanaProgress
         * @static
         * @param {ICDOTAUserMsg_WRArcanaProgress=} [properties] Properties to set
         * @returns {CDOTAUserMsg_WRArcanaProgress} CDOTAUserMsg_WRArcanaProgress instance
         */
        CDOTAUserMsg_WRArcanaProgress.create = function create(properties) {
            return new CDOTAUserMsg_WRArcanaProgress(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_WRArcanaProgress message. Does not implicitly {@link CDOTAUserMsg_WRArcanaProgress.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_WRArcanaProgress
         * @static
         * @param {ICDOTAUserMsg_WRArcanaProgress} message CDOTAUserMsg_WRArcanaProgress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_WRArcanaProgress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ehandle != null && Object.hasOwnProperty.call(message, "ehandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ehandle);
            if (message.target_ehandle != null && Object.hasOwnProperty.call(message, "target_ehandle"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.target_ehandle);
            if (message.arrows_landed != null && Object.hasOwnProperty.call(message, "arrows_landed"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.arrows_landed);
            if (message.damage_dealt != null && Object.hasOwnProperty.call(message, "damage_dealt"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.damage_dealt);
            if (message.target_hp != null && Object.hasOwnProperty.call(message, "target_hp"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.target_hp);
            if (message.target_max_hp != null && Object.hasOwnProperty.call(message, "target_max_hp"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.target_max_hp);
            if (message.arcana_level != null && Object.hasOwnProperty.call(message, "arcana_level"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.arcana_level);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_WRArcanaProgress message, length delimited. Does not implicitly {@link CDOTAUserMsg_WRArcanaProgress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_WRArcanaProgress
         * @static
         * @param {ICDOTAUserMsg_WRArcanaProgress} message CDOTAUserMsg_WRArcanaProgress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_WRArcanaProgress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_WRArcanaProgress message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_WRArcanaProgress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_WRArcanaProgress} CDOTAUserMsg_WRArcanaProgress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_WRArcanaProgress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_WRArcanaProgress();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ehandle = reader.uint32();
                    break;
                case 2:
                    message.target_ehandle = reader.uint32();
                    break;
                case 3:
                    message.arrows_landed = reader.uint32();
                    break;
                case 4:
                    message.damage_dealt = reader.uint32();
                    break;
                case 5:
                    message.target_hp = reader.uint32();
                    break;
                case 6:
                    message.target_max_hp = reader.uint32();
                    break;
                case 7:
                    message.arcana_level = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_WRArcanaProgress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_WRArcanaProgress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_WRArcanaProgress} CDOTAUserMsg_WRArcanaProgress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_WRArcanaProgress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_WRArcanaProgress message.
         * @function verify
         * @memberof CDOTAUserMsg_WRArcanaProgress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_WRArcanaProgress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ehandle != null && message.hasOwnProperty("ehandle"))
                if (!$util.isInteger(message.ehandle))
                    return "ehandle: integer expected";
            if (message.target_ehandle != null && message.hasOwnProperty("target_ehandle"))
                if (!$util.isInteger(message.target_ehandle))
                    return "target_ehandle: integer expected";
            if (message.arrows_landed != null && message.hasOwnProperty("arrows_landed"))
                if (!$util.isInteger(message.arrows_landed))
                    return "arrows_landed: integer expected";
            if (message.damage_dealt != null && message.hasOwnProperty("damage_dealt"))
                if (!$util.isInteger(message.damage_dealt))
                    return "damage_dealt: integer expected";
            if (message.target_hp != null && message.hasOwnProperty("target_hp"))
                if (!$util.isInteger(message.target_hp))
                    return "target_hp: integer expected";
            if (message.target_max_hp != null && message.hasOwnProperty("target_max_hp"))
                if (!$util.isInteger(message.target_max_hp))
                    return "target_max_hp: integer expected";
            if (message.arcana_level != null && message.hasOwnProperty("arcana_level"))
                if (!$util.isInteger(message.arcana_level))
                    return "arcana_level: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_WRArcanaProgress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_WRArcanaProgress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_WRArcanaProgress} CDOTAUserMsg_WRArcanaProgress
         */
        CDOTAUserMsg_WRArcanaProgress.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_WRArcanaProgress)
                return object;
            var message = new $root.CDOTAUserMsg_WRArcanaProgress();
            if (object.ehandle != null)
                message.ehandle = object.ehandle >>> 0;
            if (object.target_ehandle != null)
                message.target_ehandle = object.target_ehandle >>> 0;
            if (object.arrows_landed != null)
                message.arrows_landed = object.arrows_landed >>> 0;
            if (object.damage_dealt != null)
                message.damage_dealt = object.damage_dealt >>> 0;
            if (object.target_hp != null)
                message.target_hp = object.target_hp >>> 0;
            if (object.target_max_hp != null)
                message.target_max_hp = object.target_max_hp >>> 0;
            if (object.arcana_level != null)
                message.arcana_level = object.arcana_level >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_WRArcanaProgress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_WRArcanaProgress
         * @static
         * @param {CDOTAUserMsg_WRArcanaProgress} message CDOTAUserMsg_WRArcanaProgress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_WRArcanaProgress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ehandle = 0;
                object.target_ehandle = 0;
                object.arrows_landed = 0;
                object.damage_dealt = 0;
                object.target_hp = 0;
                object.target_max_hp = 0;
                object.arcana_level = 0;
            }
            if (message.ehandle != null && message.hasOwnProperty("ehandle"))
                object.ehandle = message.ehandle;
            if (message.target_ehandle != null && message.hasOwnProperty("target_ehandle"))
                object.target_ehandle = message.target_ehandle;
            if (message.arrows_landed != null && message.hasOwnProperty("arrows_landed"))
                object.arrows_landed = message.arrows_landed;
            if (message.damage_dealt != null && message.hasOwnProperty("damage_dealt"))
                object.damage_dealt = message.damage_dealt;
            if (message.target_hp != null && message.hasOwnProperty("target_hp"))
                object.target_hp = message.target_hp;
            if (message.target_max_hp != null && message.hasOwnProperty("target_max_hp"))
                object.target_max_hp = message.target_max_hp;
            if (message.arcana_level != null && message.hasOwnProperty("arcana_level"))
                object.arcana_level = message.arcana_level;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_WRArcanaProgress to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_WRArcanaProgress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_WRArcanaProgress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_WRArcanaProgress;
    })();
    
    $root.CDOTAUserMsg_WRArcanaSummary = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_WRArcanaSummary.
         * @exports ICDOTAUserMsg_WRArcanaSummary
         * @interface ICDOTAUserMsg_WRArcanaSummary
         * @property {number|null} [ehandle] CDOTAUserMsg_WRArcanaSummary ehandle
         * @property {number|null} [target_ehandle] CDOTAUserMsg_WRArcanaSummary target_ehandle
         * @property {number|null} [arrows_landed] CDOTAUserMsg_WRArcanaSummary arrows_landed
         * @property {number|null} [damage_dealt] CDOTAUserMsg_WRArcanaSummary damage_dealt
         * @property {number|null} [target_hp] CDOTAUserMsg_WRArcanaSummary target_hp
         * @property {number|null} [target_max_hp] CDOTAUserMsg_WRArcanaSummary target_max_hp
         * @property {number|null} [arcana_level] CDOTAUserMsg_WRArcanaSummary arcana_level
         * @property {boolean|null} [success] CDOTAUserMsg_WRArcanaSummary success
         */
    
        /**
         * Constructs a new CDOTAUserMsg_WRArcanaSummary.
         * @exports CDOTAUserMsg_WRArcanaSummary
         * @classdesc Represents a CDOTAUserMsg_WRArcanaSummary.
         * @implements ICDOTAUserMsg_WRArcanaSummary
         * @constructor
         * @param {ICDOTAUserMsg_WRArcanaSummary=} [properties] Properties to set
         */
        function CDOTAUserMsg_WRArcanaSummary(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_WRArcanaSummary ehandle.
         * @member {number} ehandle
         * @memberof CDOTAUserMsg_WRArcanaSummary
         * @instance
         */
        CDOTAUserMsg_WRArcanaSummary.prototype.ehandle = 0;
    
        /**
         * CDOTAUserMsg_WRArcanaSummary target_ehandle.
         * @member {number} target_ehandle
         * @memberof CDOTAUserMsg_WRArcanaSummary
         * @instance
         */
        CDOTAUserMsg_WRArcanaSummary.prototype.target_ehandle = 0;
    
        /**
         * CDOTAUserMsg_WRArcanaSummary arrows_landed.
         * @member {number} arrows_landed
         * @memberof CDOTAUserMsg_WRArcanaSummary
         * @instance
         */
        CDOTAUserMsg_WRArcanaSummary.prototype.arrows_landed = 0;
    
        /**
         * CDOTAUserMsg_WRArcanaSummary damage_dealt.
         * @member {number} damage_dealt
         * @memberof CDOTAUserMsg_WRArcanaSummary
         * @instance
         */
        CDOTAUserMsg_WRArcanaSummary.prototype.damage_dealt = 0;
    
        /**
         * CDOTAUserMsg_WRArcanaSummary target_hp.
         * @member {number} target_hp
         * @memberof CDOTAUserMsg_WRArcanaSummary
         * @instance
         */
        CDOTAUserMsg_WRArcanaSummary.prototype.target_hp = 0;
    
        /**
         * CDOTAUserMsg_WRArcanaSummary target_max_hp.
         * @member {number} target_max_hp
         * @memberof CDOTAUserMsg_WRArcanaSummary
         * @instance
         */
        CDOTAUserMsg_WRArcanaSummary.prototype.target_max_hp = 0;
    
        /**
         * CDOTAUserMsg_WRArcanaSummary arcana_level.
         * @member {number} arcana_level
         * @memberof CDOTAUserMsg_WRArcanaSummary
         * @instance
         */
        CDOTAUserMsg_WRArcanaSummary.prototype.arcana_level = 0;
    
        /**
         * CDOTAUserMsg_WRArcanaSummary success.
         * @member {boolean} success
         * @memberof CDOTAUserMsg_WRArcanaSummary
         * @instance
         */
        CDOTAUserMsg_WRArcanaSummary.prototype.success = false;
    
        /**
         * Creates a new CDOTAUserMsg_WRArcanaSummary instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_WRArcanaSummary
         * @static
         * @param {ICDOTAUserMsg_WRArcanaSummary=} [properties] Properties to set
         * @returns {CDOTAUserMsg_WRArcanaSummary} CDOTAUserMsg_WRArcanaSummary instance
         */
        CDOTAUserMsg_WRArcanaSummary.create = function create(properties) {
            return new CDOTAUserMsg_WRArcanaSummary(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_WRArcanaSummary message. Does not implicitly {@link CDOTAUserMsg_WRArcanaSummary.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_WRArcanaSummary
         * @static
         * @param {ICDOTAUserMsg_WRArcanaSummary} message CDOTAUserMsg_WRArcanaSummary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_WRArcanaSummary.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ehandle != null && Object.hasOwnProperty.call(message, "ehandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ehandle);
            if (message.target_ehandle != null && Object.hasOwnProperty.call(message, "target_ehandle"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.target_ehandle);
            if (message.arrows_landed != null && Object.hasOwnProperty.call(message, "arrows_landed"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.arrows_landed);
            if (message.damage_dealt != null && Object.hasOwnProperty.call(message, "damage_dealt"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.damage_dealt);
            if (message.target_hp != null && Object.hasOwnProperty.call(message, "target_hp"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.target_hp);
            if (message.target_max_hp != null && Object.hasOwnProperty.call(message, "target_max_hp"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.target_max_hp);
            if (message.arcana_level != null && Object.hasOwnProperty.call(message, "arcana_level"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.arcana_level);
            if (message.success != null && Object.hasOwnProperty.call(message, "success"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.success);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_WRArcanaSummary message, length delimited. Does not implicitly {@link CDOTAUserMsg_WRArcanaSummary.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_WRArcanaSummary
         * @static
         * @param {ICDOTAUserMsg_WRArcanaSummary} message CDOTAUserMsg_WRArcanaSummary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_WRArcanaSummary.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_WRArcanaSummary message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_WRArcanaSummary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_WRArcanaSummary} CDOTAUserMsg_WRArcanaSummary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_WRArcanaSummary.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_WRArcanaSummary();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ehandle = reader.uint32();
                    break;
                case 2:
                    message.target_ehandle = reader.uint32();
                    break;
                case 3:
                    message.arrows_landed = reader.uint32();
                    break;
                case 4:
                    message.damage_dealt = reader.uint32();
                    break;
                case 5:
                    message.target_hp = reader.uint32();
                    break;
                case 6:
                    message.target_max_hp = reader.uint32();
                    break;
                case 7:
                    message.arcana_level = reader.uint32();
                    break;
                case 8:
                    message.success = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_WRArcanaSummary message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_WRArcanaSummary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_WRArcanaSummary} CDOTAUserMsg_WRArcanaSummary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_WRArcanaSummary.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_WRArcanaSummary message.
         * @function verify
         * @memberof CDOTAUserMsg_WRArcanaSummary
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_WRArcanaSummary.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ehandle != null && message.hasOwnProperty("ehandle"))
                if (!$util.isInteger(message.ehandle))
                    return "ehandle: integer expected";
            if (message.target_ehandle != null && message.hasOwnProperty("target_ehandle"))
                if (!$util.isInteger(message.target_ehandle))
                    return "target_ehandle: integer expected";
            if (message.arrows_landed != null && message.hasOwnProperty("arrows_landed"))
                if (!$util.isInteger(message.arrows_landed))
                    return "arrows_landed: integer expected";
            if (message.damage_dealt != null && message.hasOwnProperty("damage_dealt"))
                if (!$util.isInteger(message.damage_dealt))
                    return "damage_dealt: integer expected";
            if (message.target_hp != null && message.hasOwnProperty("target_hp"))
                if (!$util.isInteger(message.target_hp))
                    return "target_hp: integer expected";
            if (message.target_max_hp != null && message.hasOwnProperty("target_max_hp"))
                if (!$util.isInteger(message.target_max_hp))
                    return "target_max_hp: integer expected";
            if (message.arcana_level != null && message.hasOwnProperty("arcana_level"))
                if (!$util.isInteger(message.arcana_level))
                    return "arcana_level: integer expected";
            if (message.success != null && message.hasOwnProperty("success"))
                if (typeof message.success !== "boolean")
                    return "success: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_WRArcanaSummary message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_WRArcanaSummary
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_WRArcanaSummary} CDOTAUserMsg_WRArcanaSummary
         */
        CDOTAUserMsg_WRArcanaSummary.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_WRArcanaSummary)
                return object;
            var message = new $root.CDOTAUserMsg_WRArcanaSummary();
            if (object.ehandle != null)
                message.ehandle = object.ehandle >>> 0;
            if (object.target_ehandle != null)
                message.target_ehandle = object.target_ehandle >>> 0;
            if (object.arrows_landed != null)
                message.arrows_landed = object.arrows_landed >>> 0;
            if (object.damage_dealt != null)
                message.damage_dealt = object.damage_dealt >>> 0;
            if (object.target_hp != null)
                message.target_hp = object.target_hp >>> 0;
            if (object.target_max_hp != null)
                message.target_max_hp = object.target_max_hp >>> 0;
            if (object.arcana_level != null)
                message.arcana_level = object.arcana_level >>> 0;
            if (object.success != null)
                message.success = Boolean(object.success);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_WRArcanaSummary message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_WRArcanaSummary
         * @static
         * @param {CDOTAUserMsg_WRArcanaSummary} message CDOTAUserMsg_WRArcanaSummary
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_WRArcanaSummary.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ehandle = 0;
                object.target_ehandle = 0;
                object.arrows_landed = 0;
                object.damage_dealt = 0;
                object.target_hp = 0;
                object.target_max_hp = 0;
                object.arcana_level = 0;
                object.success = false;
            }
            if (message.ehandle != null && message.hasOwnProperty("ehandle"))
                object.ehandle = message.ehandle;
            if (message.target_ehandle != null && message.hasOwnProperty("target_ehandle"))
                object.target_ehandle = message.target_ehandle;
            if (message.arrows_landed != null && message.hasOwnProperty("arrows_landed"))
                object.arrows_landed = message.arrows_landed;
            if (message.damage_dealt != null && message.hasOwnProperty("damage_dealt"))
                object.damage_dealt = message.damage_dealt;
            if (message.target_hp != null && message.hasOwnProperty("target_hp"))
                object.target_hp = message.target_hp;
            if (message.target_max_hp != null && message.hasOwnProperty("target_max_hp"))
                object.target_max_hp = message.target_max_hp;
            if (message.arcana_level != null && message.hasOwnProperty("arcana_level"))
                object.arcana_level = message.arcana_level;
            if (message.success != null && message.hasOwnProperty("success"))
                object.success = message.success;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_WRArcanaSummary to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_WRArcanaSummary
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_WRArcanaSummary.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_WRArcanaSummary;
    })();
    
    $root.CDOTAUserMsg_EmptyItemSlotAlert = (function() {
    
        /**
         * Properties of a CDOTAUserMsg_EmptyItemSlotAlert.
         * @exports ICDOTAUserMsg_EmptyItemSlotAlert
         * @interface ICDOTAUserMsg_EmptyItemSlotAlert
         * @property {number|null} [source_player_id] CDOTAUserMsg_EmptyItemSlotAlert source_player_id
         * @property {number|null} [target_player_id] CDOTAUserMsg_EmptyItemSlotAlert target_player_id
         * @property {number|null} [slot_index] CDOTAUserMsg_EmptyItemSlotAlert slot_index
         * @property {number|null} [cooldown_seconds] CDOTAUserMsg_EmptyItemSlotAlert cooldown_seconds
         */
    
        /**
         * Constructs a new CDOTAUserMsg_EmptyItemSlotAlert.
         * @exports CDOTAUserMsg_EmptyItemSlotAlert
         * @classdesc Represents a CDOTAUserMsg_EmptyItemSlotAlert.
         * @implements ICDOTAUserMsg_EmptyItemSlotAlert
         * @constructor
         * @param {ICDOTAUserMsg_EmptyItemSlotAlert=} [properties] Properties to set
         */
        function CDOTAUserMsg_EmptyItemSlotAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAUserMsg_EmptyItemSlotAlert source_player_id.
         * @member {number} source_player_id
         * @memberof CDOTAUserMsg_EmptyItemSlotAlert
         * @instance
         */
        CDOTAUserMsg_EmptyItemSlotAlert.prototype.source_player_id = 0;
    
        /**
         * CDOTAUserMsg_EmptyItemSlotAlert target_player_id.
         * @member {number} target_player_id
         * @memberof CDOTAUserMsg_EmptyItemSlotAlert
         * @instance
         */
        CDOTAUserMsg_EmptyItemSlotAlert.prototype.target_player_id = 0;
    
        /**
         * CDOTAUserMsg_EmptyItemSlotAlert slot_index.
         * @member {number} slot_index
         * @memberof CDOTAUserMsg_EmptyItemSlotAlert
         * @instance
         */
        CDOTAUserMsg_EmptyItemSlotAlert.prototype.slot_index = 0;
    
        /**
         * CDOTAUserMsg_EmptyItemSlotAlert cooldown_seconds.
         * @member {number} cooldown_seconds
         * @memberof CDOTAUserMsg_EmptyItemSlotAlert
         * @instance
         */
        CDOTAUserMsg_EmptyItemSlotAlert.prototype.cooldown_seconds = 0;
    
        /**
         * Creates a new CDOTAUserMsg_EmptyItemSlotAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAUserMsg_EmptyItemSlotAlert
         * @static
         * @param {ICDOTAUserMsg_EmptyItemSlotAlert=} [properties] Properties to set
         * @returns {CDOTAUserMsg_EmptyItemSlotAlert} CDOTAUserMsg_EmptyItemSlotAlert instance
         */
        CDOTAUserMsg_EmptyItemSlotAlert.create = function create(properties) {
            return new CDOTAUserMsg_EmptyItemSlotAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_EmptyItemSlotAlert message. Does not implicitly {@link CDOTAUserMsg_EmptyItemSlotAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAUserMsg_EmptyItemSlotAlert
         * @static
         * @param {ICDOTAUserMsg_EmptyItemSlotAlert} message CDOTAUserMsg_EmptyItemSlotAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_EmptyItemSlotAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.source_player_id != null && Object.hasOwnProperty.call(message, "source_player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.source_player_id);
            if (message.target_player_id != null && Object.hasOwnProperty.call(message, "target_player_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.target_player_id);
            if (message.slot_index != null && Object.hasOwnProperty.call(message, "slot_index"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.slot_index);
            if (message.cooldown_seconds != null && Object.hasOwnProperty.call(message, "cooldown_seconds"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.cooldown_seconds);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAUserMsg_EmptyItemSlotAlert message, length delimited. Does not implicitly {@link CDOTAUserMsg_EmptyItemSlotAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAUserMsg_EmptyItemSlotAlert
         * @static
         * @param {ICDOTAUserMsg_EmptyItemSlotAlert} message CDOTAUserMsg_EmptyItemSlotAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAUserMsg_EmptyItemSlotAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAUserMsg_EmptyItemSlotAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAUserMsg_EmptyItemSlotAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAUserMsg_EmptyItemSlotAlert} CDOTAUserMsg_EmptyItemSlotAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_EmptyItemSlotAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAUserMsg_EmptyItemSlotAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.source_player_id = reader.int32();
                    break;
                case 2:
                    message.target_player_id = reader.int32();
                    break;
                case 3:
                    message.slot_index = reader.int32();
                    break;
                case 4:
                    message.cooldown_seconds = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAUserMsg_EmptyItemSlotAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAUserMsg_EmptyItemSlotAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAUserMsg_EmptyItemSlotAlert} CDOTAUserMsg_EmptyItemSlotAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAUserMsg_EmptyItemSlotAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAUserMsg_EmptyItemSlotAlert message.
         * @function verify
         * @memberof CDOTAUserMsg_EmptyItemSlotAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAUserMsg_EmptyItemSlotAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.source_player_id != null && message.hasOwnProperty("source_player_id"))
                if (!$util.isInteger(message.source_player_id))
                    return "source_player_id: integer expected";
            if (message.target_player_id != null && message.hasOwnProperty("target_player_id"))
                if (!$util.isInteger(message.target_player_id))
                    return "target_player_id: integer expected";
            if (message.slot_index != null && message.hasOwnProperty("slot_index"))
                if (!$util.isInteger(message.slot_index))
                    return "slot_index: integer expected";
            if (message.cooldown_seconds != null && message.hasOwnProperty("cooldown_seconds"))
                if (!$util.isInteger(message.cooldown_seconds))
                    return "cooldown_seconds: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAUserMsg_EmptyItemSlotAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAUserMsg_EmptyItemSlotAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAUserMsg_EmptyItemSlotAlert} CDOTAUserMsg_EmptyItemSlotAlert
         */
        CDOTAUserMsg_EmptyItemSlotAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAUserMsg_EmptyItemSlotAlert)
                return object;
            var message = new $root.CDOTAUserMsg_EmptyItemSlotAlert();
            if (object.source_player_id != null)
                message.source_player_id = object.source_player_id | 0;
            if (object.target_player_id != null)
                message.target_player_id = object.target_player_id | 0;
            if (object.slot_index != null)
                message.slot_index = object.slot_index | 0;
            if (object.cooldown_seconds != null)
                message.cooldown_seconds = object.cooldown_seconds | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAUserMsg_EmptyItemSlotAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAUserMsg_EmptyItemSlotAlert
         * @static
         * @param {CDOTAUserMsg_EmptyItemSlotAlert} message CDOTAUserMsg_EmptyItemSlotAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAUserMsg_EmptyItemSlotAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.source_player_id = 0;
                object.target_player_id = 0;
                object.slot_index = 0;
                object.cooldown_seconds = 0;
            }
            if (message.source_player_id != null && message.hasOwnProperty("source_player_id"))
                object.source_player_id = message.source_player_id;
            if (message.target_player_id != null && message.hasOwnProperty("target_player_id"))
                object.target_player_id = message.target_player_id;
            if (message.slot_index != null && message.hasOwnProperty("slot_index"))
                object.slot_index = message.slot_index;
            if (message.cooldown_seconds != null && message.hasOwnProperty("cooldown_seconds"))
                object.cooldown_seconds = message.cooldown_seconds;
            return object;
        };
    
        /**
         * Converts this CDOTAUserMsg_EmptyItemSlotAlert to JSON.
         * @function toJSON
         * @memberof CDOTAUserMsg_EmptyItemSlotAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAUserMsg_EmptyItemSlotAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAUserMsg_EmptyItemSlotAlert;
    })();
    
    /**
     * SignonState_t enum.
     * @exports SignonState_t
     * @enum {number}
     * @property {number} SIGNONSTATE_NONE=0 SIGNONSTATE_NONE value
     * @property {number} SIGNONSTATE_CHALLENGE=1 SIGNONSTATE_CHALLENGE value
     * @property {number} SIGNONSTATE_CONNECTED=2 SIGNONSTATE_CONNECTED value
     * @property {number} SIGNONSTATE_NEW=3 SIGNONSTATE_NEW value
     * @property {number} SIGNONSTATE_PRESPAWN=4 SIGNONSTATE_PRESPAWN value
     * @property {number} SIGNONSTATE_SPAWN=5 SIGNONSTATE_SPAWN value
     * @property {number} SIGNONSTATE_FULL=6 SIGNONSTATE_FULL value
     * @property {number} SIGNONSTATE_CHANGELEVEL=7 SIGNONSTATE_CHANGELEVEL value
     */
    $root.SignonState_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SIGNONSTATE_NONE"] = 0;
        values[valuesById[1] = "SIGNONSTATE_CHALLENGE"] = 1;
        values[valuesById[2] = "SIGNONSTATE_CONNECTED"] = 2;
        values[valuesById[3] = "SIGNONSTATE_NEW"] = 3;
        values[valuesById[4] = "SIGNONSTATE_PRESPAWN"] = 4;
        values[valuesById[5] = "SIGNONSTATE_SPAWN"] = 5;
        values[valuesById[6] = "SIGNONSTATE_FULL"] = 6;
        values[valuesById[7] = "SIGNONSTATE_CHANGELEVEL"] = 7;
        return values;
    })();
    
    /**
     * NET_Messages enum.
     * @exports NET_Messages
     * @enum {number}
     * @property {number} net_NOP=0 net_NOP value
     * @property {number} net_Disconnect=1 net_Disconnect value
     * @property {number} net_SplitScreenUser=3 net_SplitScreenUser value
     * @property {number} net_Tick=4 net_Tick value
     * @property {number} net_StringCmd=5 net_StringCmd value
     * @property {number} net_SetConVar=6 net_SetConVar value
     * @property {number} net_SignonState=7 net_SignonState value
     * @property {number} net_SpawnGroup_Load=8 net_SpawnGroup_Load value
     * @property {number} net_SpawnGroup_ManifestUpdate=9 net_SpawnGroup_ManifestUpdate value
     * @property {number} net_SpawnGroup_SetCreationTick=11 net_SpawnGroup_SetCreationTick value
     * @property {number} net_SpawnGroup_Unload=12 net_SpawnGroup_Unload value
     * @property {number} net_SpawnGroup_LoadCompleted=13 net_SpawnGroup_LoadCompleted value
     */
    $root.NET_Messages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "net_NOP"] = 0;
        values[valuesById[1] = "net_Disconnect"] = 1;
        values[valuesById[3] = "net_SplitScreenUser"] = 3;
        values[valuesById[4] = "net_Tick"] = 4;
        values[valuesById[5] = "net_StringCmd"] = 5;
        values[valuesById[6] = "net_SetConVar"] = 6;
        values[valuesById[7] = "net_SignonState"] = 7;
        values[valuesById[8] = "net_SpawnGroup_Load"] = 8;
        values[valuesById[9] = "net_SpawnGroup_ManifestUpdate"] = 9;
        values[valuesById[11] = "net_SpawnGroup_SetCreationTick"] = 11;
        values[valuesById[12] = "net_SpawnGroup_Unload"] = 12;
        values[valuesById[13] = "net_SpawnGroup_LoadCompleted"] = 13;
        return values;
    })();
    
    /**
     * SpawnGroupFlags_t enum.
     * @exports SpawnGroupFlags_t
     * @enum {number}
     * @property {number} SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE=1 SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE value
     * @property {number} SPAWN_GROUP_DONT_SPAWN_ENTITIES=2 SPAWN_GROUP_DONT_SPAWN_ENTITIES value
     * @property {number} SPAWN_GROUP_SYNCHRONOUS_SPAWN=4 SPAWN_GROUP_SYNCHRONOUS_SPAWN value
     * @property {number} SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP=8 SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP value
     * @property {number} SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES=16 SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES value
     * @property {number} SPAWN_GROUP_BLOCK_UNTIL_LOADED=64 SPAWN_GROUP_BLOCK_UNTIL_LOADED value
     * @property {number} SPAWN_GROUP_LOAD_STREAMING_DATA=128 SPAWN_GROUP_LOAD_STREAMING_DATA value
     * @property {number} SPAWN_GROUP_CREATE_NEW_SCENE_WORLD=256 SPAWN_GROUP_CREATE_NEW_SCENE_WORLD value
     */
    $root.SpawnGroupFlags_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE"] = 1;
        values[valuesById[2] = "SPAWN_GROUP_DONT_SPAWN_ENTITIES"] = 2;
        values[valuesById[4] = "SPAWN_GROUP_SYNCHRONOUS_SPAWN"] = 4;
        values[valuesById[8] = "SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP"] = 8;
        values[valuesById[16] = "SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES"] = 16;
        values[valuesById[64] = "SPAWN_GROUP_BLOCK_UNTIL_LOADED"] = 64;
        values[valuesById[128] = "SPAWN_GROUP_LOAD_STREAMING_DATA"] = 128;
        values[valuesById[256] = "SPAWN_GROUP_CREATE_NEW_SCENE_WORLD"] = 256;
        return values;
    })();
    
    $root.CMsgVector = (function() {
    
        /**
         * Properties of a CMsgVector.
         * @exports ICMsgVector
         * @interface ICMsgVector
         * @property {number|null} [x] CMsgVector x
         * @property {number|null} [y] CMsgVector y
         * @property {number|null} [z] CMsgVector z
         */
    
        /**
         * Constructs a new CMsgVector.
         * @exports CMsgVector
         * @classdesc Represents a CMsgVector.
         * @implements ICMsgVector
         * @constructor
         * @param {ICMsgVector=} [properties] Properties to set
         */
        function CMsgVector(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgVector x.
         * @member {number} x
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.x = 0;
    
        /**
         * CMsgVector y.
         * @member {number} y
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.y = 0;
    
        /**
         * CMsgVector z.
         * @member {number} z
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.z = 0;
    
        /**
         * Creates a new CMsgVector instance using the specified properties.
         * @function create
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector=} [properties] Properties to set
         * @returns {CMsgVector} CMsgVector instance
         */
        CMsgVector.create = function create(properties) {
            return new CMsgVector(properties);
        };
    
        /**
         * Encodes the specified CMsgVector message. Does not implicitly {@link CMsgVector.verify|verify} messages.
         * @function encode
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector} message CMsgVector message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgVector message, length delimited. Does not implicitly {@link CMsgVector.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector} message CMsgVector message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgVector message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgVector
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgVector} CMsgVector
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                case 3:
                    message.z = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgVector message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgVector
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgVector} CMsgVector
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgVector message.
         * @function verify
         * @memberof CMsgVector
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgVector.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgVector message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgVector
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgVector} CMsgVector
         */
        CMsgVector.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgVector)
                return object;
            var message = new $root.CMsgVector();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgVector message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgVector
         * @static
         * @param {CMsgVector} message CMsgVector
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgVector.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            return object;
        };
    
        /**
         * Converts this CMsgVector to JSON.
         * @function toJSON
         * @memberof CMsgVector
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgVector.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgVector;
    })();
    
    $root.CMsgVector2D = (function() {
    
        /**
         * Properties of a CMsgVector2D.
         * @exports ICMsgVector2D
         * @interface ICMsgVector2D
         * @property {number|null} [x] CMsgVector2D x
         * @property {number|null} [y] CMsgVector2D y
         */
    
        /**
         * Constructs a new CMsgVector2D.
         * @exports CMsgVector2D
         * @classdesc Represents a CMsgVector2D.
         * @implements ICMsgVector2D
         * @constructor
         * @param {ICMsgVector2D=} [properties] Properties to set
         */
        function CMsgVector2D(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgVector2D x.
         * @member {number} x
         * @memberof CMsgVector2D
         * @instance
         */
        CMsgVector2D.prototype.x = 0;
    
        /**
         * CMsgVector2D y.
         * @member {number} y
         * @memberof CMsgVector2D
         * @instance
         */
        CMsgVector2D.prototype.y = 0;
    
        /**
         * Creates a new CMsgVector2D instance using the specified properties.
         * @function create
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D=} [properties] Properties to set
         * @returns {CMsgVector2D} CMsgVector2D instance
         */
        CMsgVector2D.create = function create(properties) {
            return new CMsgVector2D(properties);
        };
    
        /**
         * Encodes the specified CMsgVector2D message. Does not implicitly {@link CMsgVector2D.verify|verify} messages.
         * @function encode
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D} message CMsgVector2D message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector2D.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgVector2D message, length delimited. Does not implicitly {@link CMsgVector2D.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D} message CMsgVector2D message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector2D.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgVector2D message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgVector2D
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgVector2D} CMsgVector2D
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector2D.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector2D();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgVector2D message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgVector2D
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgVector2D} CMsgVector2D
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector2D.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgVector2D message.
         * @function verify
         * @memberof CMsgVector2D
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgVector2D.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgVector2D message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgVector2D
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgVector2D} CMsgVector2D
         */
        CMsgVector2D.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgVector2D)
                return object;
            var message = new $root.CMsgVector2D();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgVector2D message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgVector2D
         * @static
         * @param {CMsgVector2D} message CMsgVector2D
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgVector2D.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            return object;
        };
    
        /**
         * Converts this CMsgVector2D to JSON.
         * @function toJSON
         * @memberof CMsgVector2D
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgVector2D.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgVector2D;
    })();
    
    $root.CMsgQAngle = (function() {
    
        /**
         * Properties of a CMsgQAngle.
         * @exports ICMsgQAngle
         * @interface ICMsgQAngle
         * @property {number|null} [x] CMsgQAngle x
         * @property {number|null} [y] CMsgQAngle y
         * @property {number|null} [z] CMsgQAngle z
         */
    
        /**
         * Constructs a new CMsgQAngle.
         * @exports CMsgQAngle
         * @classdesc Represents a CMsgQAngle.
         * @implements ICMsgQAngle
         * @constructor
         * @param {ICMsgQAngle=} [properties] Properties to set
         */
        function CMsgQAngle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgQAngle x.
         * @member {number} x
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.x = 0;
    
        /**
         * CMsgQAngle y.
         * @member {number} y
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.y = 0;
    
        /**
         * CMsgQAngle z.
         * @member {number} z
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.z = 0;
    
        /**
         * Creates a new CMsgQAngle instance using the specified properties.
         * @function create
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle=} [properties] Properties to set
         * @returns {CMsgQAngle} CMsgQAngle instance
         */
        CMsgQAngle.create = function create(properties) {
            return new CMsgQAngle(properties);
        };
    
        /**
         * Encodes the specified CMsgQAngle message. Does not implicitly {@link CMsgQAngle.verify|verify} messages.
         * @function encode
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle} message CMsgQAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgQAngle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgQAngle message, length delimited. Does not implicitly {@link CMsgQAngle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle} message CMsgQAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgQAngle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgQAngle message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgQAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgQAngle} CMsgQAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgQAngle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgQAngle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                case 3:
                    message.z = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgQAngle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgQAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgQAngle} CMsgQAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgQAngle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgQAngle message.
         * @function verify
         * @memberof CMsgQAngle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgQAngle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgQAngle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgQAngle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgQAngle} CMsgQAngle
         */
        CMsgQAngle.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgQAngle)
                return object;
            var message = new $root.CMsgQAngle();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgQAngle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgQAngle
         * @static
         * @param {CMsgQAngle} message CMsgQAngle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgQAngle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            return object;
        };
    
        /**
         * Converts this CMsgQAngle to JSON.
         * @function toJSON
         * @memberof CMsgQAngle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgQAngle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgQAngle;
    })();
    
    $root.CMsgRGBA = (function() {
    
        /**
         * Properties of a CMsgRGBA.
         * @exports ICMsgRGBA
         * @interface ICMsgRGBA
         * @property {number|null} [r] CMsgRGBA r
         * @property {number|null} [g] CMsgRGBA g
         * @property {number|null} [b] CMsgRGBA b
         * @property {number|null} [a] CMsgRGBA a
         */
    
        /**
         * Constructs a new CMsgRGBA.
         * @exports CMsgRGBA
         * @classdesc Represents a CMsgRGBA.
         * @implements ICMsgRGBA
         * @constructor
         * @param {ICMsgRGBA=} [properties] Properties to set
         */
        function CMsgRGBA(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgRGBA r.
         * @member {number} r
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.r = 0;
    
        /**
         * CMsgRGBA g.
         * @member {number} g
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.g = 0;
    
        /**
         * CMsgRGBA b.
         * @member {number} b
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.b = 0;
    
        /**
         * CMsgRGBA a.
         * @member {number} a
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.a = 0;
    
        /**
         * Creates a new CMsgRGBA instance using the specified properties.
         * @function create
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA=} [properties] Properties to set
         * @returns {CMsgRGBA} CMsgRGBA instance
         */
        CMsgRGBA.create = function create(properties) {
            return new CMsgRGBA(properties);
        };
    
        /**
         * Encodes the specified CMsgRGBA message. Does not implicitly {@link CMsgRGBA.verify|verify} messages.
         * @function encode
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA} message CMsgRGBA message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgRGBA.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.r != null && Object.hasOwnProperty.call(message, "r"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.r);
            if (message.g != null && Object.hasOwnProperty.call(message, "g"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.g);
            if (message.b != null && Object.hasOwnProperty.call(message, "b"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.b);
            if (message.a != null && Object.hasOwnProperty.call(message, "a"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.a);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgRGBA message, length delimited. Does not implicitly {@link CMsgRGBA.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA} message CMsgRGBA message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgRGBA.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgRGBA message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgRGBA
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgRGBA} CMsgRGBA
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgRGBA.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgRGBA();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.r = reader.int32();
                    break;
                case 2:
                    message.g = reader.int32();
                    break;
                case 3:
                    message.b = reader.int32();
                    break;
                case 4:
                    message.a = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgRGBA message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgRGBA
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgRGBA} CMsgRGBA
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgRGBA.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgRGBA message.
         * @function verify
         * @memberof CMsgRGBA
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgRGBA.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.r != null && message.hasOwnProperty("r"))
                if (!$util.isInteger(message.r))
                    return "r: integer expected";
            if (message.g != null && message.hasOwnProperty("g"))
                if (!$util.isInteger(message.g))
                    return "g: integer expected";
            if (message.b != null && message.hasOwnProperty("b"))
                if (!$util.isInteger(message.b))
                    return "b: integer expected";
            if (message.a != null && message.hasOwnProperty("a"))
                if (!$util.isInteger(message.a))
                    return "a: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgRGBA message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgRGBA
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgRGBA} CMsgRGBA
         */
        CMsgRGBA.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgRGBA)
                return object;
            var message = new $root.CMsgRGBA();
            if (object.r != null)
                message.r = object.r | 0;
            if (object.g != null)
                message.g = object.g | 0;
            if (object.b != null)
                message.b = object.b | 0;
            if (object.a != null)
                message.a = object.a | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgRGBA message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgRGBA
         * @static
         * @param {CMsgRGBA} message CMsgRGBA
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgRGBA.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.r = 0;
                object.g = 0;
                object.b = 0;
                object.a = 0;
            }
            if (message.r != null && message.hasOwnProperty("r"))
                object.r = message.r;
            if (message.g != null && message.hasOwnProperty("g"))
                object.g = message.g;
            if (message.b != null && message.hasOwnProperty("b"))
                object.b = message.b;
            if (message.a != null && message.hasOwnProperty("a"))
                object.a = message.a;
            return object;
        };
    
        /**
         * Converts this CMsgRGBA to JSON.
         * @function toJSON
         * @memberof CMsgRGBA
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgRGBA.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgRGBA;
    })();
    
    $root.CMsgPlayerInfo = (function() {
    
        /**
         * Properties of a CMsgPlayerInfo.
         * @exports ICMsgPlayerInfo
         * @interface ICMsgPlayerInfo
         * @property {string|null} [name] CMsgPlayerInfo name
         * @property {number|Long|null} [xuid] CMsgPlayerInfo xuid
         * @property {number|null} [userid] CMsgPlayerInfo userid
         * @property {number|Long|null} [steamid] CMsgPlayerInfo steamid
         * @property {boolean|null} [fakeplayer] CMsgPlayerInfo fakeplayer
         * @property {boolean|null} [ishltv] CMsgPlayerInfo ishltv
         */
    
        /**
         * Constructs a new CMsgPlayerInfo.
         * @exports CMsgPlayerInfo
         * @classdesc Represents a CMsgPlayerInfo.
         * @implements ICMsgPlayerInfo
         * @constructor
         * @param {ICMsgPlayerInfo=} [properties] Properties to set
         */
        function CMsgPlayerInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgPlayerInfo name.
         * @member {string} name
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.name = "";
    
        /**
         * CMsgPlayerInfo xuid.
         * @member {number|Long} xuid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.xuid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgPlayerInfo userid.
         * @member {number} userid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.userid = 0;
    
        /**
         * CMsgPlayerInfo steamid.
         * @member {number|Long} steamid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.steamid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgPlayerInfo fakeplayer.
         * @member {boolean} fakeplayer
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.fakeplayer = false;
    
        /**
         * CMsgPlayerInfo ishltv.
         * @member {boolean} ishltv
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.ishltv = false;
    
        /**
         * Creates a new CMsgPlayerInfo instance using the specified properties.
         * @function create
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo=} [properties] Properties to set
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo instance
         */
        CMsgPlayerInfo.create = function create(properties) {
            return new CMsgPlayerInfo(properties);
        };
    
        /**
         * Encodes the specified CMsgPlayerInfo message. Does not implicitly {@link CMsgPlayerInfo.verify|verify} messages.
         * @function encode
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo} message CMsgPlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgPlayerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.xuid != null && Object.hasOwnProperty.call(message, "xuid"))
                writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.xuid);
            if (message.userid != null && Object.hasOwnProperty.call(message, "userid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.userid);
            if (message.steamid != null && Object.hasOwnProperty.call(message, "steamid"))
                writer.uint32(/* id 4, wireType 1 =*/33).fixed64(message.steamid);
            if (message.fakeplayer != null && Object.hasOwnProperty.call(message, "fakeplayer"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.fakeplayer);
            if (message.ishltv != null && Object.hasOwnProperty.call(message, "ishltv"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.ishltv);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgPlayerInfo message, length delimited. Does not implicitly {@link CMsgPlayerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo} message CMsgPlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgPlayerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgPlayerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgPlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgPlayerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgPlayerInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.xuid = reader.fixed64();
                    break;
                case 3:
                    message.userid = reader.int32();
                    break;
                case 4:
                    message.steamid = reader.fixed64();
                    break;
                case 5:
                    message.fakeplayer = reader.bool();
                    break;
                case 6:
                    message.ishltv = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgPlayerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgPlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgPlayerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgPlayerInfo message.
         * @function verify
         * @memberof CMsgPlayerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgPlayerInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (!$util.isInteger(message.xuid) && !(message.xuid && $util.isInteger(message.xuid.low) && $util.isInteger(message.xuid.high)))
                    return "xuid: integer|Long expected";
            if (message.userid != null && message.hasOwnProperty("userid"))
                if (!$util.isInteger(message.userid))
                    return "userid: integer expected";
            if (message.steamid != null && message.hasOwnProperty("steamid"))
                if (!$util.isInteger(message.steamid) && !(message.steamid && $util.isInteger(message.steamid.low) && $util.isInteger(message.steamid.high)))
                    return "steamid: integer|Long expected";
            if (message.fakeplayer != null && message.hasOwnProperty("fakeplayer"))
                if (typeof message.fakeplayer !== "boolean")
                    return "fakeplayer: boolean expected";
            if (message.ishltv != null && message.hasOwnProperty("ishltv"))
                if (typeof message.ishltv !== "boolean")
                    return "ishltv: boolean expected";
            return null;
        };
    
        /**
         * Creates a CMsgPlayerInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgPlayerInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         */
        CMsgPlayerInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgPlayerInfo)
                return object;
            var message = new $root.CMsgPlayerInfo();
            if (object.name != null)
                message.name = String(object.name);
            if (object.xuid != null)
                if ($util.Long)
                    (message.xuid = $util.Long.fromValue(object.xuid)).unsigned = false;
                else if (typeof object.xuid === "string")
                    message.xuid = parseInt(object.xuid, 10);
                else if (typeof object.xuid === "number")
                    message.xuid = object.xuid;
                else if (typeof object.xuid === "object")
                    message.xuid = new $util.LongBits(object.xuid.low >>> 0, object.xuid.high >>> 0).toNumber();
            if (object.userid != null)
                message.userid = object.userid | 0;
            if (object.steamid != null)
                if ($util.Long)
                    (message.steamid = $util.Long.fromValue(object.steamid)).unsigned = false;
                else if (typeof object.steamid === "string")
                    message.steamid = parseInt(object.steamid, 10);
                else if (typeof object.steamid === "number")
                    message.steamid = object.steamid;
                else if (typeof object.steamid === "object")
                    message.steamid = new $util.LongBits(object.steamid.low >>> 0, object.steamid.high >>> 0).toNumber();
            if (object.fakeplayer != null)
                message.fakeplayer = Boolean(object.fakeplayer);
            if (object.ishltv != null)
                message.ishltv = Boolean(object.ishltv);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgPlayerInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgPlayerInfo
         * @static
         * @param {CMsgPlayerInfo} message CMsgPlayerInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgPlayerInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.xuid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.xuid = options.longs === String ? "0" : 0;
                object.userid = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.steamid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.steamid = options.longs === String ? "0" : 0;
                object.fakeplayer = false;
                object.ishltv = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (typeof message.xuid === "number")
                    object.xuid = options.longs === String ? String(message.xuid) : message.xuid;
                else
                    object.xuid = options.longs === String ? $util.Long.prototype.toString.call(message.xuid) : options.longs === Number ? new $util.LongBits(message.xuid.low >>> 0, message.xuid.high >>> 0).toNumber() : message.xuid;
            if (message.userid != null && message.hasOwnProperty("userid"))
                object.userid = message.userid;
            if (message.steamid != null && message.hasOwnProperty("steamid"))
                if (typeof message.steamid === "number")
                    object.steamid = options.longs === String ? String(message.steamid) : message.steamid;
                else
                    object.steamid = options.longs === String ? $util.Long.prototype.toString.call(message.steamid) : options.longs === Number ? new $util.LongBits(message.steamid.low >>> 0, message.steamid.high >>> 0).toNumber() : message.steamid;
            if (message.fakeplayer != null && message.hasOwnProperty("fakeplayer"))
                object.fakeplayer = message.fakeplayer;
            if (message.ishltv != null && message.hasOwnProperty("ishltv"))
                object.ishltv = message.ishltv;
            return object;
        };
    
        /**
         * Converts this CMsgPlayerInfo to JSON.
         * @function toJSON
         * @memberof CMsgPlayerInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgPlayerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgPlayerInfo;
    })();
    
    $root.CEntityMsg = (function() {
    
        /**
         * Properties of a CEntityMsg.
         * @exports ICEntityMsg
         * @interface ICEntityMsg
         * @property {number|null} [target_entity] CEntityMsg target_entity
         */
    
        /**
         * Constructs a new CEntityMsg.
         * @exports CEntityMsg
         * @classdesc Represents a CEntityMsg.
         * @implements ICEntityMsg
         * @constructor
         * @param {ICEntityMsg=} [properties] Properties to set
         */
        function CEntityMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CEntityMsg target_entity.
         * @member {number} target_entity
         * @memberof CEntityMsg
         * @instance
         */
        CEntityMsg.prototype.target_entity = 0;
    
        /**
         * Creates a new CEntityMsg instance using the specified properties.
         * @function create
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg=} [properties] Properties to set
         * @returns {CEntityMsg} CEntityMsg instance
         */
        CEntityMsg.create = function create(properties) {
            return new CEntityMsg(properties);
        };
    
        /**
         * Encodes the specified CEntityMsg message. Does not implicitly {@link CEntityMsg.verify|verify} messages.
         * @function encode
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg} message CEntityMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target_entity != null && Object.hasOwnProperty.call(message, "target_entity"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.target_entity);
            return writer;
        };
    
        /**
         * Encodes the specified CEntityMsg message, length delimited. Does not implicitly {@link CEntityMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg} message CEntityMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CEntityMsg message from the specified reader or buffer.
         * @function decode
         * @memberof CEntityMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEntityMsg} CEntityMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEntityMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.target_entity = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CEntityMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CEntityMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CEntityMsg} CEntityMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CEntityMsg message.
         * @function verify
         * @memberof CEntityMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CEntityMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target_entity != null && message.hasOwnProperty("target_entity"))
                if (!$util.isInteger(message.target_entity))
                    return "target_entity: integer expected";
            return null;
        };
    
        /**
         * Creates a CEntityMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CEntityMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CEntityMsg} CEntityMsg
         */
        CEntityMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.CEntityMsg)
                return object;
            var message = new $root.CEntityMsg();
            if (object.target_entity != null)
                message.target_entity = object.target_entity >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CEntityMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CEntityMsg
         * @static
         * @param {CEntityMsg} message CEntityMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CEntityMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.target_entity = 0;
            if (message.target_entity != null && message.hasOwnProperty("target_entity"))
                object.target_entity = message.target_entity;
            return object;
        };
    
        /**
         * Converts this CEntityMsg to JSON.
         * @function toJSON
         * @memberof CEntityMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CEntityMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CEntityMsg;
    })();
    
    $root.CMsg_CVars = (function() {
    
        /**
         * Properties of a CMsg_CVars.
         * @exports ICMsg_CVars
         * @interface ICMsg_CVars
         * @property {Array.<CMsg_CVars.ICVar>|null} [cvars] CMsg_CVars cvars
         */
    
        /**
         * Constructs a new CMsg_CVars.
         * @exports CMsg_CVars
         * @classdesc Represents a CMsg_CVars.
         * @implements ICMsg_CVars
         * @constructor
         * @param {ICMsg_CVars=} [properties] Properties to set
         */
        function CMsg_CVars(properties) {
            this.cvars = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsg_CVars cvars.
         * @member {Array.<CMsg_CVars.ICVar>} cvars
         * @memberof CMsg_CVars
         * @instance
         */
        CMsg_CVars.prototype.cvars = $util.emptyArray;
    
        /**
         * Creates a new CMsg_CVars instance using the specified properties.
         * @function create
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars=} [properties] Properties to set
         * @returns {CMsg_CVars} CMsg_CVars instance
         */
        CMsg_CVars.create = function create(properties) {
            return new CMsg_CVars(properties);
        };
    
        /**
         * Encodes the specified CMsg_CVars message. Does not implicitly {@link CMsg_CVars.verify|verify} messages.
         * @function encode
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars} message CMsg_CVars message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsg_CVars.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cvars != null && message.cvars.length)
                for (var i = 0; i < message.cvars.length; ++i)
                    $root.CMsg_CVars.CVar.encode(message.cvars[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsg_CVars message, length delimited. Does not implicitly {@link CMsg_CVars.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars} message CMsg_CVars message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsg_CVars.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsg_CVars message from the specified reader or buffer.
         * @function decode
         * @memberof CMsg_CVars
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsg_CVars} CMsg_CVars
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsg_CVars.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.cvars && message.cvars.length))
                        message.cvars = [];
                    message.cvars.push($root.CMsg_CVars.CVar.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsg_CVars message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsg_CVars
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsg_CVars} CMsg_CVars
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsg_CVars.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsg_CVars message.
         * @function verify
         * @memberof CMsg_CVars
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsg_CVars.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cvars != null && message.hasOwnProperty("cvars")) {
                if (!Array.isArray(message.cvars))
                    return "cvars: array expected";
                for (var i = 0; i < message.cvars.length; ++i) {
                    var error = $root.CMsg_CVars.CVar.verify(message.cvars[i]);
                    if (error)
                        return "cvars." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsg_CVars message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsg_CVars
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsg_CVars} CMsg_CVars
         */
        CMsg_CVars.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsg_CVars)
                return object;
            var message = new $root.CMsg_CVars();
            if (object.cvars) {
                if (!Array.isArray(object.cvars))
                    throw TypeError(".CMsg_CVars.cvars: array expected");
                message.cvars = [];
                for (var i = 0; i < object.cvars.length; ++i) {
                    if (typeof object.cvars[i] !== "object")
                        throw TypeError(".CMsg_CVars.cvars: object expected");
                    message.cvars[i] = $root.CMsg_CVars.CVar.fromObject(object.cvars[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsg_CVars message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsg_CVars
         * @static
         * @param {CMsg_CVars} message CMsg_CVars
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsg_CVars.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cvars = [];
            if (message.cvars && message.cvars.length) {
                object.cvars = [];
                for (var j = 0; j < message.cvars.length; ++j)
                    object.cvars[j] = $root.CMsg_CVars.CVar.toObject(message.cvars[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsg_CVars to JSON.
         * @function toJSON
         * @memberof CMsg_CVars
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsg_CVars.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsg_CVars.CVar = (function() {
    
            /**
             * Properties of a CVar.
             * @memberof CMsg_CVars
             * @interface ICVar
             * @property {string|null} [name] CVar name
             * @property {string|null} [value] CVar value
             */
    
            /**
             * Constructs a new CVar.
             * @memberof CMsg_CVars
             * @classdesc Represents a CVar.
             * @implements ICVar
             * @constructor
             * @param {CMsg_CVars.ICVar=} [properties] Properties to set
             */
            function CVar(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CVar name.
             * @member {string} name
             * @memberof CMsg_CVars.CVar
             * @instance
             */
            CVar.prototype.name = "";
    
            /**
             * CVar value.
             * @member {string} value
             * @memberof CMsg_CVars.CVar
             * @instance
             */
            CVar.prototype.value = "";
    
            /**
             * Creates a new CVar instance using the specified properties.
             * @function create
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar=} [properties] Properties to set
             * @returns {CMsg_CVars.CVar} CVar instance
             */
            CVar.create = function create(properties) {
                return new CVar(properties);
            };
    
            /**
             * Encodes the specified CVar message. Does not implicitly {@link CMsg_CVars.CVar.verify|verify} messages.
             * @function encode
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar} message CVar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CVar.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified CVar message, length delimited. Does not implicitly {@link CMsg_CVars.CVar.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar} message CVar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CVar.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CVar message from the specified reader or buffer.
             * @function decode
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsg_CVars.CVar} CVar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CVar.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars.CVar();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CVar message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsg_CVars.CVar} CVar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CVar.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CVar message.
             * @function verify
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CVar.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };
    
            /**
             * Creates a CVar message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsg_CVars.CVar} CVar
             */
            CVar.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsg_CVars.CVar)
                    return object;
                var message = new $root.CMsg_CVars.CVar();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };
    
            /**
             * Creates a plain object from a CVar message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.CVar} message CVar
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CVar.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.value = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };
    
            /**
             * Converts this CVar to JSON.
             * @function toJSON
             * @memberof CMsg_CVars.CVar
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CVar.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CVar;
        })();
    
        return CMsg_CVars;
    })();
    
    $root.CNETMsg_NOP = (function() {
    
        /**
         * Properties of a CNETMsg_NOP.
         * @exports ICNETMsg_NOP
         * @interface ICNETMsg_NOP
         */
    
        /**
         * Constructs a new CNETMsg_NOP.
         * @exports CNETMsg_NOP
         * @classdesc Represents a CNETMsg_NOP.
         * @implements ICNETMsg_NOP
         * @constructor
         * @param {ICNETMsg_NOP=} [properties] Properties to set
         */
        function CNETMsg_NOP(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CNETMsg_NOP instance using the specified properties.
         * @function create
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP=} [properties] Properties to set
         * @returns {CNETMsg_NOP} CNETMsg_NOP instance
         */
        CNETMsg_NOP.create = function create(properties) {
            return new CNETMsg_NOP(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_NOP message. Does not implicitly {@link CNETMsg_NOP.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP} message CNETMsg_NOP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_NOP.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_NOP message, length delimited. Does not implicitly {@link CNETMsg_NOP.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP} message CNETMsg_NOP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_NOP.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_NOP message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_NOP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_NOP.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_NOP();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_NOP message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_NOP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_NOP.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_NOP message.
         * @function verify
         * @memberof CNETMsg_NOP
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_NOP.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_NOP message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_NOP
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         */
        CNETMsg_NOP.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_NOP)
                return object;
            return new $root.CNETMsg_NOP();
        };
    
        /**
         * Creates a plain object from a CNETMsg_NOP message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_NOP
         * @static
         * @param {CNETMsg_NOP} message CNETMsg_NOP
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_NOP.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CNETMsg_NOP to JSON.
         * @function toJSON
         * @memberof CNETMsg_NOP
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_NOP.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_NOP;
    })();
    
    $root.CNETMsg_SplitScreenUser = (function() {
    
        /**
         * Properties of a CNETMsg_SplitScreenUser.
         * @exports ICNETMsg_SplitScreenUser
         * @interface ICNETMsg_SplitScreenUser
         * @property {number|null} [slot] CNETMsg_SplitScreenUser slot
         */
    
        /**
         * Constructs a new CNETMsg_SplitScreenUser.
         * @exports CNETMsg_SplitScreenUser
         * @classdesc Represents a CNETMsg_SplitScreenUser.
         * @implements ICNETMsg_SplitScreenUser
         * @constructor
         * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set
         */
        function CNETMsg_SplitScreenUser(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SplitScreenUser slot.
         * @member {number} slot
         * @memberof CNETMsg_SplitScreenUser
         * @instance
         */
        CNETMsg_SplitScreenUser.prototype.slot = 0;
    
        /**
         * Creates a new CNETMsg_SplitScreenUser instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser instance
         */
        CNETMsg_SplitScreenUser.create = function create(properties) {
            return new CNETMsg_SplitScreenUser(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SplitScreenUser message. Does not implicitly {@link CNETMsg_SplitScreenUser.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SplitScreenUser.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.slot);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SplitScreenUser message, length delimited. Does not implicitly {@link CNETMsg_SplitScreenUser.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SplitScreenUser.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SplitScreenUser.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SplitScreenUser();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.slot = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SplitScreenUser.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SplitScreenUser message.
         * @function verify
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SplitScreenUser.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot))
                    return "slot: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SplitScreenUser message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         */
        CNETMsg_SplitScreenUser.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SplitScreenUser)
                return object;
            var message = new $root.CNETMsg_SplitScreenUser();
            if (object.slot != null)
                message.slot = object.slot | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SplitScreenUser message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {CNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SplitScreenUser.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.slot = 0;
            if (message.slot != null && message.hasOwnProperty("slot"))
                object.slot = message.slot;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SplitScreenUser to JSON.
         * @function toJSON
         * @memberof CNETMsg_SplitScreenUser
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SplitScreenUser.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SplitScreenUser;
    })();
    
    $root.CNETMsg_Disconnect = (function() {
    
        /**
         * Properties of a CNETMsg_Disconnect.
         * @exports ICNETMsg_Disconnect
         * @interface ICNETMsg_Disconnect
         * @property {ENetworkDisconnectionReason|null} [reason] CNETMsg_Disconnect reason
         */
    
        /**
         * Constructs a new CNETMsg_Disconnect.
         * @exports CNETMsg_Disconnect
         * @classdesc Represents a CNETMsg_Disconnect.
         * @implements ICNETMsg_Disconnect
         * @constructor
         * @param {ICNETMsg_Disconnect=} [properties] Properties to set
         */
        function CNETMsg_Disconnect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_Disconnect reason.
         * @member {ENetworkDisconnectionReason} reason
         * @memberof CNETMsg_Disconnect
         * @instance
         */
        CNETMsg_Disconnect.prototype.reason = 0;
    
        /**
         * Creates a new CNETMsg_Disconnect instance using the specified properties.
         * @function create
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect=} [properties] Properties to set
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect instance
         */
        CNETMsg_Disconnect.create = function create(properties) {
            return new CNETMsg_Disconnect(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_Disconnect message. Does not implicitly {@link CNETMsg_Disconnect.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect} message CNETMsg_Disconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Disconnect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_Disconnect message, length delimited. Does not implicitly {@link CNETMsg_Disconnect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect} message CNETMsg_Disconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Disconnect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_Disconnect message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Disconnect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Disconnect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_Disconnect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Disconnect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_Disconnect message.
         * @function verify
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_Disconnect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 70:
                case 71:
                case 72:
                case 73:
                case 74:
                case 75:
                case 76:
                case 77:
                case 79:
                case 80:
                case 81:
                case 82:
                case 83:
                case 84:
                case 85:
                case 128:
                case 129:
                case 130:
                case 131:
                case 132:
                case 133:
                case 134:
                case 135:
                case 136:
                case 137:
                case 138:
                case 139:
                case 140:
                case 141:
                case 142:
                case 143:
                case 144:
                case 145:
                case 146:
                case 147:
                case 148:
                case 149:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CNETMsg_Disconnect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         */
        CNETMsg_Disconnect.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_Disconnect)
                return object;
            var message = new $root.CNETMsg_Disconnect();
            switch (object.reason) {
            case "NETWORK_DISCONNECT_INVALID":
            case 0:
                message.reason = 0;
                break;
            case "NETWORK_DISCONNECT_SHUTDOWN":
            case 1:
                message.reason = 1;
                break;
            case "NETWORK_DISCONNECT_DISCONNECT_BY_USER":
            case 2:
                message.reason = 2;
                break;
            case "NETWORK_DISCONNECT_DISCONNECT_BY_SERVER":
            case 3:
                message.reason = 3;
                break;
            case "NETWORK_DISCONNECT_LOST":
            case 4:
                message.reason = 4;
                break;
            case "NETWORK_DISCONNECT_OVERFLOW":
            case 5:
                message.reason = 5;
                break;
            case "NETWORK_DISCONNECT_STEAM_BANNED":
            case 6:
                message.reason = 6;
                break;
            case "NETWORK_DISCONNECT_STEAM_INUSE":
            case 7:
                message.reason = 7;
                break;
            case "NETWORK_DISCONNECT_STEAM_TICKET":
            case 8:
                message.reason = 8;
                break;
            case "NETWORK_DISCONNECT_STEAM_LOGON":
            case 9:
                message.reason = 9;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHCANCELLED":
            case 10:
                message.reason = 10;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED":
            case 11:
                message.reason = 11;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHINVALID":
            case 12:
                message.reason = 12;
                break;
            case "NETWORK_DISCONNECT_STEAM_VACBANSTATE":
            case 13:
                message.reason = 13;
                break;
            case "NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE":
            case 14:
                message.reason = 14;
                break;
            case "NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT":
            case 15:
                message.reason = 15;
                break;
            case "NETWORK_DISCONNECT_STEAM_DROPPED":
            case 16:
                message.reason = 16;
                break;
            case "NETWORK_DISCONNECT_STEAM_OWNERSHIP":
            case 17:
                message.reason = 17;
                break;
            case "NETWORK_DISCONNECT_SERVERINFO_OVERFLOW":
            case 18:
                message.reason = 18;
                break;
            case "NETWORK_DISCONNECT_TICKMSG_OVERFLOW":
            case 19:
                message.reason = 19;
                break;
            case "NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW":
            case 20:
                message.reason = 20;
                break;
            case "NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW":
            case 21:
                message.reason = 21;
                break;
            case "NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW":
            case 22:
                message.reason = 22;
                break;
            case "NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW":
            case 23:
                message.reason = 23;
                break;
            case "NETWORK_DISCONNECT_SNAPSHOTOVERFLOW":
            case 24:
                message.reason = 24;
                break;
            case "NETWORK_DISCONNECT_SNAPSHOTERROR":
            case 25:
                message.reason = 25;
                break;
            case "NETWORK_DISCONNECT_RELIABLEOVERFLOW":
            case 26:
                message.reason = 26;
                break;
            case "NETWORK_DISCONNECT_BADDELTATICK":
            case 27:
                message.reason = 27;
                break;
            case "NETWORK_DISCONNECT_NOMORESPLITS":
            case 28:
                message.reason = 28;
                break;
            case "NETWORK_DISCONNECT_TIMEDOUT":
            case 29:
                message.reason = 29;
                break;
            case "NETWORK_DISCONNECT_DISCONNECTED":
            case 30:
                message.reason = 30;
                break;
            case "NETWORK_DISCONNECT_LEAVINGSPLIT":
            case 31:
                message.reason = 31;
                break;
            case "NETWORK_DISCONNECT_DIFFERENTCLASSTABLES":
            case 32:
                message.reason = 32;
                break;
            case "NETWORK_DISCONNECT_BADRELAYPASSWORD":
            case 33:
                message.reason = 33;
                break;
            case "NETWORK_DISCONNECT_BADSPECTATORPASSWORD":
            case 34:
                message.reason = 34;
                break;
            case "NETWORK_DISCONNECT_HLTVRESTRICTED":
            case 35:
                message.reason = 35;
                break;
            case "NETWORK_DISCONNECT_NOSPECTATORS":
            case 36:
                message.reason = 36;
                break;
            case "NETWORK_DISCONNECT_HLTVUNAVAILABLE":
            case 37:
                message.reason = 37;
                break;
            case "NETWORK_DISCONNECT_HLTVSTOP":
            case 38:
                message.reason = 38;
                break;
            case "NETWORK_DISCONNECT_KICKED":
            case 39:
                message.reason = 39;
                break;
            case "NETWORK_DISCONNECT_BANADDED":
            case 40:
                message.reason = 40;
                break;
            case "NETWORK_DISCONNECT_KICKBANADDED":
            case 41:
                message.reason = 41;
                break;
            case "NETWORK_DISCONNECT_HLTVDIRECT":
            case 42:
                message.reason = 42;
                break;
            case "NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA":
            case 43:
                message.reason = 43;
                break;
            case "NETWORK_DISCONNECT_PURESERVER_MISMATCH":
            case 44:
                message.reason = 44;
                break;
            case "NETWORK_DISCONNECT_USERCMD":
            case 45:
                message.reason = 45;
                break;
            case "NETWORK_DISCONNECT_REJECTED_BY_GAME":
            case 46:
                message.reason = 46;
                break;
            case "NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR":
            case 47:
                message.reason = 47;
                break;
            case "NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR":
            case 48:
                message.reason = 48;
                break;
            case "NETWORK_DISCONNECT_BAD_SERVER_PASSWORD":
            case 49:
                message.reason = 49;
                break;
            case "NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION":
            case 50:
                message.reason = 50;
                break;
            case "NETWORK_DISCONNECT_CONNECTION_FAILURE":
            case 51:
                message.reason = 51;
                break;
            case "NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS":
            case 52:
                message.reason = 52;
                break;
            case "NETWORK_DISCONNECT_RECONNECTION":
            case 53:
                message.reason = 53;
                break;
            case "NETWORK_DISCONNECT_LOOPSHUTDOWN":
            case 54:
                message.reason = 54;
                break;
            case "NETWORK_DISCONNECT_LOOPDEACTIVATE":
            case 55:
                message.reason = 55;
                break;
            case "NETWORK_DISCONNECT_HOST_ENDGAME":
            case 56:
                message.reason = 56;
                break;
            case "NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE":
            case 57:
                message.reason = 57;
                break;
            case "NETWORK_DISCONNECT_CREATE_SERVER_FAILED":
            case 58:
                message.reason = 58;
                break;
            case "NETWORK_DISCONNECT_EXITING":
            case 59:
                message.reason = 59;
                break;
            case "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE":
            case 60:
                message.reason = 60;
                break;
            case "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY":
            case 61:
                message.reason = 61;
                break;
            case "NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL":
            case 62:
                message.reason = 62;
                break;
            case "NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP":
            case 63:
                message.reason = 63;
                break;
            case "NETWORK_DISCONNECT_CLIENT_NO_MAP":
            case 64:
                message.reason = 64;
                break;
            case "NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP":
            case 65:
                message.reason = 65;
                break;
            case "NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM":
            case 66:
                message.reason = 66;
                break;
            case "NETWORK_DISCONNECT_STEAM_DENY_MISC":
            case 67:
                message.reason = 67;
                break;
            case "NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT":
            case 68:
                message.reason = 68;
                break;
            case "NETWORK_DISCONNECT_SERVER_SHUTDOWN":
            case 69:
                message.reason = 69;
                break;
            case "NETWORK_DISCONNECT_SPLITPACKET_SEND_OVERFLOW":
            case 70:
                message.reason = 70;
                break;
            case "NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE":
            case 71:
                message.reason = 71;
                break;
            case "NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT":
            case 72:
                message.reason = 72;
                break;
            case "NETWORK_DISCONNECT_SERVER_INCOMPATIBLE":
            case 73:
                message.reason = 73;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS":
            case 74:
                message.reason = 74;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY":
            case 75:
                message.reason = 75;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG":
            case 76:
                message.reason = 76;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_OTHER":
            case 77:
                message.reason = 77;
                break;
            case "NETWORK_DISCONNECT_REMOTE_TIMEOUT":
            case 79:
                message.reason = 79;
                break;
            case "NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING":
            case 80:
                message.reason = 80;
                break;
            case "NETWORK_DISCONNECT_REMOTE_OTHER":
            case 81:
                message.reason = 81;
                break;
            case "NETWORK_DISCONNECT_REMOTE_BADCRYPT":
            case 82:
                message.reason = 82;
                break;
            case "NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED":
            case 83:
                message.reason = 83;
                break;
            case "NETWORK_DISCONNECT_UNUSUAL":
            case 84:
                message.reason = 84;
                break;
            case "NETWORK_DISCONNECT_INTERNAL_ERROR":
            case 85:
                message.reason = 85;
                break;
            case "NETWORK_DISCONNECT_REJECT_BADCHALLENGE":
            case 128:
                message.reason = 128;
                break;
            case "NETWORK_DISCONNECT_REJECT_NOLOBBY":
            case 129:
                message.reason = 129;
                break;
            case "NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP":
            case 130:
                message.reason = 130;
                break;
            case "NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER":
            case 131:
                message.reason = 131;
                break;
            case "NETWORK_DISCONNECT_REJECT_HIDDEN_GAME":
            case 132:
                message.reason = 132;
                break;
            case "NETWORK_DISCONNECT_REJECT_LANRESTRICT":
            case 133:
                message.reason = 133;
                break;
            case "NETWORK_DISCONNECT_REJECT_BADPASSWORD":
            case 134:
                message.reason = 134;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERFULL":
            case 135:
                message.reason = 135;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION":
            case 136:
                message.reason = 136;
                break;
            case "NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL":
            case 137:
                message.reason = 137;
                break;
            case "NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY":
            case 138:
                message.reason = 138;
                break;
            case "NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY":
            case 139:
                message.reason = 139;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH":
            case 140:
                message.reason = 140;
                break;
            case "NETWORK_DISCONNECT_REJECT_OLDPROTOCOL":
            case 141:
                message.reason = 141;
                break;
            case "NETWORK_DISCONNECT_REJECT_NEWPROTOCOL":
            case 142:
                message.reason = 142;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION":
            case 143:
                message.reason = 143;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN":
            case 144:
                message.reason = 144;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN":
            case 145:
                message.reason = 145;
                break;
            case "NETWORK_DISCONNECT_REJECT_STEAM":
            case 146:
                message.reason = 146;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED":
            case 147:
                message.reason = 147;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID":
            case 148:
                message.reason = 148;
                break;
            case "NETWORK_DISCONNECT_REJECT_BANNED":
            case 149:
                message.reason = 149;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_Disconnect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {CNETMsg_Disconnect} message CNETMsg_Disconnect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_Disconnect.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reason = options.enums === String ? "NETWORK_DISCONNECT_INVALID" : 0;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.ENetworkDisconnectionReason[message.reason] : message.reason;
            return object;
        };
    
        /**
         * Converts this CNETMsg_Disconnect to JSON.
         * @function toJSON
         * @memberof CNETMsg_Disconnect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_Disconnect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_Disconnect;
    })();
    
    $root.CNETMsg_Tick = (function() {
    
        /**
         * Properties of a CNETMsg_Tick.
         * @exports ICNETMsg_Tick
         * @interface ICNETMsg_Tick
         * @property {number|null} [tick] CNETMsg_Tick tick
         * @property {number|null} [host_frametime] CNETMsg_Tick host_frametime
         * @property {number|null} [host_frametime_std_deviation] CNETMsg_Tick host_frametime_std_deviation
         * @property {number|null} [host_computationtime] CNETMsg_Tick host_computationtime
         * @property {number|null} [host_computationtime_std_deviation] CNETMsg_Tick host_computationtime_std_deviation
         * @property {number|null} [host_framestarttime_std_deviation] CNETMsg_Tick host_framestarttime_std_deviation
         * @property {number|null} [host_loss] CNETMsg_Tick host_loss
         */
    
        /**
         * Constructs a new CNETMsg_Tick.
         * @exports CNETMsg_Tick
         * @classdesc Represents a CNETMsg_Tick.
         * @implements ICNETMsg_Tick
         * @constructor
         * @param {ICNETMsg_Tick=} [properties] Properties to set
         */
        function CNETMsg_Tick(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_Tick tick.
         * @member {number} tick
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.tick = 0;
    
        /**
         * CNETMsg_Tick host_frametime.
         * @member {number} host_frametime
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_frametime = 0;
    
        /**
         * CNETMsg_Tick host_frametime_std_deviation.
         * @member {number} host_frametime_std_deviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_frametime_std_deviation = 0;
    
        /**
         * CNETMsg_Tick host_computationtime.
         * @member {number} host_computationtime
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_computationtime = 0;
    
        /**
         * CNETMsg_Tick host_computationtime_std_deviation.
         * @member {number} host_computationtime_std_deviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_computationtime_std_deviation = 0;
    
        /**
         * CNETMsg_Tick host_framestarttime_std_deviation.
         * @member {number} host_framestarttime_std_deviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_framestarttime_std_deviation = 0;
    
        /**
         * CNETMsg_Tick host_loss.
         * @member {number} host_loss
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_loss = 0;
    
        /**
         * Creates a new CNETMsg_Tick instance using the specified properties.
         * @function create
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick=} [properties] Properties to set
         * @returns {CNETMsg_Tick} CNETMsg_Tick instance
         */
        CNETMsg_Tick.create = function create(properties) {
            return new CNETMsg_Tick(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_Tick message. Does not implicitly {@link CNETMsg_Tick.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick} message CNETMsg_Tick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Tick.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.tick);
            if (message.host_frametime != null && Object.hasOwnProperty.call(message, "host_frametime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.host_frametime);
            if (message.host_frametime_std_deviation != null && Object.hasOwnProperty.call(message, "host_frametime_std_deviation"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.host_frametime_std_deviation);
            if (message.host_computationtime != null && Object.hasOwnProperty.call(message, "host_computationtime"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.host_computationtime);
            if (message.host_computationtime_std_deviation != null && Object.hasOwnProperty.call(message, "host_computationtime_std_deviation"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.host_computationtime_std_deviation);
            if (message.host_framestarttime_std_deviation != null && Object.hasOwnProperty.call(message, "host_framestarttime_std_deviation"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.host_framestarttime_std_deviation);
            if (message.host_loss != null && Object.hasOwnProperty.call(message, "host_loss"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.host_loss);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_Tick message, length delimited. Does not implicitly {@link CNETMsg_Tick.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick} message CNETMsg_Tick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Tick.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_Tick message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_Tick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Tick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Tick();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tick = reader.uint32();
                    break;
                case 2:
                    message.host_frametime = reader.uint32();
                    break;
                case 3:
                    message.host_frametime_std_deviation = reader.uint32();
                    break;
                case 4:
                    message.host_computationtime = reader.uint32();
                    break;
                case 5:
                    message.host_computationtime_std_deviation = reader.uint32();
                    break;
                case 6:
                    message.host_framestarttime_std_deviation = reader.uint32();
                    break;
                case 7:
                    message.host_loss = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_Tick message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_Tick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Tick.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_Tick message.
         * @function verify
         * @memberof CNETMsg_Tick
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_Tick.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tick != null && message.hasOwnProperty("tick"))
                if (!$util.isInteger(message.tick))
                    return "tick: integer expected";
            if (message.host_frametime != null && message.hasOwnProperty("host_frametime"))
                if (!$util.isInteger(message.host_frametime))
                    return "host_frametime: integer expected";
            if (message.host_frametime_std_deviation != null && message.hasOwnProperty("host_frametime_std_deviation"))
                if (!$util.isInteger(message.host_frametime_std_deviation))
                    return "host_frametime_std_deviation: integer expected";
            if (message.host_computationtime != null && message.hasOwnProperty("host_computationtime"))
                if (!$util.isInteger(message.host_computationtime))
                    return "host_computationtime: integer expected";
            if (message.host_computationtime_std_deviation != null && message.hasOwnProperty("host_computationtime_std_deviation"))
                if (!$util.isInteger(message.host_computationtime_std_deviation))
                    return "host_computationtime_std_deviation: integer expected";
            if (message.host_framestarttime_std_deviation != null && message.hasOwnProperty("host_framestarttime_std_deviation"))
                if (!$util.isInteger(message.host_framestarttime_std_deviation))
                    return "host_framestarttime_std_deviation: integer expected";
            if (message.host_loss != null && message.hasOwnProperty("host_loss"))
                if (!$util.isInteger(message.host_loss))
                    return "host_loss: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_Tick message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_Tick
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         */
        CNETMsg_Tick.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_Tick)
                return object;
            var message = new $root.CNETMsg_Tick();
            if (object.tick != null)
                message.tick = object.tick >>> 0;
            if (object.host_frametime != null)
                message.host_frametime = object.host_frametime >>> 0;
            if (object.host_frametime_std_deviation != null)
                message.host_frametime_std_deviation = object.host_frametime_std_deviation >>> 0;
            if (object.host_computationtime != null)
                message.host_computationtime = object.host_computationtime >>> 0;
            if (object.host_computationtime_std_deviation != null)
                message.host_computationtime_std_deviation = object.host_computationtime_std_deviation >>> 0;
            if (object.host_framestarttime_std_deviation != null)
                message.host_framestarttime_std_deviation = object.host_framestarttime_std_deviation >>> 0;
            if (object.host_loss != null)
                message.host_loss = object.host_loss >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_Tick message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_Tick
         * @static
         * @param {CNETMsg_Tick} message CNETMsg_Tick
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_Tick.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tick = 0;
                object.host_frametime = 0;
                object.host_frametime_std_deviation = 0;
                object.host_computationtime = 0;
                object.host_computationtime_std_deviation = 0;
                object.host_framestarttime_std_deviation = 0;
                object.host_loss = 0;
            }
            if (message.tick != null && message.hasOwnProperty("tick"))
                object.tick = message.tick;
            if (message.host_frametime != null && message.hasOwnProperty("host_frametime"))
                object.host_frametime = message.host_frametime;
            if (message.host_frametime_std_deviation != null && message.hasOwnProperty("host_frametime_std_deviation"))
                object.host_frametime_std_deviation = message.host_frametime_std_deviation;
            if (message.host_computationtime != null && message.hasOwnProperty("host_computationtime"))
                object.host_computationtime = message.host_computationtime;
            if (message.host_computationtime_std_deviation != null && message.hasOwnProperty("host_computationtime_std_deviation"))
                object.host_computationtime_std_deviation = message.host_computationtime_std_deviation;
            if (message.host_framestarttime_std_deviation != null && message.hasOwnProperty("host_framestarttime_std_deviation"))
                object.host_framestarttime_std_deviation = message.host_framestarttime_std_deviation;
            if (message.host_loss != null && message.hasOwnProperty("host_loss"))
                object.host_loss = message.host_loss;
            return object;
        };
    
        /**
         * Converts this CNETMsg_Tick to JSON.
         * @function toJSON
         * @memberof CNETMsg_Tick
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_Tick.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_Tick;
    })();
    
    $root.CNETMsg_StringCmd = (function() {
    
        /**
         * Properties of a CNETMsg_StringCmd.
         * @exports ICNETMsg_StringCmd
         * @interface ICNETMsg_StringCmd
         * @property {string|null} [command] CNETMsg_StringCmd command
         */
    
        /**
         * Constructs a new CNETMsg_StringCmd.
         * @exports CNETMsg_StringCmd
         * @classdesc Represents a CNETMsg_StringCmd.
         * @implements ICNETMsg_StringCmd
         * @constructor
         * @param {ICNETMsg_StringCmd=} [properties] Properties to set
         */
        function CNETMsg_StringCmd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_StringCmd command.
         * @member {string} command
         * @memberof CNETMsg_StringCmd
         * @instance
         */
        CNETMsg_StringCmd.prototype.command = "";
    
        /**
         * Creates a new CNETMsg_StringCmd instance using the specified properties.
         * @function create
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd=} [properties] Properties to set
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd instance
         */
        CNETMsg_StringCmd.create = function create(properties) {
            return new CNETMsg_StringCmd(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_StringCmd message. Does not implicitly {@link CNETMsg_StringCmd.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd} message CNETMsg_StringCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_StringCmd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_StringCmd message, length delimited. Does not implicitly {@link CNETMsg_StringCmd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd} message CNETMsg_StringCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_StringCmd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_StringCmd message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_StringCmd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_StringCmd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.command = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_StringCmd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_StringCmd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_StringCmd message.
         * @function verify
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_StringCmd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.command != null && message.hasOwnProperty("command"))
                if (!$util.isString(message.command))
                    return "command: string expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_StringCmd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         */
        CNETMsg_StringCmd.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_StringCmd)
                return object;
            var message = new $root.CNETMsg_StringCmd();
            if (object.command != null)
                message.command = String(object.command);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_StringCmd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {CNETMsg_StringCmd} message CNETMsg_StringCmd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_StringCmd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.command = "";
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = message.command;
            return object;
        };
    
        /**
         * Converts this CNETMsg_StringCmd to JSON.
         * @function toJSON
         * @memberof CNETMsg_StringCmd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_StringCmd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_StringCmd;
    })();
    
    $root.CNETMsg_SetConVar = (function() {
    
        /**
         * Properties of a CNETMsg_SetConVar.
         * @exports ICNETMsg_SetConVar
         * @interface ICNETMsg_SetConVar
         * @property {ICMsg_CVars|null} [convars] CNETMsg_SetConVar convars
         */
    
        /**
         * Constructs a new CNETMsg_SetConVar.
         * @exports CNETMsg_SetConVar
         * @classdesc Represents a CNETMsg_SetConVar.
         * @implements ICNETMsg_SetConVar
         * @constructor
         * @param {ICNETMsg_SetConVar=} [properties] Properties to set
         */
        function CNETMsg_SetConVar(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SetConVar convars.
         * @member {ICMsg_CVars|null|undefined} convars
         * @memberof CNETMsg_SetConVar
         * @instance
         */
        CNETMsg_SetConVar.prototype.convars = null;
    
        /**
         * Creates a new CNETMsg_SetConVar instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar=} [properties] Properties to set
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar instance
         */
        CNETMsg_SetConVar.create = function create(properties) {
            return new CNETMsg_SetConVar(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SetConVar message. Does not implicitly {@link CNETMsg_SetConVar.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar} message CNETMsg_SetConVar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SetConVar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.convars != null && Object.hasOwnProperty.call(message, "convars"))
                $root.CMsg_CVars.encode(message.convars, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SetConVar message, length delimited. Does not implicitly {@link CNETMsg_SetConVar.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar} message CNETMsg_SetConVar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SetConVar.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SetConVar message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SetConVar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SetConVar();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.convars = $root.CMsg_CVars.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SetConVar message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SetConVar.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SetConVar message.
         * @function verify
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SetConVar.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.convars != null && message.hasOwnProperty("convars")) {
                var error = $root.CMsg_CVars.verify(message.convars);
                if (error)
                    return "convars." + error;
            }
            return null;
        };
    
        /**
         * Creates a CNETMsg_SetConVar message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         */
        CNETMsg_SetConVar.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SetConVar)
                return object;
            var message = new $root.CNETMsg_SetConVar();
            if (object.convars != null) {
                if (typeof object.convars !== "object")
                    throw TypeError(".CNETMsg_SetConVar.convars: object expected");
                message.convars = $root.CMsg_CVars.fromObject(object.convars);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SetConVar message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {CNETMsg_SetConVar} message CNETMsg_SetConVar
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SetConVar.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.convars = null;
            if (message.convars != null && message.hasOwnProperty("convars"))
                object.convars = $root.CMsg_CVars.toObject(message.convars, options);
            return object;
        };
    
        /**
         * Converts this CNETMsg_SetConVar to JSON.
         * @function toJSON
         * @memberof CNETMsg_SetConVar
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SetConVar.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SetConVar;
    })();
    
    $root.CNETMsg_SignonState = (function() {
    
        /**
         * Properties of a CNETMsg_SignonState.
         * @exports ICNETMsg_SignonState
         * @interface ICNETMsg_SignonState
         * @property {SignonState_t|null} [signon_state] CNETMsg_SignonState signon_state
         * @property {number|null} [spawn_count] CNETMsg_SignonState spawn_count
         * @property {number|null} [num_server_players] CNETMsg_SignonState num_server_players
         * @property {Array.<string>|null} [players_networkids] CNETMsg_SignonState players_networkids
         * @property {string|null} [map_name] CNETMsg_SignonState map_name
         * @property {string|null} [addons] CNETMsg_SignonState addons
         */
    
        /**
         * Constructs a new CNETMsg_SignonState.
         * @exports CNETMsg_SignonState
         * @classdesc Represents a CNETMsg_SignonState.
         * @implements ICNETMsg_SignonState
         * @constructor
         * @param {ICNETMsg_SignonState=} [properties] Properties to set
         */
        function CNETMsg_SignonState(properties) {
            this.players_networkids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SignonState signon_state.
         * @member {SignonState_t} signon_state
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.signon_state = 0;
    
        /**
         * CNETMsg_SignonState spawn_count.
         * @member {number} spawn_count
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.spawn_count = 0;
    
        /**
         * CNETMsg_SignonState num_server_players.
         * @member {number} num_server_players
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.num_server_players = 0;
    
        /**
         * CNETMsg_SignonState players_networkids.
         * @member {Array.<string>} players_networkids
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.players_networkids = $util.emptyArray;
    
        /**
         * CNETMsg_SignonState map_name.
         * @member {string} map_name
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.map_name = "";
    
        /**
         * CNETMsg_SignonState addons.
         * @member {string} addons
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.addons = "";
    
        /**
         * Creates a new CNETMsg_SignonState instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState=} [properties] Properties to set
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState instance
         */
        CNETMsg_SignonState.create = function create(properties) {
            return new CNETMsg_SignonState(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SignonState message. Does not implicitly {@link CNETMsg_SignonState.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState} message CNETMsg_SignonState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SignonState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signon_state != null && Object.hasOwnProperty.call(message, "signon_state"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.signon_state);
            if (message.spawn_count != null && Object.hasOwnProperty.call(message, "spawn_count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.spawn_count);
            if (message.num_server_players != null && Object.hasOwnProperty.call(message, "num_server_players"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.num_server_players);
            if (message.players_networkids != null && message.players_networkids.length)
                for (var i = 0; i < message.players_networkids.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.players_networkids[i]);
            if (message.map_name != null && Object.hasOwnProperty.call(message, "map_name"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.map_name);
            if (message.addons != null && Object.hasOwnProperty.call(message, "addons"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.addons);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SignonState message, length delimited. Does not implicitly {@link CNETMsg_SignonState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState} message CNETMsg_SignonState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SignonState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SignonState message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SignonState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SignonState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SignonState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.signon_state = reader.int32();
                    break;
                case 2:
                    message.spawn_count = reader.uint32();
                    break;
                case 3:
                    message.num_server_players = reader.uint32();
                    break;
                case 4:
                    if (!(message.players_networkids && message.players_networkids.length))
                        message.players_networkids = [];
                    message.players_networkids.push(reader.string());
                    break;
                case 5:
                    message.map_name = reader.string();
                    break;
                case 6:
                    message.addons = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SignonState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SignonState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SignonState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SignonState message.
         * @function verify
         * @memberof CNETMsg_SignonState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SignonState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signon_state != null && message.hasOwnProperty("signon_state"))
                switch (message.signon_state) {
                default:
                    return "signon_state: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            if (message.spawn_count != null && message.hasOwnProperty("spawn_count"))
                if (!$util.isInteger(message.spawn_count))
                    return "spawn_count: integer expected";
            if (message.num_server_players != null && message.hasOwnProperty("num_server_players"))
                if (!$util.isInteger(message.num_server_players))
                    return "num_server_players: integer expected";
            if (message.players_networkids != null && message.hasOwnProperty("players_networkids")) {
                if (!Array.isArray(message.players_networkids))
                    return "players_networkids: array expected";
                for (var i = 0; i < message.players_networkids.length; ++i)
                    if (!$util.isString(message.players_networkids[i]))
                        return "players_networkids: string[] expected";
            }
            if (message.map_name != null && message.hasOwnProperty("map_name"))
                if (!$util.isString(message.map_name))
                    return "map_name: string expected";
            if (message.addons != null && message.hasOwnProperty("addons"))
                if (!$util.isString(message.addons))
                    return "addons: string expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SignonState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SignonState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         */
        CNETMsg_SignonState.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SignonState)
                return object;
            var message = new $root.CNETMsg_SignonState();
            switch (object.signon_state) {
            case "SIGNONSTATE_NONE":
            case 0:
                message.signon_state = 0;
                break;
            case "SIGNONSTATE_CHALLENGE":
            case 1:
                message.signon_state = 1;
                break;
            case "SIGNONSTATE_CONNECTED":
            case 2:
                message.signon_state = 2;
                break;
            case "SIGNONSTATE_NEW":
            case 3:
                message.signon_state = 3;
                break;
            case "SIGNONSTATE_PRESPAWN":
            case 4:
                message.signon_state = 4;
                break;
            case "SIGNONSTATE_SPAWN":
            case 5:
                message.signon_state = 5;
                break;
            case "SIGNONSTATE_FULL":
            case 6:
                message.signon_state = 6;
                break;
            case "SIGNONSTATE_CHANGELEVEL":
            case 7:
                message.signon_state = 7;
                break;
            }
            if (object.spawn_count != null)
                message.spawn_count = object.spawn_count >>> 0;
            if (object.num_server_players != null)
                message.num_server_players = object.num_server_players >>> 0;
            if (object.players_networkids) {
                if (!Array.isArray(object.players_networkids))
                    throw TypeError(".CNETMsg_SignonState.players_networkids: array expected");
                message.players_networkids = [];
                for (var i = 0; i < object.players_networkids.length; ++i)
                    message.players_networkids[i] = String(object.players_networkids[i]);
            }
            if (object.map_name != null)
                message.map_name = String(object.map_name);
            if (object.addons != null)
                message.addons = String(object.addons);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SignonState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SignonState
         * @static
         * @param {CNETMsg_SignonState} message CNETMsg_SignonState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SignonState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.players_networkids = [];
            if (options.defaults) {
                object.signon_state = options.enums === String ? "SIGNONSTATE_NONE" : 0;
                object.spawn_count = 0;
                object.num_server_players = 0;
                object.map_name = "";
                object.addons = "";
            }
            if (message.signon_state != null && message.hasOwnProperty("signon_state"))
                object.signon_state = options.enums === String ? $root.SignonState_t[message.signon_state] : message.signon_state;
            if (message.spawn_count != null && message.hasOwnProperty("spawn_count"))
                object.spawn_count = message.spawn_count;
            if (message.num_server_players != null && message.hasOwnProperty("num_server_players"))
                object.num_server_players = message.num_server_players;
            if (message.players_networkids && message.players_networkids.length) {
                object.players_networkids = [];
                for (var j = 0; j < message.players_networkids.length; ++j)
                    object.players_networkids[j] = message.players_networkids[j];
            }
            if (message.map_name != null && message.hasOwnProperty("map_name"))
                object.map_name = message.map_name;
            if (message.addons != null && message.hasOwnProperty("addons"))
                object.addons = message.addons;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SignonState to JSON.
         * @function toJSON
         * @memberof CNETMsg_SignonState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SignonState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SignonState;
    })();
    
    $root.CSVCMsg_GameEvent = (function() {
    
        /**
         * Properties of a CSVCMsg_GameEvent.
         * @exports ICSVCMsg_GameEvent
         * @interface ICSVCMsg_GameEvent
         * @property {string|null} [event_name] CSVCMsg_GameEvent event_name
         * @property {number|null} [eventid] CSVCMsg_GameEvent eventid
         * @property {Array.<CSVCMsg_GameEvent.Ikey_t>|null} [keys] CSVCMsg_GameEvent keys
         */
    
        /**
         * Constructs a new CSVCMsg_GameEvent.
         * @exports CSVCMsg_GameEvent
         * @classdesc Represents a CSVCMsg_GameEvent.
         * @implements ICSVCMsg_GameEvent
         * @constructor
         * @param {ICSVCMsg_GameEvent=} [properties] Properties to set
         */
        function CSVCMsg_GameEvent(properties) {
            this.keys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GameEvent event_name.
         * @member {string} event_name
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.event_name = "";
    
        /**
         * CSVCMsg_GameEvent eventid.
         * @member {number} eventid
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.eventid = 0;
    
        /**
         * CSVCMsg_GameEvent keys.
         * @member {Array.<CSVCMsg_GameEvent.Ikey_t>} keys
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.keys = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_GameEvent instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent=} [properties] Properties to set
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent instance
         */
        CSVCMsg_GameEvent.create = function create(properties) {
            return new CSVCMsg_GameEvent(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEvent message. Does not implicitly {@link CSVCMsg_GameEvent.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent} message CSVCMsg_GameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event_name != null && Object.hasOwnProperty.call(message, "event_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.event_name);
            if (message.eventid != null && Object.hasOwnProperty.call(message, "eventid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.eventid);
            if (message.keys != null && message.keys.length)
                for (var i = 0; i < message.keys.length; ++i)
                    $root.CSVCMsg_GameEvent.key_t.encode(message.keys[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEvent message, length delimited. Does not implicitly {@link CSVCMsg_GameEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent} message CSVCMsg_GameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.event_name = reader.string();
                    break;
                case 2:
                    message.eventid = reader.int32();
                    break;
                case 3:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push($root.CSVCMsg_GameEvent.key_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GameEvent message.
         * @function verify
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GameEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event_name != null && message.hasOwnProperty("event_name"))
                if (!$util.isString(message.event_name))
                    return "event_name: string expected";
            if (message.eventid != null && message.hasOwnProperty("eventid"))
                if (!$util.isInteger(message.eventid))
                    return "eventid: integer expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                if (!Array.isArray(message.keys))
                    return "keys: array expected";
                for (var i = 0; i < message.keys.length; ++i) {
                    var error = $root.CSVCMsg_GameEvent.key_t.verify(message.keys[i]);
                    if (error)
                        return "keys." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GameEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         */
        CSVCMsg_GameEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GameEvent)
                return object;
            var message = new $root.CSVCMsg_GameEvent();
            if (object.event_name != null)
                message.event_name = String(object.event_name);
            if (object.eventid != null)
                message.eventid = object.eventid | 0;
            if (object.keys) {
                if (!Array.isArray(object.keys))
                    throw TypeError(".CSVCMsg_GameEvent.keys: array expected");
                message.keys = [];
                for (var i = 0; i < object.keys.length; ++i) {
                    if (typeof object.keys[i] !== "object")
                        throw TypeError(".CSVCMsg_GameEvent.keys: object expected");
                    message.keys[i] = $root.CSVCMsg_GameEvent.key_t.fromObject(object.keys[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GameEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {CSVCMsg_GameEvent} message CSVCMsg_GameEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GameEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.keys = [];
            if (options.defaults) {
                object.event_name = "";
                object.eventid = 0;
            }
            if (message.event_name != null && message.hasOwnProperty("event_name"))
                object.event_name = message.event_name;
            if (message.eventid != null && message.hasOwnProperty("eventid"))
                object.eventid = message.eventid;
            if (message.keys && message.keys.length) {
                object.keys = [];
                for (var j = 0; j < message.keys.length; ++j)
                    object.keys[j] = $root.CSVCMsg_GameEvent.key_t.toObject(message.keys[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GameEvent to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GameEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GameEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsg_GameEvent.key_t = (function() {
    
            /**
             * Properties of a key_t.
             * @memberof CSVCMsg_GameEvent
             * @interface Ikey_t
             * @property {number|null} [type] key_t type
             * @property {string|null} [val_string] key_t val_string
             * @property {number|null} [val_float] key_t val_float
             * @property {number|null} [val_long] key_t val_long
             * @property {number|null} [val_short] key_t val_short
             * @property {number|null} [val_byte] key_t val_byte
             * @property {boolean|null} [val_bool] key_t val_bool
             * @property {number|Long|null} [val_uint64] key_t val_uint64
             */
    
            /**
             * Constructs a new key_t.
             * @memberof CSVCMsg_GameEvent
             * @classdesc Represents a key_t.
             * @implements Ikey_t
             * @constructor
             * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set
             */
            function key_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * key_t type.
             * @member {number} type
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.type = 0;
    
            /**
             * key_t val_string.
             * @member {string} val_string
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_string = "";
    
            /**
             * key_t val_float.
             * @member {number} val_float
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_float = 0;
    
            /**
             * key_t val_long.
             * @member {number} val_long
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_long = 0;
    
            /**
             * key_t val_short.
             * @member {number} val_short
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_short = 0;
    
            /**
             * key_t val_byte.
             * @member {number} val_byte
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_byte = 0;
    
            /**
             * key_t val_bool.
             * @member {boolean} val_bool
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_bool = false;
    
            /**
             * key_t val_uint64.
             * @member {number|Long} val_uint64
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_uint64 = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new key_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set
             * @returns {CSVCMsg_GameEvent.key_t} key_t instance
             */
            key_t.create = function create(properties) {
                return new key_t(properties);
            };
    
            /**
             * Encodes the specified key_t message. Does not implicitly {@link CSVCMsg_GameEvent.key_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.val_string != null && Object.hasOwnProperty.call(message, "val_string"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.val_string);
                if (message.val_float != null && Object.hasOwnProperty.call(message, "val_float"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.val_float);
                if (message.val_long != null && Object.hasOwnProperty.call(message, "val_long"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.val_long);
                if (message.val_short != null && Object.hasOwnProperty.call(message, "val_short"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.val_short);
                if (message.val_byte != null && Object.hasOwnProperty.call(message, "val_byte"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.val_byte);
                if (message.val_bool != null && Object.hasOwnProperty.call(message, "val_bool"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.val_bool);
                if (message.val_uint64 != null && Object.hasOwnProperty.call(message, "val_uint64"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.val_uint64);
                return writer;
            };
    
            /**
             * Encodes the specified key_t message, length delimited. Does not implicitly {@link CSVCMsg_GameEvent.key_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent.key_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.val_string = reader.string();
                        break;
                    case 3:
                        message.val_float = reader.float();
                        break;
                    case 4:
                        message.val_long = reader.int32();
                        break;
                    case 5:
                        message.val_short = reader.int32();
                        break;
                    case 6:
                        message.val_byte = reader.int32();
                        break;
                    case 7:
                        message.val_bool = reader.bool();
                        break;
                    case 8:
                        message.val_uint64 = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a key_t message.
             * @function verify
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            key_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.val_string != null && message.hasOwnProperty("val_string"))
                    if (!$util.isString(message.val_string))
                        return "val_string: string expected";
                if (message.val_float != null && message.hasOwnProperty("val_float"))
                    if (typeof message.val_float !== "number")
                        return "val_float: number expected";
                if (message.val_long != null && message.hasOwnProperty("val_long"))
                    if (!$util.isInteger(message.val_long))
                        return "val_long: integer expected";
                if (message.val_short != null && message.hasOwnProperty("val_short"))
                    if (!$util.isInteger(message.val_short))
                        return "val_short: integer expected";
                if (message.val_byte != null && message.hasOwnProperty("val_byte"))
                    if (!$util.isInteger(message.val_byte))
                        return "val_byte: integer expected";
                if (message.val_bool != null && message.hasOwnProperty("val_bool"))
                    if (typeof message.val_bool !== "boolean")
                        return "val_bool: boolean expected";
                if (message.val_uint64 != null && message.hasOwnProperty("val_uint64"))
                    if (!$util.isInteger(message.val_uint64) && !(message.val_uint64 && $util.isInteger(message.val_uint64.low) && $util.isInteger(message.val_uint64.high)))
                        return "val_uint64: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a key_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             */
            key_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_GameEvent.key_t)
                    return object;
                var message = new $root.CSVCMsg_GameEvent.key_t();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.val_string != null)
                    message.val_string = String(object.val_string);
                if (object.val_float != null)
                    message.val_float = Number(object.val_float);
                if (object.val_long != null)
                    message.val_long = object.val_long | 0;
                if (object.val_short != null)
                    message.val_short = object.val_short | 0;
                if (object.val_byte != null)
                    message.val_byte = object.val_byte | 0;
                if (object.val_bool != null)
                    message.val_bool = Boolean(object.val_bool);
                if (object.val_uint64 != null)
                    if ($util.Long)
                        (message.val_uint64 = $util.Long.fromValue(object.val_uint64)).unsigned = true;
                    else if (typeof object.val_uint64 === "string")
                        message.val_uint64 = parseInt(object.val_uint64, 10);
                    else if (typeof object.val_uint64 === "number")
                        message.val_uint64 = object.val_uint64;
                    else if (typeof object.val_uint64 === "object")
                        message.val_uint64 = new $util.LongBits(object.val_uint64.low >>> 0, object.val_uint64.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a key_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.key_t} message key_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            key_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = 0;
                    object.val_string = "";
                    object.val_float = 0;
                    object.val_long = 0;
                    object.val_short = 0;
                    object.val_byte = 0;
                    object.val_bool = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.val_uint64 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.val_uint64 = options.longs === String ? "0" : 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.val_string != null && message.hasOwnProperty("val_string"))
                    object.val_string = message.val_string;
                if (message.val_float != null && message.hasOwnProperty("val_float"))
                    object.val_float = options.json && !isFinite(message.val_float) ? String(message.val_float) : message.val_float;
                if (message.val_long != null && message.hasOwnProperty("val_long"))
                    object.val_long = message.val_long;
                if (message.val_short != null && message.hasOwnProperty("val_short"))
                    object.val_short = message.val_short;
                if (message.val_byte != null && message.hasOwnProperty("val_byte"))
                    object.val_byte = message.val_byte;
                if (message.val_bool != null && message.hasOwnProperty("val_bool"))
                    object.val_bool = message.val_bool;
                if (message.val_uint64 != null && message.hasOwnProperty("val_uint64"))
                    if (typeof message.val_uint64 === "number")
                        object.val_uint64 = options.longs === String ? String(message.val_uint64) : message.val_uint64;
                    else
                        object.val_uint64 = options.longs === String ? $util.Long.prototype.toString.call(message.val_uint64) : options.longs === Number ? new $util.LongBits(message.val_uint64.low >>> 0, message.val_uint64.high >>> 0).toNumber(true) : message.val_uint64;
                return object;
            };
    
            /**
             * Converts this key_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            key_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return key_t;
        })();
    
        return CSVCMsg_GameEvent;
    })();
    
    $root.CSVCMsgList_GameEvents = (function() {
    
        /**
         * Properties of a CSVCMsgList_GameEvents.
         * @exports ICSVCMsgList_GameEvents
         * @interface ICSVCMsgList_GameEvents
         * @property {Array.<CSVCMsgList_GameEvents.Ievent_t>|null} [events] CSVCMsgList_GameEvents events
         */
    
        /**
         * Constructs a new CSVCMsgList_GameEvents.
         * @exports CSVCMsgList_GameEvents
         * @classdesc Represents a CSVCMsgList_GameEvents.
         * @implements ICSVCMsgList_GameEvents
         * @constructor
         * @param {ICSVCMsgList_GameEvents=} [properties] Properties to set
         */
        function CSVCMsgList_GameEvents(properties) {
            this.events = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsgList_GameEvents events.
         * @member {Array.<CSVCMsgList_GameEvents.Ievent_t>} events
         * @memberof CSVCMsgList_GameEvents
         * @instance
         */
        CSVCMsgList_GameEvents.prototype.events = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsgList_GameEvents instance using the specified properties.
         * @function create
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents=} [properties] Properties to set
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents instance
         */
        CSVCMsgList_GameEvents.create = function create(properties) {
            return new CSVCMsgList_GameEvents(properties);
        };
    
        /**
         * Encodes the specified CSVCMsgList_GameEvents message. Does not implicitly {@link CSVCMsgList_GameEvents.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents} message CSVCMsgList_GameEvents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_GameEvents.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.CSVCMsgList_GameEvents.event_t.encode(message.events[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsgList_GameEvents message, length delimited. Does not implicitly {@link CSVCMsgList_GameEvents.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents} message CSVCMsgList_GameEvents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_GameEvents.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsgList_GameEvents message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_GameEvents.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_GameEvents();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.events && message.events.length))
                        message.events = [];
                    message.events.push($root.CSVCMsgList_GameEvents.event_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsgList_GameEvents message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_GameEvents.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsgList_GameEvents message.
         * @function verify
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsgList_GameEvents.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.CSVCMsgList_GameEvents.event_t.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsgList_GameEvents message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         */
        CSVCMsgList_GameEvents.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsgList_GameEvents)
                return object;
            var message = new $root.CSVCMsgList_GameEvents();
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".CSVCMsgList_GameEvents.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".CSVCMsgList_GameEvents.events: object expected");
                    message.events[i] = $root.CSVCMsgList_GameEvents.event_t.fromObject(object.events[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsgList_GameEvents message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {CSVCMsgList_GameEvents} message CSVCMsgList_GameEvents
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsgList_GameEvents.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.events = [];
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.CSVCMsgList_GameEvents.event_t.toObject(message.events[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsgList_GameEvents to JSON.
         * @function toJSON
         * @memberof CSVCMsgList_GameEvents
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsgList_GameEvents.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsgList_GameEvents.event_t = (function() {
    
            /**
             * Properties of an event_t.
             * @memberof CSVCMsgList_GameEvents
             * @interface Ievent_t
             * @property {number|null} [tick] event_t tick
             * @property {ICSVCMsg_GameEvent|null} [event] event_t event
             */
    
            /**
             * Constructs a new event_t.
             * @memberof CSVCMsgList_GameEvents
             * @classdesc Represents an event_t.
             * @implements Ievent_t
             * @constructor
             * @param {CSVCMsgList_GameEvents.Ievent_t=} [properties] Properties to set
             */
            function event_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * event_t tick.
             * @member {number} tick
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             */
            event_t.prototype.tick = 0;
    
            /**
             * event_t event.
             * @member {ICSVCMsg_GameEvent|null|undefined} event
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             */
            event_t.prototype.event = null;
    
            /**
             * Creates a new event_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t=} [properties] Properties to set
             * @returns {CSVCMsgList_GameEvents.event_t} event_t instance
             */
            event_t.create = function create(properties) {
                return new event_t(properties);
            };
    
            /**
             * Encodes the specified event_t message. Does not implicitly {@link CSVCMsgList_GameEvents.event_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t} message event_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            event_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tick);
                if (message.event != null && Object.hasOwnProperty.call(message, "event"))
                    $root.CSVCMsg_GameEvent.encode(message.event, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified event_t message, length delimited. Does not implicitly {@link CSVCMsgList_GameEvents.event_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t} message event_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            event_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an event_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            event_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_GameEvents.event_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tick = reader.int32();
                        break;
                    case 2:
                        message.event = $root.CSVCMsg_GameEvent.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an event_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            event_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an event_t message.
             * @function verify
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            event_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tick != null && message.hasOwnProperty("tick"))
                    if (!$util.isInteger(message.tick))
                        return "tick: integer expected";
                if (message.event != null && message.hasOwnProperty("event")) {
                    var error = $root.CSVCMsg_GameEvent.verify(message.event);
                    if (error)
                        return "event." + error;
                }
                return null;
            };
    
            /**
             * Creates an event_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             */
            event_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsgList_GameEvents.event_t)
                    return object;
                var message = new $root.CSVCMsgList_GameEvents.event_t();
                if (object.tick != null)
                    message.tick = object.tick | 0;
                if (object.event != null) {
                    if (typeof object.event !== "object")
                        throw TypeError(".CSVCMsgList_GameEvents.event_t.event: object expected");
                    message.event = $root.CSVCMsg_GameEvent.fromObject(object.event);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an event_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.event_t} message event_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            event_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tick = 0;
                    object.event = null;
                }
                if (message.tick != null && message.hasOwnProperty("tick"))
                    object.tick = message.tick;
                if (message.event != null && message.hasOwnProperty("event"))
                    object.event = $root.CSVCMsg_GameEvent.toObject(message.event, options);
                return object;
            };
    
            /**
             * Converts this event_t to JSON.
             * @function toJSON
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            event_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return event_t;
        })();
    
        return CSVCMsgList_GameEvents;
    })();
    
    $root.CSVCMsg_UserMessage = (function() {
    
        /**
         * Properties of a CSVCMsg_UserMessage.
         * @exports ICSVCMsg_UserMessage
         * @interface ICSVCMsg_UserMessage
         * @property {number|null} [msg_type] CSVCMsg_UserMessage msg_type
         * @property {Uint8Array|null} [msg_data] CSVCMsg_UserMessage msg_data
         */
    
        /**
         * Constructs a new CSVCMsg_UserMessage.
         * @exports CSVCMsg_UserMessage
         * @classdesc Represents a CSVCMsg_UserMessage.
         * @implements ICSVCMsg_UserMessage
         * @constructor
         * @param {ICSVCMsg_UserMessage=} [properties] Properties to set
         */
        function CSVCMsg_UserMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_UserMessage msg_type.
         * @member {number} msg_type
         * @memberof CSVCMsg_UserMessage
         * @instance
         */
        CSVCMsg_UserMessage.prototype.msg_type = 0;
    
        /**
         * CSVCMsg_UserMessage msg_data.
         * @member {Uint8Array} msg_data
         * @memberof CSVCMsg_UserMessage
         * @instance
         */
        CSVCMsg_UserMessage.prototype.msg_data = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_UserMessage instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage=} [properties] Properties to set
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage instance
         */
        CSVCMsg_UserMessage.create = function create(properties) {
            return new CSVCMsg_UserMessage(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_UserMessage message. Does not implicitly {@link CSVCMsg_UserMessage.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage} message CSVCMsg_UserMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_UserMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg_type != null && Object.hasOwnProperty.call(message, "msg_type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.msg_type);
            if (message.msg_data != null && Object.hasOwnProperty.call(message, "msg_data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.msg_data);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_UserMessage message, length delimited. Does not implicitly {@link CSVCMsg_UserMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage} message CSVCMsg_UserMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_UserMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_UserMessage message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_UserMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_UserMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg_type = reader.int32();
                    break;
                case 2:
                    message.msg_data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_UserMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_UserMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_UserMessage message.
         * @function verify
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_UserMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                if (!$util.isInteger(message.msg_type))
                    return "msg_type: integer expected";
            if (message.msg_data != null && message.hasOwnProperty("msg_data"))
                if (!(message.msg_data && typeof message.msg_data.length === "number" || $util.isString(message.msg_data)))
                    return "msg_data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_UserMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         */
        CSVCMsg_UserMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_UserMessage)
                return object;
            var message = new $root.CSVCMsg_UserMessage();
            if (object.msg_type != null)
                message.msg_type = object.msg_type | 0;
            if (object.msg_data != null)
                if (typeof object.msg_data === "string")
                    $util.base64.decode(object.msg_data, message.msg_data = $util.newBuffer($util.base64.length(object.msg_data)), 0);
                else if (object.msg_data.length)
                    message.msg_data = object.msg_data;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_UserMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {CSVCMsg_UserMessage} message CSVCMsg_UserMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_UserMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.msg_type = 0;
                if (options.bytes === String)
                    object.msg_data = "";
                else {
                    object.msg_data = [];
                    if (options.bytes !== Array)
                        object.msg_data = $util.newBuffer(object.msg_data);
                }
            }
            if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                object.msg_type = message.msg_type;
            if (message.msg_data != null && message.hasOwnProperty("msg_data"))
                object.msg_data = options.bytes === String ? $util.base64.encode(message.msg_data, 0, message.msg_data.length) : options.bytes === Array ? Array.prototype.slice.call(message.msg_data) : message.msg_data;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_UserMessage to JSON.
         * @function toJSON
         * @memberof CSVCMsg_UserMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_UserMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_UserMessage;
    })();
    
    $root.CSVCMsgList_UserMessages = (function() {
    
        /**
         * Properties of a CSVCMsgList_UserMessages.
         * @exports ICSVCMsgList_UserMessages
         * @interface ICSVCMsgList_UserMessages
         * @property {Array.<CSVCMsgList_UserMessages.Iusermsg_t>|null} [usermsgs] CSVCMsgList_UserMessages usermsgs
         */
    
        /**
         * Constructs a new CSVCMsgList_UserMessages.
         * @exports CSVCMsgList_UserMessages
         * @classdesc Represents a CSVCMsgList_UserMessages.
         * @implements ICSVCMsgList_UserMessages
         * @constructor
         * @param {ICSVCMsgList_UserMessages=} [properties] Properties to set
         */
        function CSVCMsgList_UserMessages(properties) {
            this.usermsgs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsgList_UserMessages usermsgs.
         * @member {Array.<CSVCMsgList_UserMessages.Iusermsg_t>} usermsgs
         * @memberof CSVCMsgList_UserMessages
         * @instance
         */
        CSVCMsgList_UserMessages.prototype.usermsgs = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsgList_UserMessages instance using the specified properties.
         * @function create
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {ICSVCMsgList_UserMessages=} [properties] Properties to set
         * @returns {CSVCMsgList_UserMessages} CSVCMsgList_UserMessages instance
         */
        CSVCMsgList_UserMessages.create = function create(properties) {
            return new CSVCMsgList_UserMessages(properties);
        };
    
        /**
         * Encodes the specified CSVCMsgList_UserMessages message. Does not implicitly {@link CSVCMsgList_UserMessages.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {ICSVCMsgList_UserMessages} message CSVCMsgList_UserMessages message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_UserMessages.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.usermsgs != null && message.usermsgs.length)
                for (var i = 0; i < message.usermsgs.length; ++i)
                    $root.CSVCMsgList_UserMessages.usermsg_t.encode(message.usermsgs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsgList_UserMessages message, length delimited. Does not implicitly {@link CSVCMsgList_UserMessages.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {ICSVCMsgList_UserMessages} message CSVCMsgList_UserMessages message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_UserMessages.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsgList_UserMessages message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsgList_UserMessages} CSVCMsgList_UserMessages
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_UserMessages.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_UserMessages();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.usermsgs && message.usermsgs.length))
                        message.usermsgs = [];
                    message.usermsgs.push($root.CSVCMsgList_UserMessages.usermsg_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsgList_UserMessages message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsgList_UserMessages} CSVCMsgList_UserMessages
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_UserMessages.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsgList_UserMessages message.
         * @function verify
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsgList_UserMessages.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.usermsgs != null && message.hasOwnProperty("usermsgs")) {
                if (!Array.isArray(message.usermsgs))
                    return "usermsgs: array expected";
                for (var i = 0; i < message.usermsgs.length; ++i) {
                    var error = $root.CSVCMsgList_UserMessages.usermsg_t.verify(message.usermsgs[i]);
                    if (error)
                        return "usermsgs." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsgList_UserMessages message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsgList_UserMessages} CSVCMsgList_UserMessages
         */
        CSVCMsgList_UserMessages.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsgList_UserMessages)
                return object;
            var message = new $root.CSVCMsgList_UserMessages();
            if (object.usermsgs) {
                if (!Array.isArray(object.usermsgs))
                    throw TypeError(".CSVCMsgList_UserMessages.usermsgs: array expected");
                message.usermsgs = [];
                for (var i = 0; i < object.usermsgs.length; ++i) {
                    if (typeof object.usermsgs[i] !== "object")
                        throw TypeError(".CSVCMsgList_UserMessages.usermsgs: object expected");
                    message.usermsgs[i] = $root.CSVCMsgList_UserMessages.usermsg_t.fromObject(object.usermsgs[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsgList_UserMessages message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {CSVCMsgList_UserMessages} message CSVCMsgList_UserMessages
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsgList_UserMessages.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.usermsgs = [];
            if (message.usermsgs && message.usermsgs.length) {
                object.usermsgs = [];
                for (var j = 0; j < message.usermsgs.length; ++j)
                    object.usermsgs[j] = $root.CSVCMsgList_UserMessages.usermsg_t.toObject(message.usermsgs[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsgList_UserMessages to JSON.
         * @function toJSON
         * @memberof CSVCMsgList_UserMessages
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsgList_UserMessages.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsgList_UserMessages.usermsg_t = (function() {
    
            /**
             * Properties of a usermsg_t.
             * @memberof CSVCMsgList_UserMessages
             * @interface Iusermsg_t
             * @property {number|null} [tick] usermsg_t tick
             * @property {ICSVCMsg_UserMessage|null} [msg] usermsg_t msg
             */
    
            /**
             * Constructs a new usermsg_t.
             * @memberof CSVCMsgList_UserMessages
             * @classdesc Represents a usermsg_t.
             * @implements Iusermsg_t
             * @constructor
             * @param {CSVCMsgList_UserMessages.Iusermsg_t=} [properties] Properties to set
             */
            function usermsg_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * usermsg_t tick.
             * @member {number} tick
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @instance
             */
            usermsg_t.prototype.tick = 0;
    
            /**
             * usermsg_t msg.
             * @member {ICSVCMsg_UserMessage|null|undefined} msg
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @instance
             */
            usermsg_t.prototype.msg = null;
    
            /**
             * Creates a new usermsg_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {CSVCMsgList_UserMessages.Iusermsg_t=} [properties] Properties to set
             * @returns {CSVCMsgList_UserMessages.usermsg_t} usermsg_t instance
             */
            usermsg_t.create = function create(properties) {
                return new usermsg_t(properties);
            };
    
            /**
             * Encodes the specified usermsg_t message. Does not implicitly {@link CSVCMsgList_UserMessages.usermsg_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {CSVCMsgList_UserMessages.Iusermsg_t} message usermsg_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            usermsg_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tick);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    $root.CSVCMsg_UserMessage.encode(message.msg, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified usermsg_t message, length delimited. Does not implicitly {@link CSVCMsgList_UserMessages.usermsg_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {CSVCMsgList_UserMessages.Iusermsg_t} message usermsg_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            usermsg_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a usermsg_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsgList_UserMessages.usermsg_t} usermsg_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            usermsg_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_UserMessages.usermsg_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tick = reader.int32();
                        break;
                    case 2:
                        message.msg = $root.CSVCMsg_UserMessage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a usermsg_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsgList_UserMessages.usermsg_t} usermsg_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            usermsg_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a usermsg_t message.
             * @function verify
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            usermsg_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tick != null && message.hasOwnProperty("tick"))
                    if (!$util.isInteger(message.tick))
                        return "tick: integer expected";
                if (message.msg != null && message.hasOwnProperty("msg")) {
                    var error = $root.CSVCMsg_UserMessage.verify(message.msg);
                    if (error)
                        return "msg." + error;
                }
                return null;
            };
    
            /**
             * Creates a usermsg_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsgList_UserMessages.usermsg_t} usermsg_t
             */
            usermsg_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsgList_UserMessages.usermsg_t)
                    return object;
                var message = new $root.CSVCMsgList_UserMessages.usermsg_t();
                if (object.tick != null)
                    message.tick = object.tick | 0;
                if (object.msg != null) {
                    if (typeof object.msg !== "object")
                        throw TypeError(".CSVCMsgList_UserMessages.usermsg_t.msg: object expected");
                    message.msg = $root.CSVCMsg_UserMessage.fromObject(object.msg);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a usermsg_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {CSVCMsgList_UserMessages.usermsg_t} message usermsg_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            usermsg_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tick = 0;
                    object.msg = null;
                }
                if (message.tick != null && message.hasOwnProperty("tick"))
                    object.tick = message.tick;
                if (message.msg != null && message.hasOwnProperty("msg"))
                    object.msg = $root.CSVCMsg_UserMessage.toObject(message.msg, options);
                return object;
            };
    
            /**
             * Converts this usermsg_t to JSON.
             * @function toJSON
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            usermsg_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return usermsg_t;
        })();
    
        return CSVCMsgList_UserMessages;
    })();
    
    $root.CNETMsg_SpawnGroup_Load = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_Load.
         * @exports ICNETMsg_SpawnGroup_Load
         * @interface ICNETMsg_SpawnGroup_Load
         * @property {string|null} [worldname] CNETMsg_SpawnGroup_Load worldname
         * @property {string|null} [entitylumpname] CNETMsg_SpawnGroup_Load entitylumpname
         * @property {string|null} [entityfiltername] CNETMsg_SpawnGroup_Load entityfiltername
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_Load spawngrouphandle
         * @property {number|null} [spawngroupownerhandle] CNETMsg_SpawnGroup_Load spawngroupownerhandle
         * @property {ICMsgVector|null} [world_offset_pos] CNETMsg_SpawnGroup_Load world_offset_pos
         * @property {ICMsgQAngle|null} [world_offset_angle] CNETMsg_SpawnGroup_Load world_offset_angle
         * @property {Uint8Array|null} [spawngroupmanifest] CNETMsg_SpawnGroup_Load spawngroupmanifest
         * @property {number|null} [flags] CNETMsg_SpawnGroup_Load flags
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_Load tickcount
         * @property {boolean|null} [manifestincomplete] CNETMsg_SpawnGroup_Load manifestincomplete
         * @property {string|null} [localnamefixup] CNETMsg_SpawnGroup_Load localnamefixup
         * @property {string|null} [parentnamefixup] CNETMsg_SpawnGroup_Load parentnamefixup
         * @property {number|null} [manifestloadpriority] CNETMsg_SpawnGroup_Load manifestloadpriority
         * @property {number|null} [worldgroupid] CNETMsg_SpawnGroup_Load worldgroupid
         * @property {number|null} [creationsequence] CNETMsg_SpawnGroup_Load creationsequence
         * @property {string|null} [savegamefilename] CNETMsg_SpawnGroup_Load savegamefilename
         * @property {number|null} [spawngroupparenthandle] CNETMsg_SpawnGroup_Load spawngroupparenthandle
         * @property {boolean|null} [leveltransition] CNETMsg_SpawnGroup_Load leveltransition
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_Load.
         * @exports CNETMsg_SpawnGroup_Load
         * @classdesc Represents a CNETMsg_SpawnGroup_Load.
         * @implements ICNETMsg_SpawnGroup_Load
         * @constructor
         * @param {ICNETMsg_SpawnGroup_Load=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_Load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_Load worldname.
         * @member {string} worldname
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.worldname = "";
    
        /**
         * CNETMsg_SpawnGroup_Load entitylumpname.
         * @member {string} entitylumpname
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.entitylumpname = "";
    
        /**
         * CNETMsg_SpawnGroup_Load entityfiltername.
         * @member {string} entityfiltername
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.entityfiltername = "";
    
        /**
         * CNETMsg_SpawnGroup_Load spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupownerhandle.
         * @member {number} spawngroupownerhandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupownerhandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load world_offset_pos.
         * @member {ICMsgVector|null|undefined} world_offset_pos
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.world_offset_pos = null;
    
        /**
         * CNETMsg_SpawnGroup_Load world_offset_angle.
         * @member {ICMsgQAngle|null|undefined} world_offset_angle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.world_offset_angle = null;
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupmanifest.
         * @member {Uint8Array} spawngroupmanifest
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupmanifest = $util.newBuffer([]);
    
        /**
         * CNETMsg_SpawnGroup_Load flags.
         * @member {number} flags
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.flags = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.tickcount = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load manifestincomplete.
         * @member {boolean} manifestincomplete
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.manifestincomplete = false;
    
        /**
         * CNETMsg_SpawnGroup_Load localnamefixup.
         * @member {string} localnamefixup
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.localnamefixup = "";
    
        /**
         * CNETMsg_SpawnGroup_Load parentnamefixup.
         * @member {string} parentnamefixup
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.parentnamefixup = "";
    
        /**
         * CNETMsg_SpawnGroup_Load manifestloadpriority.
         * @member {number} manifestloadpriority
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.manifestloadpriority = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load worldgroupid.
         * @member {number} worldgroupid
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.worldgroupid = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load creationsequence.
         * @member {number} creationsequence
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.creationsequence = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load savegamefilename.
         * @member {string} savegamefilename
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.savegamefilename = "";
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupparenthandle.
         * @member {number} spawngroupparenthandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupparenthandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load leveltransition.
         * @member {boolean} leveltransition
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.leveltransition = false;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_Load instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load instance
         */
        CNETMsg_SpawnGroup_Load.create = function create(properties) {
            return new CNETMsg_SpawnGroup_Load(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Load message. Does not implicitly {@link CNETMsg_SpawnGroup_Load.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.worldname != null && Object.hasOwnProperty.call(message, "worldname"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.worldname);
            if (message.entitylumpname != null && Object.hasOwnProperty.call(message, "entitylumpname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.entitylumpname);
            if (message.entityfiltername != null && Object.hasOwnProperty.call(message, "entityfiltername"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.entityfiltername);
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.spawngrouphandle);
            if (message.spawngroupownerhandle != null && Object.hasOwnProperty.call(message, "spawngroupownerhandle"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.spawngroupownerhandle);
            if (message.world_offset_pos != null && Object.hasOwnProperty.call(message, "world_offset_pos"))
                $root.CMsgVector.encode(message.world_offset_pos, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.world_offset_angle != null && Object.hasOwnProperty.call(message, "world_offset_angle"))
                $root.CMsgQAngle.encode(message.world_offset_angle, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.spawngroupmanifest != null && Object.hasOwnProperty.call(message, "spawngroupmanifest"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.spawngroupmanifest);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.flags);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.tickcount);
            if (message.manifestincomplete != null && Object.hasOwnProperty.call(message, "manifestincomplete"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.manifestincomplete);
            if (message.localnamefixup != null && Object.hasOwnProperty.call(message, "localnamefixup"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.localnamefixup);
            if (message.parentnamefixup != null && Object.hasOwnProperty.call(message, "parentnamefixup"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.parentnamefixup);
            if (message.manifestloadpriority != null && Object.hasOwnProperty.call(message, "manifestloadpriority"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.manifestloadpriority);
            if (message.worldgroupid != null && Object.hasOwnProperty.call(message, "worldgroupid"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.worldgroupid);
            if (message.creationsequence != null && Object.hasOwnProperty.call(message, "creationsequence"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.creationsequence);
            if (message.savegamefilename != null && Object.hasOwnProperty.call(message, "savegamefilename"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.savegamefilename);
            if (message.spawngroupparenthandle != null && Object.hasOwnProperty.call(message, "spawngroupparenthandle"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.spawngroupparenthandle);
            if (message.leveltransition != null && Object.hasOwnProperty.call(message, "leveltransition"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.leveltransition);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Load message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_Load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Load message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_Load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.worldname = reader.string();
                    break;
                case 2:
                    message.entitylumpname = reader.string();
                    break;
                case 3:
                    message.entityfiltername = reader.string();
                    break;
                case 4:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case 5:
                    message.spawngroupownerhandle = reader.uint32();
                    break;
                case 6:
                    message.world_offset_pos = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.world_offset_angle = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.spawngroupmanifest = reader.bytes();
                    break;
                case 9:
                    message.flags = reader.uint32();
                    break;
                case 10:
                    message.tickcount = reader.int32();
                    break;
                case 11:
                    message.manifestincomplete = reader.bool();
                    break;
                case 12:
                    message.localnamefixup = reader.string();
                    break;
                case 13:
                    message.parentnamefixup = reader.string();
                    break;
                case 14:
                    message.manifestloadpriority = reader.int32();
                    break;
                case 15:
                    message.worldgroupid = reader.uint32();
                    break;
                case 16:
                    message.creationsequence = reader.uint32();
                    break;
                case 17:
                    message.savegamefilename = reader.string();
                    break;
                case 18:
                    message.spawngroupparenthandle = reader.uint32();
                    break;
                case 19:
                    message.leveltransition = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_Load message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_Load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.worldname != null && message.hasOwnProperty("worldname"))
                if (!$util.isString(message.worldname))
                    return "worldname: string expected";
            if (message.entitylumpname != null && message.hasOwnProperty("entitylumpname"))
                if (!$util.isString(message.entitylumpname))
                    return "entitylumpname: string expected";
            if (message.entityfiltername != null && message.hasOwnProperty("entityfiltername"))
                if (!$util.isString(message.entityfiltername))
                    return "entityfiltername: string expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.spawngroupownerhandle != null && message.hasOwnProperty("spawngroupownerhandle"))
                if (!$util.isInteger(message.spawngroupownerhandle))
                    return "spawngroupownerhandle: integer expected";
            if (message.world_offset_pos != null && message.hasOwnProperty("world_offset_pos")) {
                var error = $root.CMsgVector.verify(message.world_offset_pos);
                if (error)
                    return "world_offset_pos." + error;
            }
            if (message.world_offset_angle != null && message.hasOwnProperty("world_offset_angle")) {
                var error = $root.CMsgQAngle.verify(message.world_offset_angle);
                if (error)
                    return "world_offset_angle." + error;
            }
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                if (!(message.spawngroupmanifest && typeof message.spawngroupmanifest.length === "number" || $util.isString(message.spawngroupmanifest)))
                    return "spawngroupmanifest: buffer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                if (typeof message.manifestincomplete !== "boolean")
                    return "manifestincomplete: boolean expected";
            if (message.localnamefixup != null && message.hasOwnProperty("localnamefixup"))
                if (!$util.isString(message.localnamefixup))
                    return "localnamefixup: string expected";
            if (message.parentnamefixup != null && message.hasOwnProperty("parentnamefixup"))
                if (!$util.isString(message.parentnamefixup))
                    return "parentnamefixup: string expected";
            if (message.manifestloadpriority != null && message.hasOwnProperty("manifestloadpriority"))
                if (!$util.isInteger(message.manifestloadpriority))
                    return "manifestloadpriority: integer expected";
            if (message.worldgroupid != null && message.hasOwnProperty("worldgroupid"))
                if (!$util.isInteger(message.worldgroupid))
                    return "worldgroupid: integer expected";
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                if (!$util.isInteger(message.creationsequence))
                    return "creationsequence: integer expected";
            if (message.savegamefilename != null && message.hasOwnProperty("savegamefilename"))
                if (!$util.isString(message.savegamefilename))
                    return "savegamefilename: string expected";
            if (message.spawngroupparenthandle != null && message.hasOwnProperty("spawngroupparenthandle"))
                if (!$util.isInteger(message.spawngroupparenthandle))
                    return "spawngroupparenthandle: integer expected";
            if (message.leveltransition != null && message.hasOwnProperty("leveltransition"))
                if (typeof message.leveltransition !== "boolean")
                    return "leveltransition: boolean expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_Load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         */
        CNETMsg_SpawnGroup_Load.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_Load)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_Load();
            if (object.worldname != null)
                message.worldname = String(object.worldname);
            if (object.entitylumpname != null)
                message.entitylumpname = String(object.entitylumpname);
            if (object.entityfiltername != null)
                message.entityfiltername = String(object.entityfiltername);
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.spawngroupownerhandle != null)
                message.spawngroupownerhandle = object.spawngroupownerhandle >>> 0;
            if (object.world_offset_pos != null) {
                if (typeof object.world_offset_pos !== "object")
                    throw TypeError(".CNETMsg_SpawnGroup_Load.world_offset_pos: object expected");
                message.world_offset_pos = $root.CMsgVector.fromObject(object.world_offset_pos);
            }
            if (object.world_offset_angle != null) {
                if (typeof object.world_offset_angle !== "object")
                    throw TypeError(".CNETMsg_SpawnGroup_Load.world_offset_angle: object expected");
                message.world_offset_angle = $root.CMsgQAngle.fromObject(object.world_offset_angle);
            }
            if (object.spawngroupmanifest != null)
                if (typeof object.spawngroupmanifest === "string")
                    $util.base64.decode(object.spawngroupmanifest, message.spawngroupmanifest = $util.newBuffer($util.base64.length(object.spawngroupmanifest)), 0);
                else if (object.spawngroupmanifest.length)
                    message.spawngroupmanifest = object.spawngroupmanifest;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            if (object.manifestincomplete != null)
                message.manifestincomplete = Boolean(object.manifestincomplete);
            if (object.localnamefixup != null)
                message.localnamefixup = String(object.localnamefixup);
            if (object.parentnamefixup != null)
                message.parentnamefixup = String(object.parentnamefixup);
            if (object.manifestloadpriority != null)
                message.manifestloadpriority = object.manifestloadpriority | 0;
            if (object.worldgroupid != null)
                message.worldgroupid = object.worldgroupid >>> 0;
            if (object.creationsequence != null)
                message.creationsequence = object.creationsequence >>> 0;
            if (object.savegamefilename != null)
                message.savegamefilename = String(object.savegamefilename);
            if (object.spawngroupparenthandle != null)
                message.spawngroupparenthandle = object.spawngroupparenthandle >>> 0;
            if (object.leveltransition != null)
                message.leveltransition = Boolean(object.leveltransition);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_Load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {CNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_Load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.worldname = "";
                object.entitylumpname = "";
                object.entityfiltername = "";
                object.spawngrouphandle = 0;
                object.spawngroupownerhandle = 0;
                object.world_offset_pos = null;
                object.world_offset_angle = null;
                if (options.bytes === String)
                    object.spawngroupmanifest = "";
                else {
                    object.spawngroupmanifest = [];
                    if (options.bytes !== Array)
                        object.spawngroupmanifest = $util.newBuffer(object.spawngroupmanifest);
                }
                object.flags = 0;
                object.tickcount = 0;
                object.manifestincomplete = false;
                object.localnamefixup = "";
                object.parentnamefixup = "";
                object.manifestloadpriority = 0;
                object.worldgroupid = 0;
                object.creationsequence = 0;
                object.savegamefilename = "";
                object.spawngroupparenthandle = 0;
                object.leveltransition = false;
            }
            if (message.worldname != null && message.hasOwnProperty("worldname"))
                object.worldname = message.worldname;
            if (message.entitylumpname != null && message.hasOwnProperty("entitylumpname"))
                object.entitylumpname = message.entitylumpname;
            if (message.entityfiltername != null && message.hasOwnProperty("entityfiltername"))
                object.entityfiltername = message.entityfiltername;
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.spawngroupownerhandle != null && message.hasOwnProperty("spawngroupownerhandle"))
                object.spawngroupownerhandle = message.spawngroupownerhandle;
            if (message.world_offset_pos != null && message.hasOwnProperty("world_offset_pos"))
                object.world_offset_pos = $root.CMsgVector.toObject(message.world_offset_pos, options);
            if (message.world_offset_angle != null && message.hasOwnProperty("world_offset_angle"))
                object.world_offset_angle = $root.CMsgQAngle.toObject(message.world_offset_angle, options);
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                object.spawngroupmanifest = options.bytes === String ? $util.base64.encode(message.spawngroupmanifest, 0, message.spawngroupmanifest.length) : options.bytes === Array ? Array.prototype.slice.call(message.spawngroupmanifest) : message.spawngroupmanifest;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                object.manifestincomplete = message.manifestincomplete;
            if (message.localnamefixup != null && message.hasOwnProperty("localnamefixup"))
                object.localnamefixup = message.localnamefixup;
            if (message.parentnamefixup != null && message.hasOwnProperty("parentnamefixup"))
                object.parentnamefixup = message.parentnamefixup;
            if (message.manifestloadpriority != null && message.hasOwnProperty("manifestloadpriority"))
                object.manifestloadpriority = message.manifestloadpriority;
            if (message.worldgroupid != null && message.hasOwnProperty("worldgroupid"))
                object.worldgroupid = message.worldgroupid;
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                object.creationsequence = message.creationsequence;
            if (message.savegamefilename != null && message.hasOwnProperty("savegamefilename"))
                object.savegamefilename = message.savegamefilename;
            if (message.spawngroupparenthandle != null && message.hasOwnProperty("spawngroupparenthandle"))
                object.spawngroupparenthandle = message.spawngroupparenthandle;
            if (message.leveltransition != null && message.hasOwnProperty("leveltransition"))
                object.leveltransition = message.leveltransition;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_Load to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_Load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_Load;
    })();
    
    $root.CNETMsg_SpawnGroup_ManifestUpdate = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_ManifestUpdate.
         * @exports ICNETMsg_SpawnGroup_ManifestUpdate
         * @interface ICNETMsg_SpawnGroup_ManifestUpdate
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_ManifestUpdate spawngrouphandle
         * @property {Uint8Array|null} [spawngroupmanifest] CNETMsg_SpawnGroup_ManifestUpdate spawngroupmanifest
         * @property {boolean|null} [manifestincomplete] CNETMsg_SpawnGroup_ManifestUpdate manifestincomplete
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_ManifestUpdate.
         * @exports CNETMsg_SpawnGroup_ManifestUpdate
         * @classdesc Represents a CNETMsg_SpawnGroup_ManifestUpdate.
         * @implements ICNETMsg_SpawnGroup_ManifestUpdate
         * @constructor
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_ManifestUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate spawngroupmanifest.
         * @member {Uint8Array} spawngroupmanifest
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.spawngroupmanifest = $util.newBuffer([]);
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate manifestincomplete.
         * @member {boolean} manifestincomplete
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.manifestincomplete = false;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_ManifestUpdate instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.create = function create(properties) {
            return new CNETMsg_SpawnGroup_ManifestUpdate(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_ManifestUpdate message. Does not implicitly {@link CNETMsg_SpawnGroup_ManifestUpdate.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_ManifestUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.spawngroupmanifest != null && Object.hasOwnProperty.call(message, "spawngroupmanifest"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.spawngroupmanifest);
            if (message.manifestincomplete != null && Object.hasOwnProperty.call(message, "manifestincomplete"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.manifestincomplete);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_ManifestUpdate message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_ManifestUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_ManifestUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_ManifestUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_ManifestUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_ManifestUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case 2:
                    message.spawngroupmanifest = reader.bytes();
                    break;
                case 3:
                    message.manifestincomplete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_ManifestUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_ManifestUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_ManifestUpdate message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_ManifestUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                if (!(message.spawngroupmanifest && typeof message.spawngroupmanifest.length === "number" || $util.isString(message.spawngroupmanifest)))
                    return "spawngroupmanifest: buffer expected";
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                if (typeof message.manifestincomplete !== "boolean")
                    return "manifestincomplete: boolean expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_ManifestUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         */
        CNETMsg_SpawnGroup_ManifestUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_ManifestUpdate)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_ManifestUpdate();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.spawngroupmanifest != null)
                if (typeof object.spawngroupmanifest === "string")
                    $util.base64.decode(object.spawngroupmanifest, message.spawngroupmanifest = $util.newBuffer($util.base64.length(object.spawngroupmanifest)), 0);
                else if (object.spawngroupmanifest.length)
                    message.spawngroupmanifest = object.spawngroupmanifest;
            if (object.manifestincomplete != null)
                message.manifestincomplete = Boolean(object.manifestincomplete);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_ManifestUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {CNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_ManifestUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                if (options.bytes === String)
                    object.spawngroupmanifest = "";
                else {
                    object.spawngroupmanifest = [];
                    if (options.bytes !== Array)
                        object.spawngroupmanifest = $util.newBuffer(object.spawngroupmanifest);
                }
                object.manifestincomplete = false;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                object.spawngroupmanifest = options.bytes === String ? $util.base64.encode(message.spawngroupmanifest, 0, message.spawngroupmanifest.length) : options.bytes === Array ? Array.prototype.slice.call(message.spawngroupmanifest) : message.spawngroupmanifest;
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                object.manifestincomplete = message.manifestincomplete;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_ManifestUpdate to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_ManifestUpdate;
    })();
    
    $root.CNETMsg_SpawnGroup_SetCreationTick = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_SetCreationTick.
         * @exports ICNETMsg_SpawnGroup_SetCreationTick
         * @interface ICNETMsg_SpawnGroup_SetCreationTick
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_SetCreationTick spawngrouphandle
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_SetCreationTick tickcount
         * @property {number|null} [creationsequence] CNETMsg_SpawnGroup_SetCreationTick creationsequence
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_SetCreationTick.
         * @exports CNETMsg_SpawnGroup_SetCreationTick
         * @classdesc Represents a CNETMsg_SpawnGroup_SetCreationTick.
         * @implements ICNETMsg_SpawnGroup_SetCreationTick
         * @constructor
         * @param {ICNETMsg_SpawnGroup_SetCreationTick=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_SetCreationTick(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.tickcount = 0;
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick creationsequence.
         * @member {number} creationsequence
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.creationsequence = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_SetCreationTick instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.create = function create(properties) {
            return new CNETMsg_SpawnGroup_SetCreationTick(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_SetCreationTick message. Does not implicitly {@link CNETMsg_SpawnGroup_SetCreationTick.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_SetCreationTick.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tickcount);
            if (message.creationsequence != null && Object.hasOwnProperty.call(message, "creationsequence"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.creationsequence);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_SetCreationTick message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_SetCreationTick.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_SetCreationTick.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_SetCreationTick message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_SetCreationTick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_SetCreationTick();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case 2:
                    message.tickcount = reader.int32();
                    break;
                case 3:
                    message.creationsequence = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_SetCreationTick message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_SetCreationTick.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_SetCreationTick message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_SetCreationTick.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                if (!$util.isInteger(message.creationsequence))
                    return "creationsequence: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_SetCreationTick message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         */
        CNETMsg_SpawnGroup_SetCreationTick.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_SetCreationTick)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_SetCreationTick();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            if (object.creationsequence != null)
                message.creationsequence = object.creationsequence >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_SetCreationTick message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {CNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_SetCreationTick.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                object.tickcount = 0;
                object.creationsequence = 0;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                object.creationsequence = message.creationsequence;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_SetCreationTick to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_SetCreationTick;
    })();
    
    $root.CNETMsg_SpawnGroup_Unload = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_Unload.
         * @exports ICNETMsg_SpawnGroup_Unload
         * @interface ICNETMsg_SpawnGroup_Unload
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_Unload spawngrouphandle
         * @property {number|null} [flags] CNETMsg_SpawnGroup_Unload flags
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_Unload tickcount
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_Unload.
         * @exports CNETMsg_SpawnGroup_Unload
         * @classdesc Represents a CNETMsg_SpawnGroup_Unload.
         * @implements ICNETMsg_SpawnGroup_Unload
         * @constructor
         * @param {ICNETMsg_SpawnGroup_Unload=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_Unload(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_Unload spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Unload flags.
         * @member {number} flags
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.flags = 0;
    
        /**
         * CNETMsg_SpawnGroup_Unload tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.tickcount = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_Unload instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload instance
         */
        CNETMsg_SpawnGroup_Unload.create = function create(properties) {
            return new CNETMsg_SpawnGroup_Unload(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Unload message. Does not implicitly {@link CNETMsg_SpawnGroup_Unload.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Unload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.flags);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tickcount);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Unload message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_Unload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Unload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Unload message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Unload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_Unload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case 2:
                    message.flags = reader.uint32();
                    break;
                case 3:
                    message.tickcount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Unload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Unload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_Unload message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_Unload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_Unload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         */
        CNETMsg_SpawnGroup_Unload.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_Unload)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_Unload();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_Unload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {CNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_Unload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                object.flags = 0;
                object.tickcount = 0;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_Unload to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_Unload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_Unload;
    })();
    
    $root.CNETMsg_SpawnGroup_LoadCompleted = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_LoadCompleted.
         * @exports ICNETMsg_SpawnGroup_LoadCompleted
         * @interface ICNETMsg_SpawnGroup_LoadCompleted
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_LoadCompleted spawngrouphandle
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_LoadCompleted.
         * @exports CNETMsg_SpawnGroup_LoadCompleted
         * @classdesc Represents a CNETMsg_SpawnGroup_LoadCompleted.
         * @implements ICNETMsg_SpawnGroup_LoadCompleted
         * @constructor
         * @param {ICNETMsg_SpawnGroup_LoadCompleted=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_LoadCompleted(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_LoadCompleted spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @instance
         */
        CNETMsg_SpawnGroup_LoadCompleted.prototype.spawngrouphandle = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_LoadCompleted instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted instance
         */
        CNETMsg_SpawnGroup_LoadCompleted.create = function create(properties) {
            return new CNETMsg_SpawnGroup_LoadCompleted(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_LoadCompleted message. Does not implicitly {@link CNETMsg_SpawnGroup_LoadCompleted.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_LoadCompleted.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_LoadCompleted message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_LoadCompleted.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_LoadCompleted.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_LoadCompleted message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_LoadCompleted.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_LoadCompleted();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_LoadCompleted message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_LoadCompleted.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_LoadCompleted message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_LoadCompleted.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_LoadCompleted message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         */
        CNETMsg_SpawnGroup_LoadCompleted.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_LoadCompleted)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_LoadCompleted();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_LoadCompleted message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {CNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_LoadCompleted.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.spawngrouphandle = 0;
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_LoadCompleted to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_LoadCompleted.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_LoadCompleted;
    })();
    
    $root.CSVCMsg_GameSessionConfiguration = (function() {
    
        /**
         * Properties of a CSVCMsg_GameSessionConfiguration.
         * @exports ICSVCMsg_GameSessionConfiguration
         * @interface ICSVCMsg_GameSessionConfiguration
         * @property {boolean|null} [is_multiplayer] CSVCMsg_GameSessionConfiguration is_multiplayer
         * @property {boolean|null} [is_loadsavegame] CSVCMsg_GameSessionConfiguration is_loadsavegame
         * @property {boolean|null} [is_background_map] CSVCMsg_GameSessionConfiguration is_background_map
         * @property {boolean|null} [is_headless] CSVCMsg_GameSessionConfiguration is_headless
         * @property {number|null} [min_client_limit] CSVCMsg_GameSessionConfiguration min_client_limit
         * @property {number|null} [max_client_limit] CSVCMsg_GameSessionConfiguration max_client_limit
         * @property {number|null} [max_clients] CSVCMsg_GameSessionConfiguration max_clients
         * @property {number|null} [tick_interval] CSVCMsg_GameSessionConfiguration tick_interval
         * @property {string|null} [hostname] CSVCMsg_GameSessionConfiguration hostname
         * @property {string|null} [savegamename] CSVCMsg_GameSessionConfiguration savegamename
         * @property {string|null} [s1_mapname] CSVCMsg_GameSessionConfiguration s1_mapname
         * @property {string|null} [gamemode] CSVCMsg_GameSessionConfiguration gamemode
         * @property {string|null} [server_ip_address] CSVCMsg_GameSessionConfiguration server_ip_address
         * @property {Uint8Array|null} [data] CSVCMsg_GameSessionConfiguration data
         * @property {boolean|null} [is_localonly] CSVCMsg_GameSessionConfiguration is_localonly
         * @property {boolean|null} [no_steam_server] CSVCMsg_GameSessionConfiguration no_steam_server
         * @property {boolean|null} [is_transition] CSVCMsg_GameSessionConfiguration is_transition
         * @property {string|null} [previouslevel] CSVCMsg_GameSessionConfiguration previouslevel
         * @property {string|null} [landmarkname] CSVCMsg_GameSessionConfiguration landmarkname
         */
    
        /**
         * Constructs a new CSVCMsg_GameSessionConfiguration.
         * @exports CSVCMsg_GameSessionConfiguration
         * @classdesc Represents a CSVCMsg_GameSessionConfiguration.
         * @implements ICSVCMsg_GameSessionConfiguration
         * @constructor
         * @param {ICSVCMsg_GameSessionConfiguration=} [properties] Properties to set
         */
        function CSVCMsg_GameSessionConfiguration(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GameSessionConfiguration is_multiplayer.
         * @member {boolean} is_multiplayer
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_multiplayer = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration is_loadsavegame.
         * @member {boolean} is_loadsavegame
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_loadsavegame = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration is_background_map.
         * @member {boolean} is_background_map
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_background_map = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration is_headless.
         * @member {boolean} is_headless
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_headless = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration min_client_limit.
         * @member {number} min_client_limit
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.min_client_limit = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration max_client_limit.
         * @member {number} max_client_limit
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.max_client_limit = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration max_clients.
         * @member {number} max_clients
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.max_clients = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration tick_interval.
         * @member {number} tick_interval
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.tick_interval = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration hostname.
         * @member {string} hostname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.hostname = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration savegamename.
         * @member {string} savegamename
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.savegamename = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration s1_mapname.
         * @member {string} s1_mapname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.s1_mapname = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration gamemode.
         * @member {string} gamemode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.gamemode = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration server_ip_address.
         * @member {string} server_ip_address
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.server_ip_address = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration data.
         * @member {Uint8Array} data
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.data = $util.newBuffer([]);
    
        /**
         * CSVCMsg_GameSessionConfiguration is_localonly.
         * @member {boolean} is_localonly
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_localonly = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration no_steam_server.
         * @member {boolean} no_steam_server
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.no_steam_server = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration is_transition.
         * @member {boolean} is_transition
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_transition = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration previouslevel.
         * @member {string} previouslevel
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.previouslevel = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration landmarkname.
         * @member {string} landmarkname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.landmarkname = "";
    
        /**
         * Creates a new CSVCMsg_GameSessionConfiguration instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration=} [properties] Properties to set
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration instance
         */
        CSVCMsg_GameSessionConfiguration.create = function create(properties) {
            return new CSVCMsg_GameSessionConfiguration(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GameSessionConfiguration message. Does not implicitly {@link CSVCMsg_GameSessionConfiguration.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameSessionConfiguration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.is_multiplayer != null && Object.hasOwnProperty.call(message, "is_multiplayer"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.is_multiplayer);
            if (message.is_loadsavegame != null && Object.hasOwnProperty.call(message, "is_loadsavegame"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_loadsavegame);
            if (message.is_background_map != null && Object.hasOwnProperty.call(message, "is_background_map"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.is_background_map);
            if (message.is_headless != null && Object.hasOwnProperty.call(message, "is_headless"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.is_headless);
            if (message.min_client_limit != null && Object.hasOwnProperty.call(message, "min_client_limit"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.min_client_limit);
            if (message.max_client_limit != null && Object.hasOwnProperty.call(message, "max_client_limit"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.max_client_limit);
            if (message.max_clients != null && Object.hasOwnProperty.call(message, "max_clients"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.max_clients);
            if (message.tick_interval != null && Object.hasOwnProperty.call(message, "tick_interval"))
                writer.uint32(/* id 8, wireType 5 =*/69).fixed32(message.tick_interval);
            if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.hostname);
            if (message.savegamename != null && Object.hasOwnProperty.call(message, "savegamename"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.savegamename);
            if (message.s1_mapname != null && Object.hasOwnProperty.call(message, "s1_mapname"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.s1_mapname);
            if (message.gamemode != null && Object.hasOwnProperty.call(message, "gamemode"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.gamemode);
            if (message.server_ip_address != null && Object.hasOwnProperty.call(message, "server_ip_address"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.server_ip_address);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.data);
            if (message.is_localonly != null && Object.hasOwnProperty.call(message, "is_localonly"))
                writer.uint32(/* id 15, wireType 0 =*/120).bool(message.is_localonly);
            if (message.is_transition != null && Object.hasOwnProperty.call(message, "is_transition"))
                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.is_transition);
            if (message.previouslevel != null && Object.hasOwnProperty.call(message, "previouslevel"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.previouslevel);
            if (message.landmarkname != null && Object.hasOwnProperty.call(message, "landmarkname"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.landmarkname);
            if (message.no_steam_server != null && Object.hasOwnProperty.call(message, "no_steam_server"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.no_steam_server);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GameSessionConfiguration message, length delimited. Does not implicitly {@link CSVCMsg_GameSessionConfiguration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameSessionConfiguration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GameSessionConfiguration message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameSessionConfiguration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameSessionConfiguration();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.is_multiplayer = reader.bool();
                    break;
                case 2:
                    message.is_loadsavegame = reader.bool();
                    break;
                case 3:
                    message.is_background_map = reader.bool();
                    break;
                case 4:
                    message.is_headless = reader.bool();
                    break;
                case 5:
                    message.min_client_limit = reader.uint32();
                    break;
                case 6:
                    message.max_client_limit = reader.uint32();
                    break;
                case 7:
                    message.max_clients = reader.uint32();
                    break;
                case 8:
                    message.tick_interval = reader.fixed32();
                    break;
                case 9:
                    message.hostname = reader.string();
                    break;
                case 10:
                    message.savegamename = reader.string();
                    break;
                case 11:
                    message.s1_mapname = reader.string();
                    break;
                case 12:
                    message.gamemode = reader.string();
                    break;
                case 13:
                    message.server_ip_address = reader.string();
                    break;
                case 14:
                    message.data = reader.bytes();
                    break;
                case 15:
                    message.is_localonly = reader.bool();
                    break;
                case 19:
                    message.no_steam_server = reader.bool();
                    break;
                case 16:
                    message.is_transition = reader.bool();
                    break;
                case 17:
                    message.previouslevel = reader.string();
                    break;
                case 18:
                    message.landmarkname = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GameSessionConfiguration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameSessionConfiguration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GameSessionConfiguration message.
         * @function verify
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GameSessionConfiguration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.is_multiplayer != null && message.hasOwnProperty("is_multiplayer"))
                if (typeof message.is_multiplayer !== "boolean")
                    return "is_multiplayer: boolean expected";
            if (message.is_loadsavegame != null && message.hasOwnProperty("is_loadsavegame"))
                if (typeof message.is_loadsavegame !== "boolean")
                    return "is_loadsavegame: boolean expected";
            if (message.is_background_map != null && message.hasOwnProperty("is_background_map"))
                if (typeof message.is_background_map !== "boolean")
                    return "is_background_map: boolean expected";
            if (message.is_headless != null && message.hasOwnProperty("is_headless"))
                if (typeof message.is_headless !== "boolean")
                    return "is_headless: boolean expected";
            if (message.min_client_limit != null && message.hasOwnProperty("min_client_limit"))
                if (!$util.isInteger(message.min_client_limit))
                    return "min_client_limit: integer expected";
            if (message.max_client_limit != null && message.hasOwnProperty("max_client_limit"))
                if (!$util.isInteger(message.max_client_limit))
                    return "max_client_limit: integer expected";
            if (message.max_clients != null && message.hasOwnProperty("max_clients"))
                if (!$util.isInteger(message.max_clients))
                    return "max_clients: integer expected";
            if (message.tick_interval != null && message.hasOwnProperty("tick_interval"))
                if (!$util.isInteger(message.tick_interval))
                    return "tick_interval: integer expected";
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                if (!$util.isString(message.hostname))
                    return "hostname: string expected";
            if (message.savegamename != null && message.hasOwnProperty("savegamename"))
                if (!$util.isString(message.savegamename))
                    return "savegamename: string expected";
            if (message.s1_mapname != null && message.hasOwnProperty("s1_mapname"))
                if (!$util.isString(message.s1_mapname))
                    return "s1_mapname: string expected";
            if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                if (!$util.isString(message.gamemode))
                    return "gamemode: string expected";
            if (message.server_ip_address != null && message.hasOwnProperty("server_ip_address"))
                if (!$util.isString(message.server_ip_address))
                    return "server_ip_address: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.is_localonly != null && message.hasOwnProperty("is_localonly"))
                if (typeof message.is_localonly !== "boolean")
                    return "is_localonly: boolean expected";
            if (message.no_steam_server != null && message.hasOwnProperty("no_steam_server"))
                if (typeof message.no_steam_server !== "boolean")
                    return "no_steam_server: boolean expected";
            if (message.is_transition != null && message.hasOwnProperty("is_transition"))
                if (typeof message.is_transition !== "boolean")
                    return "is_transition: boolean expected";
            if (message.previouslevel != null && message.hasOwnProperty("previouslevel"))
                if (!$util.isString(message.previouslevel))
                    return "previouslevel: string expected";
            if (message.landmarkname != null && message.hasOwnProperty("landmarkname"))
                if (!$util.isString(message.landmarkname))
                    return "landmarkname: string expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GameSessionConfiguration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         */
        CSVCMsg_GameSessionConfiguration.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GameSessionConfiguration)
                return object;
            var message = new $root.CSVCMsg_GameSessionConfiguration();
            if (object.is_multiplayer != null)
                message.is_multiplayer = Boolean(object.is_multiplayer);
            if (object.is_loadsavegame != null)
                message.is_loadsavegame = Boolean(object.is_loadsavegame);
            if (object.is_background_map != null)
                message.is_background_map = Boolean(object.is_background_map);
            if (object.is_headless != null)
                message.is_headless = Boolean(object.is_headless);
            if (object.min_client_limit != null)
                message.min_client_limit = object.min_client_limit >>> 0;
            if (object.max_client_limit != null)
                message.max_client_limit = object.max_client_limit >>> 0;
            if (object.max_clients != null)
                message.max_clients = object.max_clients >>> 0;
            if (object.tick_interval != null)
                message.tick_interval = object.tick_interval >>> 0;
            if (object.hostname != null)
                message.hostname = String(object.hostname);
            if (object.savegamename != null)
                message.savegamename = String(object.savegamename);
            if (object.s1_mapname != null)
                message.s1_mapname = String(object.s1_mapname);
            if (object.gamemode != null)
                message.gamemode = String(object.gamemode);
            if (object.server_ip_address != null)
                message.server_ip_address = String(object.server_ip_address);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.is_localonly != null)
                message.is_localonly = Boolean(object.is_localonly);
            if (object.no_steam_server != null)
                message.no_steam_server = Boolean(object.no_steam_server);
            if (object.is_transition != null)
                message.is_transition = Boolean(object.is_transition);
            if (object.previouslevel != null)
                message.previouslevel = String(object.previouslevel);
            if (object.landmarkname != null)
                message.landmarkname = String(object.landmarkname);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GameSessionConfiguration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {CSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GameSessionConfiguration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.is_multiplayer = false;
                object.is_loadsavegame = false;
                object.is_background_map = false;
                object.is_headless = false;
                object.min_client_limit = 0;
                object.max_client_limit = 0;
                object.max_clients = 0;
                object.tick_interval = 0;
                object.hostname = "";
                object.savegamename = "";
                object.s1_mapname = "";
                object.gamemode = "";
                object.server_ip_address = "";
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                object.is_localonly = false;
                object.is_transition = false;
                object.previouslevel = "";
                object.landmarkname = "";
                object.no_steam_server = false;
            }
            if (message.is_multiplayer != null && message.hasOwnProperty("is_multiplayer"))
                object.is_multiplayer = message.is_multiplayer;
            if (message.is_loadsavegame != null && message.hasOwnProperty("is_loadsavegame"))
                object.is_loadsavegame = message.is_loadsavegame;
            if (message.is_background_map != null && message.hasOwnProperty("is_background_map"))
                object.is_background_map = message.is_background_map;
            if (message.is_headless != null && message.hasOwnProperty("is_headless"))
                object.is_headless = message.is_headless;
            if (message.min_client_limit != null && message.hasOwnProperty("min_client_limit"))
                object.min_client_limit = message.min_client_limit;
            if (message.max_client_limit != null && message.hasOwnProperty("max_client_limit"))
                object.max_client_limit = message.max_client_limit;
            if (message.max_clients != null && message.hasOwnProperty("max_clients"))
                object.max_clients = message.max_clients;
            if (message.tick_interval != null && message.hasOwnProperty("tick_interval"))
                object.tick_interval = message.tick_interval;
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                object.hostname = message.hostname;
            if (message.savegamename != null && message.hasOwnProperty("savegamename"))
                object.savegamename = message.savegamename;
            if (message.s1_mapname != null && message.hasOwnProperty("s1_mapname"))
                object.s1_mapname = message.s1_mapname;
            if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                object.gamemode = message.gamemode;
            if (message.server_ip_address != null && message.hasOwnProperty("server_ip_address"))
                object.server_ip_address = message.server_ip_address;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.is_localonly != null && message.hasOwnProperty("is_localonly"))
                object.is_localonly = message.is_localonly;
            if (message.is_transition != null && message.hasOwnProperty("is_transition"))
                object.is_transition = message.is_transition;
            if (message.previouslevel != null && message.hasOwnProperty("previouslevel"))
                object.previouslevel = message.previouslevel;
            if (message.landmarkname != null && message.hasOwnProperty("landmarkname"))
                object.landmarkname = message.landmarkname;
            if (message.no_steam_server != null && message.hasOwnProperty("no_steam_server"))
                object.no_steam_server = message.no_steam_server;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GameSessionConfiguration to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GameSessionConfiguration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_GameSessionConfiguration;
    })();
    
    /**
     * ENetworkDisconnectionReason enum.
     * @exports ENetworkDisconnectionReason
     * @enum {number}
     * @property {number} NETWORK_DISCONNECT_INVALID=0 NETWORK_DISCONNECT_INVALID value
     * @property {number} NETWORK_DISCONNECT_SHUTDOWN=1 NETWORK_DISCONNECT_SHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_DISCONNECT_BY_USER=2 NETWORK_DISCONNECT_DISCONNECT_BY_USER value
     * @property {number} NETWORK_DISCONNECT_DISCONNECT_BY_SERVER=3 NETWORK_DISCONNECT_DISCONNECT_BY_SERVER value
     * @property {number} NETWORK_DISCONNECT_LOST=4 NETWORK_DISCONNECT_LOST value
     * @property {number} NETWORK_DISCONNECT_OVERFLOW=5 NETWORK_DISCONNECT_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_STEAM_BANNED=6 NETWORK_DISCONNECT_STEAM_BANNED value
     * @property {number} NETWORK_DISCONNECT_STEAM_INUSE=7 NETWORK_DISCONNECT_STEAM_INUSE value
     * @property {number} NETWORK_DISCONNECT_STEAM_TICKET=8 NETWORK_DISCONNECT_STEAM_TICKET value
     * @property {number} NETWORK_DISCONNECT_STEAM_LOGON=9 NETWORK_DISCONNECT_STEAM_LOGON value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHCANCELLED=10 NETWORK_DISCONNECT_STEAM_AUTHCANCELLED value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED=11 NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHINVALID=12 NETWORK_DISCONNECT_STEAM_AUTHINVALID value
     * @property {number} NETWORK_DISCONNECT_STEAM_VACBANSTATE=13 NETWORK_DISCONNECT_STEAM_VACBANSTATE value
     * @property {number} NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE=14 NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE value
     * @property {number} NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT=15 NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_STEAM_DROPPED=16 NETWORK_DISCONNECT_STEAM_DROPPED value
     * @property {number} NETWORK_DISCONNECT_STEAM_OWNERSHIP=17 NETWORK_DISCONNECT_STEAM_OWNERSHIP value
     * @property {number} NETWORK_DISCONNECT_SERVERINFO_OVERFLOW=18 NETWORK_DISCONNECT_SERVERINFO_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_TICKMSG_OVERFLOW=19 NETWORK_DISCONNECT_TICKMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW=20 NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW=21 NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW=22 NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW=23 NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SNAPSHOTOVERFLOW=24 NETWORK_DISCONNECT_SNAPSHOTOVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SNAPSHOTERROR=25 NETWORK_DISCONNECT_SNAPSHOTERROR value
     * @property {number} NETWORK_DISCONNECT_RELIABLEOVERFLOW=26 NETWORK_DISCONNECT_RELIABLEOVERFLOW value
     * @property {number} NETWORK_DISCONNECT_BADDELTATICK=27 NETWORK_DISCONNECT_BADDELTATICK value
     * @property {number} NETWORK_DISCONNECT_NOMORESPLITS=28 NETWORK_DISCONNECT_NOMORESPLITS value
     * @property {number} NETWORK_DISCONNECT_TIMEDOUT=29 NETWORK_DISCONNECT_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_DISCONNECTED=30 NETWORK_DISCONNECT_DISCONNECTED value
     * @property {number} NETWORK_DISCONNECT_LEAVINGSPLIT=31 NETWORK_DISCONNECT_LEAVINGSPLIT value
     * @property {number} NETWORK_DISCONNECT_DIFFERENTCLASSTABLES=32 NETWORK_DISCONNECT_DIFFERENTCLASSTABLES value
     * @property {number} NETWORK_DISCONNECT_BADRELAYPASSWORD=33 NETWORK_DISCONNECT_BADRELAYPASSWORD value
     * @property {number} NETWORK_DISCONNECT_BADSPECTATORPASSWORD=34 NETWORK_DISCONNECT_BADSPECTATORPASSWORD value
     * @property {number} NETWORK_DISCONNECT_HLTVRESTRICTED=35 NETWORK_DISCONNECT_HLTVRESTRICTED value
     * @property {number} NETWORK_DISCONNECT_NOSPECTATORS=36 NETWORK_DISCONNECT_NOSPECTATORS value
     * @property {number} NETWORK_DISCONNECT_HLTVUNAVAILABLE=37 NETWORK_DISCONNECT_HLTVUNAVAILABLE value
     * @property {number} NETWORK_DISCONNECT_HLTVSTOP=38 NETWORK_DISCONNECT_HLTVSTOP value
     * @property {number} NETWORK_DISCONNECT_KICKED=39 NETWORK_DISCONNECT_KICKED value
     * @property {number} NETWORK_DISCONNECT_BANADDED=40 NETWORK_DISCONNECT_BANADDED value
     * @property {number} NETWORK_DISCONNECT_KICKBANADDED=41 NETWORK_DISCONNECT_KICKBANADDED value
     * @property {number} NETWORK_DISCONNECT_HLTVDIRECT=42 NETWORK_DISCONNECT_HLTVDIRECT value
     * @property {number} NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA=43 NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA value
     * @property {number} NETWORK_DISCONNECT_PURESERVER_MISMATCH=44 NETWORK_DISCONNECT_PURESERVER_MISMATCH value
     * @property {number} NETWORK_DISCONNECT_USERCMD=45 NETWORK_DISCONNECT_USERCMD value
     * @property {number} NETWORK_DISCONNECT_REJECTED_BY_GAME=46 NETWORK_DISCONNECT_REJECTED_BY_GAME value
     * @property {number} NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR=47 NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR value
     * @property {number} NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR=48 NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR value
     * @property {number} NETWORK_DISCONNECT_BAD_SERVER_PASSWORD=49 NETWORK_DISCONNECT_BAD_SERVER_PASSWORD value
     * @property {number} NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION=50 NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION value
     * @property {number} NETWORK_DISCONNECT_CONNECTION_FAILURE=51 NETWORK_DISCONNECT_CONNECTION_FAILURE value
     * @property {number} NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS=52 NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS value
     * @property {number} NETWORK_DISCONNECT_RECONNECTION=53 NETWORK_DISCONNECT_RECONNECTION value
     * @property {number} NETWORK_DISCONNECT_LOOPSHUTDOWN=54 NETWORK_DISCONNECT_LOOPSHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_LOOPDEACTIVATE=55 NETWORK_DISCONNECT_LOOPDEACTIVATE value
     * @property {number} NETWORK_DISCONNECT_HOST_ENDGAME=56 NETWORK_DISCONNECT_HOST_ENDGAME value
     * @property {number} NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE=57 NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE value
     * @property {number} NETWORK_DISCONNECT_CREATE_SERVER_FAILED=58 NETWORK_DISCONNECT_CREATE_SERVER_FAILED value
     * @property {number} NETWORK_DISCONNECT_EXITING=59 NETWORK_DISCONNECT_EXITING value
     * @property {number} NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE=60 NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE value
     * @property {number} NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY=61 NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY value
     * @property {number} NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL=62 NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL value
     * @property {number} NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP=63 NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP value
     * @property {number} NETWORK_DISCONNECT_CLIENT_NO_MAP=64 NETWORK_DISCONNECT_CLIENT_NO_MAP value
     * @property {number} NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP=65 NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP value
     * @property {number} NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM=66 NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM value
     * @property {number} NETWORK_DISCONNECT_STEAM_DENY_MISC=67 NETWORK_DISCONNECT_STEAM_DENY_MISC value
     * @property {number} NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT=68 NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT value
     * @property {number} NETWORK_DISCONNECT_SERVER_SHUTDOWN=69 NETWORK_DISCONNECT_SERVER_SHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_SPLITPACKET_SEND_OVERFLOW=70 NETWORK_DISCONNECT_SPLITPACKET_SEND_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE=71 NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE value
     * @property {number} NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT=72 NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_SERVER_INCOMPATIBLE=73 NETWORK_DISCONNECT_SERVER_INCOMPATIBLE value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS=74 NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY=75 NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG=76 NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_OTHER=77 NETWORK_DISCONNECT_LOCALPROBLEM_OTHER value
     * @property {number} NETWORK_DISCONNECT_REMOTE_TIMEOUT=79 NETWORK_DISCONNECT_REMOTE_TIMEOUT value
     * @property {number} NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING=80 NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING value
     * @property {number} NETWORK_DISCONNECT_REMOTE_OTHER=81 NETWORK_DISCONNECT_REMOTE_OTHER value
     * @property {number} NETWORK_DISCONNECT_REMOTE_BADCRYPT=82 NETWORK_DISCONNECT_REMOTE_BADCRYPT value
     * @property {number} NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED=83 NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED value
     * @property {number} NETWORK_DISCONNECT_UNUSUAL=84 NETWORK_DISCONNECT_UNUSUAL value
     * @property {number} NETWORK_DISCONNECT_INTERNAL_ERROR=85 NETWORK_DISCONNECT_INTERNAL_ERROR value
     * @property {number} NETWORK_DISCONNECT_REJECT_BADCHALLENGE=128 NETWORK_DISCONNECT_REJECT_BADCHALLENGE value
     * @property {number} NETWORK_DISCONNECT_REJECT_NOLOBBY=129 NETWORK_DISCONNECT_REJECT_NOLOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP=130 NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP value
     * @property {number} NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER=131 NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER value
     * @property {number} NETWORK_DISCONNECT_REJECT_HIDDEN_GAME=132 NETWORK_DISCONNECT_REJECT_HIDDEN_GAME value
     * @property {number} NETWORK_DISCONNECT_REJECT_LANRESTRICT=133 NETWORK_DISCONNECT_REJECT_LANRESTRICT value
     * @property {number} NETWORK_DISCONNECT_REJECT_BADPASSWORD=134 NETWORK_DISCONNECT_REJECT_BADPASSWORD value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERFULL=135 NETWORK_DISCONNECT_REJECT_SERVERFULL value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION=136 NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION value
     * @property {number} NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL=137 NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL value
     * @property {number} NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY=138 NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY=139 NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH=140 NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH value
     * @property {number} NETWORK_DISCONNECT_REJECT_OLDPROTOCOL=141 NETWORK_DISCONNECT_REJECT_OLDPROTOCOL value
     * @property {number} NETWORK_DISCONNECT_REJECT_NEWPROTOCOL=142 NETWORK_DISCONNECT_REJECT_NEWPROTOCOL value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION=143 NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN=144 NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN=145 NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN value
     * @property {number} NETWORK_DISCONNECT_REJECT_STEAM=146 NETWORK_DISCONNECT_REJECT_STEAM value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED=147 NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID=148 NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID value
     * @property {number} NETWORK_DISCONNECT_REJECT_BANNED=149 NETWORK_DISCONNECT_REJECT_BANNED value
     */
    $root.ENetworkDisconnectionReason = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NETWORK_DISCONNECT_INVALID"] = 0;
        values[valuesById[1] = "NETWORK_DISCONNECT_SHUTDOWN"] = 1;
        values[valuesById[2] = "NETWORK_DISCONNECT_DISCONNECT_BY_USER"] = 2;
        values[valuesById[3] = "NETWORK_DISCONNECT_DISCONNECT_BY_SERVER"] = 3;
        values[valuesById[4] = "NETWORK_DISCONNECT_LOST"] = 4;
        values[valuesById[5] = "NETWORK_DISCONNECT_OVERFLOW"] = 5;
        values[valuesById[6] = "NETWORK_DISCONNECT_STEAM_BANNED"] = 6;
        values[valuesById[7] = "NETWORK_DISCONNECT_STEAM_INUSE"] = 7;
        values[valuesById[8] = "NETWORK_DISCONNECT_STEAM_TICKET"] = 8;
        values[valuesById[9] = "NETWORK_DISCONNECT_STEAM_LOGON"] = 9;
        values[valuesById[10] = "NETWORK_DISCONNECT_STEAM_AUTHCANCELLED"] = 10;
        values[valuesById[11] = "NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED"] = 11;
        values[valuesById[12] = "NETWORK_DISCONNECT_STEAM_AUTHINVALID"] = 12;
        values[valuesById[13] = "NETWORK_DISCONNECT_STEAM_VACBANSTATE"] = 13;
        values[valuesById[14] = "NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE"] = 14;
        values[valuesById[15] = "NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT"] = 15;
        values[valuesById[16] = "NETWORK_DISCONNECT_STEAM_DROPPED"] = 16;
        values[valuesById[17] = "NETWORK_DISCONNECT_STEAM_OWNERSHIP"] = 17;
        values[valuesById[18] = "NETWORK_DISCONNECT_SERVERINFO_OVERFLOW"] = 18;
        values[valuesById[19] = "NETWORK_DISCONNECT_TICKMSG_OVERFLOW"] = 19;
        values[valuesById[20] = "NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW"] = 20;
        values[valuesById[21] = "NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW"] = 21;
        values[valuesById[22] = "NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW"] = 22;
        values[valuesById[23] = "NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW"] = 23;
        values[valuesById[24] = "NETWORK_DISCONNECT_SNAPSHOTOVERFLOW"] = 24;
        values[valuesById[25] = "NETWORK_DISCONNECT_SNAPSHOTERROR"] = 25;
        values[valuesById[26] = "NETWORK_DISCONNECT_RELIABLEOVERFLOW"] = 26;
        values[valuesById[27] = "NETWORK_DISCONNECT_BADDELTATICK"] = 27;
        values[valuesById[28] = "NETWORK_DISCONNECT_NOMORESPLITS"] = 28;
        values[valuesById[29] = "NETWORK_DISCONNECT_TIMEDOUT"] = 29;
        values[valuesById[30] = "NETWORK_DISCONNECT_DISCONNECTED"] = 30;
        values[valuesById[31] = "NETWORK_DISCONNECT_LEAVINGSPLIT"] = 31;
        values[valuesById[32] = "NETWORK_DISCONNECT_DIFFERENTCLASSTABLES"] = 32;
        values[valuesById[33] = "NETWORK_DISCONNECT_BADRELAYPASSWORD"] = 33;
        values[valuesById[34] = "NETWORK_DISCONNECT_BADSPECTATORPASSWORD"] = 34;
        values[valuesById[35] = "NETWORK_DISCONNECT_HLTVRESTRICTED"] = 35;
        values[valuesById[36] = "NETWORK_DISCONNECT_NOSPECTATORS"] = 36;
        values[valuesById[37] = "NETWORK_DISCONNECT_HLTVUNAVAILABLE"] = 37;
        values[valuesById[38] = "NETWORK_DISCONNECT_HLTVSTOP"] = 38;
        values[valuesById[39] = "NETWORK_DISCONNECT_KICKED"] = 39;
        values[valuesById[40] = "NETWORK_DISCONNECT_BANADDED"] = 40;
        values[valuesById[41] = "NETWORK_DISCONNECT_KICKBANADDED"] = 41;
        values[valuesById[42] = "NETWORK_DISCONNECT_HLTVDIRECT"] = 42;
        values[valuesById[43] = "NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA"] = 43;
        values[valuesById[44] = "NETWORK_DISCONNECT_PURESERVER_MISMATCH"] = 44;
        values[valuesById[45] = "NETWORK_DISCONNECT_USERCMD"] = 45;
        values[valuesById[46] = "NETWORK_DISCONNECT_REJECTED_BY_GAME"] = 46;
        values[valuesById[47] = "NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR"] = 47;
        values[valuesById[48] = "NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR"] = 48;
        values[valuesById[49] = "NETWORK_DISCONNECT_BAD_SERVER_PASSWORD"] = 49;
        values[valuesById[50] = "NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION"] = 50;
        values[valuesById[51] = "NETWORK_DISCONNECT_CONNECTION_FAILURE"] = 51;
        values[valuesById[52] = "NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS"] = 52;
        values[valuesById[53] = "NETWORK_DISCONNECT_RECONNECTION"] = 53;
        values[valuesById[54] = "NETWORK_DISCONNECT_LOOPSHUTDOWN"] = 54;
        values[valuesById[55] = "NETWORK_DISCONNECT_LOOPDEACTIVATE"] = 55;
        values[valuesById[56] = "NETWORK_DISCONNECT_HOST_ENDGAME"] = 56;
        values[valuesById[57] = "NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE"] = 57;
        values[valuesById[58] = "NETWORK_DISCONNECT_CREATE_SERVER_FAILED"] = 58;
        values[valuesById[59] = "NETWORK_DISCONNECT_EXITING"] = 59;
        values[valuesById[60] = "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE"] = 60;
        values[valuesById[61] = "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY"] = 61;
        values[valuesById[62] = "NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL"] = 62;
        values[valuesById[63] = "NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP"] = 63;
        values[valuesById[64] = "NETWORK_DISCONNECT_CLIENT_NO_MAP"] = 64;
        values[valuesById[65] = "NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP"] = 65;
        values[valuesById[66] = "NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM"] = 66;
        values[valuesById[67] = "NETWORK_DISCONNECT_STEAM_DENY_MISC"] = 67;
        values[valuesById[68] = "NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT"] = 68;
        values[valuesById[69] = "NETWORK_DISCONNECT_SERVER_SHUTDOWN"] = 69;
        values[valuesById[70] = "NETWORK_DISCONNECT_SPLITPACKET_SEND_OVERFLOW"] = 70;
        values[valuesById[71] = "NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE"] = 71;
        values[valuesById[72] = "NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT"] = 72;
        values[valuesById[73] = "NETWORK_DISCONNECT_SERVER_INCOMPATIBLE"] = 73;
        values[valuesById[74] = "NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS"] = 74;
        values[valuesById[75] = "NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY"] = 75;
        values[valuesById[76] = "NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG"] = 76;
        values[valuesById[77] = "NETWORK_DISCONNECT_LOCALPROBLEM_OTHER"] = 77;
        values[valuesById[79] = "NETWORK_DISCONNECT_REMOTE_TIMEOUT"] = 79;
        values[valuesById[80] = "NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING"] = 80;
        values[valuesById[81] = "NETWORK_DISCONNECT_REMOTE_OTHER"] = 81;
        values[valuesById[82] = "NETWORK_DISCONNECT_REMOTE_BADCRYPT"] = 82;
        values[valuesById[83] = "NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED"] = 83;
        values[valuesById[84] = "NETWORK_DISCONNECT_UNUSUAL"] = 84;
        values[valuesById[85] = "NETWORK_DISCONNECT_INTERNAL_ERROR"] = 85;
        values[valuesById[128] = "NETWORK_DISCONNECT_REJECT_BADCHALLENGE"] = 128;
        values[valuesById[129] = "NETWORK_DISCONNECT_REJECT_NOLOBBY"] = 129;
        values[valuesById[130] = "NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP"] = 130;
        values[valuesById[131] = "NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER"] = 131;
        values[valuesById[132] = "NETWORK_DISCONNECT_REJECT_HIDDEN_GAME"] = 132;
        values[valuesById[133] = "NETWORK_DISCONNECT_REJECT_LANRESTRICT"] = 133;
        values[valuesById[134] = "NETWORK_DISCONNECT_REJECT_BADPASSWORD"] = 134;
        values[valuesById[135] = "NETWORK_DISCONNECT_REJECT_SERVERFULL"] = 135;
        values[valuesById[136] = "NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION"] = 136;
        values[valuesById[137] = "NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL"] = 137;
        values[valuesById[138] = "NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY"] = 138;
        values[valuesById[139] = "NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY"] = 139;
        values[valuesById[140] = "NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH"] = 140;
        values[valuesById[141] = "NETWORK_DISCONNECT_REJECT_OLDPROTOCOL"] = 141;
        values[valuesById[142] = "NETWORK_DISCONNECT_REJECT_NEWPROTOCOL"] = 142;
        values[valuesById[143] = "NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION"] = 143;
        values[valuesById[144] = "NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN"] = 144;
        values[valuesById[145] = "NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN"] = 145;
        values[valuesById[146] = "NETWORK_DISCONNECT_REJECT_STEAM"] = 146;
        values[valuesById[147] = "NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED"] = 147;
        values[valuesById[148] = "NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID"] = 148;
        values[valuesById[149] = "NETWORK_DISCONNECT_REJECT_BANNED"] = 149;
        return values;
    })();
    
    $root.google = (function() {
    
        /**
         * Namespace google.
         * @exports google
         * @namespace
         */
        var google = {};
    
        google.protobuf = (function() {
    
            /**
             * Namespace protobuf.
             * @memberof google
             * @namespace
             */
            var protobuf = {};
    
            protobuf.FileDescriptorSet = (function() {
    
                /**
                 * Properties of a FileDescriptorSet.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorSet
                 * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
                 */
    
                /**
                 * Constructs a new FileDescriptorSet.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorSet.
                 * @implements IFileDescriptorSet
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 */
                function FileDescriptorSet(properties) {
                    this.file = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorSet file.
                 * @member {Array.<google.protobuf.IFileDescriptorProto>} file
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 */
                FileDescriptorSet.prototype.file = $util.emptyArray;
    
                /**
                 * Creates a new FileDescriptorSet instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
                 */
                FileDescriptorSet.create = function create(properties) {
                    return new FileDescriptorSet(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.file != null && message.file.length)
                        for (var i = 0; i < message.file.length; ++i)
                            $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.file && message.file.length))
                                message.file = [];
                            message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileDescriptorSet message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorSet.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.file != null && message.hasOwnProperty("file")) {
                        if (!Array.isArray(message.file))
                            return "file: array expected";
                        for (var i = 0; i < message.file.length; ++i) {
                            var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                            if (error)
                                return "file." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 */
                FileDescriptorSet.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileDescriptorSet)
                        return object;
                    var message = new $root.google.protobuf.FileDescriptorSet();
                    if (object.file) {
                        if (!Array.isArray(object.file))
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                        message.file = [];
                        for (var i = 0; i < object.file.length; ++i) {
                            if (typeof object.file[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                            message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDescriptorSet.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.file = [];
                    if (message.file && message.file.length) {
                        object.file = [];
                        for (var j = 0; j < message.file.length; ++j)
                            object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FileDescriptorSet to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDescriptorSet.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FileDescriptorSet;
            })();
    
            protobuf.FileDescriptorProto = (function() {
    
                /**
                 * Properties of a FileDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorProto
                 * @property {string|null} [name] FileDescriptorProto name
                 * @property {string|null} ["package"] FileDescriptorProto package
                 * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [message_type] FileDescriptorProto message_type
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] FileDescriptorProto enum_type
                 * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
                 * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
                 * @property {google.protobuf.ISourceCodeInfo|null} [source_code_info] FileDescriptorProto source_code_info
                 */
    
                /**
                 * Constructs a new FileDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorProto.
                 * @implements IFileDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 */
                function FileDescriptorProto(properties) {
                    this.dependency = [];
                    this.message_type = [];
                    this.enum_type = [];
                    this.service = [];
                    this.extension = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.name = "";
    
                /**
                 * FileDescriptorProto package.
                 * @member {string} package
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype["package"] = "";
    
                /**
                 * FileDescriptorProto dependency.
                 * @member {Array.<string>} dependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.dependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto message_type.
                 * @member {Array.<google.protobuf.IDescriptorProto>} message_type
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.message_type = $util.emptyArray;
    
                /**
                 * FileDescriptorProto enum_type.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.enum_type = $util.emptyArray;
    
                /**
                 * FileDescriptorProto service.
                 * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.service = $util.emptyArray;
    
                /**
                 * FileDescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * FileDescriptorProto options.
                 * @member {google.protobuf.IFileOptions|null|undefined} options
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.options = null;
    
                /**
                 * FileDescriptorProto source_code_info.
                 * @member {google.protobuf.ISourceCodeInfo|null|undefined} source_code_info
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.source_code_info = null;
    
                /**
                 * Creates a new FileDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
                 */
                FileDescriptorProto.create = function create(properties) {
                    return new FileDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message["package"] != null && Object.hasOwnProperty.call(message, "package"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                    if (message.dependency != null && message.dependency.length)
                        for (var i = 0; i < message.dependency.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                    if (message.message_type != null && message.message_type.length)
                        for (var i = 0; i < message.message_type.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.message_type[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.enum_type != null && message.enum_type.length)
                        for (var i = 0; i < message.enum_type.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enum_type[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.service != null && message.service.length)
                        for (var i = 0; i < message.service.length; ++i)
                            $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.source_code_info != null && Object.hasOwnProperty.call(message, "source_code_info"))
                        $root.google.protobuf.SourceCodeInfo.encode(message.source_code_info, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message["package"] = reader.string();
                            break;
                        case 3:
                            if (!(message.dependency && message.dependency.length))
                                message.dependency = [];
                            message.dependency.push(reader.string());
                            break;
                        case 4:
                            if (!(message.message_type && message.message_type.length))
                                message.message_type = [];
                            message.message_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.enum_type && message.enum_type.length))
                                message.enum_type = [];
                            message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.service && message.service.length))
                                message.service = [];
                            message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.source_code_info = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        if (!$util.isString(message["package"]))
                            return "package: string expected";
                    if (message.dependency != null && message.hasOwnProperty("dependency")) {
                        if (!Array.isArray(message.dependency))
                            return "dependency: array expected";
                        for (var i = 0; i < message.dependency.length; ++i)
                            if (!$util.isString(message.dependency[i]))
                                return "dependency: string[] expected";
                    }
                    if (message.message_type != null && message.hasOwnProperty("message_type")) {
                        if (!Array.isArray(message.message_type))
                            return "message_type: array expected";
                        for (var i = 0; i < message.message_type.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.message_type[i]);
                            if (error)
                                return "message_type." + error;
                        }
                    }
                    if (message.enum_type != null && message.hasOwnProperty("enum_type")) {
                        if (!Array.isArray(message.enum_type))
                            return "enum_type: array expected";
                        for (var i = 0; i < message.enum_type.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
                            if (error)
                                return "enum_type." + error;
                        }
                    }
                    if (message.service != null && message.hasOwnProperty("service")) {
                        if (!Array.isArray(message.service))
                            return "service: array expected";
                        for (var i = 0; i < message.service.length; ++i) {
                            var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                            if (error)
                                return "service." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FileOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.source_code_info != null && message.hasOwnProperty("source_code_info")) {
                        var error = $root.google.protobuf.SourceCodeInfo.verify(message.source_code_info);
                        if (error)
                            return "source_code_info." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 */
                FileDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.FileDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object["package"] != null)
                        message["package"] = String(object["package"]);
                    if (object.dependency) {
                        if (!Array.isArray(object.dependency))
                            throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                        message.dependency = [];
                        for (var i = 0; i < object.dependency.length; ++i)
                            message.dependency[i] = String(object.dependency[i]);
                    }
                    if (object.message_type) {
                        if (!Array.isArray(object.message_type))
                            throw TypeError(".google.protobuf.FileDescriptorProto.message_type: array expected");
                        message.message_type = [];
                        for (var i = 0; i < object.message_type.length; ++i) {
                            if (typeof object.message_type[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.message_type: object expected");
                            message.message_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.message_type[i]);
                        }
                    }
                    if (object.enum_type) {
                        if (!Array.isArray(object.enum_type))
                            throw TypeError(".google.protobuf.FileDescriptorProto.enum_type: array expected");
                        message.enum_type = [];
                        for (var i = 0; i < object.enum_type.length; ++i) {
                            if (typeof object.enum_type[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.enum_type: object expected");
                            message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
                        }
                    }
                    if (object.service) {
                        if (!Array.isArray(object.service))
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                        message.service = [];
                        for (var i = 0; i < object.service.length; ++i) {
                            if (typeof object.service[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                            message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                        }
                    }
                    if (object.extension) {
                        if (!Array.isArray(object.extension))
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                        message.extension = [];
                        for (var i = 0; i < object.extension.length; ++i) {
                            if (typeof object.extension[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                    }
                    if (object.source_code_info != null) {
                        if (typeof object.source_code_info !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.source_code_info: object expected");
                        message.source_code_info = $root.google.protobuf.SourceCodeInfo.fromObject(object.source_code_info);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.dependency = [];
                        object.message_type = [];
                        object.enum_type = [];
                        object.service = [];
                        object.extension = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object["package"] = "";
                        object.options = null;
                        object.source_code_info = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        object["package"] = message["package"];
                    if (message.dependency && message.dependency.length) {
                        object.dependency = [];
                        for (var j = 0; j < message.dependency.length; ++j)
                            object.dependency[j] = message.dependency[j];
                    }
                    if (message.message_type && message.message_type.length) {
                        object.message_type = [];
                        for (var j = 0; j < message.message_type.length; ++j)
                            object.message_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.message_type[j], options);
                    }
                    if (message.enum_type && message.enum_type.length) {
                        object.enum_type = [];
                        for (var j = 0; j < message.enum_type.length; ++j)
                            object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
                    }
                    if (message.service && message.service.length) {
                        object.service = [];
                        for (var j = 0; j < message.service.length; ++j)
                            object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                    }
                    if (message.extension && message.extension.length) {
                        object.extension = [];
                        for (var j = 0; j < message.extension.length; ++j)
                            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                    if (message.source_code_info != null && message.hasOwnProperty("source_code_info"))
                        object.source_code_info = $root.google.protobuf.SourceCodeInfo.toObject(message.source_code_info, options);
                    return object;
                };
    
                /**
                 * Converts this FileDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FileDescriptorProto;
            })();
    
            protobuf.DescriptorProto = (function() {
    
                /**
                 * Properties of a DescriptorProto.
                 * @memberof google.protobuf
                 * @interface IDescriptorProto
                 * @property {string|null} [name] DescriptorProto name
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [nested_type] DescriptorProto nested_type
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] DescriptorProto enum_type
                 * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extension_range] DescriptorProto extension_range
                 * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
                 */
    
                /**
                 * Constructs a new DescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a DescriptorProto.
                 * @implements IDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 */
                function DescriptorProto(properties) {
                    this.field = [];
                    this.extension = [];
                    this.nested_type = [];
                    this.enum_type = [];
                    this.extension_range = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.name = "";
    
                /**
                 * DescriptorProto field.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.field = $util.emptyArray;
    
                /**
                 * DescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * DescriptorProto nested_type.
                 * @member {Array.<google.protobuf.IDescriptorProto>} nested_type
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.nested_type = $util.emptyArray;
    
                /**
                 * DescriptorProto enum_type.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.enum_type = $util.emptyArray;
    
                /**
                 * DescriptorProto extension_range.
                 * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extension_range
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extension_range = $util.emptyArray;
    
                /**
                 * DescriptorProto options.
                 * @member {google.protobuf.IMessageOptions|null|undefined} options
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new DescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
                 */
                DescriptorProto.create = function create(properties) {
                    return new DescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.field != null && message.field.length)
                        for (var i = 0; i < message.field.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.nested_type != null && message.nested_type.length)
                        for (var i = 0; i < message.nested_type.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.nested_type[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.enum_type != null && message.enum_type.length)
                        for (var i = 0; i < message.enum_type.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enum_type[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.extension_range != null && message.extension_range.length)
                        for (var i = 0; i < message.extension_range.length; ++i)
                            $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extension_range[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.field && message.field.length))
                                message.field = [];
                            message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.nested_type && message.nested_type.length))
                                message.nested_type = [];
                            message.nested_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.enum_type && message.enum_type.length))
                                message.enum_type = [];
                            message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.extension_range && message.extension_range.length))
                                message.extension_range = [];
                            message.extension_range.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.field != null && message.hasOwnProperty("field")) {
                        if (!Array.isArray(message.field))
                            return "field: array expected";
                        for (var i = 0; i < message.field.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                            if (error)
                                return "field." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.nested_type != null && message.hasOwnProperty("nested_type")) {
                        if (!Array.isArray(message.nested_type))
                            return "nested_type: array expected";
                        for (var i = 0; i < message.nested_type.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.nested_type[i]);
                            if (error)
                                return "nested_type." + error;
                        }
                    }
                    if (message.enum_type != null && message.hasOwnProperty("enum_type")) {
                        if (!Array.isArray(message.enum_type))
                            return "enum_type: array expected";
                        for (var i = 0; i < message.enum_type.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
                            if (error)
                                return "enum_type." + error;
                        }
                    }
                    if (message.extension_range != null && message.hasOwnProperty("extension_range")) {
                        if (!Array.isArray(message.extension_range))
                            return "extension_range: array expected";
                        for (var i = 0; i < message.extension_range.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extension_range[i]);
                            if (error)
                                return "extension_range." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MessageOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 */
                DescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.field) {
                        if (!Array.isArray(object.field))
                            throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                        message.field = [];
                        for (var i = 0; i < object.field.length; ++i) {
                            if (typeof object.field[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                            message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                        }
                    }
                    if (object.extension) {
                        if (!Array.isArray(object.extension))
                            throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                        message.extension = [];
                        for (var i = 0; i < object.extension.length; ++i) {
                            if (typeof object.extension[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                        }
                    }
                    if (object.nested_type) {
                        if (!Array.isArray(object.nested_type))
                            throw TypeError(".google.protobuf.DescriptorProto.nested_type: array expected");
                        message.nested_type = [];
                        for (var i = 0; i < object.nested_type.length; ++i) {
                            if (typeof object.nested_type[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.nested_type: object expected");
                            message.nested_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nested_type[i]);
                        }
                    }
                    if (object.enum_type) {
                        if (!Array.isArray(object.enum_type))
                            throw TypeError(".google.protobuf.DescriptorProto.enum_type: array expected");
                        message.enum_type = [];
                        for (var i = 0; i < object.enum_type.length; ++i) {
                            if (typeof object.enum_type[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.enum_type: object expected");
                            message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
                        }
                    }
                    if (object.extension_range) {
                        if (!Array.isArray(object.extension_range))
                            throw TypeError(".google.protobuf.DescriptorProto.extension_range: array expected");
                        message.extension_range = [];
                        for (var i = 0; i < object.extension_range.length; ++i) {
                            if (typeof object.extension_range[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.extension_range: object expected");
                            message.extension_range[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extension_range[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.DescriptorProto} message DescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.field = [];
                        object.nested_type = [];
                        object.enum_type = [];
                        object.extension_range = [];
                        object.extension = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.field && message.field.length) {
                        object.field = [];
                        for (var j = 0; j < message.field.length; ++j)
                            object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                    }
                    if (message.nested_type && message.nested_type.length) {
                        object.nested_type = [];
                        for (var j = 0; j < message.nested_type.length; ++j)
                            object.nested_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.nested_type[j], options);
                    }
                    if (message.enum_type && message.enum_type.length) {
                        object.enum_type = [];
                        for (var j = 0; j < message.enum_type.length; ++j)
                            object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
                    }
                    if (message.extension_range && message.extension_range.length) {
                        object.extension_range = [];
                        for (var j = 0; j < message.extension_range.length; ++j)
                            object.extension_range[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extension_range[j], options);
                    }
                    if (message.extension && message.extension.length) {
                        object.extension = [];
                        for (var j = 0; j < message.extension.length; ++j)
                            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this DescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                DescriptorProto.ExtensionRange = (function() {
    
                    /**
                     * Properties of an ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @interface IExtensionRange
                     * @property {number|null} [start] ExtensionRange start
                     * @property {number|null} [end] ExtensionRange end
                     */
    
                    /**
                     * Constructs a new ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @classdesc Represents an ExtensionRange.
                     * @implements IExtensionRange
                     * @constructor
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     */
                    function ExtensionRange(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ExtensionRange start.
                     * @member {number} start
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.start = 0;
    
                    /**
                     * ExtensionRange end.
                     * @member {number} end
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.end = 0;
    
                    /**
                     * Creates a new ExtensionRange instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                     */
                    ExtensionRange.create = function create(properties) {
                        return new ExtensionRange(properties);
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.start = reader.int32();
                                break;
                            case 2:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an ExtensionRange message.
                     * @function verify
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ExtensionRange.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.start != null && message.hasOwnProperty("start"))
                            if (!$util.isInteger(message.start))
                                return "start: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     */
                    ExtensionRange.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                            return object;
                        var message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        if (object.start != null)
                            message.start = object.start | 0;
                        if (object.end != null)
                            message.end = object.end | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ExtensionRange.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.start = 0;
                            object.end = 0;
                        }
                        if (message.start != null && message.hasOwnProperty("start"))
                            object.start = message.start;
                        if (message.end != null && message.hasOwnProperty("end"))
                            object.end = message.end;
                        return object;
                    };
    
                    /**
                     * Converts this ExtensionRange to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ExtensionRange.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ExtensionRange;
                })();
    
                return DescriptorProto;
            })();
    
            protobuf.FieldDescriptorProto = (function() {
    
                /**
                 * Properties of a FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFieldDescriptorProto
                 * @property {string|null} [name] FieldDescriptorProto name
                 * @property {number|null} [number] FieldDescriptorProto number
                 * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
                 * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
                 * @property {string|null} [type_name] FieldDescriptorProto type_name
                 * @property {string|null} [extendee] FieldDescriptorProto extendee
                 * @property {string|null} [default_value] FieldDescriptorProto default_value
                 * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
                 */
    
                /**
                 * Constructs a new FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldDescriptorProto.
                 * @implements IFieldDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 */
                function FieldDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.name = "";
    
                /**
                 * FieldDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.number = 0;
    
                /**
                 * FieldDescriptorProto label.
                 * @member {google.protobuf.FieldDescriptorProto.Label} label
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.label = 1;
    
                /**
                 * FieldDescriptorProto type.
                 * @member {google.protobuf.FieldDescriptorProto.Type} type
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.type = 1;
    
                /**
                 * FieldDescriptorProto type_name.
                 * @member {string} type_name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.type_name = "";
    
                /**
                 * FieldDescriptorProto extendee.
                 * @member {string} extendee
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.extendee = "";
    
                /**
                 * FieldDescriptorProto default_value.
                 * @member {string} default_value
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.default_value = "";
    
                /**
                 * FieldDescriptorProto options.
                 * @member {google.protobuf.IFieldOptions|null|undefined} options
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new FieldDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
                 */
                FieldDescriptorProto.create = function create(properties) {
                    return new FieldDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.extendee != null && Object.hasOwnProperty.call(message, "extendee"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                    if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                    if (message.type_name != null && Object.hasOwnProperty.call(message, "type_name"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.type_name);
                    if (message.default_value != null && Object.hasOwnProperty.call(message, "default_value"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.default_value);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.number = reader.int32();
                            break;
                        case 4:
                            message.label = reader.int32();
                            break;
                        case 5:
                            message.type = reader.int32();
                            break;
                        case 6:
                            message.type_name = reader.string();
                            break;
                        case 2:
                            message.extendee = reader.string();
                            break;
                        case 7:
                            message.default_value = reader.string();
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        switch (message.label) {
                        default:
                            return "label: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                            break;
                        }
                    if (message.type_name != null && message.hasOwnProperty("type_name"))
                        if (!$util.isString(message.type_name))
                            return "type_name: string expected";
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        if (!$util.isString(message.extendee))
                            return "extendee: string expected";
                    if (message.default_value != null && message.hasOwnProperty("default_value"))
                        if (!$util.isString(message.default_value))
                            return "default_value: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FieldOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 */
                FieldDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.FieldDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    switch (object.label) {
                    case "LABEL_OPTIONAL":
                    case 1:
                        message.label = 1;
                        break;
                    case "LABEL_REQUIRED":
                    case 2:
                        message.label = 2;
                        break;
                    case "LABEL_REPEATED":
                    case 3:
                        message.label = 3;
                        break;
                    }
                    switch (object.type) {
                    case "TYPE_DOUBLE":
                    case 1:
                        message.type = 1;
                        break;
                    case "TYPE_FLOAT":
                    case 2:
                        message.type = 2;
                        break;
                    case "TYPE_INT64":
                    case 3:
                        message.type = 3;
                        break;
                    case "TYPE_UINT64":
                    case 4:
                        message.type = 4;
                        break;
                    case "TYPE_INT32":
                    case 5:
                        message.type = 5;
                        break;
                    case "TYPE_FIXED64":
                    case 6:
                        message.type = 6;
                        break;
                    case "TYPE_FIXED32":
                    case 7:
                        message.type = 7;
                        break;
                    case "TYPE_BOOL":
                    case 8:
                        message.type = 8;
                        break;
                    case "TYPE_STRING":
                    case 9:
                        message.type = 9;
                        break;
                    case "TYPE_GROUP":
                    case 10:
                        message.type = 10;
                        break;
                    case "TYPE_MESSAGE":
                    case 11:
                        message.type = 11;
                        break;
                    case "TYPE_BYTES":
                    case 12:
                        message.type = 12;
                        break;
                    case "TYPE_UINT32":
                    case 13:
                        message.type = 13;
                        break;
                    case "TYPE_ENUM":
                    case 14:
                        message.type = 14;
                        break;
                    case "TYPE_SFIXED32":
                    case 15:
                        message.type = 15;
                        break;
                    case "TYPE_SFIXED64":
                    case 16:
                        message.type = 16;
                        break;
                    case "TYPE_SINT32":
                    case 17:
                        message.type = 17;
                        break;
                    case "TYPE_SINT64":
                    case 18:
                        message.type = 18;
                        break;
                    }
                    if (object.type_name != null)
                        message.type_name = String(object.type_name);
                    if (object.extendee != null)
                        message.extendee = String(object.extendee);
                    if (object.default_value != null)
                        message.default_value = String(object.default_value);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.extendee = "";
                        object.number = 0;
                        object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                        object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                        object.type_name = "";
                        object.default_value = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        object.extendee = message.extendee;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                    if (message.type_name != null && message.hasOwnProperty("type_name"))
                        object.type_name = message.type_name;
                    if (message.default_value != null && message.hasOwnProperty("default_value"))
                        object.default_value = message.default_value;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this FieldDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Type enum.
                 * @name google.protobuf.FieldDescriptorProto.Type
                 * @enum {number}
                 * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
                 * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
                 * @property {number} TYPE_INT64=3 TYPE_INT64 value
                 * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
                 * @property {number} TYPE_INT32=5 TYPE_INT32 value
                 * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
                 * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
                 * @property {number} TYPE_BOOL=8 TYPE_BOOL value
                 * @property {number} TYPE_STRING=9 TYPE_STRING value
                 * @property {number} TYPE_GROUP=10 TYPE_GROUP value
                 * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
                 * @property {number} TYPE_BYTES=12 TYPE_BYTES value
                 * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
                 * @property {number} TYPE_ENUM=14 TYPE_ENUM value
                 * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
                 * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
                 * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
                 * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
                 */
                FieldDescriptorProto.Type = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                    values[valuesById[2] = "TYPE_FLOAT"] = 2;
                    values[valuesById[3] = "TYPE_INT64"] = 3;
                    values[valuesById[4] = "TYPE_UINT64"] = 4;
                    values[valuesById[5] = "TYPE_INT32"] = 5;
                    values[valuesById[6] = "TYPE_FIXED64"] = 6;
                    values[valuesById[7] = "TYPE_FIXED32"] = 7;
                    values[valuesById[8] = "TYPE_BOOL"] = 8;
                    values[valuesById[9] = "TYPE_STRING"] = 9;
                    values[valuesById[10] = "TYPE_GROUP"] = 10;
                    values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                    values[valuesById[12] = "TYPE_BYTES"] = 12;
                    values[valuesById[13] = "TYPE_UINT32"] = 13;
                    values[valuesById[14] = "TYPE_ENUM"] = 14;
                    values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                    values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                    values[valuesById[17] = "TYPE_SINT32"] = 17;
                    values[valuesById[18] = "TYPE_SINT64"] = 18;
                    return values;
                })();
    
                /**
                 * Label enum.
                 * @name google.protobuf.FieldDescriptorProto.Label
                 * @enum {number}
                 * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
                 * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
                 * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
                 */
                FieldDescriptorProto.Label = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                    values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                    values[valuesById[3] = "LABEL_REPEATED"] = 3;
                    return values;
                })();
    
                return FieldDescriptorProto;
            })();
    
            protobuf.EnumDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumDescriptorProto
                 * @property {string|null} [name] EnumDescriptorProto name
                 * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
                 * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumDescriptorProto.
                 * @implements IEnumDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 */
                function EnumDescriptorProto(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.name = "";
    
                /**
                 * EnumDescriptorProto value.
                 * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.value = $util.emptyArray;
    
                /**
                 * EnumDescriptorProto options.
                 * @member {google.protobuf.IEnumOptions|null|undefined} options
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
                 */
                EnumDescriptorProto.create = function create(properties) {
                    return new EnumDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.value != null && message.value.length)
                        for (var i = 0; i < message.value.length; ++i)
                            $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i) {
                            var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                            if (error)
                                return "value." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 */
                EnumDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.EnumDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                        message.value = [];
                        for (var i = 0; i < object.value.length; ++i) {
                            if (typeof object.value[i] !== "object")
                                throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                            message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.value = [];
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (var j = 0; j < message.value.length; ++j)
                            object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this EnumDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumDescriptorProto;
            })();
    
            protobuf.EnumValueDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumValueDescriptorProto
                 * @property {string|null} [name] EnumValueDescriptorProto name
                 * @property {number|null} [number] EnumValueDescriptorProto number
                 * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueDescriptorProto.
                 * @implements IEnumValueDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 */
                function EnumValueDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.name = "";
    
                /**
                 * EnumValueDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.number = 0;
    
                /**
                 * EnumValueDescriptorProto options.
                 * @member {google.protobuf.IEnumValueOptions|null|undefined} options
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumValueDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
                 */
                EnumValueDescriptorProto.create = function create(properties) {
                    return new EnumValueDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.number = reader.int32();
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumValueDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 */
                EnumValueDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.EnumValueDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumValueDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.number = 0;
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this EnumValueDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumValueDescriptorProto;
            })();
    
            protobuf.ServiceDescriptorProto = (function() {
    
                /**
                 * Properties of a ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IServiceDescriptorProto
                 * @property {string|null} [name] ServiceDescriptorProto name
                 * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
                 * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
                 */
    
                /**
                 * Constructs a new ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceDescriptorProto.
                 * @implements IServiceDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 */
                function ServiceDescriptorProto(properties) {
                    this.method = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.name = "";
    
                /**
                 * ServiceDescriptorProto method.
                 * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.method = $util.emptyArray;
    
                /**
                 * ServiceDescriptorProto options.
                 * @member {google.protobuf.IServiceOptions|null|undefined} options
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new ServiceDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
                 */
                ServiceDescriptorProto.create = function create(properties) {
                    return new ServiceDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.method != null && message.method.length)
                        for (var i = 0; i < message.method.length; ++i)
                            $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.method && message.method.length))
                                message.method = [];
                            message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ServiceDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.method != null && message.hasOwnProperty("method")) {
                        if (!Array.isArray(message.method))
                            return "method: array expected";
                        for (var i = 0; i < message.method.length; ++i) {
                            var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                            if (error)
                                return "method." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.ServiceOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 */
                ServiceDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.ServiceDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.method) {
                        if (!Array.isArray(object.method))
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                        message.method = [];
                        for (var i = 0; i < object.method.length; ++i) {
                            if (typeof object.method[i] !== "object")
                                throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                            message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.method = [];
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.method && message.method.length) {
                        object.method = [];
                        for (var j = 0; j < message.method.length; ++j)
                            object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this ServiceDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ServiceDescriptorProto;
            })();
    
            protobuf.MethodDescriptorProto = (function() {
    
                /**
                 * Properties of a MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IMethodDescriptorProto
                 * @property {string|null} [name] MethodDescriptorProto name
                 * @property {string|null} [input_type] MethodDescriptorProto input_type
                 * @property {string|null} [output_type] MethodDescriptorProto output_type
                 * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
                 */
    
                /**
                 * Constructs a new MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodDescriptorProto.
                 * @implements IMethodDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 */
                function MethodDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.name = "";
    
                /**
                 * MethodDescriptorProto input_type.
                 * @member {string} input_type
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.input_type = "";
    
                /**
                 * MethodDescriptorProto output_type.
                 * @member {string} output_type
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.output_type = "";
    
                /**
                 * MethodDescriptorProto options.
                 * @member {google.protobuf.IMethodOptions|null|undefined} options
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new MethodDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
                 */
                MethodDescriptorProto.create = function create(properties) {
                    return new MethodDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.input_type != null && Object.hasOwnProperty.call(message, "input_type"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.input_type);
                    if (message.output_type != null && Object.hasOwnProperty.call(message, "output_type"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.output_type);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.input_type = reader.string();
                            break;
                        case 3:
                            message.output_type = reader.string();
                            break;
                        case 4:
                            message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MethodDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.input_type != null && message.hasOwnProperty("input_type"))
                        if (!$util.isString(message.input_type))
                            return "input_type: string expected";
                    if (message.output_type != null && message.hasOwnProperty("output_type"))
                        if (!$util.isString(message.output_type))
                            return "output_type: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MethodOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 */
                MethodDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.MethodDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.input_type != null)
                        message.input_type = String(object.input_type);
                    if (object.output_type != null)
                        message.output_type = String(object.output_type);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.input_type = "";
                        object.output_type = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.input_type != null && message.hasOwnProperty("input_type"))
                        object.input_type = message.input_type;
                    if (message.output_type != null && message.hasOwnProperty("output_type"))
                        object.output_type = message.output_type;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this MethodDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MethodDescriptorProto;
            })();
    
            protobuf.FileOptions = (function() {
    
                /**
                 * Properties of a FileOptions.
                 * @memberof google.protobuf
                 * @interface IFileOptions
                 * @property {string|null} [java_package] FileOptions java_package
                 * @property {string|null} [java_outer_classname] FileOptions java_outer_classname
                 * @property {boolean|null} [java_multiple_files] FileOptions java_multiple_files
                 * @property {boolean|null} [java_generate_equals_and_hash] FileOptions java_generate_equals_and_hash
                 * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimize_for] FileOptions optimize_for
                 * @property {boolean|null} [cc_generic_services] FileOptions cc_generic_services
                 * @property {boolean|null} [java_generic_services] FileOptions java_generic_services
                 * @property {boolean|null} [py_generic_services] FileOptions py_generic_services
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FileOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new FileOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileOptions.
                 * @implements IFileOptions
                 * @constructor
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 */
                function FileOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileOptions java_package.
                 * @member {string} java_package
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_package = "";
    
                /**
                 * FileOptions java_outer_classname.
                 * @member {string} java_outer_classname
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_outer_classname = "";
    
                /**
                 * FileOptions java_multiple_files.
                 * @member {boolean} java_multiple_files
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_multiple_files = false;
    
                /**
                 * FileOptions java_generate_equals_and_hash.
                 * @member {boolean} java_generate_equals_and_hash
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_generate_equals_and_hash = false;
    
                /**
                 * FileOptions optimize_for.
                 * @member {google.protobuf.FileOptions.OptimizeMode} optimize_for
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.optimize_for = 1;
    
                /**
                 * FileOptions cc_generic_services.
                 * @member {boolean} cc_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.cc_generic_services = false;
    
                /**
                 * FileOptions java_generic_services.
                 * @member {boolean} java_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_generic_services = false;
    
                /**
                 * FileOptions py_generic_services.
                 * @member {boolean} py_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.py_generic_services = false;
    
                /**
                 * FileOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new FileOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FileOptions} FileOptions instance
                 */
                FileOptions.create = function create(properties) {
                    return new FileOptions(properties);
                };
    
                /**
                 * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.java_package != null && Object.hasOwnProperty.call(message, "java_package"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.java_package);
                    if (message.java_outer_classname != null && Object.hasOwnProperty.call(message, "java_outer_classname"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.java_outer_classname);
                    if (message.optimize_for != null && Object.hasOwnProperty.call(message, "optimize_for"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimize_for);
                    if (message.java_multiple_files != null && Object.hasOwnProperty.call(message, "java_multiple_files"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.java_multiple_files);
                    if (message.cc_generic_services != null && Object.hasOwnProperty.call(message, "cc_generic_services"))
                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.cc_generic_services);
                    if (message.java_generic_services != null && Object.hasOwnProperty.call(message, "java_generic_services"))
                        writer.uint32(/* id 17, wireType 0 =*/136).bool(message.java_generic_services);
                    if (message.py_generic_services != null && Object.hasOwnProperty.call(message, "py_generic_services"))
                        writer.uint32(/* id 18, wireType 0 =*/144).bool(message.py_generic_services);
                    if (message.java_generate_equals_and_hash != null && Object.hasOwnProperty.call(message, "java_generate_equals_and_hash"))
                        writer.uint32(/* id 20, wireType 0 =*/160).bool(message.java_generate_equals_and_hash);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.java_package = reader.string();
                            break;
                        case 8:
                            message.java_outer_classname = reader.string();
                            break;
                        case 10:
                            message.java_multiple_files = reader.bool();
                            break;
                        case 20:
                            message.java_generate_equals_and_hash = reader.bool();
                            break;
                        case 9:
                            message.optimize_for = reader.int32();
                            break;
                        case 16:
                            message.cc_generic_services = reader.bool();
                            break;
                        case 17:
                            message.java_generic_services = reader.bool();
                            break;
                        case 18:
                            message.py_generic_services = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileOptions message.
                 * @function verify
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.java_package != null && message.hasOwnProperty("java_package"))
                        if (!$util.isString(message.java_package))
                            return "java_package: string expected";
                    if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                        if (!$util.isString(message.java_outer_classname))
                            return "java_outer_classname: string expected";
                    if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                        if (typeof message.java_multiple_files !== "boolean")
                            return "java_multiple_files: boolean expected";
                    if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                        if (typeof message.java_generate_equals_and_hash !== "boolean")
                            return "java_generate_equals_and_hash: boolean expected";
                    if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                        switch (message.optimize_for) {
                        default:
                            return "optimize_for: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                        if (typeof message.cc_generic_services !== "boolean")
                            return "cc_generic_services: boolean expected";
                    if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                        if (typeof message.java_generic_services !== "boolean")
                            return "java_generic_services: boolean expected";
                    if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                        if (typeof message.py_generic_services !== "boolean")
                            return "py_generic_services: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileOptions} FileOptions
                 */
                FileOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileOptions)
                        return object;
                    var message = new $root.google.protobuf.FileOptions();
                    if (object.java_package != null)
                        message.java_package = String(object.java_package);
                    if (object.java_outer_classname != null)
                        message.java_outer_classname = String(object.java_outer_classname);
                    if (object.java_multiple_files != null)
                        message.java_multiple_files = Boolean(object.java_multiple_files);
                    if (object.java_generate_equals_and_hash != null)
                        message.java_generate_equals_and_hash = Boolean(object.java_generate_equals_and_hash);
                    switch (object.optimize_for) {
                    case "SPEED":
                    case 1:
                        message.optimize_for = 1;
                        break;
                    case "CODE_SIZE":
                    case 2:
                        message.optimize_for = 2;
                        break;
                    case "LITE_RUNTIME":
                    case 3:
                        message.optimize_for = 3;
                        break;
                    }
                    if (object.cc_generic_services != null)
                        message.cc_generic_services = Boolean(object.cc_generic_services);
                    if (object.java_generic_services != null)
                        message.java_generic_services = Boolean(object.java_generic_services);
                    if (object.py_generic_services != null)
                        message.py_generic_services = Boolean(object.py_generic_services);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.FileOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.FileOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.FileOptions} message FileOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.java_package = "";
                        object.java_outer_classname = "";
                        object.optimize_for = options.enums === String ? "SPEED" : 1;
                        object.java_multiple_files = false;
                        object.cc_generic_services = false;
                        object.java_generic_services = false;
                        object.py_generic_services = false;
                        object.java_generate_equals_and_hash = false;
                    }
                    if (message.java_package != null && message.hasOwnProperty("java_package"))
                        object.java_package = message.java_package;
                    if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                        object.java_outer_classname = message.java_outer_classname;
                    if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                        object.optimize_for = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimize_for] : message.optimize_for;
                    if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                        object.java_multiple_files = message.java_multiple_files;
                    if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                        object.cc_generic_services = message.cc_generic_services;
                    if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                        object.java_generic_services = message.java_generic_services;
                    if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                        object.py_generic_services = message.py_generic_services;
                    if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                        object.java_generate_equals_and_hash = message.java_generate_equals_and_hash;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FileOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * OptimizeMode enum.
                 * @name google.protobuf.FileOptions.OptimizeMode
                 * @enum {number}
                 * @property {number} SPEED=1 SPEED value
                 * @property {number} CODE_SIZE=2 CODE_SIZE value
                 * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
                 */
                FileOptions.OptimizeMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "SPEED"] = 1;
                    values[valuesById[2] = "CODE_SIZE"] = 2;
                    values[valuesById[3] = "LITE_RUNTIME"] = 3;
                    return values;
                })();
    
                return FileOptions;
            })();
    
            protobuf.MessageOptions = (function() {
    
                /**
                 * Properties of a MessageOptions.
                 * @memberof google.protobuf
                 * @interface IMessageOptions
                 * @property {boolean|null} [message_set_wire_format] MessageOptions message_set_wire_format
                 * @property {boolean|null} [no_standard_descriptor_accessor] MessageOptions no_standard_descriptor_accessor
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MessageOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new MessageOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MessageOptions.
                 * @implements IMessageOptions
                 * @constructor
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 */
                function MessageOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MessageOptions message_set_wire_format.
                 * @member {boolean} message_set_wire_format
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.message_set_wire_format = false;
    
                /**
                 * MessageOptions no_standard_descriptor_accessor.
                 * @member {boolean} no_standard_descriptor_accessor
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.no_standard_descriptor_accessor = false;
    
                /**
                 * MessageOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new MessageOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MessageOptions} MessageOptions instance
                 */
                MessageOptions.create = function create(properties) {
                    return new MessageOptions(properties);
                };
    
                /**
                 * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.message_set_wire_format != null && Object.hasOwnProperty.call(message, "message_set_wire_format"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.message_set_wire_format);
                    if (message.no_standard_descriptor_accessor != null && Object.hasOwnProperty.call(message, "no_standard_descriptor_accessor"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.no_standard_descriptor_accessor);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.message_set_wire_format = reader.bool();
                            break;
                        case 2:
                            message.no_standard_descriptor_accessor = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MessageOptions message.
                 * @function verify
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                        if (typeof message.message_set_wire_format !== "boolean")
                            return "message_set_wire_format: boolean expected";
                    if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                        if (typeof message.no_standard_descriptor_accessor !== "boolean")
                            return "no_standard_descriptor_accessor: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 */
                MessageOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MessageOptions)
                        return object;
                    var message = new $root.google.protobuf.MessageOptions();
                    if (object.message_set_wire_format != null)
                        message.message_set_wire_format = Boolean(object.message_set_wire_format);
                    if (object.no_standard_descriptor_accessor != null)
                        message.no_standard_descriptor_accessor = Boolean(object.no_standard_descriptor_accessor);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.MessageOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.MessageOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.MessageOptions} message MessageOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.message_set_wire_format = false;
                        object.no_standard_descriptor_accessor = false;
                    }
                    if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                        object.message_set_wire_format = message.message_set_wire_format;
                    if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                        object.no_standard_descriptor_accessor = message.no_standard_descriptor_accessor;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MessageOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MessageOptions;
            })();
    
            protobuf.FieldOptions = (function() {
    
                /**
                 * Properties of a FieldOptions.
                 * @memberof google.protobuf
                 * @interface IFieldOptions
                 * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
                 * @property {boolean|null} [packed] FieldOptions packed
                 * @property {boolean|null} [deprecated] FieldOptions deprecated
                 * @property {string|null} [experimental_map_key] FieldOptions experimental_map_key
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FieldOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new FieldOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldOptions.
                 * @implements IFieldOptions
                 * @constructor
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 */
                function FieldOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldOptions ctype.
                 * @member {google.protobuf.FieldOptions.CType} ctype
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.ctype = 0;
    
                /**
                 * FieldOptions packed.
                 * @member {boolean} packed
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.packed = false;
    
                /**
                 * FieldOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.deprecated = false;
    
                /**
                 * FieldOptions experimental_map_key.
                 * @member {string} experimental_map_key
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.experimental_map_key = "";
    
                /**
                 * FieldOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new FieldOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FieldOptions} FieldOptions instance
                 */
                FieldOptions.create = function create(properties) {
                    return new FieldOptions(properties);
                };
    
                /**
                 * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ctype != null && Object.hasOwnProperty.call(message, "ctype"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                    if (message.packed != null && Object.hasOwnProperty.call(message, "packed"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.experimental_map_key != null && Object.hasOwnProperty.call(message, "experimental_map_key"))
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.experimental_map_key);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ctype = reader.int32();
                            break;
                        case 2:
                            message.packed = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 9:
                            message.experimental_map_key = reader.string();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldOptions message.
                 * @function verify
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        switch (message.ctype) {
                        default:
                            return "ctype: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        if (typeof message.packed !== "boolean")
                            return "packed: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.experimental_map_key != null && message.hasOwnProperty("experimental_map_key"))
                        if (!$util.isString(message.experimental_map_key))
                            return "experimental_map_key: string expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 */
                FieldOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldOptions)
                        return object;
                    var message = new $root.google.protobuf.FieldOptions();
                    switch (object.ctype) {
                    case "STRING":
                    case 0:
                        message.ctype = 0;
                        break;
                    case "CORD":
                    case 1:
                        message.ctype = 1;
                        break;
                    case "STRING_PIECE":
                    case 2:
                        message.ctype = 2;
                        break;
                    }
                    if (object.packed != null)
                        message.packed = Boolean(object.packed);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.experimental_map_key != null)
                        message.experimental_map_key = String(object.experimental_map_key);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.FieldOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.FieldOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.FieldOptions} message FieldOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.ctype = options.enums === String ? "STRING" : 0;
                        object.packed = false;
                        object.deprecated = false;
                        object.experimental_map_key = "";
                    }
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        object.packed = message.packed;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.experimental_map_key != null && message.hasOwnProperty("experimental_map_key"))
                        object.experimental_map_key = message.experimental_map_key;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FieldOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * CType enum.
                 * @name google.protobuf.FieldOptions.CType
                 * @enum {number}
                 * @property {number} STRING=0 STRING value
                 * @property {number} CORD=1 CORD value
                 * @property {number} STRING_PIECE=2 STRING_PIECE value
                 */
                FieldOptions.CType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "STRING"] = 0;
                    values[valuesById[1] = "CORD"] = 1;
                    values[valuesById[2] = "STRING_PIECE"] = 2;
                    return values;
                })();
    
                return FieldOptions;
            })();
    
            protobuf.EnumOptions = (function() {
    
                /**
                 * Properties of an EnumOptions.
                 * @memberof google.protobuf
                 * @interface IEnumOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new EnumOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumOptions.
                 * @implements IEnumOptions
                 * @constructor
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 */
                function EnumOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new EnumOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumOptions} EnumOptions instance
                 */
                EnumOptions.create = function create(properties) {
                    return new EnumOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 */
                EnumOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumOptions)
                        return object;
                    var message = new $root.google.protobuf.EnumOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.EnumOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.EnumOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.EnumOptions} message EnumOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this EnumOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumOptions;
            })();
    
            protobuf.EnumValueOptions = (function() {
    
                /**
                 * Properties of an EnumValueOptions.
                 * @memberof google.protobuf
                 * @interface IEnumValueOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumValueOptions uninterpreted_option
                 * @property {string|null} [".network_connection_token"] EnumValueOptions .network_connection_token
                 */
    
                /**
                 * Constructs a new EnumValueOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueOptions.
                 * @implements IEnumValueOptions
                 * @constructor
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 */
                function EnumValueOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * EnumValueOptions .network_connection_token.
                 * @member {string} .network_connection_token
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype[".network_connection_token"] = "";
    
                /**
                 * Creates a new EnumValueOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
                 */
                EnumValueOptions.create = function create(properties) {
                    return new EnumValueOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    if (message[".network_connection_token"] != null && Object.hasOwnProperty.call(message, ".network_connection_token"))
                        writer.uint32(/* id 50500, wireType 2 =*/404002).string(message[".network_connection_token"]);
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        case 50500:
                            message[".network_connection_token"] = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumValueOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    if (message[".network_connection_token"] != null && message.hasOwnProperty(".network_connection_token"))
                        if (!$util.isString(message[".network_connection_token"]))
                            return ".network_connection_token: string expected";
                    return null;
                };
    
                /**
                 * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 */
                EnumValueOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumValueOptions)
                        return object;
                    var message = new $root.google.protobuf.EnumValueOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.EnumValueOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    if (object[".network_connection_token"] != null)
                        message[".network_connection_token"] = String(object[".network_connection_token"]);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumValueOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults)
                        object[".network_connection_token"] = "";
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    if (message[".network_connection_token"] != null && message.hasOwnProperty(".network_connection_token"))
                        object[".network_connection_token"] = message[".network_connection_token"];
                    return object;
                };
    
                /**
                 * Converts this EnumValueOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumValueOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumValueOptions;
            })();
    
            protobuf.ServiceOptions = (function() {
    
                /**
                 * Properties of a ServiceOptions.
                 * @memberof google.protobuf
                 * @interface IServiceOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] ServiceOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new ServiceOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceOptions.
                 * @implements IServiceOptions
                 * @constructor
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 */
                function ServiceOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 */
                ServiceOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new ServiceOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
                 */
                ServiceOptions.create = function create(properties) {
                    return new ServiceOptions(properties);
                };
    
                /**
                 * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ServiceOptions message.
                 * @function verify
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 */
                ServiceOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ServiceOptions)
                        return object;
                    var message = new $root.google.protobuf.ServiceOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.ServiceOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.ServiceOptions} message ServiceOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this ServiceOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ServiceOptions;
            })();
    
            protobuf.MethodOptions = (function() {
    
                /**
                 * Properties of a MethodOptions.
                 * @memberof google.protobuf
                 * @interface IMethodOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MethodOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new MethodOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodOptions.
                 * @implements IMethodOptions
                 * @constructor
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 */
                function MethodOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 */
                MethodOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new MethodOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MethodOptions} MethodOptions instance
                 */
                MethodOptions.create = function create(properties) {
                    return new MethodOptions(properties);
                };
    
                /**
                 * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MethodOptions message.
                 * @function verify
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 */
                MethodOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MethodOptions)
                        return object;
                    var message = new $root.google.protobuf.MethodOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.MethodOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.MethodOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.MethodOptions} message MethodOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MethodOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MethodOptions;
            })();
    
            protobuf.UninterpretedOption = (function() {
    
                /**
                 * Properties of an UninterpretedOption.
                 * @memberof google.protobuf
                 * @interface IUninterpretedOption
                 * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
                 * @property {string|null} [identifier_value] UninterpretedOption identifier_value
                 * @property {number|Long|null} [positive_int_value] UninterpretedOption positive_int_value
                 * @property {number|Long|null} [negative_int_value] UninterpretedOption negative_int_value
                 * @property {number|null} [double_value] UninterpretedOption double_value
                 * @property {Uint8Array|null} [string_value] UninterpretedOption string_value
                 * @property {string|null} [aggregate_value] UninterpretedOption aggregate_value
                 */
    
                /**
                 * Constructs a new UninterpretedOption.
                 * @memberof google.protobuf
                 * @classdesc Represents an UninterpretedOption.
                 * @implements IUninterpretedOption
                 * @constructor
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 */
                function UninterpretedOption(properties) {
                    this.name = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * UninterpretedOption name.
                 * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.name = $util.emptyArray;
    
                /**
                 * UninterpretedOption identifier_value.
                 * @member {string} identifier_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.identifier_value = "";
    
                /**
                 * UninterpretedOption positive_int_value.
                 * @member {number|Long} positive_int_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.positive_int_value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * UninterpretedOption negative_int_value.
                 * @member {number|Long} negative_int_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.negative_int_value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * UninterpretedOption double_value.
                 * @member {number} double_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.double_value = 0;
    
                /**
                 * UninterpretedOption string_value.
                 * @member {Uint8Array} string_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.string_value = $util.newBuffer([]);
    
                /**
                 * UninterpretedOption aggregate_value.
                 * @member {string} aggregate_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.aggregate_value = "";
    
                /**
                 * Creates a new UninterpretedOption instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
                 */
                UninterpretedOption.create = function create(properties) {
                    return new UninterpretedOption(properties);
                };
    
                /**
                 * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.name.length)
                        for (var i = 0; i < message.name.length; ++i)
                            $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.identifier_value != null && Object.hasOwnProperty.call(message, "identifier_value"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifier_value);
                    if (message.positive_int_value != null && Object.hasOwnProperty.call(message, "positive_int_value"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positive_int_value);
                    if (message.negative_int_value != null && Object.hasOwnProperty.call(message, "negative_int_value"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negative_int_value);
                    if (message.double_value != null && Object.hasOwnProperty.call(message, "double_value"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.double_value);
                    if (message.string_value != null && Object.hasOwnProperty.call(message, "string_value"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.string_value);
                    if (message.aggregate_value != null && Object.hasOwnProperty.call(message, "aggregate_value"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregate_value);
                    return writer;
                };
    
                /**
                 * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            if (!(message.name && message.name.length))
                                message.name = [];
                            message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.identifier_value = reader.string();
                            break;
                        case 4:
                            message.positive_int_value = reader.uint64();
                            break;
                        case 5:
                            message.negative_int_value = reader.int64();
                            break;
                        case 6:
                            message.double_value = reader.double();
                            break;
                        case 7:
                            message.string_value = reader.bytes();
                            break;
                        case 8:
                            message.aggregate_value = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an UninterpretedOption message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UninterpretedOption.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name")) {
                        if (!Array.isArray(message.name))
                            return "name: array expected";
                        for (var i = 0; i < message.name.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                            if (error)
                                return "name." + error;
                        }
                    }
                    if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                        if (!$util.isString(message.identifier_value))
                            return "identifier_value: string expected";
                    if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                        if (!$util.isInteger(message.positive_int_value) && !(message.positive_int_value && $util.isInteger(message.positive_int_value.low) && $util.isInteger(message.positive_int_value.high)))
                            return "positive_int_value: integer|Long expected";
                    if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                        if (!$util.isInteger(message.negative_int_value) && !(message.negative_int_value && $util.isInteger(message.negative_int_value.low) && $util.isInteger(message.negative_int_value.high)))
                            return "negative_int_value: integer|Long expected";
                    if (message.double_value != null && message.hasOwnProperty("double_value"))
                        if (typeof message.double_value !== "number")
                            return "double_value: number expected";
                    if (message.string_value != null && message.hasOwnProperty("string_value"))
                        if (!(message.string_value && typeof message.string_value.length === "number" || $util.isString(message.string_value)))
                            return "string_value: buffer expected";
                    if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                        if (!$util.isString(message.aggregate_value))
                            return "aggregate_value: string expected";
                    return null;
                };
    
                /**
                 * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 */
                UninterpretedOption.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption)
                        return object;
                    var message = new $root.google.protobuf.UninterpretedOption();
                    if (object.name) {
                        if (!Array.isArray(object.name))
                            throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                        message.name = [];
                        for (var i = 0; i < object.name.length; ++i) {
                            if (typeof object.name[i] !== "object")
                                throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                            message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                        }
                    }
                    if (object.identifier_value != null)
                        message.identifier_value = String(object.identifier_value);
                    if (object.positive_int_value != null)
                        if ($util.Long)
                            (message.positive_int_value = $util.Long.fromValue(object.positive_int_value)).unsigned = true;
                        else if (typeof object.positive_int_value === "string")
                            message.positive_int_value = parseInt(object.positive_int_value, 10);
                        else if (typeof object.positive_int_value === "number")
                            message.positive_int_value = object.positive_int_value;
                        else if (typeof object.positive_int_value === "object")
                            message.positive_int_value = new $util.LongBits(object.positive_int_value.low >>> 0, object.positive_int_value.high >>> 0).toNumber(true);
                    if (object.negative_int_value != null)
                        if ($util.Long)
                            (message.negative_int_value = $util.Long.fromValue(object.negative_int_value)).unsigned = false;
                        else if (typeof object.negative_int_value === "string")
                            message.negative_int_value = parseInt(object.negative_int_value, 10);
                        else if (typeof object.negative_int_value === "number")
                            message.negative_int_value = object.negative_int_value;
                        else if (typeof object.negative_int_value === "object")
                            message.negative_int_value = new $util.LongBits(object.negative_int_value.low >>> 0, object.negative_int_value.high >>> 0).toNumber();
                    if (object.double_value != null)
                        message.double_value = Number(object.double_value);
                    if (object.string_value != null)
                        if (typeof object.string_value === "string")
                            $util.base64.decode(object.string_value, message.string_value = $util.newBuffer($util.base64.length(object.string_value)), 0);
                        else if (object.string_value.length)
                            message.string_value = object.string_value;
                    if (object.aggregate_value != null)
                        message.aggregate_value = String(object.aggregate_value);
                    return message;
                };
    
                /**
                 * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UninterpretedOption.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.name = [];
                    if (options.defaults) {
                        object.identifier_value = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.positive_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.positive_int_value = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.negative_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.negative_int_value = options.longs === String ? "0" : 0;
                        object.double_value = 0;
                        if (options.bytes === String)
                            object.string_value = "";
                        else {
                            object.string_value = [];
                            if (options.bytes !== Array)
                                object.string_value = $util.newBuffer(object.string_value);
                        }
                        object.aggregate_value = "";
                    }
                    if (message.name && message.name.length) {
                        object.name = [];
                        for (var j = 0; j < message.name.length; ++j)
                            object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                    }
                    if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                        object.identifier_value = message.identifier_value;
                    if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                        if (typeof message.positive_int_value === "number")
                            object.positive_int_value = options.longs === String ? String(message.positive_int_value) : message.positive_int_value;
                        else
                            object.positive_int_value = options.longs === String ? $util.Long.prototype.toString.call(message.positive_int_value) : options.longs === Number ? new $util.LongBits(message.positive_int_value.low >>> 0, message.positive_int_value.high >>> 0).toNumber(true) : message.positive_int_value;
                    if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                        if (typeof message.negative_int_value === "number")
                            object.negative_int_value = options.longs === String ? String(message.negative_int_value) : message.negative_int_value;
                        else
                            object.negative_int_value = options.longs === String ? $util.Long.prototype.toString.call(message.negative_int_value) : options.longs === Number ? new $util.LongBits(message.negative_int_value.low >>> 0, message.negative_int_value.high >>> 0).toNumber() : message.negative_int_value;
                    if (message.double_value != null && message.hasOwnProperty("double_value"))
                        object.double_value = options.json && !isFinite(message.double_value) ? String(message.double_value) : message.double_value;
                    if (message.string_value != null && message.hasOwnProperty("string_value"))
                        object.string_value = options.bytes === String ? $util.base64.encode(message.string_value, 0, message.string_value.length) : options.bytes === Array ? Array.prototype.slice.call(message.string_value) : message.string_value;
                    if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                        object.aggregate_value = message.aggregate_value;
                    return object;
                };
    
                /**
                 * Converts this UninterpretedOption to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UninterpretedOption.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                UninterpretedOption.NamePart = (function() {
    
                    /**
                     * Properties of a NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @interface INamePart
                     * @property {string} name_part NamePart name_part
                     * @property {boolean} is_extension NamePart is_extension
                     */
    
                    /**
                     * Constructs a new NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @classdesc Represents a NamePart.
                     * @implements INamePart
                     * @constructor
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     */
                    function NamePart(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * NamePart name_part.
                     * @member {string} name_part
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.name_part = "";
    
                    /**
                     * NamePart is_extension.
                     * @member {boolean} is_extension
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.is_extension = false;
    
                    /**
                     * Creates a new NamePart instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                     */
                    NamePart.create = function create(properties) {
                        return new NamePart(properties);
                    };
    
                    /**
                     * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name_part);
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_extension);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name_part = reader.string();
                                break;
                            case 2:
                                message.is_extension = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        if (!message.hasOwnProperty("name_part"))
                            throw $util.ProtocolError("missing required 'name_part'", { instance: message });
                        if (!message.hasOwnProperty("is_extension"))
                            throw $util.ProtocolError("missing required 'is_extension'", { instance: message });
                        return message;
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a NamePart message.
                     * @function verify
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    NamePart.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (!$util.isString(message.name_part))
                            return "name_part: string expected";
                        if (typeof message.is_extension !== "boolean")
                            return "is_extension: boolean expected";
                        return null;
                    };
    
                    /**
                     * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     */
                    NamePart.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                            return object;
                        var message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        if (object.name_part != null)
                            message.name_part = String(object.name_part);
                        if (object.is_extension != null)
                            message.is_extension = Boolean(object.is_extension);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    NamePart.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.name_part = "";
                            object.is_extension = false;
                        }
                        if (message.name_part != null && message.hasOwnProperty("name_part"))
                            object.name_part = message.name_part;
                        if (message.is_extension != null && message.hasOwnProperty("is_extension"))
                            object.is_extension = message.is_extension;
                        return object;
                    };
    
                    /**
                     * Converts this NamePart to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    NamePart.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return NamePart;
                })();
    
                return UninterpretedOption;
            })();
    
            protobuf.SourceCodeInfo = (function() {
    
                /**
                 * Properties of a SourceCodeInfo.
                 * @memberof google.protobuf
                 * @interface ISourceCodeInfo
                 * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
                 */
    
                /**
                 * Constructs a new SourceCodeInfo.
                 * @memberof google.protobuf
                 * @classdesc Represents a SourceCodeInfo.
                 * @implements ISourceCodeInfo
                 * @constructor
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 */
                function SourceCodeInfo(properties) {
                    this.location = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SourceCodeInfo location.
                 * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 */
                SourceCodeInfo.prototype.location = $util.emptyArray;
    
                /**
                 * Creates a new SourceCodeInfo instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
                 */
                SourceCodeInfo.create = function create(properties) {
                    return new SourceCodeInfo(properties);
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.location != null && message.location.length)
                        for (var i = 0; i < message.location.length; ++i)
                            $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.location && message.location.length))
                                message.location = [];
                            message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SourceCodeInfo message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SourceCodeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.location != null && message.hasOwnProperty("location")) {
                        if (!Array.isArray(message.location))
                            return "location: array expected";
                        for (var i = 0; i < message.location.length; ++i) {
                            var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                            if (error)
                                return "location." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 */
                SourceCodeInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo)
                        return object;
                    var message = new $root.google.protobuf.SourceCodeInfo();
                    if (object.location) {
                        if (!Array.isArray(object.location))
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                        message.location = [];
                        for (var i = 0; i < object.location.length; ++i) {
                            if (typeof object.location[i] !== "object")
                                throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                            message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SourceCodeInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.location = [];
                    if (message.location && message.location.length) {
                        object.location = [];
                        for (var j = 0; j < message.location.length; ++j)
                            object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this SourceCodeInfo to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SourceCodeInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                SourceCodeInfo.Location = (function() {
    
                    /**
                     * Properties of a Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @interface ILocation
                     * @property {Array.<number>|null} [path] Location path
                     * @property {Array.<number>|null} [span] Location span
                     */
    
                    /**
                     * Constructs a new Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @classdesc Represents a Location.
                     * @implements ILocation
                     * @constructor
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     */
                    function Location(properties) {
                        this.path = [];
                        this.span = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Location path.
                     * @member {Array.<number>} path
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.path = $util.emptyArray;
    
                    /**
                     * Location span.
                     * @member {Array.<number>} span
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.span = $util.emptyArray;
    
                    /**
                     * Creates a new Location instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                     */
                    Location.create = function create(properties) {
                        return new Location(properties);
                    };
    
                    /**
                     * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.path != null && message.path.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.path.length; ++i)
                                writer.int32(message.path[i]);
                            writer.ldelim();
                        }
                        if (message.span != null && message.span.length) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork();
                            for (var i = 0; i < message.span.length; ++i)
                                writer.int32(message.span[i]);
                            writer.ldelim();
                        }
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                } else
                                    message.path.push(reader.int32());
                                break;
                            case 2:
                                if (!(message.span && message.span.length))
                                    message.span = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.span.push(reader.int32());
                                } else
                                    message.span.push(reader.int32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Location message.
                     * @function verify
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Location.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.path != null && message.hasOwnProperty("path")) {
                            if (!Array.isArray(message.path))
                                return "path: array expected";
                            for (var i = 0; i < message.path.length; ++i)
                                if (!$util.isInteger(message.path[i]))
                                    return "path: integer[] expected";
                        }
                        if (message.span != null && message.hasOwnProperty("span")) {
                            if (!Array.isArray(message.span))
                                return "span: array expected";
                            for (var i = 0; i < message.span.length; ++i)
                                if (!$util.isInteger(message.span[i]))
                                    return "span: integer[] expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Location message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     */
                    Location.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                            return object;
                        var message = new $root.google.protobuf.SourceCodeInfo.Location();
                        if (object.path) {
                            if (!Array.isArray(object.path))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                            message.path = [];
                            for (var i = 0; i < object.path.length; ++i)
                                message.path[i] = object.path[i] | 0;
                        }
                        if (object.span) {
                            if (!Array.isArray(object.span))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                            message.span = [];
                            for (var i = 0; i < object.span.length; ++i)
                                message.span[i] = object.span[i] | 0;
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Location message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.Location} message Location
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Location.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.path = [];
                            object.span = [];
                        }
                        if (message.path && message.path.length) {
                            object.path = [];
                            for (var j = 0; j < message.path.length; ++j)
                                object.path[j] = message.path[j];
                        }
                        if (message.span && message.span.length) {
                            object.span = [];
                            for (var j = 0; j < message.span.length; ++j)
                                object.span[j] = message.span[j];
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Location to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Location.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Location;
                })();
    
                return SourceCodeInfo;
            })();
    
            return protobuf;
        })();
    
        return google;
    })();
    
    /**
     * DOTA_GameMode enum.
     * @exports DOTA_GameMode
     * @enum {number}
     * @property {number} DOTA_GAMEMODE_NONE=0 DOTA_GAMEMODE_NONE value
     * @property {number} DOTA_GAMEMODE_AP=1 DOTA_GAMEMODE_AP value
     * @property {number} DOTA_GAMEMODE_CM=2 DOTA_GAMEMODE_CM value
     * @property {number} DOTA_GAMEMODE_RD=3 DOTA_GAMEMODE_RD value
     * @property {number} DOTA_GAMEMODE_SD=4 DOTA_GAMEMODE_SD value
     * @property {number} DOTA_GAMEMODE_AR=5 DOTA_GAMEMODE_AR value
     * @property {number} DOTA_GAMEMODE_INTRO=6 DOTA_GAMEMODE_INTRO value
     * @property {number} DOTA_GAMEMODE_HW=7 DOTA_GAMEMODE_HW value
     * @property {number} DOTA_GAMEMODE_REVERSE_CM=8 DOTA_GAMEMODE_REVERSE_CM value
     * @property {number} DOTA_GAMEMODE_XMAS=9 DOTA_GAMEMODE_XMAS value
     * @property {number} DOTA_GAMEMODE_TUTORIAL=10 DOTA_GAMEMODE_TUTORIAL value
     * @property {number} DOTA_GAMEMODE_MO=11 DOTA_GAMEMODE_MO value
     * @property {number} DOTA_GAMEMODE_LP=12 DOTA_GAMEMODE_LP value
     * @property {number} DOTA_GAMEMODE_POOL1=13 DOTA_GAMEMODE_POOL1 value
     * @property {number} DOTA_GAMEMODE_FH=14 DOTA_GAMEMODE_FH value
     * @property {number} DOTA_GAMEMODE_CUSTOM=15 DOTA_GAMEMODE_CUSTOM value
     * @property {number} DOTA_GAMEMODE_CD=16 DOTA_GAMEMODE_CD value
     * @property {number} DOTA_GAMEMODE_BD=17 DOTA_GAMEMODE_BD value
     * @property {number} DOTA_GAMEMODE_ABILITY_DRAFT=18 DOTA_GAMEMODE_ABILITY_DRAFT value
     * @property {number} DOTA_GAMEMODE_EVENT=19 DOTA_GAMEMODE_EVENT value
     * @property {number} DOTA_GAMEMODE_ARDM=20 DOTA_GAMEMODE_ARDM value
     * @property {number} DOTA_GAMEMODE_1V1MID=21 DOTA_GAMEMODE_1V1MID value
     * @property {number} DOTA_GAMEMODE_ALL_DRAFT=22 DOTA_GAMEMODE_ALL_DRAFT value
     * @property {number} DOTA_GAMEMODE_TURBO=23 DOTA_GAMEMODE_TURBO value
     * @property {number} DOTA_GAMEMODE_MUTATION=24 DOTA_GAMEMODE_MUTATION value
     * @property {number} DOTA_GAMEMODE_COACHES_CHALLENGE=25 DOTA_GAMEMODE_COACHES_CHALLENGE value
     */
    $root.DOTA_GameMode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_GAMEMODE_NONE"] = 0;
        values[valuesById[1] = "DOTA_GAMEMODE_AP"] = 1;
        values[valuesById[2] = "DOTA_GAMEMODE_CM"] = 2;
        values[valuesById[3] = "DOTA_GAMEMODE_RD"] = 3;
        values[valuesById[4] = "DOTA_GAMEMODE_SD"] = 4;
        values[valuesById[5] = "DOTA_GAMEMODE_AR"] = 5;
        values[valuesById[6] = "DOTA_GAMEMODE_INTRO"] = 6;
        values[valuesById[7] = "DOTA_GAMEMODE_HW"] = 7;
        values[valuesById[8] = "DOTA_GAMEMODE_REVERSE_CM"] = 8;
        values[valuesById[9] = "DOTA_GAMEMODE_XMAS"] = 9;
        values[valuesById[10] = "DOTA_GAMEMODE_TUTORIAL"] = 10;
        values[valuesById[11] = "DOTA_GAMEMODE_MO"] = 11;
        values[valuesById[12] = "DOTA_GAMEMODE_LP"] = 12;
        values[valuesById[13] = "DOTA_GAMEMODE_POOL1"] = 13;
        values[valuesById[14] = "DOTA_GAMEMODE_FH"] = 14;
        values[valuesById[15] = "DOTA_GAMEMODE_CUSTOM"] = 15;
        values[valuesById[16] = "DOTA_GAMEMODE_CD"] = 16;
        values[valuesById[17] = "DOTA_GAMEMODE_BD"] = 17;
        values[valuesById[18] = "DOTA_GAMEMODE_ABILITY_DRAFT"] = 18;
        values[valuesById[19] = "DOTA_GAMEMODE_EVENT"] = 19;
        values[valuesById[20] = "DOTA_GAMEMODE_ARDM"] = 20;
        values[valuesById[21] = "DOTA_GAMEMODE_1V1MID"] = 21;
        values[valuesById[22] = "DOTA_GAMEMODE_ALL_DRAFT"] = 22;
        values[valuesById[23] = "DOTA_GAMEMODE_TURBO"] = 23;
        values[valuesById[24] = "DOTA_GAMEMODE_MUTATION"] = 24;
        values[valuesById[25] = "DOTA_GAMEMODE_COACHES_CHALLENGE"] = 25;
        return values;
    })();
    
    /**
     * DOTA_GameState enum.
     * @exports DOTA_GameState
     * @enum {number}
     * @property {number} DOTA_GAMERULES_STATE_INIT=0 DOTA_GAMERULES_STATE_INIT value
     * @property {number} DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD=1 DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD value
     * @property {number} DOTA_GAMERULES_STATE_HERO_SELECTION=2 DOTA_GAMERULES_STATE_HERO_SELECTION value
     * @property {number} DOTA_GAMERULES_STATE_STRATEGY_TIME=3 DOTA_GAMERULES_STATE_STRATEGY_TIME value
     * @property {number} DOTA_GAMERULES_STATE_PRE_GAME=4 DOTA_GAMERULES_STATE_PRE_GAME value
     * @property {number} DOTA_GAMERULES_STATE_GAME_IN_PROGRESS=5 DOTA_GAMERULES_STATE_GAME_IN_PROGRESS value
     * @property {number} DOTA_GAMERULES_STATE_POST_GAME=6 DOTA_GAMERULES_STATE_POST_GAME value
     * @property {number} DOTA_GAMERULES_STATE_DISCONNECT=7 DOTA_GAMERULES_STATE_DISCONNECT value
     * @property {number} DOTA_GAMERULES_STATE_TEAM_SHOWCASE=8 DOTA_GAMERULES_STATE_TEAM_SHOWCASE value
     * @property {number} DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP=9 DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP value
     * @property {number} DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD=10 DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD value
     * @property {number} DOTA_GAMERULES_STATE_LAST=11 DOTA_GAMERULES_STATE_LAST value
     */
    $root.DOTA_GameState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_GAMERULES_STATE_INIT"] = 0;
        values[valuesById[1] = "DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD"] = 1;
        values[valuesById[2] = "DOTA_GAMERULES_STATE_HERO_SELECTION"] = 2;
        values[valuesById[3] = "DOTA_GAMERULES_STATE_STRATEGY_TIME"] = 3;
        values[valuesById[4] = "DOTA_GAMERULES_STATE_PRE_GAME"] = 4;
        values[valuesById[5] = "DOTA_GAMERULES_STATE_GAME_IN_PROGRESS"] = 5;
        values[valuesById[6] = "DOTA_GAMERULES_STATE_POST_GAME"] = 6;
        values[valuesById[7] = "DOTA_GAMERULES_STATE_DISCONNECT"] = 7;
        values[valuesById[8] = "DOTA_GAMERULES_STATE_TEAM_SHOWCASE"] = 8;
        values[valuesById[9] = "DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP"] = 9;
        values[valuesById[10] = "DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD"] = 10;
        values[valuesById[11] = "DOTA_GAMERULES_STATE_LAST"] = 11;
        return values;
    })();
    
    /**
     * DOTA_GC_TEAM enum.
     * @exports DOTA_GC_TEAM
     * @enum {number}
     * @property {number} DOTA_GC_TEAM_GOOD_GUYS=0 DOTA_GC_TEAM_GOOD_GUYS value
     * @property {number} DOTA_GC_TEAM_BAD_GUYS=1 DOTA_GC_TEAM_BAD_GUYS value
     * @property {number} DOTA_GC_TEAM_BROADCASTER=2 DOTA_GC_TEAM_BROADCASTER value
     * @property {number} DOTA_GC_TEAM_SPECTATOR=3 DOTA_GC_TEAM_SPECTATOR value
     * @property {number} DOTA_GC_TEAM_PLAYER_POOL=4 DOTA_GC_TEAM_PLAYER_POOL value
     * @property {number} DOTA_GC_TEAM_NOTEAM=5 DOTA_GC_TEAM_NOTEAM value
     */
    $root.DOTA_GC_TEAM = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_GC_TEAM_GOOD_GUYS"] = 0;
        values[valuesById[1] = "DOTA_GC_TEAM_BAD_GUYS"] = 1;
        values[valuesById[2] = "DOTA_GC_TEAM_BROADCASTER"] = 2;
        values[valuesById[3] = "DOTA_GC_TEAM_SPECTATOR"] = 3;
        values[valuesById[4] = "DOTA_GC_TEAM_PLAYER_POOL"] = 4;
        values[valuesById[5] = "DOTA_GC_TEAM_NOTEAM"] = 5;
        return values;
    })();
    
    /**
     * EEvent enum.
     * @exports EEvent
     * @enum {number}
     * @property {number} EVENT_ID_NONE=0 EVENT_ID_NONE value
     * @property {number} EVENT_ID_DIRETIDE=1 EVENT_ID_DIRETIDE value
     * @property {number} EVENT_ID_SPRING_FESTIVAL=2 EVENT_ID_SPRING_FESTIVAL value
     * @property {number} EVENT_ID_FROSTIVUS_2013=3 EVENT_ID_FROSTIVUS_2013 value
     * @property {number} EVENT_ID_COMPENDIUM_2014=4 EVENT_ID_COMPENDIUM_2014 value
     * @property {number} EVENT_ID_NEXON_PC_BANG=5 EVENT_ID_NEXON_PC_BANG value
     * @property {number} EVENT_ID_PWRD_DAC_2015=6 EVENT_ID_PWRD_DAC_2015 value
     * @property {number} EVENT_ID_NEW_BLOOM_2015=7 EVENT_ID_NEW_BLOOM_2015 value
     * @property {number} EVENT_ID_INTERNATIONAL_2015=8 EVENT_ID_INTERNATIONAL_2015 value
     * @property {number} EVENT_ID_FALL_MAJOR_2015=9 EVENT_ID_FALL_MAJOR_2015 value
     * @property {number} EVENT_ID_ORACLE_PA=10 EVENT_ID_ORACLE_PA value
     * @property {number} EVENT_ID_NEW_BLOOM_2015_PREBEAST=11 EVENT_ID_NEW_BLOOM_2015_PREBEAST value
     * @property {number} EVENT_ID_FROSTIVUS=12 EVENT_ID_FROSTIVUS value
     * @property {number} EVENT_ID_WINTER_MAJOR_2016=13 EVENT_ID_WINTER_MAJOR_2016 value
     * @property {number} EVENT_ID_INTERNATIONAL_2016=14 EVENT_ID_INTERNATIONAL_2016 value
     * @property {number} EVENT_ID_FALL_MAJOR_2016=15 EVENT_ID_FALL_MAJOR_2016 value
     * @property {number} EVENT_ID_WINTER_MAJOR_2017=16 EVENT_ID_WINTER_MAJOR_2017 value
     * @property {number} EVENT_ID_NEW_BLOOM_2017=17 EVENT_ID_NEW_BLOOM_2017 value
     * @property {number} EVENT_ID_INTERNATIONAL_2017=18 EVENT_ID_INTERNATIONAL_2017 value
     * @property {number} EVENT_ID_PLUS_SUBSCRIPTION=19 EVENT_ID_PLUS_SUBSCRIPTION value
     * @property {number} EVENT_ID_SINGLES_DAY_2017=20 EVENT_ID_SINGLES_DAY_2017 value
     * @property {number} EVENT_ID_FROSTIVUS_2017=21 EVENT_ID_FROSTIVUS_2017 value
     * @property {number} EVENT_ID_INTERNATIONAL_2018=22 EVENT_ID_INTERNATIONAL_2018 value
     * @property {number} EVENT_ID_FROSTIVUS_2018=23 EVENT_ID_FROSTIVUS_2018 value
     * @property {number} EVENT_ID_NEW_BLOOM_2019=24 EVENT_ID_NEW_BLOOM_2019 value
     * @property {number} EVENT_ID_INTERNATIONAL_2019=25 EVENT_ID_INTERNATIONAL_2019 value
     * @property {number} EVENT_ID_NEW_PLAYER_EXPERIENCE=26 EVENT_ID_NEW_PLAYER_EXPERIENCE value
     * @property {number} EVENT_ID_FROSTIVUS_2019=27 EVENT_ID_FROSTIVUS_2019 value
     * @property {number} EVENT_ID_NEW_BLOOM_2020=28 EVENT_ID_NEW_BLOOM_2020 value
     * @property {number} EVENT_ID_INTERNATIONAL_2020=29 EVENT_ID_INTERNATIONAL_2020 value
     * @property {number} EVENT_ID_TEAM_FANDOM=30 EVENT_ID_TEAM_FANDOM value
     * @property {number} EVENT_ID_DIRETIDE_2020=31 EVENT_ID_DIRETIDE_2020 value
     * @property {number} EVENT_ID_COUNT=32 EVENT_ID_COUNT value
     */
    $root.EEvent = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "EVENT_ID_NONE"] = 0;
        values[valuesById[1] = "EVENT_ID_DIRETIDE"] = 1;
        values[valuesById[2] = "EVENT_ID_SPRING_FESTIVAL"] = 2;
        values[valuesById[3] = "EVENT_ID_FROSTIVUS_2013"] = 3;
        values[valuesById[4] = "EVENT_ID_COMPENDIUM_2014"] = 4;
        values[valuesById[5] = "EVENT_ID_NEXON_PC_BANG"] = 5;
        values[valuesById[6] = "EVENT_ID_PWRD_DAC_2015"] = 6;
        values[valuesById[7] = "EVENT_ID_NEW_BLOOM_2015"] = 7;
        values[valuesById[8] = "EVENT_ID_INTERNATIONAL_2015"] = 8;
        values[valuesById[9] = "EVENT_ID_FALL_MAJOR_2015"] = 9;
        values[valuesById[10] = "EVENT_ID_ORACLE_PA"] = 10;
        values[valuesById[11] = "EVENT_ID_NEW_BLOOM_2015_PREBEAST"] = 11;
        values[valuesById[12] = "EVENT_ID_FROSTIVUS"] = 12;
        values[valuesById[13] = "EVENT_ID_WINTER_MAJOR_2016"] = 13;
        values[valuesById[14] = "EVENT_ID_INTERNATIONAL_2016"] = 14;
        values[valuesById[15] = "EVENT_ID_FALL_MAJOR_2016"] = 15;
        values[valuesById[16] = "EVENT_ID_WINTER_MAJOR_2017"] = 16;
        values[valuesById[17] = "EVENT_ID_NEW_BLOOM_2017"] = 17;
        values[valuesById[18] = "EVENT_ID_INTERNATIONAL_2017"] = 18;
        values[valuesById[19] = "EVENT_ID_PLUS_SUBSCRIPTION"] = 19;
        values[valuesById[20] = "EVENT_ID_SINGLES_DAY_2017"] = 20;
        values[valuesById[21] = "EVENT_ID_FROSTIVUS_2017"] = 21;
        values[valuesById[22] = "EVENT_ID_INTERNATIONAL_2018"] = 22;
        values[valuesById[23] = "EVENT_ID_FROSTIVUS_2018"] = 23;
        values[valuesById[24] = "EVENT_ID_NEW_BLOOM_2019"] = 24;
        values[valuesById[25] = "EVENT_ID_INTERNATIONAL_2019"] = 25;
        values[valuesById[26] = "EVENT_ID_NEW_PLAYER_EXPERIENCE"] = 26;
        values[valuesById[27] = "EVENT_ID_FROSTIVUS_2019"] = 27;
        values[valuesById[28] = "EVENT_ID_NEW_BLOOM_2020"] = 28;
        values[valuesById[29] = "EVENT_ID_INTERNATIONAL_2020"] = 29;
        values[valuesById[30] = "EVENT_ID_TEAM_FANDOM"] = 30;
        values[valuesById[31] = "EVENT_ID_DIRETIDE_2020"] = 31;
        values[valuesById[32] = "EVENT_ID_COUNT"] = 32;
        return values;
    })();
    
    /**
     * DOTALeaverStatus_t enum.
     * @exports DOTALeaverStatus_t
     * @enum {number}
     * @property {number} DOTA_LEAVER_NONE=0 DOTA_LEAVER_NONE value
     * @property {number} DOTA_LEAVER_DISCONNECTED=1 DOTA_LEAVER_DISCONNECTED value
     * @property {number} DOTA_LEAVER_DISCONNECTED_TOO_LONG=2 DOTA_LEAVER_DISCONNECTED_TOO_LONG value
     * @property {number} DOTA_LEAVER_ABANDONED=3 DOTA_LEAVER_ABANDONED value
     * @property {number} DOTA_LEAVER_AFK=4 DOTA_LEAVER_AFK value
     * @property {number} DOTA_LEAVER_NEVER_CONNECTED=5 DOTA_LEAVER_NEVER_CONNECTED value
     * @property {number} DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG=6 DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG value
     * @property {number} DOTA_LEAVER_FAILED_TO_READY_UP=7 DOTA_LEAVER_FAILED_TO_READY_UP value
     * @property {number} DOTA_LEAVER_DECLINED=8 DOTA_LEAVER_DECLINED value
     */
    $root.DOTALeaverStatus_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_LEAVER_NONE"] = 0;
        values[valuesById[1] = "DOTA_LEAVER_DISCONNECTED"] = 1;
        values[valuesById[2] = "DOTA_LEAVER_DISCONNECTED_TOO_LONG"] = 2;
        values[valuesById[3] = "DOTA_LEAVER_ABANDONED"] = 3;
        values[valuesById[4] = "DOTA_LEAVER_AFK"] = 4;
        values[valuesById[5] = "DOTA_LEAVER_NEVER_CONNECTED"] = 5;
        values[valuesById[6] = "DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG"] = 6;
        values[valuesById[7] = "DOTA_LEAVER_FAILED_TO_READY_UP"] = 7;
        values[valuesById[8] = "DOTA_LEAVER_DECLINED"] = 8;
        return values;
    })();
    
    /**
     * DOTAConnectionState_t enum.
     * @exports DOTAConnectionState_t
     * @enum {number}
     * @property {number} DOTA_CONNECTION_STATE_UNKNOWN=0 DOTA_CONNECTION_STATE_UNKNOWN value
     * @property {number} DOTA_CONNECTION_STATE_NOT_YET_CONNECTED=1 DOTA_CONNECTION_STATE_NOT_YET_CONNECTED value
     * @property {number} DOTA_CONNECTION_STATE_CONNECTED=2 DOTA_CONNECTION_STATE_CONNECTED value
     * @property {number} DOTA_CONNECTION_STATE_DISCONNECTED=3 DOTA_CONNECTION_STATE_DISCONNECTED value
     * @property {number} DOTA_CONNECTION_STATE_ABANDONED=4 DOTA_CONNECTION_STATE_ABANDONED value
     * @property {number} DOTA_CONNECTION_STATE_LOADING=5 DOTA_CONNECTION_STATE_LOADING value
     * @property {number} DOTA_CONNECTION_STATE_FAILED=6 DOTA_CONNECTION_STATE_FAILED value
     */
    $root.DOTAConnectionState_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_CONNECTION_STATE_UNKNOWN"] = 0;
        values[valuesById[1] = "DOTA_CONNECTION_STATE_NOT_YET_CONNECTED"] = 1;
        values[valuesById[2] = "DOTA_CONNECTION_STATE_CONNECTED"] = 2;
        values[valuesById[3] = "DOTA_CONNECTION_STATE_DISCONNECTED"] = 3;
        values[valuesById[4] = "DOTA_CONNECTION_STATE_ABANDONED"] = 4;
        values[valuesById[5] = "DOTA_CONNECTION_STATE_LOADING"] = 5;
        values[valuesById[6] = "DOTA_CONNECTION_STATE_FAILED"] = 6;
        return values;
    })();
    
    /**
     * Fantasy_Roles enum.
     * @exports Fantasy_Roles
     * @enum {number}
     * @property {number} FANTASY_ROLE_UNDEFINED=0 FANTASY_ROLE_UNDEFINED value
     * @property {number} FANTASY_ROLE_CORE=1 FANTASY_ROLE_CORE value
     * @property {number} FANTASY_ROLE_SUPPORT=2 FANTASY_ROLE_SUPPORT value
     * @property {number} FANTASY_ROLE_OFFLANE=3 FANTASY_ROLE_OFFLANE value
     * @property {number} FANTASY_ROLE_MID=4 FANTASY_ROLE_MID value
     */
    $root.Fantasy_Roles = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FANTASY_ROLE_UNDEFINED"] = 0;
        values[valuesById[1] = "FANTASY_ROLE_CORE"] = 1;
        values[valuesById[2] = "FANTASY_ROLE_SUPPORT"] = 2;
        values[valuesById[3] = "FANTASY_ROLE_OFFLANE"] = 3;
        values[valuesById[4] = "FANTASY_ROLE_MID"] = 4;
        return values;
    })();
    
    /**
     * Fantasy_Team_Slots enum.
     * @exports Fantasy_Team_Slots
     * @enum {number}
     * @property {number} FANTASY_SLOT_NONE=0 FANTASY_SLOT_NONE value
     * @property {number} FANTASY_SLOT_CORE=1 FANTASY_SLOT_CORE value
     * @property {number} FANTASY_SLOT_SUPPORT=2 FANTASY_SLOT_SUPPORT value
     * @property {number} FANTASY_SLOT_ANY=3 FANTASY_SLOT_ANY value
     * @property {number} FANTASY_SLOT_BENCH=4 FANTASY_SLOT_BENCH value
     */
    $root.Fantasy_Team_Slots = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FANTASY_SLOT_NONE"] = 0;
        values[valuesById[1] = "FANTASY_SLOT_CORE"] = 1;
        values[valuesById[2] = "FANTASY_SLOT_SUPPORT"] = 2;
        values[valuesById[3] = "FANTASY_SLOT_ANY"] = 3;
        values[valuesById[4] = "FANTASY_SLOT_BENCH"] = 4;
        return values;
    })();
    
    /**
     * Fantasy_Selection_Mode enum.
     * @exports Fantasy_Selection_Mode
     * @enum {number}
     * @property {number} FANTASY_SELECTION_INVALID=0 FANTASY_SELECTION_INVALID value
     * @property {number} FANTASY_SELECTION_LOCKED=1 FANTASY_SELECTION_LOCKED value
     * @property {number} FANTASY_SELECTION_SHUFFLE=2 FANTASY_SELECTION_SHUFFLE value
     * @property {number} FANTASY_SELECTION_FREE_PICK=3 FANTASY_SELECTION_FREE_PICK value
     * @property {number} FANTASY_SELECTION_ENDED=4 FANTASY_SELECTION_ENDED value
     * @property {number} FANTASY_SELECTION_PRE_SEASON=5 FANTASY_SELECTION_PRE_SEASON value
     * @property {number} FANTASY_SELECTION_PRE_DRAFT=6 FANTASY_SELECTION_PRE_DRAFT value
     * @property {number} FANTASY_SELECTION_DRAFTING=7 FANTASY_SELECTION_DRAFTING value
     * @property {number} FANTASY_SELECTION_REGULAR_SEASON=8 FANTASY_SELECTION_REGULAR_SEASON value
     * @property {number} FANTASY_SELECTION_CARD_BASED=9 FANTASY_SELECTION_CARD_BASED value
     */
    $root.Fantasy_Selection_Mode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FANTASY_SELECTION_INVALID"] = 0;
        values[valuesById[1] = "FANTASY_SELECTION_LOCKED"] = 1;
        values[valuesById[2] = "FANTASY_SELECTION_SHUFFLE"] = 2;
        values[valuesById[3] = "FANTASY_SELECTION_FREE_PICK"] = 3;
        values[valuesById[4] = "FANTASY_SELECTION_ENDED"] = 4;
        values[valuesById[5] = "FANTASY_SELECTION_PRE_SEASON"] = 5;
        values[valuesById[6] = "FANTASY_SELECTION_PRE_DRAFT"] = 6;
        values[valuesById[7] = "FANTASY_SELECTION_DRAFTING"] = 7;
        values[valuesById[8] = "FANTASY_SELECTION_REGULAR_SEASON"] = 8;
        values[valuesById[9] = "FANTASY_SELECTION_CARD_BASED"] = 9;
        return values;
    })();
    
    /**
     * DOTAChatChannelType_t enum.
     * @exports DOTAChatChannelType_t
     * @enum {number}
     * @property {number} DOTAChannelType_Regional=0 DOTAChannelType_Regional value
     * @property {number} DOTAChannelType_Custom=1 DOTAChannelType_Custom value
     * @property {number} DOTAChannelType_Party=2 DOTAChannelType_Party value
     * @property {number} DOTAChannelType_Lobby=3 DOTAChannelType_Lobby value
     * @property {number} DOTAChannelType_Team=4 DOTAChannelType_Team value
     * @property {number} DOTAChannelType_Guild=5 DOTAChannelType_Guild value
     * @property {number} DOTAChannelType_Fantasy=6 DOTAChannelType_Fantasy value
     * @property {number} DOTAChannelType_Whisper=7 DOTAChannelType_Whisper value
     * @property {number} DOTAChannelType_Console=8 DOTAChannelType_Console value
     * @property {number} DOTAChannelType_Tab=9 DOTAChannelType_Tab value
     * @property {number} DOTAChannelType_Invalid=10 DOTAChannelType_Invalid value
     * @property {number} DOTAChannelType_GameAll=11 DOTAChannelType_GameAll value
     * @property {number} DOTAChannelType_GameAllies=12 DOTAChannelType_GameAllies value
     * @property {number} DOTAChannelType_GameSpectator=13 DOTAChannelType_GameSpectator value
     * @property {number} DOTAChannelType_Cafe=15 DOTAChannelType_Cafe value
     * @property {number} DOTAChannelType_CustomGame=16 DOTAChannelType_CustomGame value
     * @property {number} DOTAChannelType_Private=17 DOTAChannelType_Private value
     * @property {number} DOTAChannelType_PostGame=18 DOTAChannelType_PostGame value
     * @property {number} DOTAChannelType_BattleCup=19 DOTAChannelType_BattleCup value
     * @property {number} DOTAChannelType_HLTVSpectator=20 DOTAChannelType_HLTVSpectator value
     * @property {number} DOTAChannelType_GameEvents=21 DOTAChannelType_GameEvents value
     * @property {number} DOTAChannelType_Trivia=22 DOTAChannelType_Trivia value
     */
    $root.DOTAChatChannelType_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTAChannelType_Regional"] = 0;
        values[valuesById[1] = "DOTAChannelType_Custom"] = 1;
        values[valuesById[2] = "DOTAChannelType_Party"] = 2;
        values[valuesById[3] = "DOTAChannelType_Lobby"] = 3;
        values[valuesById[4] = "DOTAChannelType_Team"] = 4;
        values[valuesById[5] = "DOTAChannelType_Guild"] = 5;
        values[valuesById[6] = "DOTAChannelType_Fantasy"] = 6;
        values[valuesById[7] = "DOTAChannelType_Whisper"] = 7;
        values[valuesById[8] = "DOTAChannelType_Console"] = 8;
        values[valuesById[9] = "DOTAChannelType_Tab"] = 9;
        values[valuesById[10] = "DOTAChannelType_Invalid"] = 10;
        values[valuesById[11] = "DOTAChannelType_GameAll"] = 11;
        values[valuesById[12] = "DOTAChannelType_GameAllies"] = 12;
        values[valuesById[13] = "DOTAChannelType_GameSpectator"] = 13;
        values[valuesById[15] = "DOTAChannelType_Cafe"] = 15;
        values[valuesById[16] = "DOTAChannelType_CustomGame"] = 16;
        values[valuesById[17] = "DOTAChannelType_Private"] = 17;
        values[valuesById[18] = "DOTAChannelType_PostGame"] = 18;
        values[valuesById[19] = "DOTAChannelType_BattleCup"] = 19;
        values[valuesById[20] = "DOTAChannelType_HLTVSpectator"] = 20;
        values[valuesById[21] = "DOTAChannelType_GameEvents"] = 21;
        values[valuesById[22] = "DOTAChannelType_Trivia"] = 22;
        return values;
    })();
    
    /**
     * EProfileCardSlotType enum.
     * @exports EProfileCardSlotType
     * @enum {number}
     * @property {number} k_EProfileCardSlotType_Empty=0 k_EProfileCardSlotType_Empty value
     * @property {number} k_EProfileCardSlotType_Stat=1 k_EProfileCardSlotType_Stat value
     * @property {number} k_EProfileCardSlotType_Trophy=2 k_EProfileCardSlotType_Trophy value
     * @property {number} k_EProfileCardSlotType_Item=3 k_EProfileCardSlotType_Item value
     * @property {number} k_EProfileCardSlotType_Hero=4 k_EProfileCardSlotType_Hero value
     * @property {number} k_EProfileCardSlotType_Emoticon=5 k_EProfileCardSlotType_Emoticon value
     * @property {number} k_EProfileCardSlotType_Team=6 k_EProfileCardSlotType_Team value
     */
    $root.EProfileCardSlotType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_EProfileCardSlotType_Empty"] = 0;
        values[valuesById[1] = "k_EProfileCardSlotType_Stat"] = 1;
        values[valuesById[2] = "k_EProfileCardSlotType_Trophy"] = 2;
        values[valuesById[3] = "k_EProfileCardSlotType_Item"] = 3;
        values[valuesById[4] = "k_EProfileCardSlotType_Hero"] = 4;
        values[valuesById[5] = "k_EProfileCardSlotType_Emoticon"] = 5;
        values[valuesById[6] = "k_EProfileCardSlotType_Team"] = 6;
        return values;
    })();
    
    /**
     * EMatchGroupServerStatus enum.
     * @exports EMatchGroupServerStatus
     * @enum {number}
     * @property {number} k_EMatchGroupServerStatus_OK=0 k_EMatchGroupServerStatus_OK value
     * @property {number} k_EMatchGroupServerStatus_LimitedAvailability=1 k_EMatchGroupServerStatus_LimitedAvailability value
     * @property {number} k_EMatchGroupServerStatus_Offline=2 k_EMatchGroupServerStatus_Offline value
     */
    $root.EMatchGroupServerStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_EMatchGroupServerStatus_OK"] = 0;
        values[valuesById[1] = "k_EMatchGroupServerStatus_LimitedAvailability"] = 1;
        values[valuesById[2] = "k_EMatchGroupServerStatus_Offline"] = 2;
        return values;
    })();
    
    /**
     * DOTA_CM_PICK enum.
     * @exports DOTA_CM_PICK
     * @enum {number}
     * @property {number} DOTA_CM_RANDOM=0 DOTA_CM_RANDOM value
     * @property {number} DOTA_CM_GOOD_GUYS=1 DOTA_CM_GOOD_GUYS value
     * @property {number} DOTA_CM_BAD_GUYS=2 DOTA_CM_BAD_GUYS value
     */
    $root.DOTA_CM_PICK = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_CM_RANDOM"] = 0;
        values[valuesById[1] = "DOTA_CM_GOOD_GUYS"] = 1;
        values[valuesById[2] = "DOTA_CM_BAD_GUYS"] = 2;
        return values;
    })();
    
    /**
     * DOTALowPriorityBanType enum.
     * @exports DOTALowPriorityBanType
     * @enum {number}
     * @property {number} DOTA_LOW_PRIORITY_BAN_ABANDON=0 DOTA_LOW_PRIORITY_BAN_ABANDON value
     * @property {number} DOTA_LOW_PRIORITY_BAN_REPORTS=1 DOTA_LOW_PRIORITY_BAN_REPORTS value
     * @property {number} DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON=2 DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON value
     * @property {number} DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE=3 DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE value
     */
    $root.DOTALowPriorityBanType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_LOW_PRIORITY_BAN_ABANDON"] = 0;
        values[valuesById[1] = "DOTA_LOW_PRIORITY_BAN_REPORTS"] = 1;
        values[valuesById[2] = "DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON"] = 2;
        values[valuesById[3] = "DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE"] = 3;
        return values;
    })();
    
    /**
     * DOTALobbyReadyState enum.
     * @exports DOTALobbyReadyState
     * @enum {number}
     * @property {number} DOTALobbyReadyState_UNDECLARED=0 DOTALobbyReadyState_UNDECLARED value
     * @property {number} DOTALobbyReadyState_ACCEPTED=1 DOTALobbyReadyState_ACCEPTED value
     * @property {number} DOTALobbyReadyState_DECLINED=2 DOTALobbyReadyState_DECLINED value
     */
    $root.DOTALobbyReadyState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTALobbyReadyState_UNDECLARED"] = 0;
        values[valuesById[1] = "DOTALobbyReadyState_ACCEPTED"] = 1;
        values[valuesById[2] = "DOTALobbyReadyState_DECLINED"] = 2;
        return values;
    })();
    
    /**
     * DOTAGameVersion enum.
     * @exports DOTAGameVersion
     * @enum {number}
     * @property {number} GAME_VERSION_CURRENT=0 GAME_VERSION_CURRENT value
     * @property {number} GAME_VERSION_STABLE=1 GAME_VERSION_STABLE value
     */
    $root.DOTAGameVersion = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "GAME_VERSION_CURRENT"] = 0;
        values[valuesById[1] = "GAME_VERSION_STABLE"] = 1;
        return values;
    })();
    
    /**
     * DOTAJoinLobbyResult enum.
     * @exports DOTAJoinLobbyResult
     * @enum {number}
     * @property {number} DOTA_JOIN_RESULT_SUCCESS=0 DOTA_JOIN_RESULT_SUCCESS value
     * @property {number} DOTA_JOIN_RESULT_ALREADY_IN_GAME=1 DOTA_JOIN_RESULT_ALREADY_IN_GAME value
     * @property {number} DOTA_JOIN_RESULT_INVALID_LOBBY=2 DOTA_JOIN_RESULT_INVALID_LOBBY value
     * @property {number} DOTA_JOIN_RESULT_INCORRECT_PASSWORD=3 DOTA_JOIN_RESULT_INCORRECT_PASSWORD value
     * @property {number} DOTA_JOIN_RESULT_ACCESS_DENIED=4 DOTA_JOIN_RESULT_ACCESS_DENIED value
     * @property {number} DOTA_JOIN_RESULT_GENERIC_ERROR=5 DOTA_JOIN_RESULT_GENERIC_ERROR value
     * @property {number} DOTA_JOIN_RESULT_INCORRECT_VERSION=6 DOTA_JOIN_RESULT_INCORRECT_VERSION value
     * @property {number} DOTA_JOIN_RESULT_IN_TEAM_PARTY=7 DOTA_JOIN_RESULT_IN_TEAM_PARTY value
     * @property {number} DOTA_JOIN_RESULT_NO_LOBBY_FOUND=8 DOTA_JOIN_RESULT_NO_LOBBY_FOUND value
     * @property {number} DOTA_JOIN_RESULT_LOBBY_FULL=9 DOTA_JOIN_RESULT_LOBBY_FULL value
     * @property {number} DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION=10 DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION value
     * @property {number} DOTA_JOIN_RESULT_TIMEOUT=11 DOTA_JOIN_RESULT_TIMEOUT value
     * @property {number} DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN=12 DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN value
     * @property {number} DOTA_JOIN_RESULT_BUSY=13 DOTA_JOIN_RESULT_BUSY value
     * @property {number} DOTA_JOIN_RESULT_NO_PLAYTIME=14 DOTA_JOIN_RESULT_NO_PLAYTIME value
     */
    $root.DOTAJoinLobbyResult = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_JOIN_RESULT_SUCCESS"] = 0;
        values[valuesById[1] = "DOTA_JOIN_RESULT_ALREADY_IN_GAME"] = 1;
        values[valuesById[2] = "DOTA_JOIN_RESULT_INVALID_LOBBY"] = 2;
        values[valuesById[3] = "DOTA_JOIN_RESULT_INCORRECT_PASSWORD"] = 3;
        values[valuesById[4] = "DOTA_JOIN_RESULT_ACCESS_DENIED"] = 4;
        values[valuesById[5] = "DOTA_JOIN_RESULT_GENERIC_ERROR"] = 5;
        values[valuesById[6] = "DOTA_JOIN_RESULT_INCORRECT_VERSION"] = 6;
        values[valuesById[7] = "DOTA_JOIN_RESULT_IN_TEAM_PARTY"] = 7;
        values[valuesById[8] = "DOTA_JOIN_RESULT_NO_LOBBY_FOUND"] = 8;
        values[valuesById[9] = "DOTA_JOIN_RESULT_LOBBY_FULL"] = 9;
        values[valuesById[10] = "DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION"] = 10;
        values[valuesById[11] = "DOTA_JOIN_RESULT_TIMEOUT"] = 11;
        values[valuesById[12] = "DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN"] = 12;
        values[valuesById[13] = "DOTA_JOIN_RESULT_BUSY"] = 13;
        values[valuesById[14] = "DOTA_JOIN_RESULT_NO_PLAYTIME"] = 14;
        return values;
    })();
    
    /**
     * DOTASelectionPriorityRules enum.
     * @exports DOTASelectionPriorityRules
     * @enum {number}
     * @property {number} k_DOTASelectionPriorityRules_Manual=0 k_DOTASelectionPriorityRules_Manual value
     * @property {number} k_DOTASelectionPriorityRules_Automatic=1 k_DOTASelectionPriorityRules_Automatic value
     */
    $root.DOTASelectionPriorityRules = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_DOTASelectionPriorityRules_Manual"] = 0;
        values[valuesById[1] = "k_DOTASelectionPriorityRules_Automatic"] = 1;
        return values;
    })();
    
    /**
     * DOTASelectionPriorityChoice enum.
     * @exports DOTASelectionPriorityChoice
     * @enum {number}
     * @property {number} k_DOTASelectionPriorityChoice_Invalid=0 k_DOTASelectionPriorityChoice_Invalid value
     * @property {number} k_DOTASelectionPriorityChoice_FirstPick=1 k_DOTASelectionPriorityChoice_FirstPick value
     * @property {number} k_DOTASelectionPriorityChoice_SecondPick=2 k_DOTASelectionPriorityChoice_SecondPick value
     * @property {number} k_DOTASelectionPriorityChoice_Radiant=3 k_DOTASelectionPriorityChoice_Radiant value
     * @property {number} k_DOTASelectionPriorityChoice_Dire=4 k_DOTASelectionPriorityChoice_Dire value
     */
    $root.DOTASelectionPriorityChoice = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_DOTASelectionPriorityChoice_Invalid"] = 0;
        values[valuesById[1] = "k_DOTASelectionPriorityChoice_FirstPick"] = 1;
        values[valuesById[2] = "k_DOTASelectionPriorityChoice_SecondPick"] = 2;
        values[valuesById[3] = "k_DOTASelectionPriorityChoice_Radiant"] = 3;
        values[valuesById[4] = "k_DOTASelectionPriorityChoice_Dire"] = 4;
        return values;
    })();
    
    /**
     * DOTAMatchVote enum.
     * @exports DOTAMatchVote
     * @enum {number}
     * @property {number} DOTAMatchVote_INVALID=0 DOTAMatchVote_INVALID value
     * @property {number} DOTAMatchVote_POSITIVE=1 DOTAMatchVote_POSITIVE value
     * @property {number} DOTAMatchVote_NEGATIVE=2 DOTAMatchVote_NEGATIVE value
     */
    $root.DOTAMatchVote = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTAMatchVote_INVALID"] = 0;
        values[valuesById[1] = "DOTAMatchVote_POSITIVE"] = 1;
        values[valuesById[2] = "DOTAMatchVote_NEGATIVE"] = 2;
        return values;
    })();
    
    /**
     * DOTALobbyVisibility enum.
     * @exports DOTALobbyVisibility
     * @enum {number}
     * @property {number} DOTALobbyVisibility_Public=0 DOTALobbyVisibility_Public value
     * @property {number} DOTALobbyVisibility_Friends=1 DOTALobbyVisibility_Friends value
     * @property {number} DOTALobbyVisibility_Unlisted=2 DOTALobbyVisibility_Unlisted value
     */
    $root.DOTALobbyVisibility = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTALobbyVisibility_Public"] = 0;
        values[valuesById[1] = "DOTALobbyVisibility_Friends"] = 1;
        values[valuesById[2] = "DOTALobbyVisibility_Unlisted"] = 2;
        return values;
    })();
    
    /**
     * EDOTAPlayerMMRType enum.
     * @exports EDOTAPlayerMMRType
     * @enum {number}
     * @property {number} k_EDOTAPlayerMMRType_Invalid=0 k_EDOTAPlayerMMRType_Invalid value
     * @property {number} k_EDOTAPlayerMMRType_GeneralHidden=1 k_EDOTAPlayerMMRType_GeneralHidden value
     * @property {number} k_EDOTAPlayerMMRType_GeneralCompetitive=3 k_EDOTAPlayerMMRType_GeneralCompetitive value
     * @property {number} k_EDOTAPlayerMMRType_SoloCompetitive2019=4 k_EDOTAPlayerMMRType_SoloCompetitive2019 value
     * @property {number} k_EDOTAPlayerMMRType_1v1Competitive_UNUSED=5 k_EDOTAPlayerMMRType_1v1Competitive_UNUSED value
     * @property {number} k_EDOTAPlayerMMRType_GeneralSeasonalRanked=6 k_EDOTAPlayerMMRType_GeneralSeasonalRanked value
     * @property {number} k_EDOTAPlayerMMRType_SoloSeasonalRanked=7 k_EDOTAPlayerMMRType_SoloSeasonalRanked value
     * @property {number} k_EDOTAPlayerMMRType_Competitive_Core=8 k_EDOTAPlayerMMRType_Competitive_Core value
     * @property {number} k_EDOTAPlayerMMRType_Competitive_Support=9 k_EDOTAPlayerMMRType_Competitive_Support value
     * @property {number} k_EDOTAPlayerMMRType_Competitive_Classic=10 k_EDOTAPlayerMMRType_Competitive_Classic value
     */
    $root.EDOTAPlayerMMRType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_EDOTAPlayerMMRType_Invalid"] = 0;
        values[valuesById[1] = "k_EDOTAPlayerMMRType_GeneralHidden"] = 1;
        values[valuesById[3] = "k_EDOTAPlayerMMRType_GeneralCompetitive"] = 3;
        values[valuesById[4] = "k_EDOTAPlayerMMRType_SoloCompetitive2019"] = 4;
        values[valuesById[5] = "k_EDOTAPlayerMMRType_1v1Competitive_UNUSED"] = 5;
        values[valuesById[6] = "k_EDOTAPlayerMMRType_GeneralSeasonalRanked"] = 6;
        values[valuesById[7] = "k_EDOTAPlayerMMRType_SoloSeasonalRanked"] = 7;
        values[valuesById[8] = "k_EDOTAPlayerMMRType_Competitive_Core"] = 8;
        values[valuesById[9] = "k_EDOTAPlayerMMRType_Competitive_Support"] = 9;
        values[valuesById[10] = "k_EDOTAPlayerMMRType_Competitive_Classic"] = 10;
        return values;
    })();
    
    /**
     * EDOTAMMRBoostType enum.
     * @exports EDOTAMMRBoostType
     * @enum {number}
     * @property {number} k_EDOTAMMRBoostType_None=0 k_EDOTAMMRBoostType_None value
     * @property {number} k_EDOTAMMRBoostType_Leader=1 k_EDOTAMMRBoostType_Leader value
     * @property {number} k_EDOTAMMRBoostType_Follower=2 k_EDOTAMMRBoostType_Follower value
     */
    $root.EDOTAMMRBoostType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_EDOTAMMRBoostType_None"] = 0;
        values[valuesById[1] = "k_EDOTAMMRBoostType_Leader"] = 1;
        values[valuesById[2] = "k_EDOTAMMRBoostType_Follower"] = 2;
        return values;
    })();
    
    /**
     * MatchType enum.
     * @exports MatchType
     * @enum {number}
     * @property {number} MATCH_TYPE_CASUAL=0 MATCH_TYPE_CASUAL value
     * @property {number} MATCH_TYPE_COOP_BOTS=1 MATCH_TYPE_COOP_BOTS value
     * @property {number} MATCH_TYPE_LEGACY_TEAM_RANKED=2 MATCH_TYPE_LEGACY_TEAM_RANKED value
     * @property {number} MATCH_TYPE_LEGACY_SOLO_QUEUE=3 MATCH_TYPE_LEGACY_SOLO_QUEUE value
     * @property {number} MATCH_TYPE_COMPETITIVE=4 MATCH_TYPE_COMPETITIVE value
     * @property {number} MATCH_TYPE_WEEKEND_TOURNEY=5 MATCH_TYPE_WEEKEND_TOURNEY value
     * @property {number} MATCH_TYPE_CASUAL_1V1=6 MATCH_TYPE_CASUAL_1V1 value
     * @property {number} MATCH_TYPE_EVENT=7 MATCH_TYPE_EVENT value
     * @property {number} MATCH_TYPE_SEASONAL_RANKED=8 MATCH_TYPE_SEASONAL_RANKED value
     * @property {number} MATCH_TYPE_LOWPRI_DEPRECATED=9 MATCH_TYPE_LOWPRI_DEPRECATED value
     * @property {number} MATCH_TYPE_STEAM_GROUP=10 MATCH_TYPE_STEAM_GROUP value
     * @property {number} MATCH_TYPE_MUTATION=11 MATCH_TYPE_MUTATION value
     * @property {number} MATCH_TYPE_COACHES_CHALLENGE=12 MATCH_TYPE_COACHES_CHALLENGE value
     * @property {number} MATCH_TYPE_GAUNTLET=13 MATCH_TYPE_GAUNTLET value
     */
    $root.MatchType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MATCH_TYPE_CASUAL"] = 0;
        values[valuesById[1] = "MATCH_TYPE_COOP_BOTS"] = 1;
        values[valuesById[2] = "MATCH_TYPE_LEGACY_TEAM_RANKED"] = 2;
        values[valuesById[3] = "MATCH_TYPE_LEGACY_SOLO_QUEUE"] = 3;
        values[valuesById[4] = "MATCH_TYPE_COMPETITIVE"] = 4;
        values[valuesById[5] = "MATCH_TYPE_WEEKEND_TOURNEY"] = 5;
        values[valuesById[6] = "MATCH_TYPE_CASUAL_1V1"] = 6;
        values[valuesById[7] = "MATCH_TYPE_EVENT"] = 7;
        values[valuesById[8] = "MATCH_TYPE_SEASONAL_RANKED"] = 8;
        values[valuesById[9] = "MATCH_TYPE_LOWPRI_DEPRECATED"] = 9;
        values[valuesById[10] = "MATCH_TYPE_STEAM_GROUP"] = 10;
        values[valuesById[11] = "MATCH_TYPE_MUTATION"] = 11;
        values[valuesById[12] = "MATCH_TYPE_COACHES_CHALLENGE"] = 12;
        values[valuesById[13] = "MATCH_TYPE_GAUNTLET"] = 13;
        return values;
    })();
    
    /**
     * DOTABotDifficulty enum.
     * @exports DOTABotDifficulty
     * @enum {number}
     * @property {number} BOT_DIFFICULTY_PASSIVE=0 BOT_DIFFICULTY_PASSIVE value
     * @property {number} BOT_DIFFICULTY_EASY=1 BOT_DIFFICULTY_EASY value
     * @property {number} BOT_DIFFICULTY_MEDIUM=2 BOT_DIFFICULTY_MEDIUM value
     * @property {number} BOT_DIFFICULTY_HARD=3 BOT_DIFFICULTY_HARD value
     * @property {number} BOT_DIFFICULTY_UNFAIR=4 BOT_DIFFICULTY_UNFAIR value
     * @property {number} BOT_DIFFICULTY_INVALID=5 BOT_DIFFICULTY_INVALID value
     * @property {number} BOT_DIFFICULTY_EXTRA1=6 BOT_DIFFICULTY_EXTRA1 value
     * @property {number} BOT_DIFFICULTY_EXTRA2=7 BOT_DIFFICULTY_EXTRA2 value
     * @property {number} BOT_DIFFICULTY_EXTRA3=8 BOT_DIFFICULTY_EXTRA3 value
     */
    $root.DOTABotDifficulty = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "BOT_DIFFICULTY_PASSIVE"] = 0;
        values[valuesById[1] = "BOT_DIFFICULTY_EASY"] = 1;
        values[valuesById[2] = "BOT_DIFFICULTY_MEDIUM"] = 2;
        values[valuesById[3] = "BOT_DIFFICULTY_HARD"] = 3;
        values[valuesById[4] = "BOT_DIFFICULTY_UNFAIR"] = 4;
        values[valuesById[5] = "BOT_DIFFICULTY_INVALID"] = 5;
        values[valuesById[6] = "BOT_DIFFICULTY_EXTRA1"] = 6;
        values[valuesById[7] = "BOT_DIFFICULTY_EXTRA2"] = 7;
        values[valuesById[8] = "BOT_DIFFICULTY_EXTRA3"] = 8;
        return values;
    })();
    
    /**
     * DOTA_BOT_MODE enum.
     * @exports DOTA_BOT_MODE
     * @enum {number}
     * @property {number} DOTA_BOT_MODE_NONE=0 DOTA_BOT_MODE_NONE value
     * @property {number} DOTA_BOT_MODE_LANING=1 DOTA_BOT_MODE_LANING value
     * @property {number} DOTA_BOT_MODE_ATTACK=2 DOTA_BOT_MODE_ATTACK value
     * @property {number} DOTA_BOT_MODE_ROAM=3 DOTA_BOT_MODE_ROAM value
     * @property {number} DOTA_BOT_MODE_RETREAT=4 DOTA_BOT_MODE_RETREAT value
     * @property {number} DOTA_BOT_MODE_SECRET_SHOP=5 DOTA_BOT_MODE_SECRET_SHOP value
     * @property {number} DOTA_BOT_MODE_SIDE_SHOP=6 DOTA_BOT_MODE_SIDE_SHOP value
     * @property {number} DOTA_BOT_MODE_RUNE=7 DOTA_BOT_MODE_RUNE value
     * @property {number} DOTA_BOT_MODE_PUSH_TOWER_TOP=8 DOTA_BOT_MODE_PUSH_TOWER_TOP value
     * @property {number} DOTA_BOT_MODE_PUSH_TOWER_MID=9 DOTA_BOT_MODE_PUSH_TOWER_MID value
     * @property {number} DOTA_BOT_MODE_PUSH_TOWER_BOT=10 DOTA_BOT_MODE_PUSH_TOWER_BOT value
     * @property {number} DOTA_BOT_MODE_DEFEND_TOWER_TOP=11 DOTA_BOT_MODE_DEFEND_TOWER_TOP value
     * @property {number} DOTA_BOT_MODE_DEFEND_TOWER_MID=12 DOTA_BOT_MODE_DEFEND_TOWER_MID value
     * @property {number} DOTA_BOT_MODE_DEFEND_TOWER_BOT=13 DOTA_BOT_MODE_DEFEND_TOWER_BOT value
     * @property {number} DOTA_BOT_MODE_ASSEMBLE=14 DOTA_BOT_MODE_ASSEMBLE value
     * @property {number} DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS=15 DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS value
     * @property {number} DOTA_BOT_MODE_TEAM_ROAM=16 DOTA_BOT_MODE_TEAM_ROAM value
     * @property {number} DOTA_BOT_MODE_FARM=17 DOTA_BOT_MODE_FARM value
     * @property {number} DOTA_BOT_MODE_DEFEND_ALLY=18 DOTA_BOT_MODE_DEFEND_ALLY value
     * @property {number} DOTA_BOT_MODE_EVASIVE_MANEUVERS=19 DOTA_BOT_MODE_EVASIVE_MANEUVERS value
     * @property {number} DOTA_BOT_MODE_ROSHAN=20 DOTA_BOT_MODE_ROSHAN value
     * @property {number} DOTA_BOT_MODE_ITEM=21 DOTA_BOT_MODE_ITEM value
     * @property {number} DOTA_BOT_MODE_WARD=22 DOTA_BOT_MODE_WARD value
     * @property {number} DOTA_BOT_MODE_COMPANION=23 DOTA_BOT_MODE_COMPANION value
     * @property {number} DOTA_BOT_MODE_TUTORIAL_BOSS=24 DOTA_BOT_MODE_TUTORIAL_BOSS value
     * @property {number} DOTA_BOT_MODE_MINION=25 DOTA_BOT_MODE_MINION value
     */
    $root.DOTA_BOT_MODE = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_BOT_MODE_NONE"] = 0;
        values[valuesById[1] = "DOTA_BOT_MODE_LANING"] = 1;
        values[valuesById[2] = "DOTA_BOT_MODE_ATTACK"] = 2;
        values[valuesById[3] = "DOTA_BOT_MODE_ROAM"] = 3;
        values[valuesById[4] = "DOTA_BOT_MODE_RETREAT"] = 4;
        values[valuesById[5] = "DOTA_BOT_MODE_SECRET_SHOP"] = 5;
        values[valuesById[6] = "DOTA_BOT_MODE_SIDE_SHOP"] = 6;
        values[valuesById[7] = "DOTA_BOT_MODE_RUNE"] = 7;
        values[valuesById[8] = "DOTA_BOT_MODE_PUSH_TOWER_TOP"] = 8;
        values[valuesById[9] = "DOTA_BOT_MODE_PUSH_TOWER_MID"] = 9;
        values[valuesById[10] = "DOTA_BOT_MODE_PUSH_TOWER_BOT"] = 10;
        values[valuesById[11] = "DOTA_BOT_MODE_DEFEND_TOWER_TOP"] = 11;
        values[valuesById[12] = "DOTA_BOT_MODE_DEFEND_TOWER_MID"] = 12;
        values[valuesById[13] = "DOTA_BOT_MODE_DEFEND_TOWER_BOT"] = 13;
        values[valuesById[14] = "DOTA_BOT_MODE_ASSEMBLE"] = 14;
        values[valuesById[15] = "DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS"] = 15;
        values[valuesById[16] = "DOTA_BOT_MODE_TEAM_ROAM"] = 16;
        values[valuesById[17] = "DOTA_BOT_MODE_FARM"] = 17;
        values[valuesById[18] = "DOTA_BOT_MODE_DEFEND_ALLY"] = 18;
        values[valuesById[19] = "DOTA_BOT_MODE_EVASIVE_MANEUVERS"] = 19;
        values[valuesById[20] = "DOTA_BOT_MODE_ROSHAN"] = 20;
        values[valuesById[21] = "DOTA_BOT_MODE_ITEM"] = 21;
        values[valuesById[22] = "DOTA_BOT_MODE_WARD"] = 22;
        values[valuesById[23] = "DOTA_BOT_MODE_COMPANION"] = 23;
        values[valuesById[24] = "DOTA_BOT_MODE_TUTORIAL_BOSS"] = 24;
        values[valuesById[25] = "DOTA_BOT_MODE_MINION"] = 25;
        return values;
    })();
    
    /**
     * MatchLanguages enum.
     * @exports MatchLanguages
     * @enum {number}
     * @property {number} MATCH_LANGUAGE_INVALID=0 MATCH_LANGUAGE_INVALID value
     * @property {number} MATCH_LANGUAGE_ENGLISH=1 MATCH_LANGUAGE_ENGLISH value
     * @property {number} MATCH_LANGUAGE_RUSSIAN=2 MATCH_LANGUAGE_RUSSIAN value
     * @property {number} MATCH_LANGUAGE_CHINESE=3 MATCH_LANGUAGE_CHINESE value
     * @property {number} MATCH_LANGUAGE_KOREAN=4 MATCH_LANGUAGE_KOREAN value
     * @property {number} MATCH_LANGUAGE_SPANISH=5 MATCH_LANGUAGE_SPANISH value
     * @property {number} MATCH_LANGUAGE_PORTUGUESE=6 MATCH_LANGUAGE_PORTUGUESE value
     * @property {number} MATCH_LANGUAGE_ENGLISH2=7 MATCH_LANGUAGE_ENGLISH2 value
     */
    $root.MatchLanguages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MATCH_LANGUAGE_INVALID"] = 0;
        values[valuesById[1] = "MATCH_LANGUAGE_ENGLISH"] = 1;
        values[valuesById[2] = "MATCH_LANGUAGE_RUSSIAN"] = 2;
        values[valuesById[3] = "MATCH_LANGUAGE_CHINESE"] = 3;
        values[valuesById[4] = "MATCH_LANGUAGE_KOREAN"] = 4;
        values[valuesById[5] = "MATCH_LANGUAGE_SPANISH"] = 5;
        values[valuesById[6] = "MATCH_LANGUAGE_PORTUGUESE"] = 6;
        values[valuesById[7] = "MATCH_LANGUAGE_ENGLISH2"] = 7;
        return values;
    })();
    
    /**
     * ETourneyQueueDeadlineState enum.
     * @exports ETourneyQueueDeadlineState
     * @enum {number}
     * @property {number} k_ETourneyQueueDeadlineState_Normal=0 k_ETourneyQueueDeadlineState_Normal value
     * @property {number} k_ETourneyQueueDeadlineState_Missed=1 k_ETourneyQueueDeadlineState_Missed value
     * @property {number} k_ETourneyQueueDeadlineState_ExpiredOK=2 k_ETourneyQueueDeadlineState_ExpiredOK value
     * @property {number} k_ETourneyQueueDeadlineState_SeekingBye=3 k_ETourneyQueueDeadlineState_SeekingBye value
     * @property {number} k_ETourneyQueueDeadlineState_EligibleForRefund=4 k_ETourneyQueueDeadlineState_EligibleForRefund value
     * @property {number} k_ETourneyQueueDeadlineState_NA=-1 k_ETourneyQueueDeadlineState_NA value
     * @property {number} k_ETourneyQueueDeadlineState_ExpiringSoon=101 k_ETourneyQueueDeadlineState_ExpiringSoon value
     */
    $root.ETourneyQueueDeadlineState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_ETourneyQueueDeadlineState_Normal"] = 0;
        values[valuesById[1] = "k_ETourneyQueueDeadlineState_Missed"] = 1;
        values[valuesById[2] = "k_ETourneyQueueDeadlineState_ExpiredOK"] = 2;
        values[valuesById[3] = "k_ETourneyQueueDeadlineState_SeekingBye"] = 3;
        values[valuesById[4] = "k_ETourneyQueueDeadlineState_EligibleForRefund"] = 4;
        values[valuesById[-1] = "k_ETourneyQueueDeadlineState_NA"] = -1;
        values[valuesById[101] = "k_ETourneyQueueDeadlineState_ExpiringSoon"] = 101;
        return values;
    })();
    
    /**
     * EMatchOutcome enum.
     * @exports EMatchOutcome
     * @enum {number}
     * @property {number} k_EMatchOutcome_Unknown=0 k_EMatchOutcome_Unknown value
     * @property {number} k_EMatchOutcome_RadVictory=2 k_EMatchOutcome_RadVictory value
     * @property {number} k_EMatchOutcome_DireVictory=3 k_EMatchOutcome_DireVictory value
     * @property {number} k_EMatchOutcome_NotScored_PoorNetworkConditions=64 k_EMatchOutcome_NotScored_PoorNetworkConditions value
     * @property {number} k_EMatchOutcome_NotScored_Leaver=65 k_EMatchOutcome_NotScored_Leaver value
     * @property {number} k_EMatchOutcome_NotScored_ServerCrash=66 k_EMatchOutcome_NotScored_ServerCrash value
     * @property {number} k_EMatchOutcome_NotScored_NeverStarted=67 k_EMatchOutcome_NotScored_NeverStarted value
     * @property {number} k_EMatchOutcome_NotScored_Canceled=68 k_EMatchOutcome_NotScored_Canceled value
     * @property {number} k_EMatchOutcome_NotScored_Suspicious=69 k_EMatchOutcome_NotScored_Suspicious value
     */
    $root.EMatchOutcome = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_EMatchOutcome_Unknown"] = 0;
        values[valuesById[2] = "k_EMatchOutcome_RadVictory"] = 2;
        values[valuesById[3] = "k_EMatchOutcome_DireVictory"] = 3;
        values[valuesById[64] = "k_EMatchOutcome_NotScored_PoorNetworkConditions"] = 64;
        values[valuesById[65] = "k_EMatchOutcome_NotScored_Leaver"] = 65;
        values[valuesById[66] = "k_EMatchOutcome_NotScored_ServerCrash"] = 66;
        values[valuesById[67] = "k_EMatchOutcome_NotScored_NeverStarted"] = 67;
        values[valuesById[68] = "k_EMatchOutcome_NotScored_Canceled"] = 68;
        values[valuesById[69] = "k_EMatchOutcome_NotScored_Suspicious"] = 69;
        return values;
    })();
    
    /**
     * ELaneType enum.
     * @exports ELaneType
     * @enum {number}
     * @property {number} LANE_TYPE_UNKNOWN=0 LANE_TYPE_UNKNOWN value
     * @property {number} LANE_TYPE_SAFE=1 LANE_TYPE_SAFE value
     * @property {number} LANE_TYPE_OFF=2 LANE_TYPE_OFF value
     * @property {number} LANE_TYPE_MID=3 LANE_TYPE_MID value
     * @property {number} LANE_TYPE_JUNGLE=4 LANE_TYPE_JUNGLE value
     * @property {number} LANE_TYPE_ROAM=5 LANE_TYPE_ROAM value
     */
    $root.ELaneType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LANE_TYPE_UNKNOWN"] = 0;
        values[valuesById[1] = "LANE_TYPE_SAFE"] = 1;
        values[valuesById[2] = "LANE_TYPE_OFF"] = 2;
        values[valuesById[3] = "LANE_TYPE_MID"] = 3;
        values[valuesById[4] = "LANE_TYPE_JUNGLE"] = 4;
        values[valuesById[5] = "LANE_TYPE_ROAM"] = 5;
        return values;
    })();
    
    /**
     * EBadgeType enum.
     * @exports EBadgeType
     * @enum {number}
     * @property {number} k_EBadgeType_TI7_Midweek=1 k_EBadgeType_TI7_Midweek value
     * @property {number} k_EBadgeType_TI7_Finals=2 k_EBadgeType_TI7_Finals value
     * @property {number} k_EBadgeType_TI7_AllEvent=3 k_EBadgeType_TI7_AllEvent value
     * @property {number} k_EBadgeType_TI8_Midweek=4 k_EBadgeType_TI8_Midweek value
     * @property {number} k_EBadgeType_TI8_Finals=5 k_EBadgeType_TI8_Finals value
     * @property {number} k_EBadgeType_TI8_AllEvent=6 k_EBadgeType_TI8_AllEvent value
     */
    $root.EBadgeType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "k_EBadgeType_TI7_Midweek"] = 1;
        values[valuesById[2] = "k_EBadgeType_TI7_Finals"] = 2;
        values[valuesById[3] = "k_EBadgeType_TI7_AllEvent"] = 3;
        values[valuesById[4] = "k_EBadgeType_TI8_Midweek"] = 4;
        values[valuesById[5] = "k_EBadgeType_TI8_Finals"] = 5;
        values[valuesById[6] = "k_EBadgeType_TI8_AllEvent"] = 6;
        return values;
    })();
    
    /**
     * ELeagueStatus enum.
     * @exports ELeagueStatus
     * @enum {number}
     * @property {number} LEAGUE_STATUS_UNSET=0 LEAGUE_STATUS_UNSET value
     * @property {number} LEAGUE_STATUS_UNSUBMITTED=1 LEAGUE_STATUS_UNSUBMITTED value
     * @property {number} LEAGUE_STATUS_SUBMITTED=2 LEAGUE_STATUS_SUBMITTED value
     * @property {number} LEAGUE_STATUS_ACCEPTED=3 LEAGUE_STATUS_ACCEPTED value
     * @property {number} LEAGUE_STATUS_REJECTED=4 LEAGUE_STATUS_REJECTED value
     * @property {number} LEAGUE_STATUS_CONCLUDED=5 LEAGUE_STATUS_CONCLUDED value
     * @property {number} LEAGUE_STATUS_DELETED=6 LEAGUE_STATUS_DELETED value
     */
    $root.ELeagueStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_STATUS_UNSET"] = 0;
        values[valuesById[1] = "LEAGUE_STATUS_UNSUBMITTED"] = 1;
        values[valuesById[2] = "LEAGUE_STATUS_SUBMITTED"] = 2;
        values[valuesById[3] = "LEAGUE_STATUS_ACCEPTED"] = 3;
        values[valuesById[4] = "LEAGUE_STATUS_REJECTED"] = 4;
        values[valuesById[5] = "LEAGUE_STATUS_CONCLUDED"] = 5;
        values[valuesById[6] = "LEAGUE_STATUS_DELETED"] = 6;
        return values;
    })();
    
    /**
     * ELeagueRegion enum.
     * @exports ELeagueRegion
     * @enum {number}
     * @property {number} LEAGUE_REGION_UNSET=0 LEAGUE_REGION_UNSET value
     * @property {number} LEAGUE_REGION_NA=1 LEAGUE_REGION_NA value
     * @property {number} LEAGUE_REGION_SA=2 LEAGUE_REGION_SA value
     * @property {number} LEAGUE_REGION_EUROPE=3 LEAGUE_REGION_EUROPE value
     * @property {number} LEAGUE_REGION_CIS=4 LEAGUE_REGION_CIS value
     * @property {number} LEAGUE_REGION_CHINA=5 LEAGUE_REGION_CHINA value
     * @property {number} LEAGUE_REGION_SEA=6 LEAGUE_REGION_SEA value
     */
    $root.ELeagueRegion = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_REGION_UNSET"] = 0;
        values[valuesById[1] = "LEAGUE_REGION_NA"] = 1;
        values[valuesById[2] = "LEAGUE_REGION_SA"] = 2;
        values[valuesById[3] = "LEAGUE_REGION_EUROPE"] = 3;
        values[valuesById[4] = "LEAGUE_REGION_CIS"] = 4;
        values[valuesById[5] = "LEAGUE_REGION_CHINA"] = 5;
        values[valuesById[6] = "LEAGUE_REGION_SEA"] = 6;
        return values;
    })();
    
    /**
     * ELeagueTier enum.
     * @exports ELeagueTier
     * @enum {number}
     * @property {number} LEAGUE_TIER_UNSET=0 LEAGUE_TIER_UNSET value
     * @property {number} LEAGUE_TIER_AMATEUR=1 LEAGUE_TIER_AMATEUR value
     * @property {number} LEAGUE_TIER_PROFESSIONAL=2 LEAGUE_TIER_PROFESSIONAL value
     * @property {number} LEAGUE_TIER_MINOR=3 LEAGUE_TIER_MINOR value
     * @property {number} LEAGUE_TIER_MAJOR=4 LEAGUE_TIER_MAJOR value
     * @property {number} LEAGUE_TIER_INTERNATIONAL=5 LEAGUE_TIER_INTERNATIONAL value
     * @property {number} LEAGUE_TIER_DPC_QUALIFIER=6 LEAGUE_TIER_DPC_QUALIFIER value
     */
    $root.ELeagueTier = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_TIER_UNSET"] = 0;
        values[valuesById[1] = "LEAGUE_TIER_AMATEUR"] = 1;
        values[valuesById[2] = "LEAGUE_TIER_PROFESSIONAL"] = 2;
        values[valuesById[3] = "LEAGUE_TIER_MINOR"] = 3;
        values[valuesById[4] = "LEAGUE_TIER_MAJOR"] = 4;
        values[valuesById[5] = "LEAGUE_TIER_INTERNATIONAL"] = 5;
        values[valuesById[6] = "LEAGUE_TIER_DPC_QUALIFIER"] = 6;
        return values;
    })();
    
    /**
     * ELeagueTierCategory enum.
     * @exports ELeagueTierCategory
     * @enum {number}
     * @property {number} LEAGUE_TIER_CATEGORY_AMATEUR=1 LEAGUE_TIER_CATEGORY_AMATEUR value
     * @property {number} LEAGUE_TIER_CATEGORY_PROFESSIONAL=2 LEAGUE_TIER_CATEGORY_PROFESSIONAL value
     * @property {number} LEAGUE_TIER_CATEGORY_DPC=3 LEAGUE_TIER_CATEGORY_DPC value
     */
    $root.ELeagueTierCategory = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "LEAGUE_TIER_CATEGORY_AMATEUR"] = 1;
        values[valuesById[2] = "LEAGUE_TIER_CATEGORY_PROFESSIONAL"] = 2;
        values[valuesById[3] = "LEAGUE_TIER_CATEGORY_DPC"] = 3;
        return values;
    })();
    
    /**
     * ELeagueFlags enum.
     * @exports ELeagueFlags
     * @enum {number}
     * @property {number} LEAGUE_FLAGS_NONE=0 LEAGUE_FLAGS_NONE value
     * @property {number} LEAGUE_ACCEPTED_AGREEMENT=1 LEAGUE_ACCEPTED_AGREEMENT value
     * @property {number} LEAGUE_PAYMENT_EMAIL_SENT=2 LEAGUE_PAYMENT_EMAIL_SENT value
     * @property {number} LEAGUE_COMPENDIUM_ALLOWED=4 LEAGUE_COMPENDIUM_ALLOWED value
     * @property {number} LEAGUE_COMPENDIUM_PUBLIC=8 LEAGUE_COMPENDIUM_PUBLIC value
     */
    $root.ELeagueFlags = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_FLAGS_NONE"] = 0;
        values[valuesById[1] = "LEAGUE_ACCEPTED_AGREEMENT"] = 1;
        values[valuesById[2] = "LEAGUE_PAYMENT_EMAIL_SENT"] = 2;
        values[valuesById[4] = "LEAGUE_COMPENDIUM_ALLOWED"] = 4;
        values[valuesById[8] = "LEAGUE_COMPENDIUM_PUBLIC"] = 8;
        return values;
    })();
    
    /**
     * ELeagueBroadcastProvider enum.
     * @exports ELeagueBroadcastProvider
     * @enum {number}
     * @property {number} LEAGUE_BROADCAST_UNKNOWN=0 LEAGUE_BROADCAST_UNKNOWN value
     * @property {number} LEAGUE_BROADCAST_STEAM=1 LEAGUE_BROADCAST_STEAM value
     * @property {number} LEAGUE_BROADCAST_TWITCH=2 LEAGUE_BROADCAST_TWITCH value
     * @property {number} LEAGUE_BROADCAST_YOUTUBE=3 LEAGUE_BROADCAST_YOUTUBE value
     * @property {number} LEAGUE_BROADCAST_OTHER=100 LEAGUE_BROADCAST_OTHER value
     */
    $root.ELeagueBroadcastProvider = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_BROADCAST_UNKNOWN"] = 0;
        values[valuesById[1] = "LEAGUE_BROADCAST_STEAM"] = 1;
        values[valuesById[2] = "LEAGUE_BROADCAST_TWITCH"] = 2;
        values[valuesById[3] = "LEAGUE_BROADCAST_YOUTUBE"] = 3;
        values[valuesById[100] = "LEAGUE_BROADCAST_OTHER"] = 100;
        return values;
    })();
    
    /**
     * ELeaguePhase enum.
     * @exports ELeaguePhase
     * @enum {number}
     * @property {number} LEAGUE_PHASE_UNSET=0 LEAGUE_PHASE_UNSET value
     * @property {number} LEAGUE_PHASE_REGIONAL_QUALIFIER=1 LEAGUE_PHASE_REGIONAL_QUALIFIER value
     * @property {number} LEAGUE_PHASE_GROUP_STAGE=2 LEAGUE_PHASE_GROUP_STAGE value
     * @property {number} LEAGUE_PHASE_MAIN_EVENT=3 LEAGUE_PHASE_MAIN_EVENT value
     */
    $root.ELeaguePhase = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_PHASE_UNSET"] = 0;
        values[valuesById[1] = "LEAGUE_PHASE_REGIONAL_QUALIFIER"] = 1;
        values[valuesById[2] = "LEAGUE_PHASE_GROUP_STAGE"] = 2;
        values[valuesById[3] = "LEAGUE_PHASE_MAIN_EVENT"] = 3;
        return values;
    })();
    
    /**
     * ELeagueAuditAction enum.
     * @exports ELeagueAuditAction
     * @enum {number}
     * @property {number} LEAGUE_AUDIT_ACTION_INVALID=0 LEAGUE_AUDIT_ACTION_INVALID value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_CREATE=1 LEAGUE_AUDIT_ACTION_LEAGUE_CREATE value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_EDIT=2 LEAGUE_AUDIT_ACTION_LEAGUE_EDIT value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_DELETE=3 LEAGUE_AUDIT_ACTION_LEAGUE_DELETE value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD=4 LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE=5 LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE=6 LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD=7 LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE=8 LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED=9 LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED=10 LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED=11 LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL=12 LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM=13 LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM=14 LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START=15 LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END=16 LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM=17 LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM=18 LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED=19 LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT=20 LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE=100 LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY=101 LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM=102 LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM=103 LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING=104 LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT=105 LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE=106 LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED=107 LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING=108 LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING=109 LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_CREATE=200 LEAGUE_AUDIT_ACTION_NODE_CREATE value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_DESTROY=201 LEAGUE_AUDIT_ACTION_NODE_DESTROY value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE=202 LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_SET_TEAM=203 LEAGUE_AUDIT_ACTION_NODE_SET_TEAM value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID=204 LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING=205 LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_SET_TIME=206 LEAGUE_AUDIT_ACTION_NODE_SET_TIME value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED=207 LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_COMPLETED=208 LEAGUE_AUDIT_ACTION_NODE_COMPLETED value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_EDIT=209 LEAGUE_AUDIT_ACTION_NODE_EDIT value
     */
    $root.ELeagueAuditAction = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_AUDIT_ACTION_INVALID"] = 0;
        values[valuesById[1] = "LEAGUE_AUDIT_ACTION_LEAGUE_CREATE"] = 1;
        values[valuesById[2] = "LEAGUE_AUDIT_ACTION_LEAGUE_EDIT"] = 2;
        values[valuesById[3] = "LEAGUE_AUDIT_ACTION_LEAGUE_DELETE"] = 3;
        values[valuesById[4] = "LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD"] = 4;
        values[valuesById[5] = "LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE"] = 5;
        values[valuesById[6] = "LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE"] = 6;
        values[valuesById[7] = "LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD"] = 7;
        values[valuesById[8] = "LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE"] = 8;
        values[valuesById[9] = "LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED"] = 9;
        values[valuesById[10] = "LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED"] = 10;
        values[valuesById[11] = "LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED"] = 11;
        values[valuesById[12] = "LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL"] = 12;
        values[valuesById[13] = "LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM"] = 13;
        values[valuesById[14] = "LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM"] = 14;
        values[valuesById[15] = "LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START"] = 15;
        values[valuesById[16] = "LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END"] = 16;
        values[valuesById[17] = "LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM"] = 17;
        values[valuesById[18] = "LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM"] = 18;
        values[valuesById[19] = "LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED"] = 19;
        values[valuesById[20] = "LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT"] = 20;
        values[valuesById[100] = "LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE"] = 100;
        values[valuesById[101] = "LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY"] = 101;
        values[valuesById[102] = "LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM"] = 102;
        values[valuesById[103] = "LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM"] = 103;
        values[valuesById[104] = "LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING"] = 104;
        values[valuesById[105] = "LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT"] = 105;
        values[valuesById[106] = "LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE"] = 106;
        values[valuesById[107] = "LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED"] = 107;
        values[valuesById[108] = "LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING"] = 108;
        values[valuesById[109] = "LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING"] = 109;
        values[valuesById[200] = "LEAGUE_AUDIT_ACTION_NODE_CREATE"] = 200;
        values[valuesById[201] = "LEAGUE_AUDIT_ACTION_NODE_DESTROY"] = 201;
        values[valuesById[202] = "LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE"] = 202;
        values[valuesById[203] = "LEAGUE_AUDIT_ACTION_NODE_SET_TEAM"] = 203;
        values[valuesById[204] = "LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID"] = 204;
        values[valuesById[205] = "LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING"] = 205;
        values[valuesById[206] = "LEAGUE_AUDIT_ACTION_NODE_SET_TIME"] = 206;
        values[valuesById[207] = "LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED"] = 207;
        values[valuesById[208] = "LEAGUE_AUDIT_ACTION_NODE_COMPLETED"] = 208;
        values[valuesById[209] = "LEAGUE_AUDIT_ACTION_NODE_EDIT"] = 209;
        return values;
    })();
    
    /**
     * DOTA_COMBATLOG_TYPES enum.
     * @exports DOTA_COMBATLOG_TYPES
     * @enum {number}
     * @property {number} DOTA_COMBATLOG_INVALID=-1 DOTA_COMBATLOG_INVALID value
     * @property {number} DOTA_COMBATLOG_DAMAGE=0 DOTA_COMBATLOG_DAMAGE value
     * @property {number} DOTA_COMBATLOG_HEAL=1 DOTA_COMBATLOG_HEAL value
     * @property {number} DOTA_COMBATLOG_MODIFIER_ADD=2 DOTA_COMBATLOG_MODIFIER_ADD value
     * @property {number} DOTA_COMBATLOG_MODIFIER_REMOVE=3 DOTA_COMBATLOG_MODIFIER_REMOVE value
     * @property {number} DOTA_COMBATLOG_DEATH=4 DOTA_COMBATLOG_DEATH value
     * @property {number} DOTA_COMBATLOG_ABILITY=5 DOTA_COMBATLOG_ABILITY value
     * @property {number} DOTA_COMBATLOG_ITEM=6 DOTA_COMBATLOG_ITEM value
     * @property {number} DOTA_COMBATLOG_LOCATION=7 DOTA_COMBATLOG_LOCATION value
     * @property {number} DOTA_COMBATLOG_GOLD=8 DOTA_COMBATLOG_GOLD value
     * @property {number} DOTA_COMBATLOG_GAME_STATE=9 DOTA_COMBATLOG_GAME_STATE value
     * @property {number} DOTA_COMBATLOG_XP=10 DOTA_COMBATLOG_XP value
     * @property {number} DOTA_COMBATLOG_PURCHASE=11 DOTA_COMBATLOG_PURCHASE value
     * @property {number} DOTA_COMBATLOG_BUYBACK=12 DOTA_COMBATLOG_BUYBACK value
     * @property {number} DOTA_COMBATLOG_ABILITY_TRIGGER=13 DOTA_COMBATLOG_ABILITY_TRIGGER value
     * @property {number} DOTA_COMBATLOG_PLAYERSTATS=14 DOTA_COMBATLOG_PLAYERSTATS value
     * @property {number} DOTA_COMBATLOG_MULTIKILL=15 DOTA_COMBATLOG_MULTIKILL value
     * @property {number} DOTA_COMBATLOG_KILLSTREAK=16 DOTA_COMBATLOG_KILLSTREAK value
     * @property {number} DOTA_COMBATLOG_TEAM_BUILDING_KILL=17 DOTA_COMBATLOG_TEAM_BUILDING_KILL value
     * @property {number} DOTA_COMBATLOG_FIRST_BLOOD=18 DOTA_COMBATLOG_FIRST_BLOOD value
     * @property {number} DOTA_COMBATLOG_MODIFIER_STACK_EVENT=19 DOTA_COMBATLOG_MODIFIER_STACK_EVENT value
     * @property {number} DOTA_COMBATLOG_NEUTRAL_CAMP_STACK=20 DOTA_COMBATLOG_NEUTRAL_CAMP_STACK value
     * @property {number} DOTA_COMBATLOG_PICKUP_RUNE=21 DOTA_COMBATLOG_PICKUP_RUNE value
     * @property {number} DOTA_COMBATLOG_REVEALED_INVISIBLE=22 DOTA_COMBATLOG_REVEALED_INVISIBLE value
     * @property {number} DOTA_COMBATLOG_HERO_SAVED=23 DOTA_COMBATLOG_HERO_SAVED value
     * @property {number} DOTA_COMBATLOG_MANA_RESTORED=24 DOTA_COMBATLOG_MANA_RESTORED value
     * @property {number} DOTA_COMBATLOG_HERO_LEVELUP=25 DOTA_COMBATLOG_HERO_LEVELUP value
     * @property {number} DOTA_COMBATLOG_BOTTLE_HEAL_ALLY=26 DOTA_COMBATLOG_BOTTLE_HEAL_ALLY value
     * @property {number} DOTA_COMBATLOG_ENDGAME_STATS=27 DOTA_COMBATLOG_ENDGAME_STATS value
     * @property {number} DOTA_COMBATLOG_INTERRUPT_CHANNEL=28 DOTA_COMBATLOG_INTERRUPT_CHANNEL value
     * @property {number} DOTA_COMBATLOG_ALLIED_GOLD=29 DOTA_COMBATLOG_ALLIED_GOLD value
     * @property {number} DOTA_COMBATLOG_AEGIS_TAKEN=30 DOTA_COMBATLOG_AEGIS_TAKEN value
     * @property {number} DOTA_COMBATLOG_MANA_DAMAGE=31 DOTA_COMBATLOG_MANA_DAMAGE value
     * @property {number} DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED=32 DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED value
     * @property {number} DOTA_COMBATLOG_UNIT_SUMMONED=33 DOTA_COMBATLOG_UNIT_SUMMONED value
     * @property {number} DOTA_COMBATLOG_ATTACK_EVADE=34 DOTA_COMBATLOG_ATTACK_EVADE value
     * @property {number} DOTA_COMBATLOG_TREE_CUT=35 DOTA_COMBATLOG_TREE_CUT value
     * @property {number} DOTA_COMBATLOG_SUCCESSFUL_SCAN=36 DOTA_COMBATLOG_SUCCESSFUL_SCAN value
     * @property {number} DOTA_COMBATLOG_END_KILLSTREAK=37 DOTA_COMBATLOG_END_KILLSTREAK value
     * @property {number} DOTA_COMBATLOG_BLOODSTONE_CHARGE=38 DOTA_COMBATLOG_BLOODSTONE_CHARGE value
     * @property {number} DOTA_COMBATLOG_CRITICAL_DAMAGE=39 DOTA_COMBATLOG_CRITICAL_DAMAGE value
     * @property {number} DOTA_COMBATLOG_SPELL_ABSORB=40 DOTA_COMBATLOG_SPELL_ABSORB value
     * @property {number} DOTA_COMBATLOG_UNIT_TELEPORTED=41 DOTA_COMBATLOG_UNIT_TELEPORTED value
     * @property {number} DOTA_COMBATLOG_KILL_EATER_EVENT=42 DOTA_COMBATLOG_KILL_EATER_EVENT value
     */
    $root.DOTA_COMBATLOG_TYPES = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[-1] = "DOTA_COMBATLOG_INVALID"] = -1;
        values[valuesById[0] = "DOTA_COMBATLOG_DAMAGE"] = 0;
        values[valuesById[1] = "DOTA_COMBATLOG_HEAL"] = 1;
        values[valuesById[2] = "DOTA_COMBATLOG_MODIFIER_ADD"] = 2;
        values[valuesById[3] = "DOTA_COMBATLOG_MODIFIER_REMOVE"] = 3;
        values[valuesById[4] = "DOTA_COMBATLOG_DEATH"] = 4;
        values[valuesById[5] = "DOTA_COMBATLOG_ABILITY"] = 5;
        values[valuesById[6] = "DOTA_COMBATLOG_ITEM"] = 6;
        values[valuesById[7] = "DOTA_COMBATLOG_LOCATION"] = 7;
        values[valuesById[8] = "DOTA_COMBATLOG_GOLD"] = 8;
        values[valuesById[9] = "DOTA_COMBATLOG_GAME_STATE"] = 9;
        values[valuesById[10] = "DOTA_COMBATLOG_XP"] = 10;
        values[valuesById[11] = "DOTA_COMBATLOG_PURCHASE"] = 11;
        values[valuesById[12] = "DOTA_COMBATLOG_BUYBACK"] = 12;
        values[valuesById[13] = "DOTA_COMBATLOG_ABILITY_TRIGGER"] = 13;
        values[valuesById[14] = "DOTA_COMBATLOG_PLAYERSTATS"] = 14;
        values[valuesById[15] = "DOTA_COMBATLOG_MULTIKILL"] = 15;
        values[valuesById[16] = "DOTA_COMBATLOG_KILLSTREAK"] = 16;
        values[valuesById[17] = "DOTA_COMBATLOG_TEAM_BUILDING_KILL"] = 17;
        values[valuesById[18] = "DOTA_COMBATLOG_FIRST_BLOOD"] = 18;
        values[valuesById[19] = "DOTA_COMBATLOG_MODIFIER_STACK_EVENT"] = 19;
        values[valuesById[20] = "DOTA_COMBATLOG_NEUTRAL_CAMP_STACK"] = 20;
        values[valuesById[21] = "DOTA_COMBATLOG_PICKUP_RUNE"] = 21;
        values[valuesById[22] = "DOTA_COMBATLOG_REVEALED_INVISIBLE"] = 22;
        values[valuesById[23] = "DOTA_COMBATLOG_HERO_SAVED"] = 23;
        values[valuesById[24] = "DOTA_COMBATLOG_MANA_RESTORED"] = 24;
        values[valuesById[25] = "DOTA_COMBATLOG_HERO_LEVELUP"] = 25;
        values[valuesById[26] = "DOTA_COMBATLOG_BOTTLE_HEAL_ALLY"] = 26;
        values[valuesById[27] = "DOTA_COMBATLOG_ENDGAME_STATS"] = 27;
        values[valuesById[28] = "DOTA_COMBATLOG_INTERRUPT_CHANNEL"] = 28;
        values[valuesById[29] = "DOTA_COMBATLOG_ALLIED_GOLD"] = 29;
        values[valuesById[30] = "DOTA_COMBATLOG_AEGIS_TAKEN"] = 30;
        values[valuesById[31] = "DOTA_COMBATLOG_MANA_DAMAGE"] = 31;
        values[valuesById[32] = "DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED"] = 32;
        values[valuesById[33] = "DOTA_COMBATLOG_UNIT_SUMMONED"] = 33;
        values[valuesById[34] = "DOTA_COMBATLOG_ATTACK_EVADE"] = 34;
        values[valuesById[35] = "DOTA_COMBATLOG_TREE_CUT"] = 35;
        values[valuesById[36] = "DOTA_COMBATLOG_SUCCESSFUL_SCAN"] = 36;
        values[valuesById[37] = "DOTA_COMBATLOG_END_KILLSTREAK"] = 37;
        values[valuesById[38] = "DOTA_COMBATLOG_BLOODSTONE_CHARGE"] = 38;
        values[valuesById[39] = "DOTA_COMBATLOG_CRITICAL_DAMAGE"] = 39;
        values[valuesById[40] = "DOTA_COMBATLOG_SPELL_ABSORB"] = 40;
        values[valuesById[41] = "DOTA_COMBATLOG_UNIT_TELEPORTED"] = 41;
        values[valuesById[42] = "DOTA_COMBATLOG_KILL_EATER_EVENT"] = 42;
        return values;
    })();
    
    /**
     * EDPCFavoriteType enum.
     * @exports EDPCFavoriteType
     * @enum {number}
     * @property {number} FAVORITE_TYPE_ALL=0 FAVORITE_TYPE_ALL value
     * @property {number} FAVORITE_TYPE_PLAYER=1 FAVORITE_TYPE_PLAYER value
     * @property {number} FAVORITE_TYPE_TEAM=2 FAVORITE_TYPE_TEAM value
     * @property {number} FAVORITE_TYPE_LEAGUE=3 FAVORITE_TYPE_LEAGUE value
     */
    $root.EDPCFavoriteType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FAVORITE_TYPE_ALL"] = 0;
        values[valuesById[1] = "FAVORITE_TYPE_PLAYER"] = 1;
        values[valuesById[2] = "FAVORITE_TYPE_TEAM"] = 2;
        values[valuesById[3] = "FAVORITE_TYPE_LEAGUE"] = 3;
        return values;
    })();
    
    /**
     * EDPCPushNotification enum.
     * @exports EDPCPushNotification
     * @enum {number}
     * @property {number} DPC_PUSH_NOTIFICATION_MATCH_STARTING=1 DPC_PUSH_NOTIFICATION_MATCH_STARTING value
     * @property {number} DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM=10 DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM value
     * @property {number} DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM=11 DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM value
     * @property {number} DPC_PUSH_NOTIFICATION_LEAGUE_RESULT=20 DPC_PUSH_NOTIFICATION_LEAGUE_RESULT value
     * @property {number} DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE=30 DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE value
     * @property {number} DPC_PUSH_NOTIFICATION_PREDICTION_RESULT=31 DPC_PUSH_NOTIFICATION_PREDICTION_RESULT value
     * @property {number} DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED=40 DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED value
     * @property {number} DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY=41 DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY value
     * @property {number} DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS=42 DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS value
     */
    $root.EDPCPushNotification = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "DPC_PUSH_NOTIFICATION_MATCH_STARTING"] = 1;
        values[valuesById[10] = "DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM"] = 10;
        values[valuesById[11] = "DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM"] = 11;
        values[valuesById[20] = "DPC_PUSH_NOTIFICATION_LEAGUE_RESULT"] = 20;
        values[valuesById[30] = "DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE"] = 30;
        values[valuesById[31] = "DPC_PUSH_NOTIFICATION_PREDICTION_RESULT"] = 31;
        values[valuesById[40] = "DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED"] = 40;
        values[valuesById[41] = "DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY"] = 41;
        values[valuesById[42] = "DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS"] = 42;
        return values;
    })();
    
    /**
     * EEventActionScoreMode enum.
     * @exports EEventActionScoreMode
     * @enum {number}
     * @property {number} k_eEventActionScoreMode_Add=0 k_eEventActionScoreMode_Add value
     * @property {number} k_eEventActionScoreMode_Min=1 k_eEventActionScoreMode_Min value
     */
    $root.EEventActionScoreMode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_eEventActionScoreMode_Add"] = 0;
        values[valuesById[1] = "k_eEventActionScoreMode_Min"] = 1;
        return values;
    })();
    
    $root.CDOTAClientHardwareSpecs = (function() {
    
        /**
         * Properties of a CDOTAClientHardwareSpecs.
         * @exports ICDOTAClientHardwareSpecs
         * @interface ICDOTAClientHardwareSpecs
         * @property {number|null} [logical_processors] CDOTAClientHardwareSpecs logical_processors
         * @property {number|Long|null} [cpu_cycles_per_second] CDOTAClientHardwareSpecs cpu_cycles_per_second
         * @property {number|Long|null} [total_physical_memory] CDOTAClientHardwareSpecs total_physical_memory
         * @property {boolean|null} [is_64_bit_os] CDOTAClientHardwareSpecs is_64_bit_os
         * @property {number|Long|null} [upload_measurement] CDOTAClientHardwareSpecs upload_measurement
         * @property {boolean|null} [prefer_not_host] CDOTAClientHardwareSpecs prefer_not_host
         */
    
        /**
         * Constructs a new CDOTAClientHardwareSpecs.
         * @exports CDOTAClientHardwareSpecs
         * @classdesc Represents a CDOTAClientHardwareSpecs.
         * @implements ICDOTAClientHardwareSpecs
         * @constructor
         * @param {ICDOTAClientHardwareSpecs=} [properties] Properties to set
         */
        function CDOTAClientHardwareSpecs(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientHardwareSpecs logical_processors.
         * @member {number} logical_processors
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         */
        CDOTAClientHardwareSpecs.prototype.logical_processors = 0;
    
        /**
         * CDOTAClientHardwareSpecs cpu_cycles_per_second.
         * @member {number|Long} cpu_cycles_per_second
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         */
        CDOTAClientHardwareSpecs.prototype.cpu_cycles_per_second = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CDOTAClientHardwareSpecs total_physical_memory.
         * @member {number|Long} total_physical_memory
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         */
        CDOTAClientHardwareSpecs.prototype.total_physical_memory = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CDOTAClientHardwareSpecs is_64_bit_os.
         * @member {boolean} is_64_bit_os
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         */
        CDOTAClientHardwareSpecs.prototype.is_64_bit_os = false;
    
        /**
         * CDOTAClientHardwareSpecs upload_measurement.
         * @member {number|Long} upload_measurement
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         */
        CDOTAClientHardwareSpecs.prototype.upload_measurement = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CDOTAClientHardwareSpecs prefer_not_host.
         * @member {boolean} prefer_not_host
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         */
        CDOTAClientHardwareSpecs.prototype.prefer_not_host = false;
    
        /**
         * Creates a new CDOTAClientHardwareSpecs instance using the specified properties.
         * @function create
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {ICDOTAClientHardwareSpecs=} [properties] Properties to set
         * @returns {CDOTAClientHardwareSpecs} CDOTAClientHardwareSpecs instance
         */
        CDOTAClientHardwareSpecs.create = function create(properties) {
            return new CDOTAClientHardwareSpecs(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientHardwareSpecs message. Does not implicitly {@link CDOTAClientHardwareSpecs.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {ICDOTAClientHardwareSpecs} message CDOTAClientHardwareSpecs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientHardwareSpecs.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.logical_processors != null && Object.hasOwnProperty.call(message, "logical_processors"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.logical_processors);
            if (message.cpu_cycles_per_second != null && Object.hasOwnProperty.call(message, "cpu_cycles_per_second"))
                writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.cpu_cycles_per_second);
            if (message.total_physical_memory != null && Object.hasOwnProperty.call(message, "total_physical_memory"))
                writer.uint32(/* id 3, wireType 1 =*/25).fixed64(message.total_physical_memory);
            if (message.is_64_bit_os != null && Object.hasOwnProperty.call(message, "is_64_bit_os"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.is_64_bit_os);
            if (message.upload_measurement != null && Object.hasOwnProperty.call(message, "upload_measurement"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.upload_measurement);
            if (message.prefer_not_host != null && Object.hasOwnProperty.call(message, "prefer_not_host"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.prefer_not_host);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientHardwareSpecs message, length delimited. Does not implicitly {@link CDOTAClientHardwareSpecs.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {ICDOTAClientHardwareSpecs} message CDOTAClientHardwareSpecs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientHardwareSpecs.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientHardwareSpecs message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientHardwareSpecs} CDOTAClientHardwareSpecs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientHardwareSpecs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientHardwareSpecs();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.logical_processors = reader.uint32();
                    break;
                case 2:
                    message.cpu_cycles_per_second = reader.fixed64();
                    break;
                case 3:
                    message.total_physical_memory = reader.fixed64();
                    break;
                case 4:
                    message.is_64_bit_os = reader.bool();
                    break;
                case 5:
                    message.upload_measurement = reader.uint64();
                    break;
                case 6:
                    message.prefer_not_host = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientHardwareSpecs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientHardwareSpecs} CDOTAClientHardwareSpecs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientHardwareSpecs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientHardwareSpecs message.
         * @function verify
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientHardwareSpecs.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.logical_processors != null && message.hasOwnProperty("logical_processors"))
                if (!$util.isInteger(message.logical_processors))
                    return "logical_processors: integer expected";
            if (message.cpu_cycles_per_second != null && message.hasOwnProperty("cpu_cycles_per_second"))
                if (!$util.isInteger(message.cpu_cycles_per_second) && !(message.cpu_cycles_per_second && $util.isInteger(message.cpu_cycles_per_second.low) && $util.isInteger(message.cpu_cycles_per_second.high)))
                    return "cpu_cycles_per_second: integer|Long expected";
            if (message.total_physical_memory != null && message.hasOwnProperty("total_physical_memory"))
                if (!$util.isInteger(message.total_physical_memory) && !(message.total_physical_memory && $util.isInteger(message.total_physical_memory.low) && $util.isInteger(message.total_physical_memory.high)))
                    return "total_physical_memory: integer|Long expected";
            if (message.is_64_bit_os != null && message.hasOwnProperty("is_64_bit_os"))
                if (typeof message.is_64_bit_os !== "boolean")
                    return "is_64_bit_os: boolean expected";
            if (message.upload_measurement != null && message.hasOwnProperty("upload_measurement"))
                if (!$util.isInteger(message.upload_measurement) && !(message.upload_measurement && $util.isInteger(message.upload_measurement.low) && $util.isInteger(message.upload_measurement.high)))
                    return "upload_measurement: integer|Long expected";
            if (message.prefer_not_host != null && message.hasOwnProperty("prefer_not_host"))
                if (typeof message.prefer_not_host !== "boolean")
                    return "prefer_not_host: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientHardwareSpecs message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientHardwareSpecs} CDOTAClientHardwareSpecs
         */
        CDOTAClientHardwareSpecs.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientHardwareSpecs)
                return object;
            var message = new $root.CDOTAClientHardwareSpecs();
            if (object.logical_processors != null)
                message.logical_processors = object.logical_processors >>> 0;
            if (object.cpu_cycles_per_second != null)
                if ($util.Long)
                    (message.cpu_cycles_per_second = $util.Long.fromValue(object.cpu_cycles_per_second)).unsigned = false;
                else if (typeof object.cpu_cycles_per_second === "string")
                    message.cpu_cycles_per_second = parseInt(object.cpu_cycles_per_second, 10);
                else if (typeof object.cpu_cycles_per_second === "number")
                    message.cpu_cycles_per_second = object.cpu_cycles_per_second;
                else if (typeof object.cpu_cycles_per_second === "object")
                    message.cpu_cycles_per_second = new $util.LongBits(object.cpu_cycles_per_second.low >>> 0, object.cpu_cycles_per_second.high >>> 0).toNumber();
            if (object.total_physical_memory != null)
                if ($util.Long)
                    (message.total_physical_memory = $util.Long.fromValue(object.total_physical_memory)).unsigned = false;
                else if (typeof object.total_physical_memory === "string")
                    message.total_physical_memory = parseInt(object.total_physical_memory, 10);
                else if (typeof object.total_physical_memory === "number")
                    message.total_physical_memory = object.total_physical_memory;
                else if (typeof object.total_physical_memory === "object")
                    message.total_physical_memory = new $util.LongBits(object.total_physical_memory.low >>> 0, object.total_physical_memory.high >>> 0).toNumber();
            if (object.is_64_bit_os != null)
                message.is_64_bit_os = Boolean(object.is_64_bit_os);
            if (object.upload_measurement != null)
                if ($util.Long)
                    (message.upload_measurement = $util.Long.fromValue(object.upload_measurement)).unsigned = true;
                else if (typeof object.upload_measurement === "string")
                    message.upload_measurement = parseInt(object.upload_measurement, 10);
                else if (typeof object.upload_measurement === "number")
                    message.upload_measurement = object.upload_measurement;
                else if (typeof object.upload_measurement === "object")
                    message.upload_measurement = new $util.LongBits(object.upload_measurement.low >>> 0, object.upload_measurement.high >>> 0).toNumber(true);
            if (object.prefer_not_host != null)
                message.prefer_not_host = Boolean(object.prefer_not_host);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientHardwareSpecs message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {CDOTAClientHardwareSpecs} message CDOTAClientHardwareSpecs
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientHardwareSpecs.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.logical_processors = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.cpu_cycles_per_second = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.cpu_cycles_per_second = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.total_physical_memory = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.total_physical_memory = options.longs === String ? "0" : 0;
                object.is_64_bit_os = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.upload_measurement = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.upload_measurement = options.longs === String ? "0" : 0;
                object.prefer_not_host = false;
            }
            if (message.logical_processors != null && message.hasOwnProperty("logical_processors"))
                object.logical_processors = message.logical_processors;
            if (message.cpu_cycles_per_second != null && message.hasOwnProperty("cpu_cycles_per_second"))
                if (typeof message.cpu_cycles_per_second === "number")
                    object.cpu_cycles_per_second = options.longs === String ? String(message.cpu_cycles_per_second) : message.cpu_cycles_per_second;
                else
                    object.cpu_cycles_per_second = options.longs === String ? $util.Long.prototype.toString.call(message.cpu_cycles_per_second) : options.longs === Number ? new $util.LongBits(message.cpu_cycles_per_second.low >>> 0, message.cpu_cycles_per_second.high >>> 0).toNumber() : message.cpu_cycles_per_second;
            if (message.total_physical_memory != null && message.hasOwnProperty("total_physical_memory"))
                if (typeof message.total_physical_memory === "number")
                    object.total_physical_memory = options.longs === String ? String(message.total_physical_memory) : message.total_physical_memory;
                else
                    object.total_physical_memory = options.longs === String ? $util.Long.prototype.toString.call(message.total_physical_memory) : options.longs === Number ? new $util.LongBits(message.total_physical_memory.low >>> 0, message.total_physical_memory.high >>> 0).toNumber() : message.total_physical_memory;
            if (message.is_64_bit_os != null && message.hasOwnProperty("is_64_bit_os"))
                object.is_64_bit_os = message.is_64_bit_os;
            if (message.upload_measurement != null && message.hasOwnProperty("upload_measurement"))
                if (typeof message.upload_measurement === "number")
                    object.upload_measurement = options.longs === String ? String(message.upload_measurement) : message.upload_measurement;
                else
                    object.upload_measurement = options.longs === String ? $util.Long.prototype.toString.call(message.upload_measurement) : options.longs === Number ? new $util.LongBits(message.upload_measurement.low >>> 0, message.upload_measurement.high >>> 0).toNumber(true) : message.upload_measurement;
            if (message.prefer_not_host != null && message.hasOwnProperty("prefer_not_host"))
                object.prefer_not_host = message.prefer_not_host;
            return object;
        };
    
        /**
         * Converts this CDOTAClientHardwareSpecs to JSON.
         * @function toJSON
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientHardwareSpecs.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientHardwareSpecs;
    })();
    
    $root.CDOTASaveGame = (function() {
    
        /**
         * Properties of a CDOTASaveGame.
         * @exports ICDOTASaveGame
         * @interface ICDOTASaveGame
         * @property {number|Long|null} [match_id] CDOTASaveGame match_id
         * @property {number|null} [save_time] CDOTASaveGame save_time
         * @property {Array.<CDOTASaveGame.IPlayer>|null} [players] CDOTASaveGame players
         * @property {Array.<CDOTASaveGame.ISaveInstance>|null} [save_instances] CDOTASaveGame save_instances
         */
    
        /**
         * Constructs a new CDOTASaveGame.
         * @exports CDOTASaveGame
         * @classdesc Represents a CDOTASaveGame.
         * @implements ICDOTASaveGame
         * @constructor
         * @param {ICDOTASaveGame=} [properties] Properties to set
         */
        function CDOTASaveGame(properties) {
            this.players = [];
            this.save_instances = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTASaveGame match_id.
         * @member {number|Long} match_id
         * @memberof CDOTASaveGame
         * @instance
         */
        CDOTASaveGame.prototype.match_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CDOTASaveGame save_time.
         * @member {number} save_time
         * @memberof CDOTASaveGame
         * @instance
         */
        CDOTASaveGame.prototype.save_time = 0;
    
        /**
         * CDOTASaveGame players.
         * @member {Array.<CDOTASaveGame.IPlayer>} players
         * @memberof CDOTASaveGame
         * @instance
         */
        CDOTASaveGame.prototype.players = $util.emptyArray;
    
        /**
         * CDOTASaveGame save_instances.
         * @member {Array.<CDOTASaveGame.ISaveInstance>} save_instances
         * @memberof CDOTASaveGame
         * @instance
         */
        CDOTASaveGame.prototype.save_instances = $util.emptyArray;
    
        /**
         * Creates a new CDOTASaveGame instance using the specified properties.
         * @function create
         * @memberof CDOTASaveGame
         * @static
         * @param {ICDOTASaveGame=} [properties] Properties to set
         * @returns {CDOTASaveGame} CDOTASaveGame instance
         */
        CDOTASaveGame.create = function create(properties) {
            return new CDOTASaveGame(properties);
        };
    
        /**
         * Encodes the specified CDOTASaveGame message. Does not implicitly {@link CDOTASaveGame.verify|verify} messages.
         * @function encode
         * @memberof CDOTASaveGame
         * @static
         * @param {ICDOTASaveGame} message CDOTASaveGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTASaveGame.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.save_time != null && Object.hasOwnProperty.call(message, "save_time"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.save_time);
            if (message.players != null && message.players.length)
                for (var i = 0; i < message.players.length; ++i)
                    $root.CDOTASaveGame.Player.encode(message.players[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.save_instances != null && message.save_instances.length)
                for (var i = 0; i < message.save_instances.length; ++i)
                    $root.CDOTASaveGame.SaveInstance.encode(message.save_instances[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.match_id != null && Object.hasOwnProperty.call(message, "match_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.match_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTASaveGame message, length delimited. Does not implicitly {@link CDOTASaveGame.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTASaveGame
         * @static
         * @param {ICDOTASaveGame} message CDOTASaveGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTASaveGame.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTASaveGame message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTASaveGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTASaveGame} CDOTASaveGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTASaveGame.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTASaveGame();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 5:
                    message.match_id = reader.uint64();
                    break;
                case 2:
                    message.save_time = reader.uint32();
                    break;
                case 3:
                    if (!(message.players && message.players.length))
                        message.players = [];
                    message.players.push($root.CDOTASaveGame.Player.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.save_instances && message.save_instances.length))
                        message.save_instances = [];
                    message.save_instances.push($root.CDOTASaveGame.SaveInstance.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTASaveGame message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTASaveGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTASaveGame} CDOTASaveGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTASaveGame.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTASaveGame message.
         * @function verify
         * @memberof CDOTASaveGame
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTASaveGame.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.match_id != null && message.hasOwnProperty("match_id"))
                if (!$util.isInteger(message.match_id) && !(message.match_id && $util.isInteger(message.match_id.low) && $util.isInteger(message.match_id.high)))
                    return "match_id: integer|Long expected";
            if (message.save_time != null && message.hasOwnProperty("save_time"))
                if (!$util.isInteger(message.save_time))
                    return "save_time: integer expected";
            if (message.players != null && message.hasOwnProperty("players")) {
                if (!Array.isArray(message.players))
                    return "players: array expected";
                for (var i = 0; i < message.players.length; ++i) {
                    var error = $root.CDOTASaveGame.Player.verify(message.players[i]);
                    if (error)
                        return "players." + error;
                }
            }
            if (message.save_instances != null && message.hasOwnProperty("save_instances")) {
                if (!Array.isArray(message.save_instances))
                    return "save_instances: array expected";
                for (var i = 0; i < message.save_instances.length; ++i) {
                    var error = $root.CDOTASaveGame.SaveInstance.verify(message.save_instances[i]);
                    if (error)
                        return "save_instances." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CDOTASaveGame message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTASaveGame
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTASaveGame} CDOTASaveGame
         */
        CDOTASaveGame.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTASaveGame)
                return object;
            var message = new $root.CDOTASaveGame();
            if (object.match_id != null)
                if ($util.Long)
                    (message.match_id = $util.Long.fromValue(object.match_id)).unsigned = true;
                else if (typeof object.match_id === "string")
                    message.match_id = parseInt(object.match_id, 10);
                else if (typeof object.match_id === "number")
                    message.match_id = object.match_id;
                else if (typeof object.match_id === "object")
                    message.match_id = new $util.LongBits(object.match_id.low >>> 0, object.match_id.high >>> 0).toNumber(true);
            if (object.save_time != null)
                message.save_time = object.save_time >>> 0;
            if (object.players) {
                if (!Array.isArray(object.players))
                    throw TypeError(".CDOTASaveGame.players: array expected");
                message.players = [];
                for (var i = 0; i < object.players.length; ++i) {
                    if (typeof object.players[i] !== "object")
                        throw TypeError(".CDOTASaveGame.players: object expected");
                    message.players[i] = $root.CDOTASaveGame.Player.fromObject(object.players[i]);
                }
            }
            if (object.save_instances) {
                if (!Array.isArray(object.save_instances))
                    throw TypeError(".CDOTASaveGame.save_instances: array expected");
                message.save_instances = [];
                for (var i = 0; i < object.save_instances.length; ++i) {
                    if (typeof object.save_instances[i] !== "object")
                        throw TypeError(".CDOTASaveGame.save_instances: object expected");
                    message.save_instances[i] = $root.CDOTASaveGame.SaveInstance.fromObject(object.save_instances[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTASaveGame message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTASaveGame
         * @static
         * @param {CDOTASaveGame} message CDOTASaveGame
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTASaveGame.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.players = [];
                object.save_instances = [];
            }
            if (options.defaults) {
                object.save_time = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.match_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.match_id = options.longs === String ? "0" : 0;
            }
            if (message.save_time != null && message.hasOwnProperty("save_time"))
                object.save_time = message.save_time;
            if (message.players && message.players.length) {
                object.players = [];
                for (var j = 0; j < message.players.length; ++j)
                    object.players[j] = $root.CDOTASaveGame.Player.toObject(message.players[j], options);
            }
            if (message.save_instances && message.save_instances.length) {
                object.save_instances = [];
                for (var j = 0; j < message.save_instances.length; ++j)
                    object.save_instances[j] = $root.CDOTASaveGame.SaveInstance.toObject(message.save_instances[j], options);
            }
            if (message.match_id != null && message.hasOwnProperty("match_id"))
                if (typeof message.match_id === "number")
                    object.match_id = options.longs === String ? String(message.match_id) : message.match_id;
                else
                    object.match_id = options.longs === String ? $util.Long.prototype.toString.call(message.match_id) : options.longs === Number ? new $util.LongBits(message.match_id.low >>> 0, message.match_id.high >>> 0).toNumber(true) : message.match_id;
            return object;
        };
    
        /**
         * Converts this CDOTASaveGame to JSON.
         * @function toJSON
         * @memberof CDOTASaveGame
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTASaveGame.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CDOTASaveGame.Player = (function() {
    
            /**
             * Properties of a Player.
             * @memberof CDOTASaveGame
             * @interface IPlayer
             * @property {DOTA_GC_TEAM|null} [team] Player team
             * @property {string|null} [name] Player name
             * @property {string|null} [hero] Player hero
             */
    
            /**
             * Constructs a new Player.
             * @memberof CDOTASaveGame
             * @classdesc Represents a Player.
             * @implements IPlayer
             * @constructor
             * @param {CDOTASaveGame.IPlayer=} [properties] Properties to set
             */
            function Player(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Player team.
             * @member {DOTA_GC_TEAM} team
             * @memberof CDOTASaveGame.Player
             * @instance
             */
            Player.prototype.team = 0;
    
            /**
             * Player name.
             * @member {string} name
             * @memberof CDOTASaveGame.Player
             * @instance
             */
            Player.prototype.name = "";
    
            /**
             * Player hero.
             * @member {string} hero
             * @memberof CDOTASaveGame.Player
             * @instance
             */
            Player.prototype.hero = "";
    
            /**
             * Creates a new Player instance using the specified properties.
             * @function create
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {CDOTASaveGame.IPlayer=} [properties] Properties to set
             * @returns {CDOTASaveGame.Player} Player instance
             */
            Player.create = function create(properties) {
                return new Player(properties);
            };
    
            /**
             * Encodes the specified Player message. Does not implicitly {@link CDOTASaveGame.Player.verify|verify} messages.
             * @function encode
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {CDOTASaveGame.IPlayer} message Player message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Player.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.team != null && Object.hasOwnProperty.call(message, "team"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.team);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.hero != null && Object.hasOwnProperty.call(message, "hero"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.hero);
                return writer;
            };
    
            /**
             * Encodes the specified Player message, length delimited. Does not implicitly {@link CDOTASaveGame.Player.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {CDOTASaveGame.IPlayer} message Player message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Player.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Player message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTASaveGame.Player} Player
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Player.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTASaveGame.Player();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.team = reader.int32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.hero = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Player message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTASaveGame.Player} Player
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Player.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Player message.
             * @function verify
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Player.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.team != null && message.hasOwnProperty("team"))
                    switch (message.team) {
                    default:
                        return "team: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.hero != null && message.hasOwnProperty("hero"))
                    if (!$util.isString(message.hero))
                        return "hero: string expected";
                return null;
            };
    
            /**
             * Creates a Player message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTASaveGame.Player} Player
             */
            Player.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTASaveGame.Player)
                    return object;
                var message = new $root.CDOTASaveGame.Player();
                switch (object.team) {
                case "DOTA_GC_TEAM_GOOD_GUYS":
                case 0:
                    message.team = 0;
                    break;
                case "DOTA_GC_TEAM_BAD_GUYS":
                case 1:
                    message.team = 1;
                    break;
                case "DOTA_GC_TEAM_BROADCASTER":
                case 2:
                    message.team = 2;
                    break;
                case "DOTA_GC_TEAM_SPECTATOR":
                case 3:
                    message.team = 3;
                    break;
                case "DOTA_GC_TEAM_PLAYER_POOL":
                case 4:
                    message.team = 4;
                    break;
                case "DOTA_GC_TEAM_NOTEAM":
                case 5:
                    message.team = 5;
                    break;
                }
                if (object.name != null)
                    message.name = String(object.name);
                if (object.hero != null)
                    message.hero = String(object.hero);
                return message;
            };
    
            /**
             * Creates a plain object from a Player message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {CDOTASaveGame.Player} message Player
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Player.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.team = options.enums === String ? "DOTA_GC_TEAM_GOOD_GUYS" : 0;
                    object.name = "";
                    object.hero = "";
                }
                if (message.team != null && message.hasOwnProperty("team"))
                    object.team = options.enums === String ? $root.DOTA_GC_TEAM[message.team] : message.team;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.hero != null && message.hasOwnProperty("hero"))
                    object.hero = message.hero;
                return object;
            };
    
            /**
             * Converts this Player to JSON.
             * @function toJSON
             * @memberof CDOTASaveGame.Player
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Player.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Player;
        })();
    
        CDOTASaveGame.SaveInstance = (function() {
    
            /**
             * Properties of a SaveInstance.
             * @memberof CDOTASaveGame
             * @interface ISaveInstance
             * @property {number|null} [game_time] SaveInstance game_time
             * @property {number|null} [team1_score] SaveInstance team1_score
             * @property {number|null} [team2_score] SaveInstance team2_score
             * @property {Array.<CDOTASaveGame.SaveInstance.IPlayerPositions>|null} [player_positions] SaveInstance player_positions
             * @property {number|null} [save_id] SaveInstance save_id
             * @property {number|null} [save_time] SaveInstance save_time
             */
    
            /**
             * Constructs a new SaveInstance.
             * @memberof CDOTASaveGame
             * @classdesc Represents a SaveInstance.
             * @implements ISaveInstance
             * @constructor
             * @param {CDOTASaveGame.ISaveInstance=} [properties] Properties to set
             */
            function SaveInstance(properties) {
                this.player_positions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SaveInstance game_time.
             * @member {number} game_time
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             */
            SaveInstance.prototype.game_time = 0;
    
            /**
             * SaveInstance team1_score.
             * @member {number} team1_score
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             */
            SaveInstance.prototype.team1_score = 0;
    
            /**
             * SaveInstance team2_score.
             * @member {number} team2_score
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             */
            SaveInstance.prototype.team2_score = 0;
    
            /**
             * SaveInstance player_positions.
             * @member {Array.<CDOTASaveGame.SaveInstance.IPlayerPositions>} player_positions
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             */
            SaveInstance.prototype.player_positions = $util.emptyArray;
    
            /**
             * SaveInstance save_id.
             * @member {number} save_id
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             */
            SaveInstance.prototype.save_id = 0;
    
            /**
             * SaveInstance save_time.
             * @member {number} save_time
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             */
            SaveInstance.prototype.save_time = 0;
    
            /**
             * Creates a new SaveInstance instance using the specified properties.
             * @function create
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {CDOTASaveGame.ISaveInstance=} [properties] Properties to set
             * @returns {CDOTASaveGame.SaveInstance} SaveInstance instance
             */
            SaveInstance.create = function create(properties) {
                return new SaveInstance(properties);
            };
    
            /**
             * Encodes the specified SaveInstance message. Does not implicitly {@link CDOTASaveGame.SaveInstance.verify|verify} messages.
             * @function encode
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {CDOTASaveGame.ISaveInstance} message SaveInstance message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveInstance.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.game_time != null && Object.hasOwnProperty.call(message, "game_time"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.game_time);
                if (message.team1_score != null && Object.hasOwnProperty.call(message, "team1_score"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.team1_score);
                if (message.team2_score != null && Object.hasOwnProperty.call(message, "team2_score"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.team2_score);
                if (message.player_positions != null && message.player_positions.length)
                    for (var i = 0; i < message.player_positions.length; ++i)
                        $root.CDOTASaveGame.SaveInstance.PlayerPositions.encode(message.player_positions[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.save_id != null && Object.hasOwnProperty.call(message, "save_id"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.save_id);
                if (message.save_time != null && Object.hasOwnProperty.call(message, "save_time"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.save_time);
                return writer;
            };
    
            /**
             * Encodes the specified SaveInstance message, length delimited. Does not implicitly {@link CDOTASaveGame.SaveInstance.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {CDOTASaveGame.ISaveInstance} message SaveInstance message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveInstance.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SaveInstance message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTASaveGame.SaveInstance} SaveInstance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveInstance.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTASaveGame.SaveInstance();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.game_time = reader.uint32();
                        break;
                    case 3:
                        message.team1_score = reader.uint32();
                        break;
                    case 4:
                        message.team2_score = reader.uint32();
                        break;
                    case 5:
                        if (!(message.player_positions && message.player_positions.length))
                            message.player_positions = [];
                        message.player_positions.push($root.CDOTASaveGame.SaveInstance.PlayerPositions.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.save_id = reader.uint32();
                        break;
                    case 7:
                        message.save_time = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SaveInstance message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTASaveGame.SaveInstance} SaveInstance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveInstance.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SaveInstance message.
             * @function verify
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SaveInstance.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.game_time != null && message.hasOwnProperty("game_time"))
                    if (!$util.isInteger(message.game_time))
                        return "game_time: integer expected";
                if (message.team1_score != null && message.hasOwnProperty("team1_score"))
                    if (!$util.isInteger(message.team1_score))
                        return "team1_score: integer expected";
                if (message.team2_score != null && message.hasOwnProperty("team2_score"))
                    if (!$util.isInteger(message.team2_score))
                        return "team2_score: integer expected";
                if (message.player_positions != null && message.hasOwnProperty("player_positions")) {
                    if (!Array.isArray(message.player_positions))
                        return "player_positions: array expected";
                    for (var i = 0; i < message.player_positions.length; ++i) {
                        var error = $root.CDOTASaveGame.SaveInstance.PlayerPositions.verify(message.player_positions[i]);
                        if (error)
                            return "player_positions." + error;
                    }
                }
                if (message.save_id != null && message.hasOwnProperty("save_id"))
                    if (!$util.isInteger(message.save_id))
                        return "save_id: integer expected";
                if (message.save_time != null && message.hasOwnProperty("save_time"))
                    if (!$util.isInteger(message.save_time))
                        return "save_time: integer expected";
                return null;
            };
    
            /**
             * Creates a SaveInstance message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTASaveGame.SaveInstance} SaveInstance
             */
            SaveInstance.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTASaveGame.SaveInstance)
                    return object;
                var message = new $root.CDOTASaveGame.SaveInstance();
                if (object.game_time != null)
                    message.game_time = object.game_time >>> 0;
                if (object.team1_score != null)
                    message.team1_score = object.team1_score >>> 0;
                if (object.team2_score != null)
                    message.team2_score = object.team2_score >>> 0;
                if (object.player_positions) {
                    if (!Array.isArray(object.player_positions))
                        throw TypeError(".CDOTASaveGame.SaveInstance.player_positions: array expected");
                    message.player_positions = [];
                    for (var i = 0; i < object.player_positions.length; ++i) {
                        if (typeof object.player_positions[i] !== "object")
                            throw TypeError(".CDOTASaveGame.SaveInstance.player_positions: object expected");
                        message.player_positions[i] = $root.CDOTASaveGame.SaveInstance.PlayerPositions.fromObject(object.player_positions[i]);
                    }
                }
                if (object.save_id != null)
                    message.save_id = object.save_id >>> 0;
                if (object.save_time != null)
                    message.save_time = object.save_time >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a SaveInstance message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {CDOTASaveGame.SaveInstance} message SaveInstance
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SaveInstance.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.player_positions = [];
                if (options.defaults) {
                    object.game_time = 0;
                    object.team1_score = 0;
                    object.team2_score = 0;
                    object.save_id = 0;
                    object.save_time = 0;
                }
                if (message.game_time != null && message.hasOwnProperty("game_time"))
                    object.game_time = message.game_time;
                if (message.team1_score != null && message.hasOwnProperty("team1_score"))
                    object.team1_score = message.team1_score;
                if (message.team2_score != null && message.hasOwnProperty("team2_score"))
                    object.team2_score = message.team2_score;
                if (message.player_positions && message.player_positions.length) {
                    object.player_positions = [];
                    for (var j = 0; j < message.player_positions.length; ++j)
                        object.player_positions[j] = $root.CDOTASaveGame.SaveInstance.PlayerPositions.toObject(message.player_positions[j], options);
                }
                if (message.save_id != null && message.hasOwnProperty("save_id"))
                    object.save_id = message.save_id;
                if (message.save_time != null && message.hasOwnProperty("save_time"))
                    object.save_time = message.save_time;
                return object;
            };
    
            /**
             * Converts this SaveInstance to JSON.
             * @function toJSON
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SaveInstance.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            SaveInstance.PlayerPositions = (function() {
    
                /**
                 * Properties of a PlayerPositions.
                 * @memberof CDOTASaveGame.SaveInstance
                 * @interface IPlayerPositions
                 * @property {number|null} [x] PlayerPositions x
                 * @property {number|null} [y] PlayerPositions y
                 */
    
                /**
                 * Constructs a new PlayerPositions.
                 * @memberof CDOTASaveGame.SaveInstance
                 * @classdesc Represents a PlayerPositions.
                 * @implements IPlayerPositions
                 * @constructor
                 * @param {CDOTASaveGame.SaveInstance.IPlayerPositions=} [properties] Properties to set
                 */
                function PlayerPositions(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PlayerPositions x.
                 * @member {number} x
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @instance
                 */
                PlayerPositions.prototype.x = 0;
    
                /**
                 * PlayerPositions y.
                 * @member {number} y
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @instance
                 */
                PlayerPositions.prototype.y = 0;
    
                /**
                 * Creates a new PlayerPositions instance using the specified properties.
                 * @function create
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {CDOTASaveGame.SaveInstance.IPlayerPositions=} [properties] Properties to set
                 * @returns {CDOTASaveGame.SaveInstance.PlayerPositions} PlayerPositions instance
                 */
                PlayerPositions.create = function create(properties) {
                    return new PlayerPositions(properties);
                };
    
                /**
                 * Encodes the specified PlayerPositions message. Does not implicitly {@link CDOTASaveGame.SaveInstance.PlayerPositions.verify|verify} messages.
                 * @function encode
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {CDOTASaveGame.SaveInstance.IPlayerPositions} message PlayerPositions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayerPositions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
                    if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
                    return writer;
                };
    
                /**
                 * Encodes the specified PlayerPositions message, length delimited. Does not implicitly {@link CDOTASaveGame.SaveInstance.PlayerPositions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {CDOTASaveGame.SaveInstance.IPlayerPositions} message PlayerPositions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayerPositions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PlayerPositions message from the specified reader or buffer.
                 * @function decode
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CDOTASaveGame.SaveInstance.PlayerPositions} PlayerPositions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayerPositions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTASaveGame.SaveInstance.PlayerPositions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.x = reader.float();
                            break;
                        case 2:
                            message.y = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PlayerPositions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CDOTASaveGame.SaveInstance.PlayerPositions} PlayerPositions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayerPositions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PlayerPositions message.
                 * @function verify
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PlayerPositions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.x != null && message.hasOwnProperty("x"))
                        if (typeof message.x !== "number")
                            return "x: number expected";
                    if (message.y != null && message.hasOwnProperty("y"))
                        if (typeof message.y !== "number")
                            return "y: number expected";
                    return null;
                };
    
                /**
                 * Creates a PlayerPositions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CDOTASaveGame.SaveInstance.PlayerPositions} PlayerPositions
                 */
                PlayerPositions.fromObject = function fromObject(object) {
                    if (object instanceof $root.CDOTASaveGame.SaveInstance.PlayerPositions)
                        return object;
                    var message = new $root.CDOTASaveGame.SaveInstance.PlayerPositions();
                    if (object.x != null)
                        message.x = Number(object.x);
                    if (object.y != null)
                        message.y = Number(object.y);
                    return message;
                };
    
                /**
                 * Creates a plain object from a PlayerPositions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {CDOTASaveGame.SaveInstance.PlayerPositions} message PlayerPositions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlayerPositions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.x = 0;
                        object.y = 0;
                    }
                    if (message.x != null && message.hasOwnProperty("x"))
                        object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
                    if (message.y != null && message.hasOwnProperty("y"))
                        object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
                    return object;
                };
    
                /**
                 * Converts this PlayerPositions to JSON.
                 * @function toJSON
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlayerPositions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PlayerPositions;
            })();
    
            return SaveInstance;
        })();
    
        return CDOTASaveGame;
    })();
    
    $root.CMsgDOTACombatLogEntry = (function() {
    
        /**
         * Properties of a CMsgDOTACombatLogEntry.
         * @exports ICMsgDOTACombatLogEntry
         * @interface ICMsgDOTACombatLogEntry
         * @property {DOTA_COMBATLOG_TYPES|null} [type] CMsgDOTACombatLogEntry type
         * @property {number|null} [target_name] CMsgDOTACombatLogEntry target_name
         * @property {number|null} [target_source_name] CMsgDOTACombatLogEntry target_source_name
         * @property {number|null} [attacker_name] CMsgDOTACombatLogEntry attacker_name
         * @property {number|null} [damage_source_name] CMsgDOTACombatLogEntry damage_source_name
         * @property {number|null} [inflictor_name] CMsgDOTACombatLogEntry inflictor_name
         * @property {boolean|null} [is_attacker_illusion] CMsgDOTACombatLogEntry is_attacker_illusion
         * @property {boolean|null} [is_attacker_hero] CMsgDOTACombatLogEntry is_attacker_hero
         * @property {boolean|null} [is_target_illusion] CMsgDOTACombatLogEntry is_target_illusion
         * @property {boolean|null} [is_target_hero] CMsgDOTACombatLogEntry is_target_hero
         * @property {boolean|null} [is_visible_radiant] CMsgDOTACombatLogEntry is_visible_radiant
         * @property {boolean|null} [is_visible_dire] CMsgDOTACombatLogEntry is_visible_dire
         * @property {number|null} [value] CMsgDOTACombatLogEntry value
         * @property {number|null} [health] CMsgDOTACombatLogEntry health
         * @property {number|null} [timestamp] CMsgDOTACombatLogEntry timestamp
         * @property {number|null} [stun_duration] CMsgDOTACombatLogEntry stun_duration
         * @property {number|null} [slow_duration] CMsgDOTACombatLogEntry slow_duration
         * @property {boolean|null} [is_ability_toggle_on] CMsgDOTACombatLogEntry is_ability_toggle_on
         * @property {boolean|null} [is_ability_toggle_off] CMsgDOTACombatLogEntry is_ability_toggle_off
         * @property {number|null} [ability_level] CMsgDOTACombatLogEntry ability_level
         * @property {number|null} [location_x] CMsgDOTACombatLogEntry location_x
         * @property {number|null} [location_y] CMsgDOTACombatLogEntry location_y
         * @property {number|null} [gold_reason] CMsgDOTACombatLogEntry gold_reason
         * @property {number|null} [timestamp_raw] CMsgDOTACombatLogEntry timestamp_raw
         * @property {number|null} [modifier_duration] CMsgDOTACombatLogEntry modifier_duration
         * @property {number|null} [xp_reason] CMsgDOTACombatLogEntry xp_reason
         * @property {number|null} [last_hits] CMsgDOTACombatLogEntry last_hits
         * @property {number|null} [attacker_team] CMsgDOTACombatLogEntry attacker_team
         * @property {number|null} [target_team] CMsgDOTACombatLogEntry target_team
         * @property {number|null} [obs_wards_placed] CMsgDOTACombatLogEntry obs_wards_placed
         * @property {number|null} [assist_player0] CMsgDOTACombatLogEntry assist_player0
         * @property {number|null} [assist_player1] CMsgDOTACombatLogEntry assist_player1
         * @property {number|null} [assist_player2] CMsgDOTACombatLogEntry assist_player2
         * @property {number|null} [assist_player3] CMsgDOTACombatLogEntry assist_player3
         * @property {number|null} [stack_count] CMsgDOTACombatLogEntry stack_count
         * @property {boolean|null} [hidden_modifier] CMsgDOTACombatLogEntry hidden_modifier
         * @property {boolean|null} [is_target_building] CMsgDOTACombatLogEntry is_target_building
         * @property {number|null} [neutral_camp_type] CMsgDOTACombatLogEntry neutral_camp_type
         * @property {number|null} [rune_type] CMsgDOTACombatLogEntry rune_type
         * @property {Array.<number>|null} [assist_players] CMsgDOTACombatLogEntry assist_players
         * @property {boolean|null} [is_heal_save] CMsgDOTACombatLogEntry is_heal_save
         * @property {boolean|null} [is_ultimate_ability] CMsgDOTACombatLogEntry is_ultimate_ability
         * @property {number|null} [attacker_hero_level] CMsgDOTACombatLogEntry attacker_hero_level
         * @property {number|null} [target_hero_level] CMsgDOTACombatLogEntry target_hero_level
         * @property {number|null} [xpm] CMsgDOTACombatLogEntry xpm
         * @property {number|null} [gpm] CMsgDOTACombatLogEntry gpm
         * @property {number|null} [event_location] CMsgDOTACombatLogEntry event_location
         * @property {boolean|null} [target_is_self] CMsgDOTACombatLogEntry target_is_self
         * @property {number|null} [damage_type] CMsgDOTACombatLogEntry damage_type
         * @property {boolean|null} [invisibility_modifier] CMsgDOTACombatLogEntry invisibility_modifier
         * @property {number|null} [damage_category] CMsgDOTACombatLogEntry damage_category
         * @property {number|null} [networth] CMsgDOTACombatLogEntry networth
         * @property {number|null} [building_type] CMsgDOTACombatLogEntry building_type
         * @property {number|null} [modifier_elapsed_duration] CMsgDOTACombatLogEntry modifier_elapsed_duration
         * @property {boolean|null} [silence_modifier] CMsgDOTACombatLogEntry silence_modifier
         * @property {boolean|null} [heal_from_lifesteal] CMsgDOTACombatLogEntry heal_from_lifesteal
         * @property {boolean|null} [modifier_purged] CMsgDOTACombatLogEntry modifier_purged
         * @property {boolean|null} [spell_evaded] CMsgDOTACombatLogEntry spell_evaded
         * @property {boolean|null} [motion_controller_modifier] CMsgDOTACombatLogEntry motion_controller_modifier
         * @property {boolean|null} [long_range_kill] CMsgDOTACombatLogEntry long_range_kill
         * @property {number|null} [modifier_purge_ability] CMsgDOTACombatLogEntry modifier_purge_ability
         * @property {number|null} [modifier_purge_npc] CMsgDOTACombatLogEntry modifier_purge_npc
         * @property {boolean|null} [root_modifier] CMsgDOTACombatLogEntry root_modifier
         * @property {number|null} [total_unit_death_count] CMsgDOTACombatLogEntry total_unit_death_count
         * @property {boolean|null} [aura_modifier] CMsgDOTACombatLogEntry aura_modifier
         * @property {boolean|null} [armor_debuff_modifier] CMsgDOTACombatLogEntry armor_debuff_modifier
         * @property {boolean|null} [no_physical_damage_modifier] CMsgDOTACombatLogEntry no_physical_damage_modifier
         * @property {number|null} [modifier_ability] CMsgDOTACombatLogEntry modifier_ability
         * @property {boolean|null} [modifier_hidden] CMsgDOTACombatLogEntry modifier_hidden
         * @property {boolean|null} [inflictor_is_stolen_ability] CMsgDOTACombatLogEntry inflictor_is_stolen_ability
         * @property {number|null} [kill_eater_event] CMsgDOTACombatLogEntry kill_eater_event
         * @property {number|null} [unit_status_label] CMsgDOTACombatLogEntry unit_status_label
         * @property {boolean|null} [spell_generated_attack] CMsgDOTACombatLogEntry spell_generated_attack
         * @property {boolean|null} [at_night_time] CMsgDOTACombatLogEntry at_night_time
         * @property {boolean|null} [attacker_has_scepter] CMsgDOTACombatLogEntry attacker_has_scepter
         */
    
        /**
         * Constructs a new CMsgDOTACombatLogEntry.
         * @exports CMsgDOTACombatLogEntry
         * @classdesc Represents a CMsgDOTACombatLogEntry.
         * @implements ICMsgDOTACombatLogEntry
         * @constructor
         * @param {ICMsgDOTACombatLogEntry=} [properties] Properties to set
         */
        function CMsgDOTACombatLogEntry(properties) {
            this.assist_players = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTACombatLogEntry type.
         * @member {DOTA_COMBATLOG_TYPES} type
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.type = -1;
    
        /**
         * CMsgDOTACombatLogEntry target_name.
         * @member {number} target_name
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.target_name = 0;
    
        /**
         * CMsgDOTACombatLogEntry target_source_name.
         * @member {number} target_source_name
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.target_source_name = 0;
    
        /**
         * CMsgDOTACombatLogEntry attacker_name.
         * @member {number} attacker_name
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.attacker_name = 0;
    
        /**
         * CMsgDOTACombatLogEntry damage_source_name.
         * @member {number} damage_source_name
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.damage_source_name = 0;
    
        /**
         * CMsgDOTACombatLogEntry inflictor_name.
         * @member {number} inflictor_name
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.inflictor_name = 0;
    
        /**
         * CMsgDOTACombatLogEntry is_attacker_illusion.
         * @member {boolean} is_attacker_illusion
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_attacker_illusion = false;
    
        /**
         * CMsgDOTACombatLogEntry is_attacker_hero.
         * @member {boolean} is_attacker_hero
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_attacker_hero = false;
    
        /**
         * CMsgDOTACombatLogEntry is_target_illusion.
         * @member {boolean} is_target_illusion
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_target_illusion = false;
    
        /**
         * CMsgDOTACombatLogEntry is_target_hero.
         * @member {boolean} is_target_hero
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_target_hero = false;
    
        /**
         * CMsgDOTACombatLogEntry is_visible_radiant.
         * @member {boolean} is_visible_radiant
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_visible_radiant = false;
    
        /**
         * CMsgDOTACombatLogEntry is_visible_dire.
         * @member {boolean} is_visible_dire
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_visible_dire = false;
    
        /**
         * CMsgDOTACombatLogEntry value.
         * @member {number} value
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.value = 0;
    
        /**
         * CMsgDOTACombatLogEntry health.
         * @member {number} health
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.health = 0;
    
        /**
         * CMsgDOTACombatLogEntry timestamp.
         * @member {number} timestamp
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.timestamp = 0;
    
        /**
         * CMsgDOTACombatLogEntry stun_duration.
         * @member {number} stun_duration
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.stun_duration = 0;
    
        /**
         * CMsgDOTACombatLogEntry slow_duration.
         * @member {number} slow_duration
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.slow_duration = 0;
    
        /**
         * CMsgDOTACombatLogEntry is_ability_toggle_on.
         * @member {boolean} is_ability_toggle_on
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_ability_toggle_on = false;
    
        /**
         * CMsgDOTACombatLogEntry is_ability_toggle_off.
         * @member {boolean} is_ability_toggle_off
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_ability_toggle_off = false;
    
        /**
         * CMsgDOTACombatLogEntry ability_level.
         * @member {number} ability_level
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.ability_level = 0;
    
        /**
         * CMsgDOTACombatLogEntry location_x.
         * @member {number} location_x
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.location_x = 0;
    
        /**
         * CMsgDOTACombatLogEntry location_y.
         * @member {number} location_y
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.location_y = 0;
    
        /**
         * CMsgDOTACombatLogEntry gold_reason.
         * @member {number} gold_reason
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.gold_reason = 0;
    
        /**
         * CMsgDOTACombatLogEntry timestamp_raw.
         * @member {number} timestamp_raw
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.timestamp_raw = 0;
    
        /**
         * CMsgDOTACombatLogEntry modifier_duration.
         * @member {number} modifier_duration
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_duration = 0;
    
        /**
         * CMsgDOTACombatLogEntry xp_reason.
         * @member {number} xp_reason
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.xp_reason = 0;
    
        /**
         * CMsgDOTACombatLogEntry last_hits.
         * @member {number} last_hits
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.last_hits = 0;
    
        /**
         * CMsgDOTACombatLogEntry attacker_team.
         * @member {number} attacker_team
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.attacker_team = 0;
    
        /**
         * CMsgDOTACombatLogEntry target_team.
         * @member {number} target_team
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.target_team = 0;
    
        /**
         * CMsgDOTACombatLogEntry obs_wards_placed.
         * @member {number} obs_wards_placed
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.obs_wards_placed = 0;
    
        /**
         * CMsgDOTACombatLogEntry assist_player0.
         * @member {number} assist_player0
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.assist_player0 = 0;
    
        /**
         * CMsgDOTACombatLogEntry assist_player1.
         * @member {number} assist_player1
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.assist_player1 = 0;
    
        /**
         * CMsgDOTACombatLogEntry assist_player2.
         * @member {number} assist_player2
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.assist_player2 = 0;
    
        /**
         * CMsgDOTACombatLogEntry assist_player3.
         * @member {number} assist_player3
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.assist_player3 = 0;
    
        /**
         * CMsgDOTACombatLogEntry stack_count.
         * @member {number} stack_count
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.stack_count = 0;
    
        /**
         * CMsgDOTACombatLogEntry hidden_modifier.
         * @member {boolean} hidden_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.hidden_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry is_target_building.
         * @member {boolean} is_target_building
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_target_building = false;
    
        /**
         * CMsgDOTACombatLogEntry neutral_camp_type.
         * @member {number} neutral_camp_type
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.neutral_camp_type = 0;
    
        /**
         * CMsgDOTACombatLogEntry rune_type.
         * @member {number} rune_type
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.rune_type = 0;
    
        /**
         * CMsgDOTACombatLogEntry assist_players.
         * @member {Array.<number>} assist_players
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.assist_players = $util.emptyArray;
    
        /**
         * CMsgDOTACombatLogEntry is_heal_save.
         * @member {boolean} is_heal_save
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_heal_save = false;
    
        /**
         * CMsgDOTACombatLogEntry is_ultimate_ability.
         * @member {boolean} is_ultimate_ability
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_ultimate_ability = false;
    
        /**
         * CMsgDOTACombatLogEntry attacker_hero_level.
         * @member {number} attacker_hero_level
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.attacker_hero_level = 0;
    
        /**
         * CMsgDOTACombatLogEntry target_hero_level.
         * @member {number} target_hero_level
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.target_hero_level = 0;
    
        /**
         * CMsgDOTACombatLogEntry xpm.
         * @member {number} xpm
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.xpm = 0;
    
        /**
         * CMsgDOTACombatLogEntry gpm.
         * @member {number} gpm
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.gpm = 0;
    
        /**
         * CMsgDOTACombatLogEntry event_location.
         * @member {number} event_location
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.event_location = 0;
    
        /**
         * CMsgDOTACombatLogEntry target_is_self.
         * @member {boolean} target_is_self
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.target_is_self = false;
    
        /**
         * CMsgDOTACombatLogEntry damage_type.
         * @member {number} damage_type
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.damage_type = 0;
    
        /**
         * CMsgDOTACombatLogEntry invisibility_modifier.
         * @member {boolean} invisibility_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.invisibility_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry damage_category.
         * @member {number} damage_category
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.damage_category = 0;
    
        /**
         * CMsgDOTACombatLogEntry networth.
         * @member {number} networth
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.networth = 0;
    
        /**
         * CMsgDOTACombatLogEntry building_type.
         * @member {number} building_type
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.building_type = 0;
    
        /**
         * CMsgDOTACombatLogEntry modifier_elapsed_duration.
         * @member {number} modifier_elapsed_duration
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_elapsed_duration = 0;
    
        /**
         * CMsgDOTACombatLogEntry silence_modifier.
         * @member {boolean} silence_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.silence_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry heal_from_lifesteal.
         * @member {boolean} heal_from_lifesteal
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.heal_from_lifesteal = false;
    
        /**
         * CMsgDOTACombatLogEntry modifier_purged.
         * @member {boolean} modifier_purged
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_purged = false;
    
        /**
         * CMsgDOTACombatLogEntry spell_evaded.
         * @member {boolean} spell_evaded
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.spell_evaded = false;
    
        /**
         * CMsgDOTACombatLogEntry motion_controller_modifier.
         * @member {boolean} motion_controller_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.motion_controller_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry long_range_kill.
         * @member {boolean} long_range_kill
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.long_range_kill = false;
    
        /**
         * CMsgDOTACombatLogEntry modifier_purge_ability.
         * @member {number} modifier_purge_ability
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_purge_ability = 0;
    
        /**
         * CMsgDOTACombatLogEntry modifier_purge_npc.
         * @member {number} modifier_purge_npc
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_purge_npc = 0;
    
        /**
         * CMsgDOTACombatLogEntry root_modifier.
         * @member {boolean} root_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.root_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry total_unit_death_count.
         * @member {number} total_unit_death_count
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.total_unit_death_count = 0;
    
        /**
         * CMsgDOTACombatLogEntry aura_modifier.
         * @member {boolean} aura_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.aura_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry armor_debuff_modifier.
         * @member {boolean} armor_debuff_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.armor_debuff_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry no_physical_damage_modifier.
         * @member {boolean} no_physical_damage_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.no_physical_damage_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry modifier_ability.
         * @member {number} modifier_ability
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_ability = 0;
    
        /**
         * CMsgDOTACombatLogEntry modifier_hidden.
         * @member {boolean} modifier_hidden
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_hidden = false;
    
        /**
         * CMsgDOTACombatLogEntry inflictor_is_stolen_ability.
         * @member {boolean} inflictor_is_stolen_ability
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.inflictor_is_stolen_ability = false;
    
        /**
         * CMsgDOTACombatLogEntry kill_eater_event.
         * @member {number} kill_eater_event
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.kill_eater_event = 0;
    
        /**
         * CMsgDOTACombatLogEntry unit_status_label.
         * @member {number} unit_status_label
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.unit_status_label = 0;
    
        /**
         * CMsgDOTACombatLogEntry spell_generated_attack.
         * @member {boolean} spell_generated_attack
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.spell_generated_attack = false;
    
        /**
         * CMsgDOTACombatLogEntry at_night_time.
         * @member {boolean} at_night_time
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.at_night_time = false;
    
        /**
         * CMsgDOTACombatLogEntry attacker_has_scepter.
         * @member {boolean} attacker_has_scepter
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.attacker_has_scepter = false;
    
        /**
         * Creates a new CMsgDOTACombatLogEntry instance using the specified properties.
         * @function create
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {ICMsgDOTACombatLogEntry=} [properties] Properties to set
         * @returns {CMsgDOTACombatLogEntry} CMsgDOTACombatLogEntry instance
         */
        CMsgDOTACombatLogEntry.create = function create(properties) {
            return new CMsgDOTACombatLogEntry(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTACombatLogEntry message. Does not implicitly {@link CMsgDOTACombatLogEntry.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {ICMsgDOTACombatLogEntry} message CMsgDOTACombatLogEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTACombatLogEntry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.target_name != null && Object.hasOwnProperty.call(message, "target_name"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.target_name);
            if (message.target_source_name != null && Object.hasOwnProperty.call(message, "target_source_name"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.target_source_name);
            if (message.attacker_name != null && Object.hasOwnProperty.call(message, "attacker_name"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.attacker_name);
            if (message.damage_source_name != null && Object.hasOwnProperty.call(message, "damage_source_name"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.damage_source_name);
            if (message.inflictor_name != null && Object.hasOwnProperty.call(message, "inflictor_name"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.inflictor_name);
            if (message.is_attacker_illusion != null && Object.hasOwnProperty.call(message, "is_attacker_illusion"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.is_attacker_illusion);
            if (message.is_attacker_hero != null && Object.hasOwnProperty.call(message, "is_attacker_hero"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.is_attacker_hero);
            if (message.is_target_illusion != null && Object.hasOwnProperty.call(message, "is_target_illusion"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.is_target_illusion);
            if (message.is_target_hero != null && Object.hasOwnProperty.call(message, "is_target_hero"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.is_target_hero);
            if (message.is_visible_radiant != null && Object.hasOwnProperty.call(message, "is_visible_radiant"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.is_visible_radiant);
            if (message.is_visible_dire != null && Object.hasOwnProperty.call(message, "is_visible_dire"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.is_visible_dire);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.value);
            if (message.health != null && Object.hasOwnProperty.call(message, "health"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.health);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 15, wireType 5 =*/125).float(message.timestamp);
            if (message.stun_duration != null && Object.hasOwnProperty.call(message, "stun_duration"))
                writer.uint32(/* id 16, wireType 5 =*/133).float(message.stun_duration);
            if (message.slow_duration != null && Object.hasOwnProperty.call(message, "slow_duration"))
                writer.uint32(/* id 17, wireType 5 =*/141).float(message.slow_duration);
            if (message.is_ability_toggle_on != null && Object.hasOwnProperty.call(message, "is_ability_toggle_on"))
                writer.uint32(/* id 18, wireType 0 =*/144).bool(message.is_ability_toggle_on);
            if (message.is_ability_toggle_off != null && Object.hasOwnProperty.call(message, "is_ability_toggle_off"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.is_ability_toggle_off);
            if (message.ability_level != null && Object.hasOwnProperty.call(message, "ability_level"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.ability_level);
            if (message.location_x != null && Object.hasOwnProperty.call(message, "location_x"))
                writer.uint32(/* id 21, wireType 5 =*/173).float(message.location_x);
            if (message.location_y != null && Object.hasOwnProperty.call(message, "location_y"))
                writer.uint32(/* id 22, wireType 5 =*/181).float(message.location_y);
            if (message.gold_reason != null && Object.hasOwnProperty.call(message, "gold_reason"))
                writer.uint32(/* id 23, wireType 0 =*/184).uint32(message.gold_reason);
            if (message.timestamp_raw != null && Object.hasOwnProperty.call(message, "timestamp_raw"))
                writer.uint32(/* id 24, wireType 5 =*/197).float(message.timestamp_raw);
            if (message.modifier_duration != null && Object.hasOwnProperty.call(message, "modifier_duration"))
                writer.uint32(/* id 25, wireType 5 =*/205).float(message.modifier_duration);
            if (message.xp_reason != null && Object.hasOwnProperty.call(message, "xp_reason"))
                writer.uint32(/* id 26, wireType 0 =*/208).uint32(message.xp_reason);
            if (message.last_hits != null && Object.hasOwnProperty.call(message, "last_hits"))
                writer.uint32(/* id 27, wireType 0 =*/216).uint32(message.last_hits);
            if (message.attacker_team != null && Object.hasOwnProperty.call(message, "attacker_team"))
                writer.uint32(/* id 28, wireType 0 =*/224).uint32(message.attacker_team);
            if (message.target_team != null && Object.hasOwnProperty.call(message, "target_team"))
                writer.uint32(/* id 29, wireType 0 =*/232).uint32(message.target_team);
            if (message.obs_wards_placed != null && Object.hasOwnProperty.call(message, "obs_wards_placed"))
                writer.uint32(/* id 30, wireType 0 =*/240).uint32(message.obs_wards_placed);
            if (message.assist_player0 != null && Object.hasOwnProperty.call(message, "assist_player0"))
                writer.uint32(/* id 31, wireType 0 =*/248).uint32(message.assist_player0);
            if (message.assist_player1 != null && Object.hasOwnProperty.call(message, "assist_player1"))
                writer.uint32(/* id 32, wireType 0 =*/256).uint32(message.assist_player1);
            if (message.assist_player2 != null && Object.hasOwnProperty.call(message, "assist_player2"))
                writer.uint32(/* id 33, wireType 0 =*/264).uint32(message.assist_player2);
            if (message.assist_player3 != null && Object.hasOwnProperty.call(message, "assist_player3"))
                writer.uint32(/* id 34, wireType 0 =*/272).uint32(message.assist_player3);
            if (message.stack_count != null && Object.hasOwnProperty.call(message, "stack_count"))
                writer.uint32(/* id 35, wireType 0 =*/280).uint32(message.stack_count);
            if (message.hidden_modifier != null && Object.hasOwnProperty.call(message, "hidden_modifier"))
                writer.uint32(/* id 36, wireType 0 =*/288).bool(message.hidden_modifier);
            if (message.is_target_building != null && Object.hasOwnProperty.call(message, "is_target_building"))
                writer.uint32(/* id 37, wireType 0 =*/296).bool(message.is_target_building);
            if (message.neutral_camp_type != null && Object.hasOwnProperty.call(message, "neutral_camp_type"))
                writer.uint32(/* id 38, wireType 0 =*/304).uint32(message.neutral_camp_type);
            if (message.rune_type != null && Object.hasOwnProperty.call(message, "rune_type"))
                writer.uint32(/* id 39, wireType 0 =*/312).uint32(message.rune_type);
            if (message.assist_players != null && message.assist_players.length)
                for (var i = 0; i < message.assist_players.length; ++i)
                    writer.uint32(/* id 40, wireType 0 =*/320).uint32(message.assist_players[i]);
            if (message.is_heal_save != null && Object.hasOwnProperty.call(message, "is_heal_save"))
                writer.uint32(/* id 41, wireType 0 =*/328).bool(message.is_heal_save);
            if (message.is_ultimate_ability != null && Object.hasOwnProperty.call(message, "is_ultimate_ability"))
                writer.uint32(/* id 42, wireType 0 =*/336).bool(message.is_ultimate_ability);
            if (message.attacker_hero_level != null && Object.hasOwnProperty.call(message, "attacker_hero_level"))
                writer.uint32(/* id 43, wireType 0 =*/344).uint32(message.attacker_hero_level);
            if (message.target_hero_level != null && Object.hasOwnProperty.call(message, "target_hero_level"))
                writer.uint32(/* id 44, wireType 0 =*/352).uint32(message.target_hero_level);
            if (message.xpm != null && Object.hasOwnProperty.call(message, "xpm"))
                writer.uint32(/* id 45, wireType 0 =*/360).uint32(message.xpm);
            if (message.gpm != null && Object.hasOwnProperty.call(message, "gpm"))
                writer.uint32(/* id 46, wireType 0 =*/368).uint32(message.gpm);
            if (message.event_location != null && Object.hasOwnProperty.call(message, "event_location"))
                writer.uint32(/* id 47, wireType 0 =*/376).uint32(message.event_location);
            if (message.target_is_self != null && Object.hasOwnProperty.call(message, "target_is_self"))
                writer.uint32(/* id 48, wireType 0 =*/384).bool(message.target_is_self);
            if (message.damage_type != null && Object.hasOwnProperty.call(message, "damage_type"))
                writer.uint32(/* id 49, wireType 0 =*/392).uint32(message.damage_type);
            if (message.invisibility_modifier != null && Object.hasOwnProperty.call(message, "invisibility_modifier"))
                writer.uint32(/* id 50, wireType 0 =*/400).bool(message.invisibility_modifier);
            if (message.damage_category != null && Object.hasOwnProperty.call(message, "damage_category"))
                writer.uint32(/* id 51, wireType 0 =*/408).uint32(message.damage_category);
            if (message.networth != null && Object.hasOwnProperty.call(message, "networth"))
                writer.uint32(/* id 52, wireType 0 =*/416).uint32(message.networth);
            if (message.building_type != null && Object.hasOwnProperty.call(message, "building_type"))
                writer.uint32(/* id 53, wireType 0 =*/424).uint32(message.building_type);
            if (message.modifier_elapsed_duration != null && Object.hasOwnProperty.call(message, "modifier_elapsed_duration"))
                writer.uint32(/* id 54, wireType 5 =*/437).float(message.modifier_elapsed_duration);
            if (message.silence_modifier != null && Object.hasOwnProperty.call(message, "silence_modifier"))
                writer.uint32(/* id 55, wireType 0 =*/440).bool(message.silence_modifier);
            if (message.heal_from_lifesteal != null && Object.hasOwnProperty.call(message, "heal_from_lifesteal"))
                writer.uint32(/* id 56, wireType 0 =*/448).bool(message.heal_from_lifesteal);
            if (message.modifier_purged != null && Object.hasOwnProperty.call(message, "modifier_purged"))
                writer.uint32(/* id 57, wireType 0 =*/456).bool(message.modifier_purged);
            if (message.spell_evaded != null && Object.hasOwnProperty.call(message, "spell_evaded"))
                writer.uint32(/* id 58, wireType 0 =*/464).bool(message.spell_evaded);
            if (message.motion_controller_modifier != null && Object.hasOwnProperty.call(message, "motion_controller_modifier"))
                writer.uint32(/* id 59, wireType 0 =*/472).bool(message.motion_controller_modifier);
            if (message.long_range_kill != null && Object.hasOwnProperty.call(message, "long_range_kill"))
                writer.uint32(/* id 60, wireType 0 =*/480).bool(message.long_range_kill);
            if (message.modifier_purge_ability != null && Object.hasOwnProperty.call(message, "modifier_purge_ability"))
                writer.uint32(/* id 61, wireType 0 =*/488).uint32(message.modifier_purge_ability);
            if (message.modifier_purge_npc != null && Object.hasOwnProperty.call(message, "modifier_purge_npc"))
                writer.uint32(/* id 62, wireType 0 =*/496).uint32(message.modifier_purge_npc);
            if (message.root_modifier != null && Object.hasOwnProperty.call(message, "root_modifier"))
                writer.uint32(/* id 63, wireType 0 =*/504).bool(message.root_modifier);
            if (message.total_unit_death_count != null && Object.hasOwnProperty.call(message, "total_unit_death_count"))
                writer.uint32(/* id 64, wireType 0 =*/512).uint32(message.total_unit_death_count);
            if (message.aura_modifier != null && Object.hasOwnProperty.call(message, "aura_modifier"))
                writer.uint32(/* id 65, wireType 0 =*/520).bool(message.aura_modifier);
            if (message.armor_debuff_modifier != null && Object.hasOwnProperty.call(message, "armor_debuff_modifier"))
                writer.uint32(/* id 66, wireType 0 =*/528).bool(message.armor_debuff_modifier);
            if (message.no_physical_damage_modifier != null && Object.hasOwnProperty.call(message, "no_physical_damage_modifier"))
                writer.uint32(/* id 67, wireType 0 =*/536).bool(message.no_physical_damage_modifier);
            if (message.modifier_ability != null && Object.hasOwnProperty.call(message, "modifier_ability"))
                writer.uint32(/* id 68, wireType 0 =*/544).uint32(message.modifier_ability);
            if (message.modifier_hidden != null && Object.hasOwnProperty.call(message, "modifier_hidden"))
                writer.uint32(/* id 69, wireType 0 =*/552).bool(message.modifier_hidden);
            if (message.inflictor_is_stolen_ability != null && Object.hasOwnProperty.call(message, "inflictor_is_stolen_ability"))
                writer.uint32(/* id 70, wireType 0 =*/560).bool(message.inflictor_is_stolen_ability);
            if (message.kill_eater_event != null && Object.hasOwnProperty.call(message, "kill_eater_event"))
                writer.uint32(/* id 71, wireType 0 =*/568).uint32(message.kill_eater_event);
            if (message.unit_status_label != null && Object.hasOwnProperty.call(message, "unit_status_label"))
                writer.uint32(/* id 72, wireType 0 =*/576).uint32(message.unit_status_label);
            if (message.spell_generated_attack != null && Object.hasOwnProperty.call(message, "spell_generated_attack"))
                writer.uint32(/* id 73, wireType 0 =*/584).bool(message.spell_generated_attack);
            if (message.at_night_time != null && Object.hasOwnProperty.call(message, "at_night_time"))
                writer.uint32(/* id 74, wireType 0 =*/592).bool(message.at_night_time);
            if (message.attacker_has_scepter != null && Object.hasOwnProperty.call(message, "attacker_has_scepter"))
                writer.uint32(/* id 75, wireType 0 =*/600).bool(message.attacker_has_scepter);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTACombatLogEntry message, length delimited. Does not implicitly {@link CMsgDOTACombatLogEntry.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {ICMsgDOTACombatLogEntry} message CMsgDOTACombatLogEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTACombatLogEntry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTACombatLogEntry message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTACombatLogEntry} CMsgDOTACombatLogEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTACombatLogEntry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTACombatLogEntry();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.target_name = reader.uint32();
                    break;
                case 3:
                    message.target_source_name = reader.uint32();
                    break;
                case 4:
                    message.attacker_name = reader.uint32();
                    break;
                case 5:
                    message.damage_source_name = reader.uint32();
                    break;
                case 6:
                    message.inflictor_name = reader.uint32();
                    break;
                case 7:
                    message.is_attacker_illusion = reader.bool();
                    break;
                case 8:
                    message.is_attacker_hero = reader.bool();
                    break;
                case 9:
                    message.is_target_illusion = reader.bool();
                    break;
                case 10:
                    message.is_target_hero = reader.bool();
                    break;
                case 11:
                    message.is_visible_radiant = reader.bool();
                    break;
                case 12:
                    message.is_visible_dire = reader.bool();
                    break;
                case 13:
                    message.value = reader.uint32();
                    break;
                case 14:
                    message.health = reader.int32();
                    break;
                case 15:
                    message.timestamp = reader.float();
                    break;
                case 16:
                    message.stun_duration = reader.float();
                    break;
                case 17:
                    message.slow_duration = reader.float();
                    break;
                case 18:
                    message.is_ability_toggle_on = reader.bool();
                    break;
                case 19:
                    message.is_ability_toggle_off = reader.bool();
                    break;
                case 20:
                    message.ability_level = reader.uint32();
                    break;
                case 21:
                    message.location_x = reader.float();
                    break;
                case 22:
                    message.location_y = reader.float();
                    break;
                case 23:
                    message.gold_reason = reader.uint32();
                    break;
                case 24:
                    message.timestamp_raw = reader.float();
                    break;
                case 25:
                    message.modifier_duration = reader.float();
                    break;
                case 26:
                    message.xp_reason = reader.uint32();
                    break;
                case 27:
                    message.last_hits = reader.uint32();
                    break;
                case 28:
                    message.attacker_team = reader.uint32();
                    break;
                case 29:
                    message.target_team = reader.uint32();
                    break;
                case 30:
                    message.obs_wards_placed = reader.uint32();
                    break;
                case 31:
                    message.assist_player0 = reader.uint32();
                    break;
                case 32:
                    message.assist_player1 = reader.uint32();
                    break;
                case 33:
                    message.assist_player2 = reader.uint32();
                    break;
                case 34:
                    message.assist_player3 = reader.uint32();
                    break;
                case 35:
                    message.stack_count = reader.uint32();
                    break;
                case 36:
                    message.hidden_modifier = reader.bool();
                    break;
                case 37:
                    message.is_target_building = reader.bool();
                    break;
                case 38:
                    message.neutral_camp_type = reader.uint32();
                    break;
                case 39:
                    message.rune_type = reader.uint32();
                    break;
                case 40:
                    if (!(message.assist_players && message.assist_players.length))
                        message.assist_players = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.assist_players.push(reader.uint32());
                    } else
                        message.assist_players.push(reader.uint32());
                    break;
                case 41:
                    message.is_heal_save = reader.bool();
                    break;
                case 42:
                    message.is_ultimate_ability = reader.bool();
                    break;
                case 43:
                    message.attacker_hero_level = reader.uint32();
                    break;
                case 44:
                    message.target_hero_level = reader.uint32();
                    break;
                case 45:
                    message.xpm = reader.uint32();
                    break;
                case 46:
                    message.gpm = reader.uint32();
                    break;
                case 47:
                    message.event_location = reader.uint32();
                    break;
                case 48:
                    message.target_is_self = reader.bool();
                    break;
                case 49:
                    message.damage_type = reader.uint32();
                    break;
                case 50:
                    message.invisibility_modifier = reader.bool();
                    break;
                case 51:
                    message.damage_category = reader.uint32();
                    break;
                case 52:
                    message.networth = reader.uint32();
                    break;
                case 53:
                    message.building_type = reader.uint32();
                    break;
                case 54:
                    message.modifier_elapsed_duration = reader.float();
                    break;
                case 55:
                    message.silence_modifier = reader.bool();
                    break;
                case 56:
                    message.heal_from_lifesteal = reader.bool();
                    break;
                case 57:
                    message.modifier_purged = reader.bool();
                    break;
                case 58:
                    message.spell_evaded = reader.bool();
                    break;
                case 59:
                    message.motion_controller_modifier = reader.bool();
                    break;
                case 60:
                    message.long_range_kill = reader.bool();
                    break;
                case 61:
                    message.modifier_purge_ability = reader.uint32();
                    break;
                case 62:
                    message.modifier_purge_npc = reader.uint32();
                    break;
                case 63:
                    message.root_modifier = reader.bool();
                    break;
                case 64:
                    message.total_unit_death_count = reader.uint32();
                    break;
                case 65:
                    message.aura_modifier = reader.bool();
                    break;
                case 66:
                    message.armor_debuff_modifier = reader.bool();
                    break;
                case 67:
                    message.no_physical_damage_modifier = reader.bool();
                    break;
                case 68:
                    message.modifier_ability = reader.uint32();
                    break;
                case 69:
                    message.modifier_hidden = reader.bool();
                    break;
                case 70:
                    message.inflictor_is_stolen_ability = reader.bool();
                    break;
                case 71:
                    message.kill_eater_event = reader.uint32();
                    break;
                case 72:
                    message.unit_status_label = reader.uint32();
                    break;
                case 73:
                    message.spell_generated_attack = reader.bool();
                    break;
                case 74:
                    message.at_night_time = reader.bool();
                    break;
                case 75:
                    message.attacker_has_scepter = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTACombatLogEntry message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTACombatLogEntry} CMsgDOTACombatLogEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTACombatLogEntry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTACombatLogEntry message.
         * @function verify
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTACombatLogEntry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case -1:
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                    break;
                }
            if (message.target_name != null && message.hasOwnProperty("target_name"))
                if (!$util.isInteger(message.target_name))
                    return "target_name: integer expected";
            if (message.target_source_name != null && message.hasOwnProperty("target_source_name"))
                if (!$util.isInteger(message.target_source_name))
                    return "target_source_name: integer expected";
            if (message.attacker_name != null && message.hasOwnProperty("attacker_name"))
                if (!$util.isInteger(message.attacker_name))
                    return "attacker_name: integer expected";
            if (message.damage_source_name != null && message.hasOwnProperty("damage_source_name"))
                if (!$util.isInteger(message.damage_source_name))
                    return "damage_source_name: integer expected";
            if (message.inflictor_name != null && message.hasOwnProperty("inflictor_name"))
                if (!$util.isInteger(message.inflictor_name))
                    return "inflictor_name: integer expected";
            if (message.is_attacker_illusion != null && message.hasOwnProperty("is_attacker_illusion"))
                if (typeof message.is_attacker_illusion !== "boolean")
                    return "is_attacker_illusion: boolean expected";
            if (message.is_attacker_hero != null && message.hasOwnProperty("is_attacker_hero"))
                if (typeof message.is_attacker_hero !== "boolean")
                    return "is_attacker_hero: boolean expected";
            if (message.is_target_illusion != null && message.hasOwnProperty("is_target_illusion"))
                if (typeof message.is_target_illusion !== "boolean")
                    return "is_target_illusion: boolean expected";
            if (message.is_target_hero != null && message.hasOwnProperty("is_target_hero"))
                if (typeof message.is_target_hero !== "boolean")
                    return "is_target_hero: boolean expected";
            if (message.is_visible_radiant != null && message.hasOwnProperty("is_visible_radiant"))
                if (typeof message.is_visible_radiant !== "boolean")
                    return "is_visible_radiant: boolean expected";
            if (message.is_visible_dire != null && message.hasOwnProperty("is_visible_dire"))
                if (typeof message.is_visible_dire !== "boolean")
                    return "is_visible_dire: boolean expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value))
                    return "value: integer expected";
            if (message.health != null && message.hasOwnProperty("health"))
                if (!$util.isInteger(message.health))
                    return "health: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            if (message.stun_duration != null && message.hasOwnProperty("stun_duration"))
                if (typeof message.stun_duration !== "number")
                    return "stun_duration: number expected";
            if (message.slow_duration != null && message.hasOwnProperty("slow_duration"))
                if (typeof message.slow_duration !== "number")
                    return "slow_duration: number expected";
            if (message.is_ability_toggle_on != null && message.hasOwnProperty("is_ability_toggle_on"))
                if (typeof message.is_ability_toggle_on !== "boolean")
                    return "is_ability_toggle_on: boolean expected";
            if (message.is_ability_toggle_off != null && message.hasOwnProperty("is_ability_toggle_off"))
                if (typeof message.is_ability_toggle_off !== "boolean")
                    return "is_ability_toggle_off: boolean expected";
            if (message.ability_level != null && message.hasOwnProperty("ability_level"))
                if (!$util.isInteger(message.ability_level))
                    return "ability_level: integer expected";
            if (message.location_x != null && message.hasOwnProperty("location_x"))
                if (typeof message.location_x !== "number")
                    return "location_x: number expected";
            if (message.location_y != null && message.hasOwnProperty("location_y"))
                if (typeof message.location_y !== "number")
                    return "location_y: number expected";
            if (message.gold_reason != null && message.hasOwnProperty("gold_reason"))
                if (!$util.isInteger(message.gold_reason))
                    return "gold_reason: integer expected";
            if (message.timestamp_raw != null && message.hasOwnProperty("timestamp_raw"))
                if (typeof message.timestamp_raw !== "number")
                    return "timestamp_raw: number expected";
            if (message.modifier_duration != null && message.hasOwnProperty("modifier_duration"))
                if (typeof message.modifier_duration !== "number")
                    return "modifier_duration: number expected";
            if (message.xp_reason != null && message.hasOwnProperty("xp_reason"))
                if (!$util.isInteger(message.xp_reason))
                    return "xp_reason: integer expected";
            if (message.last_hits != null && message.hasOwnProperty("last_hits"))
                if (!$util.isInteger(message.last_hits))
                    return "last_hits: integer expected";
            if (message.attacker_team != null && message.hasOwnProperty("attacker_team"))
                if (!$util.isInteger(message.attacker_team))
                    return "attacker_team: integer expected";
            if (message.target_team != null && message.hasOwnProperty("target_team"))
                if (!$util.isInteger(message.target_team))
                    return "target_team: integer expected";
            if (message.obs_wards_placed != null && message.hasOwnProperty("obs_wards_placed"))
                if (!$util.isInteger(message.obs_wards_placed))
                    return "obs_wards_placed: integer expected";
            if (message.assist_player0 != null && message.hasOwnProperty("assist_player0"))
                if (!$util.isInteger(message.assist_player0))
                    return "assist_player0: integer expected";
            if (message.assist_player1 != null && message.hasOwnProperty("assist_player1"))
                if (!$util.isInteger(message.assist_player1))
                    return "assist_player1: integer expected";
            if (message.assist_player2 != null && message.hasOwnProperty("assist_player2"))
                if (!$util.isInteger(message.assist_player2))
                    return "assist_player2: integer expected";
            if (message.assist_player3 != null && message.hasOwnProperty("assist_player3"))
                if (!$util.isInteger(message.assist_player3))
                    return "assist_player3: integer expected";
            if (message.stack_count != null && message.hasOwnProperty("stack_count"))
                if (!$util.isInteger(message.stack_count))
                    return "stack_count: integer expected";
            if (message.hidden_modifier != null && message.hasOwnProperty("hidden_modifier"))
                if (typeof message.hidden_modifier !== "boolean")
                    return "hidden_modifier: boolean expected";
            if (message.is_target_building != null && message.hasOwnProperty("is_target_building"))
                if (typeof message.is_target_building !== "boolean")
                    return "is_target_building: boolean expected";
            if (message.neutral_camp_type != null && message.hasOwnProperty("neutral_camp_type"))
                if (!$util.isInteger(message.neutral_camp_type))
                    return "neutral_camp_type: integer expected";
            if (message.rune_type != null && message.hasOwnProperty("rune_type"))
                if (!$util.isInteger(message.rune_type))
                    return "rune_type: integer expected";
            if (message.assist_players != null && message.hasOwnProperty("assist_players")) {
                if (!Array.isArray(message.assist_players))
                    return "assist_players: array expected";
                for (var i = 0; i < message.assist_players.length; ++i)
                    if (!$util.isInteger(message.assist_players[i]))
                        return "assist_players: integer[] expected";
            }
            if (message.is_heal_save != null && message.hasOwnProperty("is_heal_save"))
                if (typeof message.is_heal_save !== "boolean")
                    return "is_heal_save: boolean expected";
            if (message.is_ultimate_ability != null && message.hasOwnProperty("is_ultimate_ability"))
                if (typeof message.is_ultimate_ability !== "boolean")
                    return "is_ultimate_ability: boolean expected";
            if (message.attacker_hero_level != null && message.hasOwnProperty("attacker_hero_level"))
                if (!$util.isInteger(message.attacker_hero_level))
                    return "attacker_hero_level: integer expected";
            if (message.target_hero_level != null && message.hasOwnProperty("target_hero_level"))
                if (!$util.isInteger(message.target_hero_level))
                    return "target_hero_level: integer expected";
            if (message.xpm != null && message.hasOwnProperty("xpm"))
                if (!$util.isInteger(message.xpm))
                    return "xpm: integer expected";
            if (message.gpm != null && message.hasOwnProperty("gpm"))
                if (!$util.isInteger(message.gpm))
                    return "gpm: integer expected";
            if (message.event_location != null && message.hasOwnProperty("event_location"))
                if (!$util.isInteger(message.event_location))
                    return "event_location: integer expected";
            if (message.target_is_self != null && message.hasOwnProperty("target_is_self"))
                if (typeof message.target_is_self !== "boolean")
                    return "target_is_self: boolean expected";
            if (message.damage_type != null && message.hasOwnProperty("damage_type"))
                if (!$util.isInteger(message.damage_type))
                    return "damage_type: integer expected";
            if (message.invisibility_modifier != null && message.hasOwnProperty("invisibility_modifier"))
                if (typeof message.invisibility_modifier !== "boolean")
                    return "invisibility_modifier: boolean expected";
            if (message.damage_category != null && message.hasOwnProperty("damage_category"))
                if (!$util.isInteger(message.damage_category))
                    return "damage_category: integer expected";
            if (message.networth != null && message.hasOwnProperty("networth"))
                if (!$util.isInteger(message.networth))
                    return "networth: integer expected";
            if (message.building_type != null && message.hasOwnProperty("building_type"))
                if (!$util.isInteger(message.building_type))
                    return "building_type: integer expected";
            if (message.modifier_elapsed_duration != null && message.hasOwnProperty("modifier_elapsed_duration"))
                if (typeof message.modifier_elapsed_duration !== "number")
                    return "modifier_elapsed_duration: number expected";
            if (message.silence_modifier != null && message.hasOwnProperty("silence_modifier"))
                if (typeof message.silence_modifier !== "boolean")
                    return "silence_modifier: boolean expected";
            if (message.heal_from_lifesteal != null && message.hasOwnProperty("heal_from_lifesteal"))
                if (typeof message.heal_from_lifesteal !== "boolean")
                    return "heal_from_lifesteal: boolean expected";
            if (message.modifier_purged != null && message.hasOwnProperty("modifier_purged"))
                if (typeof message.modifier_purged !== "boolean")
                    return "modifier_purged: boolean expected";
            if (message.spell_evaded != null && message.hasOwnProperty("spell_evaded"))
                if (typeof message.spell_evaded !== "boolean")
                    return "spell_evaded: boolean expected";
            if (message.motion_controller_modifier != null && message.hasOwnProperty("motion_controller_modifier"))
                if (typeof message.motion_controller_modifier !== "boolean")
                    return "motion_controller_modifier: boolean expected";
            if (message.long_range_kill != null && message.hasOwnProperty("long_range_kill"))
                if (typeof message.long_range_kill !== "boolean")
                    return "long_range_kill: boolean expected";
            if (message.modifier_purge_ability != null && message.hasOwnProperty("modifier_purge_ability"))
                if (!$util.isInteger(message.modifier_purge_ability))
                    return "modifier_purge_ability: integer expected";
            if (message.modifier_purge_npc != null && message.hasOwnProperty("modifier_purge_npc"))
                if (!$util.isInteger(message.modifier_purge_npc))
                    return "modifier_purge_npc: integer expected";
            if (message.root_modifier != null && message.hasOwnProperty("root_modifier"))
                if (typeof message.root_modifier !== "boolean")
                    return "root_modifier: boolean expected";
            if (message.total_unit_death_count != null && message.hasOwnProperty("total_unit_death_count"))
                if (!$util.isInteger(message.total_unit_death_count))
                    return "total_unit_death_count: integer expected";
            if (message.aura_modifier != null && message.hasOwnProperty("aura_modifier"))
                if (typeof message.aura_modifier !== "boolean")
                    return "aura_modifier: boolean expected";
            if (message.armor_debuff_modifier != null && message.hasOwnProperty("armor_debuff_modifier"))
                if (typeof message.armor_debuff_modifier !== "boolean")
                    return "armor_debuff_modifier: boolean expected";
            if (message.no_physical_damage_modifier != null && message.hasOwnProperty("no_physical_damage_modifier"))
                if (typeof message.no_physical_damage_modifier !== "boolean")
                    return "no_physical_damage_modifier: boolean expected";
            if (message.modifier_ability != null && message.hasOwnProperty("modifier_ability"))
                if (!$util.isInteger(message.modifier_ability))
                    return "modifier_ability: integer expected";
            if (message.modifier_hidden != null && message.hasOwnProperty("modifier_hidden"))
                if (typeof message.modifier_hidden !== "boolean")
                    return "modifier_hidden: boolean expected";
            if (message.inflictor_is_stolen_ability != null && message.hasOwnProperty("inflictor_is_stolen_ability"))
                if (typeof message.inflictor_is_stolen_ability !== "boolean")
                    return "inflictor_is_stolen_ability: boolean expected";
            if (message.kill_eater_event != null && message.hasOwnProperty("kill_eater_event"))
                if (!$util.isInteger(message.kill_eater_event))
                    return "kill_eater_event: integer expected";
            if (message.unit_status_label != null && message.hasOwnProperty("unit_status_label"))
                if (!$util.isInteger(message.unit_status_label))
                    return "unit_status_label: integer expected";
            if (message.spell_generated_attack != null && message.hasOwnProperty("spell_generated_attack"))
                if (typeof message.spell_generated_attack !== "boolean")
                    return "spell_generated_attack: boolean expected";
            if (message.at_night_time != null && message.hasOwnProperty("at_night_time"))
                if (typeof message.at_night_time !== "boolean")
                    return "at_night_time: boolean expected";
            if (message.attacker_has_scepter != null && message.hasOwnProperty("attacker_has_scepter"))
                if (typeof message.attacker_has_scepter !== "boolean")
                    return "attacker_has_scepter: boolean expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTACombatLogEntry message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTACombatLogEntry} CMsgDOTACombatLogEntry
         */
        CMsgDOTACombatLogEntry.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTACombatLogEntry)
                return object;
            var message = new $root.CMsgDOTACombatLogEntry();
            switch (object.type) {
            case "DOTA_COMBATLOG_INVALID":
            case -1:
                message.type = -1;
                break;
            case "DOTA_COMBATLOG_DAMAGE":
            case 0:
                message.type = 0;
                break;
            case "DOTA_COMBATLOG_HEAL":
            case 1:
                message.type = 1;
                break;
            case "DOTA_COMBATLOG_MODIFIER_ADD":
            case 2:
                message.type = 2;
                break;
            case "DOTA_COMBATLOG_MODIFIER_REMOVE":
            case 3:
                message.type = 3;
                break;
            case "DOTA_COMBATLOG_DEATH":
            case 4:
                message.type = 4;
                break;
            case "DOTA_COMBATLOG_ABILITY":
            case 5:
                message.type = 5;
                break;
            case "DOTA_COMBATLOG_ITEM":
            case 6:
                message.type = 6;
                break;
            case "DOTA_COMBATLOG_LOCATION":
            case 7:
                message.type = 7;
                break;
            case "DOTA_COMBATLOG_GOLD":
            case 8:
                message.type = 8;
                break;
            case "DOTA_COMBATLOG_GAME_STATE":
            case 9:
                message.type = 9;
                break;
            case "DOTA_COMBATLOG_XP":
            case 10:
                message.type = 10;
                break;
            case "DOTA_COMBATLOG_PURCHASE":
            case 11:
                message.type = 11;
                break;
            case "DOTA_COMBATLOG_BUYBACK":
            case 12:
                message.type = 12;
                break;
            case "DOTA_COMBATLOG_ABILITY_TRIGGER":
            case 13:
                message.type = 13;
                break;
            case "DOTA_COMBATLOG_PLAYERSTATS":
            case 14:
                message.type = 14;
                break;
            case "DOTA_COMBATLOG_MULTIKILL":
            case 15:
                message.type = 15;
                break;
            case "DOTA_COMBATLOG_KILLSTREAK":
            case 16:
                message.type = 16;
                break;
            case "DOTA_COMBATLOG_TEAM_BUILDING_KILL":
            case 17:
                message.type = 17;
                break;
            case "DOTA_COMBATLOG_FIRST_BLOOD":
            case 18:
                message.type = 18;
                break;
            case "DOTA_COMBATLOG_MODIFIER_STACK_EVENT":
            case 19:
                message.type = 19;
                break;
            case "DOTA_COMBATLOG_NEUTRAL_CAMP_STACK":
            case 20:
                message.type = 20;
                break;
            case "DOTA_COMBATLOG_PICKUP_RUNE":
            case 21:
                message.type = 21;
                break;
            case "DOTA_COMBATLOG_REVEALED_INVISIBLE":
            case 22:
                message.type = 22;
                break;
            case "DOTA_COMBATLOG_HERO_SAVED":
            case 23:
                message.type = 23;
                break;
            case "DOTA_COMBATLOG_MANA_RESTORED":
            case 24:
                message.type = 24;
                break;
            case "DOTA_COMBATLOG_HERO_LEVELUP":
            case 25:
                message.type = 25;
                break;
            case "DOTA_COMBATLOG_BOTTLE_HEAL_ALLY":
            case 26:
                message.type = 26;
                break;
            case "DOTA_COMBATLOG_ENDGAME_STATS":
            case 27:
                message.type = 27;
                break;
            case "DOTA_COMBATLOG_INTERRUPT_CHANNEL":
            case 28:
                message.type = 28;
                break;
            case "DOTA_COMBATLOG_ALLIED_GOLD":
            case 29:
                message.type = 29;
                break;
            case "DOTA_COMBATLOG_AEGIS_TAKEN":
            case 30:
                message.type = 30;
                break;
            case "DOTA_COMBATLOG_MANA_DAMAGE":
            case 31:
                message.type = 31;
                break;
            case "DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED":
            case 32:
                message.type = 32;
                break;
            case "DOTA_COMBATLOG_UNIT_SUMMONED":
            case 33:
                message.type = 33;
                break;
            case "DOTA_COMBATLOG_ATTACK_EVADE":
            case 34:
                message.type = 34;
                break;
            case "DOTA_COMBATLOG_TREE_CUT":
            case 35:
                message.type = 35;
                break;
            case "DOTA_COMBATLOG_SUCCESSFUL_SCAN":
            case 36:
                message.type = 36;
                break;
            case "DOTA_COMBATLOG_END_KILLSTREAK":
            case 37:
                message.type = 37;
                break;
            case "DOTA_COMBATLOG_BLOODSTONE_CHARGE":
            case 38:
                message.type = 38;
                break;
            case "DOTA_COMBATLOG_CRITICAL_DAMAGE":
            case 39:
                message.type = 39;
                break;
            case "DOTA_COMBATLOG_SPELL_ABSORB":
            case 40:
                message.type = 40;
                break;
            case "DOTA_COMBATLOG_UNIT_TELEPORTED":
            case 41:
                message.type = 41;
                break;
            case "DOTA_COMBATLOG_KILL_EATER_EVENT":
            case 42:
                message.type = 42;
                break;
            }
            if (object.target_name != null)
                message.target_name = object.target_name >>> 0;
            if (object.target_source_name != null)
                message.target_source_name = object.target_source_name >>> 0;
            if (object.attacker_name != null)
                message.attacker_name = object.attacker_name >>> 0;
            if (object.damage_source_name != null)
                message.damage_source_name = object.damage_source_name >>> 0;
            if (object.inflictor_name != null)
                message.inflictor_name = object.inflictor_name >>> 0;
            if (object.is_attacker_illusion != null)
                message.is_attacker_illusion = Boolean(object.is_attacker_illusion);
            if (object.is_attacker_hero != null)
                message.is_attacker_hero = Boolean(object.is_attacker_hero);
            if (object.is_target_illusion != null)
                message.is_target_illusion = Boolean(object.is_target_illusion);
            if (object.is_target_hero != null)
                message.is_target_hero = Boolean(object.is_target_hero);
            if (object.is_visible_radiant != null)
                message.is_visible_radiant = Boolean(object.is_visible_radiant);
            if (object.is_visible_dire != null)
                message.is_visible_dire = Boolean(object.is_visible_dire);
            if (object.value != null)
                message.value = object.value >>> 0;
            if (object.health != null)
                message.health = object.health | 0;
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            if (object.stun_duration != null)
                message.stun_duration = Number(object.stun_duration);
            if (object.slow_duration != null)
                message.slow_duration = Number(object.slow_duration);
            if (object.is_ability_toggle_on != null)
                message.is_ability_toggle_on = Boolean(object.is_ability_toggle_on);
            if (object.is_ability_toggle_off != null)
                message.is_ability_toggle_off = Boolean(object.is_ability_toggle_off);
            if (object.ability_level != null)
                message.ability_level = object.ability_level >>> 0;
            if (object.location_x != null)
                message.location_x = Number(object.location_x);
            if (object.location_y != null)
                message.location_y = Number(object.location_y);
            if (object.gold_reason != null)
                message.gold_reason = object.gold_reason >>> 0;
            if (object.timestamp_raw != null)
                message.timestamp_raw = Number(object.timestamp_raw);
            if (object.modifier_duration != null)
                message.modifier_duration = Number(object.modifier_duration);
            if (object.xp_reason != null)
                message.xp_reason = object.xp_reason >>> 0;
            if (object.last_hits != null)
                message.last_hits = object.last_hits >>> 0;
            if (object.attacker_team != null)
                message.attacker_team = object.attacker_team >>> 0;
            if (object.target_team != null)
                message.target_team = object.target_team >>> 0;
            if (object.obs_wards_placed != null)
                message.obs_wards_placed = object.obs_wards_placed >>> 0;
            if (object.assist_player0 != null)
                message.assist_player0 = object.assist_player0 >>> 0;
            if (object.assist_player1 != null)
                message.assist_player1 = object.assist_player1 >>> 0;
            if (object.assist_player2 != null)
                message.assist_player2 = object.assist_player2 >>> 0;
            if (object.assist_player3 != null)
                message.assist_player3 = object.assist_player3 >>> 0;
            if (object.stack_count != null)
                message.stack_count = object.stack_count >>> 0;
            if (object.hidden_modifier != null)
                message.hidden_modifier = Boolean(object.hidden_modifier);
            if (object.is_target_building != null)
                message.is_target_building = Boolean(object.is_target_building);
            if (object.neutral_camp_type != null)
                message.neutral_camp_type = object.neutral_camp_type >>> 0;
            if (object.rune_type != null)
                message.rune_type = object.rune_type >>> 0;
            if (object.assist_players) {
                if (!Array.isArray(object.assist_players))
                    throw TypeError(".CMsgDOTACombatLogEntry.assist_players: array expected");
                message.assist_players = [];
                for (var i = 0; i < object.assist_players.length; ++i)
                    message.assist_players[i] = object.assist_players[i] >>> 0;
            }
            if (object.is_heal_save != null)
                message.is_heal_save = Boolean(object.is_heal_save);
            if (object.is_ultimate_ability != null)
                message.is_ultimate_ability = Boolean(object.is_ultimate_ability);
            if (object.attacker_hero_level != null)
                message.attacker_hero_level = object.attacker_hero_level >>> 0;
            if (object.target_hero_level != null)
                message.target_hero_level = object.target_hero_level >>> 0;
            if (object.xpm != null)
                message.xpm = object.xpm >>> 0;
            if (object.gpm != null)
                message.gpm = object.gpm >>> 0;
            if (object.event_location != null)
                message.event_location = object.event_location >>> 0;
            if (object.target_is_self != null)
                message.target_is_self = Boolean(object.target_is_self);
            if (object.damage_type != null)
                message.damage_type = object.damage_type >>> 0;
            if (object.invisibility_modifier != null)
                message.invisibility_modifier = Boolean(object.invisibility_modifier);
            if (object.damage_category != null)
                message.damage_category = object.damage_category >>> 0;
            if (object.networth != null)
                message.networth = object.networth >>> 0;
            if (object.building_type != null)
                message.building_type = object.building_type >>> 0;
            if (object.modifier_elapsed_duration != null)
                message.modifier_elapsed_duration = Number(object.modifier_elapsed_duration);
            if (object.silence_modifier != null)
                message.silence_modifier = Boolean(object.silence_modifier);
            if (object.heal_from_lifesteal != null)
                message.heal_from_lifesteal = Boolean(object.heal_from_lifesteal);
            if (object.modifier_purged != null)
                message.modifier_purged = Boolean(object.modifier_purged);
            if (object.spell_evaded != null)
                message.spell_evaded = Boolean(object.spell_evaded);
            if (object.motion_controller_modifier != null)
                message.motion_controller_modifier = Boolean(object.motion_controller_modifier);
            if (object.long_range_kill != null)
                message.long_range_kill = Boolean(object.long_range_kill);
            if (object.modifier_purge_ability != null)
                message.modifier_purge_ability = object.modifier_purge_ability >>> 0;
            if (object.modifier_purge_npc != null)
                message.modifier_purge_npc = object.modifier_purge_npc >>> 0;
            if (object.root_modifier != null)
                message.root_modifier = Boolean(object.root_modifier);
            if (object.total_unit_death_count != null)
                message.total_unit_death_count = object.total_unit_death_count >>> 0;
            if (object.aura_modifier != null)
                message.aura_modifier = Boolean(object.aura_modifier);
            if (object.armor_debuff_modifier != null)
                message.armor_debuff_modifier = Boolean(object.armor_debuff_modifier);
            if (object.no_physical_damage_modifier != null)
                message.no_physical_damage_modifier = Boolean(object.no_physical_damage_modifier);
            if (object.modifier_ability != null)
                message.modifier_ability = object.modifier_ability >>> 0;
            if (object.modifier_hidden != null)
                message.modifier_hidden = Boolean(object.modifier_hidden);
            if (object.inflictor_is_stolen_ability != null)
                message.inflictor_is_stolen_ability = Boolean(object.inflictor_is_stolen_ability);
            if (object.kill_eater_event != null)
                message.kill_eater_event = object.kill_eater_event >>> 0;
            if (object.unit_status_label != null)
                message.unit_status_label = object.unit_status_label >>> 0;
            if (object.spell_generated_attack != null)
                message.spell_generated_attack = Boolean(object.spell_generated_attack);
            if (object.at_night_time != null)
                message.at_night_time = Boolean(object.at_night_time);
            if (object.attacker_has_scepter != null)
                message.attacker_has_scepter = Boolean(object.attacker_has_scepter);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTACombatLogEntry message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {CMsgDOTACombatLogEntry} message CMsgDOTACombatLogEntry
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTACombatLogEntry.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.assist_players = [];
            if (options.defaults) {
                object.type = options.enums === String ? "DOTA_COMBATLOG_INVALID" : -1;
                object.target_name = 0;
                object.target_source_name = 0;
                object.attacker_name = 0;
                object.damage_source_name = 0;
                object.inflictor_name = 0;
                object.is_attacker_illusion = false;
                object.is_attacker_hero = false;
                object.is_target_illusion = false;
                object.is_target_hero = false;
                object.is_visible_radiant = false;
                object.is_visible_dire = false;
                object.value = 0;
                object.health = 0;
                object.timestamp = 0;
                object.stun_duration = 0;
                object.slow_duration = 0;
                object.is_ability_toggle_on = false;
                object.is_ability_toggle_off = false;
                object.ability_level = 0;
                object.location_x = 0;
                object.location_y = 0;
                object.gold_reason = 0;
                object.timestamp_raw = 0;
                object.modifier_duration = 0;
                object.xp_reason = 0;
                object.last_hits = 0;
                object.attacker_team = 0;
                object.target_team = 0;
                object.obs_wards_placed = 0;
                object.assist_player0 = 0;
                object.assist_player1 = 0;
                object.assist_player2 = 0;
                object.assist_player3 = 0;
                object.stack_count = 0;
                object.hidden_modifier = false;
                object.is_target_building = false;
                object.neutral_camp_type = 0;
                object.rune_type = 0;
                object.is_heal_save = false;
                object.is_ultimate_ability = false;
                object.attacker_hero_level = 0;
                object.target_hero_level = 0;
                object.xpm = 0;
                object.gpm = 0;
                object.event_location = 0;
                object.target_is_self = false;
                object.damage_type = 0;
                object.invisibility_modifier = false;
                object.damage_category = 0;
                object.networth = 0;
                object.building_type = 0;
                object.modifier_elapsed_duration = 0;
                object.silence_modifier = false;
                object.heal_from_lifesteal = false;
                object.modifier_purged = false;
                object.spell_evaded = false;
                object.motion_controller_modifier = false;
                object.long_range_kill = false;
                object.modifier_purge_ability = 0;
                object.modifier_purge_npc = 0;
                object.root_modifier = false;
                object.total_unit_death_count = 0;
                object.aura_modifier = false;
                object.armor_debuff_modifier = false;
                object.no_physical_damage_modifier = false;
                object.modifier_ability = 0;
                object.modifier_hidden = false;
                object.inflictor_is_stolen_ability = false;
                object.kill_eater_event = 0;
                object.unit_status_label = 0;
                object.spell_generated_attack = false;
                object.at_night_time = false;
                object.attacker_has_scepter = false;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.DOTA_COMBATLOG_TYPES[message.type] : message.type;
            if (message.target_name != null && message.hasOwnProperty("target_name"))
                object.target_name = message.target_name;
            if (message.target_source_name != null && message.hasOwnProperty("target_source_name"))
                object.target_source_name = message.target_source_name;
            if (message.attacker_name != null && message.hasOwnProperty("attacker_name"))
                object.attacker_name = message.attacker_name;
            if (message.damage_source_name != null && message.hasOwnProperty("damage_source_name"))
                object.damage_source_name = message.damage_source_name;
            if (message.inflictor_name != null && message.hasOwnProperty("inflictor_name"))
                object.inflictor_name = message.inflictor_name;
            if (message.is_attacker_illusion != null && message.hasOwnProperty("is_attacker_illusion"))
                object.is_attacker_illusion = message.is_attacker_illusion;
            if (message.is_attacker_hero != null && message.hasOwnProperty("is_attacker_hero"))
                object.is_attacker_hero = message.is_attacker_hero;
            if (message.is_target_illusion != null && message.hasOwnProperty("is_target_illusion"))
                object.is_target_illusion = message.is_target_illusion;
            if (message.is_target_hero != null && message.hasOwnProperty("is_target_hero"))
                object.is_target_hero = message.is_target_hero;
            if (message.is_visible_radiant != null && message.hasOwnProperty("is_visible_radiant"))
                object.is_visible_radiant = message.is_visible_radiant;
            if (message.is_visible_dire != null && message.hasOwnProperty("is_visible_dire"))
                object.is_visible_dire = message.is_visible_dire;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.health != null && message.hasOwnProperty("health"))
                object.health = message.health;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            if (message.stun_duration != null && message.hasOwnProperty("stun_duration"))
                object.stun_duration = options.json && !isFinite(message.stun_duration) ? String(message.stun_duration) : message.stun_duration;
            if (message.slow_duration != null && message.hasOwnProperty("slow_duration"))
                object.slow_duration = options.json && !isFinite(message.slow_duration) ? String(message.slow_duration) : message.slow_duration;
            if (message.is_ability_toggle_on != null && message.hasOwnProperty("is_ability_toggle_on"))
                object.is_ability_toggle_on = message.is_ability_toggle_on;
            if (message.is_ability_toggle_off != null && message.hasOwnProperty("is_ability_toggle_off"))
                object.is_ability_toggle_off = message.is_ability_toggle_off;
            if (message.ability_level != null && message.hasOwnProperty("ability_level"))
                object.ability_level = message.ability_level;
            if (message.location_x != null && message.hasOwnProperty("location_x"))
                object.location_x = options.json && !isFinite(message.location_x) ? String(message.location_x) : message.location_x;
            if (message.location_y != null && message.hasOwnProperty("location_y"))
                object.location_y = options.json && !isFinite(message.location_y) ? String(message.location_y) : message.location_y;
            if (message.gold_reason != null && message.hasOwnProperty("gold_reason"))
                object.gold_reason = message.gold_reason;
            if (message.timestamp_raw != null && message.hasOwnProperty("timestamp_raw"))
                object.timestamp_raw = options.json && !isFinite(message.timestamp_raw) ? String(message.timestamp_raw) : message.timestamp_raw;
            if (message.modifier_duration != null && message.hasOwnProperty("modifier_duration"))
                object.modifier_duration = options.json && !isFinite(message.modifier_duration) ? String(message.modifier_duration) : message.modifier_duration;
            if (message.xp_reason != null && message.hasOwnProperty("xp_reason"))
                object.xp_reason = message.xp_reason;
            if (message.last_hits != null && message.hasOwnProperty("last_hits"))
                object.last_hits = message.last_hits;
            if (message.attacker_team != null && message.hasOwnProperty("attacker_team"))
                object.attacker_team = message.attacker_team;
            if (message.target_team != null && message.hasOwnProperty("target_team"))
                object.target_team = message.target_team;
            if (message.obs_wards_placed != null && message.hasOwnProperty("obs_wards_placed"))
                object.obs_wards_placed = message.obs_wards_placed;
            if (message.assist_player0 != null && message.hasOwnProperty("assist_player0"))
                object.assist_player0 = message.assist_player0;
            if (message.assist_player1 != null && message.hasOwnProperty("assist_player1"))
                object.assist_player1 = message.assist_player1;
            if (message.assist_player2 != null && message.hasOwnProperty("assist_player2"))
                object.assist_player2 = message.assist_player2;
            if (message.assist_player3 != null && message.hasOwnProperty("assist_player3"))
                object.assist_player3 = message.assist_player3;
            if (message.stack_count != null && message.hasOwnProperty("stack_count"))
                object.stack_count = message.stack_count;
            if (message.hidden_modifier != null && message.hasOwnProperty("hidden_modifier"))
                object.hidden_modifier = message.hidden_modifier;
            if (message.is_target_building != null && message.hasOwnProperty("is_target_building"))
                object.is_target_building = message.is_target_building;
            if (message.neutral_camp_type != null && message.hasOwnProperty("neutral_camp_type"))
                object.neutral_camp_type = message.neutral_camp_type;
            if (message.rune_type != null && message.hasOwnProperty("rune_type"))
                object.rune_type = message.rune_type;
            if (message.assist_players && message.assist_players.length) {
                object.assist_players = [];
                for (var j = 0; j < message.assist_players.length; ++j)
                    object.assist_players[j] = message.assist_players[j];
            }
            if (message.is_heal_save != null && message.hasOwnProperty("is_heal_save"))
                object.is_heal_save = message.is_heal_save;
            if (message.is_ultimate_ability != null && message.hasOwnProperty("is_ultimate_ability"))
                object.is_ultimate_ability = message.is_ultimate_ability;
            if (message.attacker_hero_level != null && message.hasOwnProperty("attacker_hero_level"))
                object.attacker_hero_level = message.attacker_hero_level;
            if (message.target_hero_level != null && message.hasOwnProperty("target_hero_level"))
                object.target_hero_level = message.target_hero_level;
            if (message.xpm != null && message.hasOwnProperty("xpm"))
                object.xpm = message.xpm;
            if (message.gpm != null && message.hasOwnProperty("gpm"))
                object.gpm = message.gpm;
            if (message.event_location != null && message.hasOwnProperty("event_location"))
                object.event_location = message.event_location;
            if (message.target_is_self != null && message.hasOwnProperty("target_is_self"))
                object.target_is_self = message.target_is_self;
            if (message.damage_type != null && message.hasOwnProperty("damage_type"))
                object.damage_type = message.damage_type;
            if (message.invisibility_modifier != null && message.hasOwnProperty("invisibility_modifier"))
                object.invisibility_modifier = message.invisibility_modifier;
            if (message.damage_category != null && message.hasOwnProperty("damage_category"))
                object.damage_category = message.damage_category;
            if (message.networth != null && message.hasOwnProperty("networth"))
                object.networth = message.networth;
            if (message.building_type != null && message.hasOwnProperty("building_type"))
                object.building_type = message.building_type;
            if (message.modifier_elapsed_duration != null && message.hasOwnProperty("modifier_elapsed_duration"))
                object.modifier_elapsed_duration = options.json && !isFinite(message.modifier_elapsed_duration) ? String(message.modifier_elapsed_duration) : message.modifier_elapsed_duration;
            if (message.silence_modifier != null && message.hasOwnProperty("silence_modifier"))
                object.silence_modifier = message.silence_modifier;
            if (message.heal_from_lifesteal != null && message.hasOwnProperty("heal_from_lifesteal"))
                object.heal_from_lifesteal = message.heal_from_lifesteal;
            if (message.modifier_purged != null && message.hasOwnProperty("modifier_purged"))
                object.modifier_purged = message.modifier_purged;
            if (message.spell_evaded != null && message.hasOwnProperty("spell_evaded"))
                object.spell_evaded = message.spell_evaded;
            if (message.motion_controller_modifier != null && message.hasOwnProperty("motion_controller_modifier"))
                object.motion_controller_modifier = message.motion_controller_modifier;
            if (message.long_range_kill != null && message.hasOwnProperty("long_range_kill"))
                object.long_range_kill = message.long_range_kill;
            if (message.modifier_purge_ability != null && message.hasOwnProperty("modifier_purge_ability"))
                object.modifier_purge_ability = message.modifier_purge_ability;
            if (message.modifier_purge_npc != null && message.hasOwnProperty("modifier_purge_npc"))
                object.modifier_purge_npc = message.modifier_purge_npc;
            if (message.root_modifier != null && message.hasOwnProperty("root_modifier"))
                object.root_modifier = message.root_modifier;
            if (message.total_unit_death_count != null && message.hasOwnProperty("total_unit_death_count"))
                object.total_unit_death_count = message.total_unit_death_count;
            if (message.aura_modifier != null && message.hasOwnProperty("aura_modifier"))
                object.aura_modifier = message.aura_modifier;
            if (message.armor_debuff_modifier != null && message.hasOwnProperty("armor_debuff_modifier"))
                object.armor_debuff_modifier = message.armor_debuff_modifier;
            if (message.no_physical_damage_modifier != null && message.hasOwnProperty("no_physical_damage_modifier"))
                object.no_physical_damage_modifier = message.no_physical_damage_modifier;
            if (message.modifier_ability != null && message.hasOwnProperty("modifier_ability"))
                object.modifier_ability = message.modifier_ability;
            if (message.modifier_hidden != null && message.hasOwnProperty("modifier_hidden"))
                object.modifier_hidden = message.modifier_hidden;
            if (message.inflictor_is_stolen_ability != null && message.hasOwnProperty("inflictor_is_stolen_ability"))
                object.inflictor_is_stolen_ability = message.inflictor_is_stolen_ability;
            if (message.kill_eater_event != null && message.hasOwnProperty("kill_eater_event"))
                object.kill_eater_event = message.kill_eater_event;
            if (message.unit_status_label != null && message.hasOwnProperty("unit_status_label"))
                object.unit_status_label = message.unit_status_label;
            if (message.spell_generated_attack != null && message.hasOwnProperty("spell_generated_attack"))
                object.spell_generated_attack = message.spell_generated_attack;
            if (message.at_night_time != null && message.hasOwnProperty("at_night_time"))
                object.at_night_time = message.at_night_time;
            if (message.attacker_has_scepter != null && message.hasOwnProperty("attacker_has_scepter"))
                object.attacker_has_scepter = message.attacker_has_scepter;
            return object;
        };
    
        /**
         * Converts this CMsgDOTACombatLogEntry to JSON.
         * @function toJSON
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTACombatLogEntry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTACombatLogEntry;
    })();
    
    $root.CMsgPendingEventAward = (function() {
    
        /**
         * Properties of a CMsgPendingEventAward.
         * @exports ICMsgPendingEventAward
         * @interface ICMsgPendingEventAward
         * @property {EEvent|null} [event_id] CMsgPendingEventAward event_id
         * @property {number|null} [action_id] CMsgPendingEventAward action_id
         * @property {number|null} [num_to_grant] CMsgPendingEventAward num_to_grant
         * @property {EEventActionScoreMode|null} [score_mode] CMsgPendingEventAward score_mode
         * @property {number|null} [audit_action] CMsgPendingEventAward audit_action
         */
    
        /**
         * Constructs a new CMsgPendingEventAward.
         * @exports CMsgPendingEventAward
         * @classdesc Represents a CMsgPendingEventAward.
         * @implements ICMsgPendingEventAward
         * @constructor
         * @param {ICMsgPendingEventAward=} [properties] Properties to set
         */
        function CMsgPendingEventAward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgPendingEventAward event_id.
         * @member {EEvent} event_id
         * @memberof CMsgPendingEventAward
         * @instance
         */
        CMsgPendingEventAward.prototype.event_id = 0;
    
        /**
         * CMsgPendingEventAward action_id.
         * @member {number} action_id
         * @memberof CMsgPendingEventAward
         * @instance
         */
        CMsgPendingEventAward.prototype.action_id = 0;
    
        /**
         * CMsgPendingEventAward num_to_grant.
         * @member {number} num_to_grant
         * @memberof CMsgPendingEventAward
         * @instance
         */
        CMsgPendingEventAward.prototype.num_to_grant = 0;
    
        /**
         * CMsgPendingEventAward score_mode.
         * @member {EEventActionScoreMode} score_mode
         * @memberof CMsgPendingEventAward
         * @instance
         */
        CMsgPendingEventAward.prototype.score_mode = 0;
    
        /**
         * CMsgPendingEventAward audit_action.
         * @member {number} audit_action
         * @memberof CMsgPendingEventAward
         * @instance
         */
        CMsgPendingEventAward.prototype.audit_action = 0;
    
        /**
         * Creates a new CMsgPendingEventAward instance using the specified properties.
         * @function create
         * @memberof CMsgPendingEventAward
         * @static
         * @param {ICMsgPendingEventAward=} [properties] Properties to set
         * @returns {CMsgPendingEventAward} CMsgPendingEventAward instance
         */
        CMsgPendingEventAward.create = function create(properties) {
            return new CMsgPendingEventAward(properties);
        };
    
        /**
         * Encodes the specified CMsgPendingEventAward message. Does not implicitly {@link CMsgPendingEventAward.verify|verify} messages.
         * @function encode
         * @memberof CMsgPendingEventAward
         * @static
         * @param {ICMsgPendingEventAward} message CMsgPendingEventAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgPendingEventAward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event_id != null && Object.hasOwnProperty.call(message, "event_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.event_id);
            if (message.action_id != null && Object.hasOwnProperty.call(message, "action_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.action_id);
            if (message.num_to_grant != null && Object.hasOwnProperty.call(message, "num_to_grant"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.num_to_grant);
            if (message.score_mode != null && Object.hasOwnProperty.call(message, "score_mode"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.score_mode);
            if (message.audit_action != null && Object.hasOwnProperty.call(message, "audit_action"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.audit_action);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgPendingEventAward message, length delimited. Does not implicitly {@link CMsgPendingEventAward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgPendingEventAward
         * @static
         * @param {ICMsgPendingEventAward} message CMsgPendingEventAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgPendingEventAward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgPendingEventAward message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgPendingEventAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgPendingEventAward} CMsgPendingEventAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgPendingEventAward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgPendingEventAward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.event_id = reader.int32();
                    break;
                case 2:
                    message.action_id = reader.uint32();
                    break;
                case 3:
                    message.num_to_grant = reader.uint32();
                    break;
                case 4:
                    message.score_mode = reader.int32();
                    break;
                case 5:
                    message.audit_action = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgPendingEventAward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgPendingEventAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgPendingEventAward} CMsgPendingEventAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgPendingEventAward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgPendingEventAward message.
         * @function verify
         * @memberof CMsgPendingEventAward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgPendingEventAward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                switch (message.event_id) {
                default:
                    return "event_id: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                    break;
                }
            if (message.action_id != null && message.hasOwnProperty("action_id"))
                if (!$util.isInteger(message.action_id))
                    return "action_id: integer expected";
            if (message.num_to_grant != null && message.hasOwnProperty("num_to_grant"))
                if (!$util.isInteger(message.num_to_grant))
                    return "num_to_grant: integer expected";
            if (message.score_mode != null && message.hasOwnProperty("score_mode"))
                switch (message.score_mode) {
                default:
                    return "score_mode: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.audit_action != null && message.hasOwnProperty("audit_action"))
                if (!$util.isInteger(message.audit_action))
                    return "audit_action: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgPendingEventAward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgPendingEventAward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgPendingEventAward} CMsgPendingEventAward
         */
        CMsgPendingEventAward.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgPendingEventAward)
                return object;
            var message = new $root.CMsgPendingEventAward();
            switch (object.event_id) {
            case "EVENT_ID_NONE":
            case 0:
                message.event_id = 0;
                break;
            case "EVENT_ID_DIRETIDE":
            case 1:
                message.event_id = 1;
                break;
            case "EVENT_ID_SPRING_FESTIVAL":
            case 2:
                message.event_id = 2;
                break;
            case "EVENT_ID_FROSTIVUS_2013":
            case 3:
                message.event_id = 3;
                break;
            case "EVENT_ID_COMPENDIUM_2014":
            case 4:
                message.event_id = 4;
                break;
            case "EVENT_ID_NEXON_PC_BANG":
            case 5:
                message.event_id = 5;
                break;
            case "EVENT_ID_PWRD_DAC_2015":
            case 6:
                message.event_id = 6;
                break;
            case "EVENT_ID_NEW_BLOOM_2015":
            case 7:
                message.event_id = 7;
                break;
            case "EVENT_ID_INTERNATIONAL_2015":
            case 8:
                message.event_id = 8;
                break;
            case "EVENT_ID_FALL_MAJOR_2015":
            case 9:
                message.event_id = 9;
                break;
            case "EVENT_ID_ORACLE_PA":
            case 10:
                message.event_id = 10;
                break;
            case "EVENT_ID_NEW_BLOOM_2015_PREBEAST":
            case 11:
                message.event_id = 11;
                break;
            case "EVENT_ID_FROSTIVUS":
            case 12:
                message.event_id = 12;
                break;
            case "EVENT_ID_WINTER_MAJOR_2016":
            case 13:
                message.event_id = 13;
                break;
            case "EVENT_ID_INTERNATIONAL_2016":
            case 14:
                message.event_id = 14;
                break;
            case "EVENT_ID_FALL_MAJOR_2016":
            case 15:
                message.event_id = 15;
                break;
            case "EVENT_ID_WINTER_MAJOR_2017":
            case 16:
                message.event_id = 16;
                break;
            case "EVENT_ID_NEW_BLOOM_2017":
            case 17:
                message.event_id = 17;
                break;
            case "EVENT_ID_INTERNATIONAL_2017":
            case 18:
                message.event_id = 18;
                break;
            case "EVENT_ID_PLUS_SUBSCRIPTION":
            case 19:
                message.event_id = 19;
                break;
            case "EVENT_ID_SINGLES_DAY_2017":
            case 20:
                message.event_id = 20;
                break;
            case "EVENT_ID_FROSTIVUS_2017":
            case 21:
                message.event_id = 21;
                break;
            case "EVENT_ID_INTERNATIONAL_2018":
            case 22:
                message.event_id = 22;
                break;
            case "EVENT_ID_FROSTIVUS_2018":
            case 23:
                message.event_id = 23;
                break;
            case "EVENT_ID_NEW_BLOOM_2019":
            case 24:
                message.event_id = 24;
                break;
            case "EVENT_ID_INTERNATIONAL_2019":
            case 25:
                message.event_id = 25;
                break;
            case "EVENT_ID_NEW_PLAYER_EXPERIENCE":
            case 26:
                message.event_id = 26;
                break;
            case "EVENT_ID_FROSTIVUS_2019":
            case 27:
                message.event_id = 27;
                break;
            case "EVENT_ID_NEW_BLOOM_2020":
            case 28:
                message.event_id = 28;
                break;
            case "EVENT_ID_INTERNATIONAL_2020":
            case 29:
                message.event_id = 29;
                break;
            case "EVENT_ID_TEAM_FANDOM":
            case 30:
                message.event_id = 30;
                break;
            case "EVENT_ID_DIRETIDE_2020":
            case 31:
                message.event_id = 31;
                break;
            case "EVENT_ID_COUNT":
            case 32:
                message.event_id = 32;
                break;
            }
            if (object.action_id != null)
                message.action_id = object.action_id >>> 0;
            if (object.num_to_grant != null)
                message.num_to_grant = object.num_to_grant >>> 0;
            switch (object.score_mode) {
            case "k_eEventActionScoreMode_Add":
            case 0:
                message.score_mode = 0;
                break;
            case "k_eEventActionScoreMode_Min":
            case 1:
                message.score_mode = 1;
                break;
            }
            if (object.audit_action != null)
                message.audit_action = object.audit_action >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgPendingEventAward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgPendingEventAward
         * @static
         * @param {CMsgPendingEventAward} message CMsgPendingEventAward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgPendingEventAward.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.event_id = options.enums === String ? "EVENT_ID_NONE" : 0;
                object.action_id = 0;
                object.num_to_grant = 0;
                object.score_mode = options.enums === String ? "k_eEventActionScoreMode_Add" : 0;
                object.audit_action = 0;
            }
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                object.event_id = options.enums === String ? $root.EEvent[message.event_id] : message.event_id;
            if (message.action_id != null && message.hasOwnProperty("action_id"))
                object.action_id = message.action_id;
            if (message.num_to_grant != null && message.hasOwnProperty("num_to_grant"))
                object.num_to_grant = message.num_to_grant;
            if (message.score_mode != null && message.hasOwnProperty("score_mode"))
                object.score_mode = options.enums === String ? $root.EEventActionScoreMode[message.score_mode] : message.score_mode;
            if (message.audit_action != null && message.hasOwnProperty("audit_action"))
                object.audit_action = message.audit_action;
            return object;
        };
    
        /**
         * Converts this CMsgPendingEventAward to JSON.
         * @function toJSON
         * @memberof CMsgPendingEventAward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgPendingEventAward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgPendingEventAward;
    })();
    
    /**
     * EDOTAStatPopupTypes enum.
     * @exports EDOTAStatPopupTypes
     * @enum {number}
     * @property {number} k_EDOTA_SPT_Textline=0 k_EDOTA_SPT_Textline value
     * @property {number} k_EDOTA_SPT_Basic=1 k_EDOTA_SPT_Basic value
     * @property {number} k_EDOTA_SPT_Poll=2 k_EDOTA_SPT_Poll value
     * @property {number} k_EDOTA_SPT_Grid=3 k_EDOTA_SPT_Grid value
     * @property {number} k_EDOTA_SPT_DualImage=4 k_EDOTA_SPT_DualImage value
     * @property {number} k_EDOTA_SPT_Movie=5 k_EDOTA_SPT_Movie value
     */
    $root.EDOTAStatPopupTypes = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_EDOTA_SPT_Textline"] = 0;
        values[valuesById[1] = "k_EDOTA_SPT_Basic"] = 1;
        values[valuesById[2] = "k_EDOTA_SPT_Poll"] = 2;
        values[valuesById[3] = "k_EDOTA_SPT_Grid"] = 3;
        values[valuesById[4] = "k_EDOTA_SPT_DualImage"] = 4;
        values[valuesById[5] = "k_EDOTA_SPT_Movie"] = 5;
        return values;
    })();
    
    /**
     * dotaunitorder_t enum.
     * @exports dotaunitorder_t
     * @enum {number}
     * @property {number} DOTA_UNIT_ORDER_NONE=0 DOTA_UNIT_ORDER_NONE value
     * @property {number} DOTA_UNIT_ORDER_MOVE_TO_POSITION=1 DOTA_UNIT_ORDER_MOVE_TO_POSITION value
     * @property {number} DOTA_UNIT_ORDER_MOVE_TO_TARGET=2 DOTA_UNIT_ORDER_MOVE_TO_TARGET value
     * @property {number} DOTA_UNIT_ORDER_ATTACK_MOVE=3 DOTA_UNIT_ORDER_ATTACK_MOVE value
     * @property {number} DOTA_UNIT_ORDER_ATTACK_TARGET=4 DOTA_UNIT_ORDER_ATTACK_TARGET value
     * @property {number} DOTA_UNIT_ORDER_CAST_POSITION=5 DOTA_UNIT_ORDER_CAST_POSITION value
     * @property {number} DOTA_UNIT_ORDER_CAST_TARGET=6 DOTA_UNIT_ORDER_CAST_TARGET value
     * @property {number} DOTA_UNIT_ORDER_CAST_TARGET_TREE=7 DOTA_UNIT_ORDER_CAST_TARGET_TREE value
     * @property {number} DOTA_UNIT_ORDER_CAST_NO_TARGET=8 DOTA_UNIT_ORDER_CAST_NO_TARGET value
     * @property {number} DOTA_UNIT_ORDER_CAST_TOGGLE=9 DOTA_UNIT_ORDER_CAST_TOGGLE value
     * @property {number} DOTA_UNIT_ORDER_HOLD_POSITION=10 DOTA_UNIT_ORDER_HOLD_POSITION value
     * @property {number} DOTA_UNIT_ORDER_TRAIN_ABILITY=11 DOTA_UNIT_ORDER_TRAIN_ABILITY value
     * @property {number} DOTA_UNIT_ORDER_DROP_ITEM=12 DOTA_UNIT_ORDER_DROP_ITEM value
     * @property {number} DOTA_UNIT_ORDER_GIVE_ITEM=13 DOTA_UNIT_ORDER_GIVE_ITEM value
     * @property {number} DOTA_UNIT_ORDER_PICKUP_ITEM=14 DOTA_UNIT_ORDER_PICKUP_ITEM value
     * @property {number} DOTA_UNIT_ORDER_PICKUP_RUNE=15 DOTA_UNIT_ORDER_PICKUP_RUNE value
     * @property {number} DOTA_UNIT_ORDER_PURCHASE_ITEM=16 DOTA_UNIT_ORDER_PURCHASE_ITEM value
     * @property {number} DOTA_UNIT_ORDER_SELL_ITEM=17 DOTA_UNIT_ORDER_SELL_ITEM value
     * @property {number} DOTA_UNIT_ORDER_DISASSEMBLE_ITEM=18 DOTA_UNIT_ORDER_DISASSEMBLE_ITEM value
     * @property {number} DOTA_UNIT_ORDER_MOVE_ITEM=19 DOTA_UNIT_ORDER_MOVE_ITEM value
     * @property {number} DOTA_UNIT_ORDER_CAST_TOGGLE_AUTO=20 DOTA_UNIT_ORDER_CAST_TOGGLE_AUTO value
     * @property {number} DOTA_UNIT_ORDER_STOP=21 DOTA_UNIT_ORDER_STOP value
     * @property {number} DOTA_UNIT_ORDER_TAUNT=22 DOTA_UNIT_ORDER_TAUNT value
     * @property {number} DOTA_UNIT_ORDER_BUYBACK=23 DOTA_UNIT_ORDER_BUYBACK value
     * @property {number} DOTA_UNIT_ORDER_GLYPH=24 DOTA_UNIT_ORDER_GLYPH value
     * @property {number} DOTA_UNIT_ORDER_EJECT_ITEM_FROM_STASH=25 DOTA_UNIT_ORDER_EJECT_ITEM_FROM_STASH value
     * @property {number} DOTA_UNIT_ORDER_CAST_RUNE=26 DOTA_UNIT_ORDER_CAST_RUNE value
     * @property {number} DOTA_UNIT_ORDER_PING_ABILITY=27 DOTA_UNIT_ORDER_PING_ABILITY value
     * @property {number} DOTA_UNIT_ORDER_MOVE_TO_DIRECTION=28 DOTA_UNIT_ORDER_MOVE_TO_DIRECTION value
     * @property {number} DOTA_UNIT_ORDER_PATROL=29 DOTA_UNIT_ORDER_PATROL value
     * @property {number} DOTA_UNIT_ORDER_VECTOR_TARGET_POSITION=30 DOTA_UNIT_ORDER_VECTOR_TARGET_POSITION value
     * @property {number} DOTA_UNIT_ORDER_RADAR=31 DOTA_UNIT_ORDER_RADAR value
     * @property {number} DOTA_UNIT_ORDER_SET_ITEM_COMBINE_LOCK=32 DOTA_UNIT_ORDER_SET_ITEM_COMBINE_LOCK value
     * @property {number} DOTA_UNIT_ORDER_CONTINUE=33 DOTA_UNIT_ORDER_CONTINUE value
     * @property {number} DOTA_UNIT_ORDER_VECTOR_TARGET_CANCELED=34 DOTA_UNIT_ORDER_VECTOR_TARGET_CANCELED value
     * @property {number} DOTA_UNIT_ORDER_CAST_RIVER_PAINT=35 DOTA_UNIT_ORDER_CAST_RIVER_PAINT value
     * @property {number} DOTA_UNIT_ORDER_PREGAME_ADJUST_ITEM_ASSIGNMENT=36 DOTA_UNIT_ORDER_PREGAME_ADJUST_ITEM_ASSIGNMENT value
     * @property {number} DOTA_UNIT_ORDER_DROP_ITEM_AT_FOUNTAIN=37 DOTA_UNIT_ORDER_DROP_ITEM_AT_FOUNTAIN value
     * @property {number} DOTA_UNIT_ORDER_TAKE_ITEM_FROM_NEUTRAL_ITEM_STASH=38 DOTA_UNIT_ORDER_TAKE_ITEM_FROM_NEUTRAL_ITEM_STASH value
     */
    $root.dotaunitorder_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_UNIT_ORDER_NONE"] = 0;
        values[valuesById[1] = "DOTA_UNIT_ORDER_MOVE_TO_POSITION"] = 1;
        values[valuesById[2] = "DOTA_UNIT_ORDER_MOVE_TO_TARGET"] = 2;
        values[valuesById[3] = "DOTA_UNIT_ORDER_ATTACK_MOVE"] = 3;
        values[valuesById[4] = "DOTA_UNIT_ORDER_ATTACK_TARGET"] = 4;
        values[valuesById[5] = "DOTA_UNIT_ORDER_CAST_POSITION"] = 5;
        values[valuesById[6] = "DOTA_UNIT_ORDER_CAST_TARGET"] = 6;
        values[valuesById[7] = "DOTA_UNIT_ORDER_CAST_TARGET_TREE"] = 7;
        values[valuesById[8] = "DOTA_UNIT_ORDER_CAST_NO_TARGET"] = 8;
        values[valuesById[9] = "DOTA_UNIT_ORDER_CAST_TOGGLE"] = 9;
        values[valuesById[10] = "DOTA_UNIT_ORDER_HOLD_POSITION"] = 10;
        values[valuesById[11] = "DOTA_UNIT_ORDER_TRAIN_ABILITY"] = 11;
        values[valuesById[12] = "DOTA_UNIT_ORDER_DROP_ITEM"] = 12;
        values[valuesById[13] = "DOTA_UNIT_ORDER_GIVE_ITEM"] = 13;
        values[valuesById[14] = "DOTA_UNIT_ORDER_PICKUP_ITEM"] = 14;
        values[valuesById[15] = "DOTA_UNIT_ORDER_PICKUP_RUNE"] = 15;
        values[valuesById[16] = "DOTA_UNIT_ORDER_PURCHASE_ITEM"] = 16;
        values[valuesById[17] = "DOTA_UNIT_ORDER_SELL_ITEM"] = 17;
        values[valuesById[18] = "DOTA_UNIT_ORDER_DISASSEMBLE_ITEM"] = 18;
        values[valuesById[19] = "DOTA_UNIT_ORDER_MOVE_ITEM"] = 19;
        values[valuesById[20] = "DOTA_UNIT_ORDER_CAST_TOGGLE_AUTO"] = 20;
        values[valuesById[21] = "DOTA_UNIT_ORDER_STOP"] = 21;
        values[valuesById[22] = "DOTA_UNIT_ORDER_TAUNT"] = 22;
        values[valuesById[23] = "DOTA_UNIT_ORDER_BUYBACK"] = 23;
        values[valuesById[24] = "DOTA_UNIT_ORDER_GLYPH"] = 24;
        values[valuesById[25] = "DOTA_UNIT_ORDER_EJECT_ITEM_FROM_STASH"] = 25;
        values[valuesById[26] = "DOTA_UNIT_ORDER_CAST_RUNE"] = 26;
        values[valuesById[27] = "DOTA_UNIT_ORDER_PING_ABILITY"] = 27;
        values[valuesById[28] = "DOTA_UNIT_ORDER_MOVE_TO_DIRECTION"] = 28;
        values[valuesById[29] = "DOTA_UNIT_ORDER_PATROL"] = 29;
        values[valuesById[30] = "DOTA_UNIT_ORDER_VECTOR_TARGET_POSITION"] = 30;
        values[valuesById[31] = "DOTA_UNIT_ORDER_RADAR"] = 31;
        values[valuesById[32] = "DOTA_UNIT_ORDER_SET_ITEM_COMBINE_LOCK"] = 32;
        values[valuesById[33] = "DOTA_UNIT_ORDER_CONTINUE"] = 33;
        values[valuesById[34] = "DOTA_UNIT_ORDER_VECTOR_TARGET_CANCELED"] = 34;
        values[valuesById[35] = "DOTA_UNIT_ORDER_CAST_RIVER_PAINT"] = 35;
        values[valuesById[36] = "DOTA_UNIT_ORDER_PREGAME_ADJUST_ITEM_ASSIGNMENT"] = 36;
        values[valuesById[37] = "DOTA_UNIT_ORDER_DROP_ITEM_AT_FOUNTAIN"] = 37;
        values[valuesById[38] = "DOTA_UNIT_ORDER_TAKE_ITEM_FROM_NEUTRAL_ITEM_STASH"] = 38;
        return values;
    })();
    
    /**
     * EDOTAVersusScenePlayerBehavior enum.
     * @exports EDOTAVersusScenePlayerBehavior
     * @enum {number}
     * @property {number} VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY=1 VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY value
     * @property {number} VS_PLAYER_BEHAVIOR_CHAT_WHEEL=2 VS_PLAYER_BEHAVIOR_CHAT_WHEEL value
     * @property {number} VS_PLAYER_BEHAVIOR_PLAYBACK_RATE=3 VS_PLAYER_BEHAVIOR_PLAYBACK_RATE value
     */
    $root.EDOTAVersusScenePlayerBehavior = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY"] = 1;
        values[valuesById[2] = "VS_PLAYER_BEHAVIOR_CHAT_WHEEL"] = 2;
        values[valuesById[3] = "VS_PLAYER_BEHAVIOR_PLAYBACK_RATE"] = 3;
        return values;
    })();
    
    $root.CDOTAMsg_LocationPing = (function() {
    
        /**
         * Properties of a CDOTAMsg_LocationPing.
         * @exports ICDOTAMsg_LocationPing
         * @interface ICDOTAMsg_LocationPing
         * @property {number|null} [x] CDOTAMsg_LocationPing x
         * @property {number|null} [y] CDOTAMsg_LocationPing y
         * @property {number|null} [target] CDOTAMsg_LocationPing target
         * @property {boolean|null} [direct_ping] CDOTAMsg_LocationPing direct_ping
         * @property {number|null} [type] CDOTAMsg_LocationPing type
         */
    
        /**
         * Constructs a new CDOTAMsg_LocationPing.
         * @exports CDOTAMsg_LocationPing
         * @classdesc Represents a CDOTAMsg_LocationPing.
         * @implements ICDOTAMsg_LocationPing
         * @constructor
         * @param {ICDOTAMsg_LocationPing=} [properties] Properties to set
         */
        function CDOTAMsg_LocationPing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAMsg_LocationPing x.
         * @member {number} x
         * @memberof CDOTAMsg_LocationPing
         * @instance
         */
        CDOTAMsg_LocationPing.prototype.x = 0;
    
        /**
         * CDOTAMsg_LocationPing y.
         * @member {number} y
         * @memberof CDOTAMsg_LocationPing
         * @instance
         */
        CDOTAMsg_LocationPing.prototype.y = 0;
    
        /**
         * CDOTAMsg_LocationPing target.
         * @member {number} target
         * @memberof CDOTAMsg_LocationPing
         * @instance
         */
        CDOTAMsg_LocationPing.prototype.target = 0;
    
        /**
         * CDOTAMsg_LocationPing direct_ping.
         * @member {boolean} direct_ping
         * @memberof CDOTAMsg_LocationPing
         * @instance
         */
        CDOTAMsg_LocationPing.prototype.direct_ping = false;
    
        /**
         * CDOTAMsg_LocationPing type.
         * @member {number} type
         * @memberof CDOTAMsg_LocationPing
         * @instance
         */
        CDOTAMsg_LocationPing.prototype.type = 0;
    
        /**
         * Creates a new CDOTAMsg_LocationPing instance using the specified properties.
         * @function create
         * @memberof CDOTAMsg_LocationPing
         * @static
         * @param {ICDOTAMsg_LocationPing=} [properties] Properties to set
         * @returns {CDOTAMsg_LocationPing} CDOTAMsg_LocationPing instance
         */
        CDOTAMsg_LocationPing.create = function create(properties) {
            return new CDOTAMsg_LocationPing(properties);
        };
    
        /**
         * Encodes the specified CDOTAMsg_LocationPing message. Does not implicitly {@link CDOTAMsg_LocationPing.verify|verify} messages.
         * @function encode
         * @memberof CDOTAMsg_LocationPing
         * @static
         * @param {ICDOTAMsg_LocationPing} message CDOTAMsg_LocationPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_LocationPing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.y);
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.target);
            if (message.direct_ping != null && Object.hasOwnProperty.call(message, "direct_ping"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.direct_ping);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAMsg_LocationPing message, length delimited. Does not implicitly {@link CDOTAMsg_LocationPing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAMsg_LocationPing
         * @static
         * @param {ICDOTAMsg_LocationPing} message CDOTAMsg_LocationPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_LocationPing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAMsg_LocationPing message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAMsg_LocationPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAMsg_LocationPing} CDOTAMsg_LocationPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_LocationPing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAMsg_LocationPing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.int32();
                    break;
                case 2:
                    message.y = reader.int32();
                    break;
                case 3:
                    message.target = reader.int32();
                    break;
                case 4:
                    message.direct_ping = reader.bool();
                    break;
                case 5:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAMsg_LocationPing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAMsg_LocationPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAMsg_LocationPing} CDOTAMsg_LocationPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_LocationPing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAMsg_LocationPing message.
         * @function verify
         * @memberof CDOTAMsg_LocationPing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAMsg_LocationPing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            if (message.target != null && message.hasOwnProperty("target"))
                if (!$util.isInteger(message.target))
                    return "target: integer expected";
            if (message.direct_ping != null && message.hasOwnProperty("direct_ping"))
                if (typeof message.direct_ping !== "boolean")
                    return "direct_ping: boolean expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAMsg_LocationPing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAMsg_LocationPing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAMsg_LocationPing} CDOTAMsg_LocationPing
         */
        CDOTAMsg_LocationPing.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAMsg_LocationPing)
                return object;
            var message = new $root.CDOTAMsg_LocationPing();
            if (object.x != null)
                message.x = object.x | 0;
            if (object.y != null)
                message.y = object.y | 0;
            if (object.target != null)
                message.target = object.target | 0;
            if (object.direct_ping != null)
                message.direct_ping = Boolean(object.direct_ping);
            if (object.type != null)
                message.type = object.type | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAMsg_LocationPing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAMsg_LocationPing
         * @static
         * @param {CDOTAMsg_LocationPing} message CDOTAMsg_LocationPing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAMsg_LocationPing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.target = 0;
                object.direct_ping = false;
                object.type = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = message.target;
            if (message.direct_ping != null && message.hasOwnProperty("direct_ping"))
                object.direct_ping = message.direct_ping;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            return object;
        };
    
        /**
         * Converts this CDOTAMsg_LocationPing to JSON.
         * @function toJSON
         * @memberof CDOTAMsg_LocationPing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAMsg_LocationPing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAMsg_LocationPing;
    })();
    
    $root.CDOTAMsg_ItemAlert = (function() {
    
        /**
         * Properties of a CDOTAMsg_ItemAlert.
         * @exports ICDOTAMsg_ItemAlert
         * @interface ICDOTAMsg_ItemAlert
         * @property {number|null} [x] CDOTAMsg_ItemAlert x
         * @property {number|null} [y] CDOTAMsg_ItemAlert y
         * @property {number|null} [item_ability_id] CDOTAMsg_ItemAlert item_ability_id
         */
    
        /**
         * Constructs a new CDOTAMsg_ItemAlert.
         * @exports CDOTAMsg_ItemAlert
         * @classdesc Represents a CDOTAMsg_ItemAlert.
         * @implements ICDOTAMsg_ItemAlert
         * @constructor
         * @param {ICDOTAMsg_ItemAlert=} [properties] Properties to set
         */
        function CDOTAMsg_ItemAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAMsg_ItemAlert x.
         * @member {number} x
         * @memberof CDOTAMsg_ItemAlert
         * @instance
         */
        CDOTAMsg_ItemAlert.prototype.x = 0;
    
        /**
         * CDOTAMsg_ItemAlert y.
         * @member {number} y
         * @memberof CDOTAMsg_ItemAlert
         * @instance
         */
        CDOTAMsg_ItemAlert.prototype.y = 0;
    
        /**
         * CDOTAMsg_ItemAlert item_ability_id.
         * @member {number} item_ability_id
         * @memberof CDOTAMsg_ItemAlert
         * @instance
         */
        CDOTAMsg_ItemAlert.prototype.item_ability_id = 0;
    
        /**
         * Creates a new CDOTAMsg_ItemAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAMsg_ItemAlert
         * @static
         * @param {ICDOTAMsg_ItemAlert=} [properties] Properties to set
         * @returns {CDOTAMsg_ItemAlert} CDOTAMsg_ItemAlert instance
         */
        CDOTAMsg_ItemAlert.create = function create(properties) {
            return new CDOTAMsg_ItemAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAMsg_ItemAlert message. Does not implicitly {@link CDOTAMsg_ItemAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAMsg_ItemAlert
         * @static
         * @param {ICDOTAMsg_ItemAlert} message CDOTAMsg_ItemAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_ItemAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.y);
            if (message.item_ability_id != null && Object.hasOwnProperty.call(message, "item_ability_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.item_ability_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAMsg_ItemAlert message, length delimited. Does not implicitly {@link CDOTAMsg_ItemAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAMsg_ItemAlert
         * @static
         * @param {ICDOTAMsg_ItemAlert} message CDOTAMsg_ItemAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_ItemAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAMsg_ItemAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAMsg_ItemAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAMsg_ItemAlert} CDOTAMsg_ItemAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_ItemAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAMsg_ItemAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.int32();
                    break;
                case 2:
                    message.y = reader.int32();
                    break;
                case 3:
                    message.item_ability_id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAMsg_ItemAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAMsg_ItemAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAMsg_ItemAlert} CDOTAMsg_ItemAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_ItemAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAMsg_ItemAlert message.
         * @function verify
         * @memberof CDOTAMsg_ItemAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAMsg_ItemAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                if (!$util.isInteger(message.item_ability_id))
                    return "item_ability_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAMsg_ItemAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAMsg_ItemAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAMsg_ItemAlert} CDOTAMsg_ItemAlert
         */
        CDOTAMsg_ItemAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAMsg_ItemAlert)
                return object;
            var message = new $root.CDOTAMsg_ItemAlert();
            if (object.x != null)
                message.x = object.x | 0;
            if (object.y != null)
                message.y = object.y | 0;
            if (object.item_ability_id != null)
                message.item_ability_id = object.item_ability_id | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAMsg_ItemAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAMsg_ItemAlert
         * @static
         * @param {CDOTAMsg_ItemAlert} message CDOTAMsg_ItemAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAMsg_ItemAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.item_ability_id = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                object.item_ability_id = message.item_ability_id;
            return object;
        };
    
        /**
         * Converts this CDOTAMsg_ItemAlert to JSON.
         * @function toJSON
         * @memberof CDOTAMsg_ItemAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAMsg_ItemAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAMsg_ItemAlert;
    })();
    
    $root.CDOTAMsg_MapLine = (function() {
    
        /**
         * Properties of a CDOTAMsg_MapLine.
         * @exports ICDOTAMsg_MapLine
         * @interface ICDOTAMsg_MapLine
         * @property {number|null} [x] CDOTAMsg_MapLine x
         * @property {number|null} [y] CDOTAMsg_MapLine y
         * @property {boolean|null} [initial] CDOTAMsg_MapLine initial
         */
    
        /**
         * Constructs a new CDOTAMsg_MapLine.
         * @exports CDOTAMsg_MapLine
         * @classdesc Represents a CDOTAMsg_MapLine.
         * @implements ICDOTAMsg_MapLine
         * @constructor
         * @param {ICDOTAMsg_MapLine=} [properties] Properties to set
         */
        function CDOTAMsg_MapLine(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAMsg_MapLine x.
         * @member {number} x
         * @memberof CDOTAMsg_MapLine
         * @instance
         */
        CDOTAMsg_MapLine.prototype.x = 0;
    
        /**
         * CDOTAMsg_MapLine y.
         * @member {number} y
         * @memberof CDOTAMsg_MapLine
         * @instance
         */
        CDOTAMsg_MapLine.prototype.y = 0;
    
        /**
         * CDOTAMsg_MapLine initial.
         * @member {boolean} initial
         * @memberof CDOTAMsg_MapLine
         * @instance
         */
        CDOTAMsg_MapLine.prototype.initial = false;
    
        /**
         * Creates a new CDOTAMsg_MapLine instance using the specified properties.
         * @function create
         * @memberof CDOTAMsg_MapLine
         * @static
         * @param {ICDOTAMsg_MapLine=} [properties] Properties to set
         * @returns {CDOTAMsg_MapLine} CDOTAMsg_MapLine instance
         */
        CDOTAMsg_MapLine.create = function create(properties) {
            return new CDOTAMsg_MapLine(properties);
        };
    
        /**
         * Encodes the specified CDOTAMsg_MapLine message. Does not implicitly {@link CDOTAMsg_MapLine.verify|verify} messages.
         * @function encode
         * @memberof CDOTAMsg_MapLine
         * @static
         * @param {ICDOTAMsg_MapLine} message CDOTAMsg_MapLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_MapLine.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.y);
            if (message.initial != null && Object.hasOwnProperty.call(message, "initial"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.initial);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAMsg_MapLine message, length delimited. Does not implicitly {@link CDOTAMsg_MapLine.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAMsg_MapLine
         * @static
         * @param {ICDOTAMsg_MapLine} message CDOTAMsg_MapLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_MapLine.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAMsg_MapLine message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAMsg_MapLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAMsg_MapLine} CDOTAMsg_MapLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_MapLine.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAMsg_MapLine();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.int32();
                    break;
                case 2:
                    message.y = reader.int32();
                    break;
                case 3:
                    message.initial = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAMsg_MapLine message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAMsg_MapLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAMsg_MapLine} CDOTAMsg_MapLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_MapLine.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAMsg_MapLine message.
         * @function verify
         * @memberof CDOTAMsg_MapLine
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAMsg_MapLine.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            if (message.initial != null && message.hasOwnProperty("initial"))
                if (typeof message.initial !== "boolean")
                    return "initial: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAMsg_MapLine message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAMsg_MapLine
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAMsg_MapLine} CDOTAMsg_MapLine
         */
        CDOTAMsg_MapLine.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAMsg_MapLine)
                return object;
            var message = new $root.CDOTAMsg_MapLine();
            if (object.x != null)
                message.x = object.x | 0;
            if (object.y != null)
                message.y = object.y | 0;
            if (object.initial != null)
                message.initial = Boolean(object.initial);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAMsg_MapLine message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAMsg_MapLine
         * @static
         * @param {CDOTAMsg_MapLine} message CDOTAMsg_MapLine
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAMsg_MapLine.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.initial = false;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            if (message.initial != null && message.hasOwnProperty("initial"))
                object.initial = message.initial;
            return object;
        };
    
        /**
         * Converts this CDOTAMsg_MapLine to JSON.
         * @function toJSON
         * @memberof CDOTAMsg_MapLine
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAMsg_MapLine.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAMsg_MapLine;
    })();
    
    $root.CDOTAMsg_WorldLine = (function() {
    
        /**
         * Properties of a CDOTAMsg_WorldLine.
         * @exports ICDOTAMsg_WorldLine
         * @interface ICDOTAMsg_WorldLine
         * @property {number|null} [x] CDOTAMsg_WorldLine x
         * @property {number|null} [y] CDOTAMsg_WorldLine y
         * @property {number|null} [z] CDOTAMsg_WorldLine z
         * @property {boolean|null} [initial] CDOTAMsg_WorldLine initial
         * @property {boolean|null} [end] CDOTAMsg_WorldLine end
         */
    
        /**
         * Constructs a new CDOTAMsg_WorldLine.
         * @exports CDOTAMsg_WorldLine
         * @classdesc Represents a CDOTAMsg_WorldLine.
         * @implements ICDOTAMsg_WorldLine
         * @constructor
         * @param {ICDOTAMsg_WorldLine=} [properties] Properties to set
         */
        function CDOTAMsg_WorldLine(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAMsg_WorldLine x.
         * @member {number} x
         * @memberof CDOTAMsg_WorldLine
         * @instance
         */
        CDOTAMsg_WorldLine.prototype.x = 0;
    
        /**
         * CDOTAMsg_WorldLine y.
         * @member {number} y
         * @memberof CDOTAMsg_WorldLine
         * @instance
         */
        CDOTAMsg_WorldLine.prototype.y = 0;
    
        /**
         * CDOTAMsg_WorldLine z.
         * @member {number} z
         * @memberof CDOTAMsg_WorldLine
         * @instance
         */
        CDOTAMsg_WorldLine.prototype.z = 0;
    
        /**
         * CDOTAMsg_WorldLine initial.
         * @member {boolean} initial
         * @memberof CDOTAMsg_WorldLine
         * @instance
         */
        CDOTAMsg_WorldLine.prototype.initial = false;
    
        /**
         * CDOTAMsg_WorldLine end.
         * @member {boolean} end
         * @memberof CDOTAMsg_WorldLine
         * @instance
         */
        CDOTAMsg_WorldLine.prototype.end = false;
    
        /**
         * Creates a new CDOTAMsg_WorldLine instance using the specified properties.
         * @function create
         * @memberof CDOTAMsg_WorldLine
         * @static
         * @param {ICDOTAMsg_WorldLine=} [properties] Properties to set
         * @returns {CDOTAMsg_WorldLine} CDOTAMsg_WorldLine instance
         */
        CDOTAMsg_WorldLine.create = function create(properties) {
            return new CDOTAMsg_WorldLine(properties);
        };
    
        /**
         * Encodes the specified CDOTAMsg_WorldLine message. Does not implicitly {@link CDOTAMsg_WorldLine.verify|verify} messages.
         * @function encode
         * @memberof CDOTAMsg_WorldLine
         * @static
         * @param {ICDOTAMsg_WorldLine} message CDOTAMsg_WorldLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_WorldLine.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.z);
            if (message.initial != null && Object.hasOwnProperty.call(message, "initial"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.initial);
            if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.end);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAMsg_WorldLine message, length delimited. Does not implicitly {@link CDOTAMsg_WorldLine.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAMsg_WorldLine
         * @static
         * @param {ICDOTAMsg_WorldLine} message CDOTAMsg_WorldLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_WorldLine.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAMsg_WorldLine message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAMsg_WorldLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAMsg_WorldLine} CDOTAMsg_WorldLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_WorldLine.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAMsg_WorldLine();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.int32();
                    break;
                case 2:
                    message.y = reader.int32();
                    break;
                case 3:
                    message.z = reader.int32();
                    break;
                case 4:
                    message.initial = reader.bool();
                    break;
                case 5:
                    message.end = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAMsg_WorldLine message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAMsg_WorldLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAMsg_WorldLine} CDOTAMsg_WorldLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_WorldLine.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAMsg_WorldLine message.
         * @function verify
         * @memberof CDOTAMsg_WorldLine
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAMsg_WorldLine.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (!$util.isInteger(message.z))
                    return "z: integer expected";
            if (message.initial != null && message.hasOwnProperty("initial"))
                if (typeof message.initial !== "boolean")
                    return "initial: boolean expected";
            if (message.end != null && message.hasOwnProperty("end"))
                if (typeof message.end !== "boolean")
                    return "end: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAMsg_WorldLine message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAMsg_WorldLine
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAMsg_WorldLine} CDOTAMsg_WorldLine
         */
        CDOTAMsg_WorldLine.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAMsg_WorldLine)
                return object;
            var message = new $root.CDOTAMsg_WorldLine();
            if (object.x != null)
                message.x = object.x | 0;
            if (object.y != null)
                message.y = object.y | 0;
            if (object.z != null)
                message.z = object.z | 0;
            if (object.initial != null)
                message.initial = Boolean(object.initial);
            if (object.end != null)
                message.end = Boolean(object.end);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAMsg_WorldLine message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAMsg_WorldLine
         * @static
         * @param {CDOTAMsg_WorldLine} message CDOTAMsg_WorldLine
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAMsg_WorldLine.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
                object.initial = false;
                object.end = false;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = message.z;
            if (message.initial != null && message.hasOwnProperty("initial"))
                object.initial = message.initial;
            if (message.end != null && message.hasOwnProperty("end"))
                object.end = message.end;
            return object;
        };
    
        /**
         * Converts this CDOTAMsg_WorldLine to JSON.
         * @function toJSON
         * @memberof CDOTAMsg_WorldLine
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAMsg_WorldLine.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAMsg_WorldLine;
    })();
    
    $root.CDOTAMsg_SendStatPopup = (function() {
    
        /**
         * Properties of a CDOTAMsg_SendStatPopup.
         * @exports ICDOTAMsg_SendStatPopup
         * @interface ICDOTAMsg_SendStatPopup
         * @property {EDOTAStatPopupTypes|null} [style] CDOTAMsg_SendStatPopup style
         * @property {Array.<string>|null} [stat_strings] CDOTAMsg_SendStatPopup stat_strings
         * @property {Array.<number>|null} [stat_images] CDOTAMsg_SendStatPopup stat_images
         * @property {Array.<number>|null} [stat_image_types] CDOTAMsg_SendStatPopup stat_image_types
         * @property {number|null} [duration] CDOTAMsg_SendStatPopup duration
         * @property {boolean|null} [use_html] CDOTAMsg_SendStatPopup use_html
         * @property {string|null} [movie_name] CDOTAMsg_SendStatPopup movie_name
         */
    
        /**
         * Constructs a new CDOTAMsg_SendStatPopup.
         * @exports CDOTAMsg_SendStatPopup
         * @classdesc Represents a CDOTAMsg_SendStatPopup.
         * @implements ICDOTAMsg_SendStatPopup
         * @constructor
         * @param {ICDOTAMsg_SendStatPopup=} [properties] Properties to set
         */
        function CDOTAMsg_SendStatPopup(properties) {
            this.stat_strings = [];
            this.stat_images = [];
            this.stat_image_types = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAMsg_SendStatPopup style.
         * @member {EDOTAStatPopupTypes} style
         * @memberof CDOTAMsg_SendStatPopup
         * @instance
         */
        CDOTAMsg_SendStatPopup.prototype.style = 0;
    
        /**
         * CDOTAMsg_SendStatPopup stat_strings.
         * @member {Array.<string>} stat_strings
         * @memberof CDOTAMsg_SendStatPopup
         * @instance
         */
        CDOTAMsg_SendStatPopup.prototype.stat_strings = $util.emptyArray;
    
        /**
         * CDOTAMsg_SendStatPopup stat_images.
         * @member {Array.<number>} stat_images
         * @memberof CDOTAMsg_SendStatPopup
         * @instance
         */
        CDOTAMsg_SendStatPopup.prototype.stat_images = $util.emptyArray;
    
        /**
         * CDOTAMsg_SendStatPopup stat_image_types.
         * @member {Array.<number>} stat_image_types
         * @memberof CDOTAMsg_SendStatPopup
         * @instance
         */
        CDOTAMsg_SendStatPopup.prototype.stat_image_types = $util.emptyArray;
    
        /**
         * CDOTAMsg_SendStatPopup duration.
         * @member {number} duration
         * @memberof CDOTAMsg_SendStatPopup
         * @instance
         */
        CDOTAMsg_SendStatPopup.prototype.duration = 0;
    
        /**
         * CDOTAMsg_SendStatPopup use_html.
         * @member {boolean} use_html
         * @memberof CDOTAMsg_SendStatPopup
         * @instance
         */
        CDOTAMsg_SendStatPopup.prototype.use_html = false;
    
        /**
         * CDOTAMsg_SendStatPopup movie_name.
         * @member {string} movie_name
         * @memberof CDOTAMsg_SendStatPopup
         * @instance
         */
        CDOTAMsg_SendStatPopup.prototype.movie_name = "";
    
        /**
         * Creates a new CDOTAMsg_SendStatPopup instance using the specified properties.
         * @function create
         * @memberof CDOTAMsg_SendStatPopup
         * @static
         * @param {ICDOTAMsg_SendStatPopup=} [properties] Properties to set
         * @returns {CDOTAMsg_SendStatPopup} CDOTAMsg_SendStatPopup instance
         */
        CDOTAMsg_SendStatPopup.create = function create(properties) {
            return new CDOTAMsg_SendStatPopup(properties);
        };
    
        /**
         * Encodes the specified CDOTAMsg_SendStatPopup message. Does not implicitly {@link CDOTAMsg_SendStatPopup.verify|verify} messages.
         * @function encode
         * @memberof CDOTAMsg_SendStatPopup
         * @static
         * @param {ICDOTAMsg_SendStatPopup} message CDOTAMsg_SendStatPopup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_SendStatPopup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.style != null && Object.hasOwnProperty.call(message, "style"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.style);
            if (message.stat_strings != null && message.stat_strings.length)
                for (var i = 0; i < message.stat_strings.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.stat_strings[i]);
            if (message.stat_images != null && message.stat_images.length)
                for (var i = 0; i < message.stat_images.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.stat_images[i]);
            if (message.stat_image_types != null && message.stat_image_types.length)
                for (var i = 0; i < message.stat_image_types.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.stat_image_types[i]);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.duration);
            if (message.use_html != null && Object.hasOwnProperty.call(message, "use_html"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.use_html);
            if (message.movie_name != null && Object.hasOwnProperty.call(message, "movie_name"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.movie_name);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAMsg_SendStatPopup message, length delimited. Does not implicitly {@link CDOTAMsg_SendStatPopup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAMsg_SendStatPopup
         * @static
         * @param {ICDOTAMsg_SendStatPopup} message CDOTAMsg_SendStatPopup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_SendStatPopup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAMsg_SendStatPopup message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAMsg_SendStatPopup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAMsg_SendStatPopup} CDOTAMsg_SendStatPopup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_SendStatPopup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAMsg_SendStatPopup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.style = reader.int32();
                    break;
                case 2:
                    if (!(message.stat_strings && message.stat_strings.length))
                        message.stat_strings = [];
                    message.stat_strings.push(reader.string());
                    break;
                case 3:
                    if (!(message.stat_images && message.stat_images.length))
                        message.stat_images = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.stat_images.push(reader.int32());
                    } else
                        message.stat_images.push(reader.int32());
                    break;
                case 4:
                    if (!(message.stat_image_types && message.stat_image_types.length))
                        message.stat_image_types = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.stat_image_types.push(reader.int32());
                    } else
                        message.stat_image_types.push(reader.int32());
                    break;
                case 5:
                    message.duration = reader.float();
                    break;
                case 6:
                    message.use_html = reader.bool();
                    break;
                case 7:
                    message.movie_name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAMsg_SendStatPopup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAMsg_SendStatPopup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAMsg_SendStatPopup} CDOTAMsg_SendStatPopup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_SendStatPopup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAMsg_SendStatPopup message.
         * @function verify
         * @memberof CDOTAMsg_SendStatPopup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAMsg_SendStatPopup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.style != null && message.hasOwnProperty("style"))
                switch (message.style) {
                default:
                    return "style: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.stat_strings != null && message.hasOwnProperty("stat_strings")) {
                if (!Array.isArray(message.stat_strings))
                    return "stat_strings: array expected";
                for (var i = 0; i < message.stat_strings.length; ++i)
                    if (!$util.isString(message.stat_strings[i]))
                        return "stat_strings: string[] expected";
            }
            if (message.stat_images != null && message.hasOwnProperty("stat_images")) {
                if (!Array.isArray(message.stat_images))
                    return "stat_images: array expected";
                for (var i = 0; i < message.stat_images.length; ++i)
                    if (!$util.isInteger(message.stat_images[i]))
                        return "stat_images: integer[] expected";
            }
            if (message.stat_image_types != null && message.hasOwnProperty("stat_image_types")) {
                if (!Array.isArray(message.stat_image_types))
                    return "stat_image_types: array expected";
                for (var i = 0; i < message.stat_image_types.length; ++i)
                    if (!$util.isInteger(message.stat_image_types[i]))
                        return "stat_image_types: integer[] expected";
            }
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            if (message.use_html != null && message.hasOwnProperty("use_html"))
                if (typeof message.use_html !== "boolean")
                    return "use_html: boolean expected";
            if (message.movie_name != null && message.hasOwnProperty("movie_name"))
                if (!$util.isString(message.movie_name))
                    return "movie_name: string expected";
            return null;
        };
    
        /**
         * Creates a CDOTAMsg_SendStatPopup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAMsg_SendStatPopup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAMsg_SendStatPopup} CDOTAMsg_SendStatPopup
         */
        CDOTAMsg_SendStatPopup.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAMsg_SendStatPopup)
                return object;
            var message = new $root.CDOTAMsg_SendStatPopup();
            switch (object.style) {
            case "k_EDOTA_SPT_Textline":
            case 0:
                message.style = 0;
                break;
            case "k_EDOTA_SPT_Basic":
            case 1:
                message.style = 1;
                break;
            case "k_EDOTA_SPT_Poll":
            case 2:
                message.style = 2;
                break;
            case "k_EDOTA_SPT_Grid":
            case 3:
                message.style = 3;
                break;
            case "k_EDOTA_SPT_DualImage":
            case 4:
                message.style = 4;
                break;
            case "k_EDOTA_SPT_Movie":
            case 5:
                message.style = 5;
                break;
            }
            if (object.stat_strings) {
                if (!Array.isArray(object.stat_strings))
                    throw TypeError(".CDOTAMsg_SendStatPopup.stat_strings: array expected");
                message.stat_strings = [];
                for (var i = 0; i < object.stat_strings.length; ++i)
                    message.stat_strings[i] = String(object.stat_strings[i]);
            }
            if (object.stat_images) {
                if (!Array.isArray(object.stat_images))
                    throw TypeError(".CDOTAMsg_SendStatPopup.stat_images: array expected");
                message.stat_images = [];
                for (var i = 0; i < object.stat_images.length; ++i)
                    message.stat_images[i] = object.stat_images[i] | 0;
            }
            if (object.stat_image_types) {
                if (!Array.isArray(object.stat_image_types))
                    throw TypeError(".CDOTAMsg_SendStatPopup.stat_image_types: array expected");
                message.stat_image_types = [];
                for (var i = 0; i < object.stat_image_types.length; ++i)
                    message.stat_image_types[i] = object.stat_image_types[i] | 0;
            }
            if (object.duration != null)
                message.duration = Number(object.duration);
            if (object.use_html != null)
                message.use_html = Boolean(object.use_html);
            if (object.movie_name != null)
                message.movie_name = String(object.movie_name);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAMsg_SendStatPopup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAMsg_SendStatPopup
         * @static
         * @param {CDOTAMsg_SendStatPopup} message CDOTAMsg_SendStatPopup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAMsg_SendStatPopup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.stat_strings = [];
                object.stat_images = [];
                object.stat_image_types = [];
            }
            if (options.defaults) {
                object.style = options.enums === String ? "k_EDOTA_SPT_Textline" : 0;
                object.duration = 0;
                object.use_html = false;
                object.movie_name = "";
            }
            if (message.style != null && message.hasOwnProperty("style"))
                object.style = options.enums === String ? $root.EDOTAStatPopupTypes[message.style] : message.style;
            if (message.stat_strings && message.stat_strings.length) {
                object.stat_strings = [];
                for (var j = 0; j < message.stat_strings.length; ++j)
                    object.stat_strings[j] = message.stat_strings[j];
            }
            if (message.stat_images && message.stat_images.length) {
                object.stat_images = [];
                for (var j = 0; j < message.stat_images.length; ++j)
                    object.stat_images[j] = message.stat_images[j];
            }
            if (message.stat_image_types && message.stat_image_types.length) {
                object.stat_image_types = [];
                for (var j = 0; j < message.stat_image_types.length; ++j)
                    object.stat_image_types[j] = message.stat_image_types[j];
            }
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            if (message.use_html != null && message.hasOwnProperty("use_html"))
                object.use_html = message.use_html;
            if (message.movie_name != null && message.hasOwnProperty("movie_name"))
                object.movie_name = message.movie_name;
            return object;
        };
    
        /**
         * Converts this CDOTAMsg_SendStatPopup to JSON.
         * @function toJSON
         * @memberof CDOTAMsg_SendStatPopup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAMsg_SendStatPopup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAMsg_SendStatPopup;
    })();
    
    $root.CDOTAMsg_DismissAllStatPopups = (function() {
    
        /**
         * Properties of a CDOTAMsg_DismissAllStatPopups.
         * @exports ICDOTAMsg_DismissAllStatPopups
         * @interface ICDOTAMsg_DismissAllStatPopups
         * @property {number|null} [time_delay] CDOTAMsg_DismissAllStatPopups time_delay
         */
    
        /**
         * Constructs a new CDOTAMsg_DismissAllStatPopups.
         * @exports CDOTAMsg_DismissAllStatPopups
         * @classdesc Represents a CDOTAMsg_DismissAllStatPopups.
         * @implements ICDOTAMsg_DismissAllStatPopups
         * @constructor
         * @param {ICDOTAMsg_DismissAllStatPopups=} [properties] Properties to set
         */
        function CDOTAMsg_DismissAllStatPopups(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAMsg_DismissAllStatPopups time_delay.
         * @member {number} time_delay
         * @memberof CDOTAMsg_DismissAllStatPopups
         * @instance
         */
        CDOTAMsg_DismissAllStatPopups.prototype.time_delay = 0;
    
        /**
         * Creates a new CDOTAMsg_DismissAllStatPopups instance using the specified properties.
         * @function create
         * @memberof CDOTAMsg_DismissAllStatPopups
         * @static
         * @param {ICDOTAMsg_DismissAllStatPopups=} [properties] Properties to set
         * @returns {CDOTAMsg_DismissAllStatPopups} CDOTAMsg_DismissAllStatPopups instance
         */
        CDOTAMsg_DismissAllStatPopups.create = function create(properties) {
            return new CDOTAMsg_DismissAllStatPopups(properties);
        };
    
        /**
         * Encodes the specified CDOTAMsg_DismissAllStatPopups message. Does not implicitly {@link CDOTAMsg_DismissAllStatPopups.verify|verify} messages.
         * @function encode
         * @memberof CDOTAMsg_DismissAllStatPopups
         * @static
         * @param {ICDOTAMsg_DismissAllStatPopups} message CDOTAMsg_DismissAllStatPopups message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_DismissAllStatPopups.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time_delay != null && Object.hasOwnProperty.call(message, "time_delay"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.time_delay);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAMsg_DismissAllStatPopups message, length delimited. Does not implicitly {@link CDOTAMsg_DismissAllStatPopups.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAMsg_DismissAllStatPopups
         * @static
         * @param {ICDOTAMsg_DismissAllStatPopups} message CDOTAMsg_DismissAllStatPopups message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_DismissAllStatPopups.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAMsg_DismissAllStatPopups message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAMsg_DismissAllStatPopups
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAMsg_DismissAllStatPopups} CDOTAMsg_DismissAllStatPopups
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_DismissAllStatPopups.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAMsg_DismissAllStatPopups();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time_delay = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAMsg_DismissAllStatPopups message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAMsg_DismissAllStatPopups
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAMsg_DismissAllStatPopups} CDOTAMsg_DismissAllStatPopups
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_DismissAllStatPopups.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAMsg_DismissAllStatPopups message.
         * @function verify
         * @memberof CDOTAMsg_DismissAllStatPopups
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAMsg_DismissAllStatPopups.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time_delay != null && message.hasOwnProperty("time_delay"))
                if (typeof message.time_delay !== "number")
                    return "time_delay: number expected";
            return null;
        };
    
        /**
         * Creates a CDOTAMsg_DismissAllStatPopups message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAMsg_DismissAllStatPopups
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAMsg_DismissAllStatPopups} CDOTAMsg_DismissAllStatPopups
         */
        CDOTAMsg_DismissAllStatPopups.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAMsg_DismissAllStatPopups)
                return object;
            var message = new $root.CDOTAMsg_DismissAllStatPopups();
            if (object.time_delay != null)
                message.time_delay = Number(object.time_delay);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAMsg_DismissAllStatPopups message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAMsg_DismissAllStatPopups
         * @static
         * @param {CDOTAMsg_DismissAllStatPopups} message CDOTAMsg_DismissAllStatPopups
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAMsg_DismissAllStatPopups.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.time_delay = 0;
            if (message.time_delay != null && message.hasOwnProperty("time_delay"))
                object.time_delay = options.json && !isFinite(message.time_delay) ? String(message.time_delay) : message.time_delay;
            return object;
        };
    
        /**
         * Converts this CDOTAMsg_DismissAllStatPopups to JSON.
         * @function toJSON
         * @memberof CDOTAMsg_DismissAllStatPopups
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAMsg_DismissAllStatPopups.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAMsg_DismissAllStatPopups;
    })();
    
    $root.CDOTAMsg_CoachHUDPing = (function() {
    
        /**
         * Properties of a CDOTAMsg_CoachHUDPing.
         * @exports ICDOTAMsg_CoachHUDPing
         * @interface ICDOTAMsg_CoachHUDPing
         * @property {number|null} [x] CDOTAMsg_CoachHUDPing x
         * @property {number|null} [y] CDOTAMsg_CoachHUDPing y
         * @property {string|null} [tgtpath] CDOTAMsg_CoachHUDPing tgtpath
         */
    
        /**
         * Constructs a new CDOTAMsg_CoachHUDPing.
         * @exports CDOTAMsg_CoachHUDPing
         * @classdesc Represents a CDOTAMsg_CoachHUDPing.
         * @implements ICDOTAMsg_CoachHUDPing
         * @constructor
         * @param {ICDOTAMsg_CoachHUDPing=} [properties] Properties to set
         */
        function CDOTAMsg_CoachHUDPing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAMsg_CoachHUDPing x.
         * @member {number} x
         * @memberof CDOTAMsg_CoachHUDPing
         * @instance
         */
        CDOTAMsg_CoachHUDPing.prototype.x = 0;
    
        /**
         * CDOTAMsg_CoachHUDPing y.
         * @member {number} y
         * @memberof CDOTAMsg_CoachHUDPing
         * @instance
         */
        CDOTAMsg_CoachHUDPing.prototype.y = 0;
    
        /**
         * CDOTAMsg_CoachHUDPing tgtpath.
         * @member {string} tgtpath
         * @memberof CDOTAMsg_CoachHUDPing
         * @instance
         */
        CDOTAMsg_CoachHUDPing.prototype.tgtpath = "";
    
        /**
         * Creates a new CDOTAMsg_CoachHUDPing instance using the specified properties.
         * @function create
         * @memberof CDOTAMsg_CoachHUDPing
         * @static
         * @param {ICDOTAMsg_CoachHUDPing=} [properties] Properties to set
         * @returns {CDOTAMsg_CoachHUDPing} CDOTAMsg_CoachHUDPing instance
         */
        CDOTAMsg_CoachHUDPing.create = function create(properties) {
            return new CDOTAMsg_CoachHUDPing(properties);
        };
    
        /**
         * Encodes the specified CDOTAMsg_CoachHUDPing message. Does not implicitly {@link CDOTAMsg_CoachHUDPing.verify|verify} messages.
         * @function encode
         * @memberof CDOTAMsg_CoachHUDPing
         * @static
         * @param {ICDOTAMsg_CoachHUDPing} message CDOTAMsg_CoachHUDPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_CoachHUDPing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.y);
            if (message.tgtpath != null && Object.hasOwnProperty.call(message, "tgtpath"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.tgtpath);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAMsg_CoachHUDPing message, length delimited. Does not implicitly {@link CDOTAMsg_CoachHUDPing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAMsg_CoachHUDPing
         * @static
         * @param {ICDOTAMsg_CoachHUDPing} message CDOTAMsg_CoachHUDPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_CoachHUDPing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAMsg_CoachHUDPing message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAMsg_CoachHUDPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAMsg_CoachHUDPing} CDOTAMsg_CoachHUDPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_CoachHUDPing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAMsg_CoachHUDPing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.uint32();
                    break;
                case 2:
                    message.y = reader.uint32();
                    break;
                case 3:
                    message.tgtpath = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAMsg_CoachHUDPing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAMsg_CoachHUDPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAMsg_CoachHUDPing} CDOTAMsg_CoachHUDPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_CoachHUDPing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAMsg_CoachHUDPing message.
         * @function verify
         * @memberof CDOTAMsg_CoachHUDPing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAMsg_CoachHUDPing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            if (message.tgtpath != null && message.hasOwnProperty("tgtpath"))
                if (!$util.isString(message.tgtpath))
                    return "tgtpath: string expected";
            return null;
        };
    
        /**
         * Creates a CDOTAMsg_CoachHUDPing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAMsg_CoachHUDPing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAMsg_CoachHUDPing} CDOTAMsg_CoachHUDPing
         */
        CDOTAMsg_CoachHUDPing.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAMsg_CoachHUDPing)
                return object;
            var message = new $root.CDOTAMsg_CoachHUDPing();
            if (object.x != null)
                message.x = object.x >>> 0;
            if (object.y != null)
                message.y = object.y >>> 0;
            if (object.tgtpath != null)
                message.tgtpath = String(object.tgtpath);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAMsg_CoachHUDPing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAMsg_CoachHUDPing
         * @static
         * @param {CDOTAMsg_CoachHUDPing} message CDOTAMsg_CoachHUDPing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAMsg_CoachHUDPing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.tgtpath = "";
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            if (message.tgtpath != null && message.hasOwnProperty("tgtpath"))
                object.tgtpath = message.tgtpath;
            return object;
        };
    
        /**
         * Converts this CDOTAMsg_CoachHUDPing to JSON.
         * @function toJSON
         * @memberof CDOTAMsg_CoachHUDPing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAMsg_CoachHUDPing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAMsg_CoachHUDPing;
    })();
    
    $root.CDOTAMsg_UnitOrder = (function() {
    
        /**
         * Properties of a CDOTAMsg_UnitOrder.
         * @exports ICDOTAMsg_UnitOrder
         * @interface ICDOTAMsg_UnitOrder
         * @property {number|null} [issuer] CDOTAMsg_UnitOrder issuer
         * @property {dotaunitorder_t|null} [order_type] CDOTAMsg_UnitOrder order_type
         * @property {Array.<number>|null} [units] CDOTAMsg_UnitOrder units
         * @property {number|null} [target_index] CDOTAMsg_UnitOrder target_index
         * @property {number|null} [ability_index] CDOTAMsg_UnitOrder ability_index
         * @property {ICMsgVector|null} [position] CDOTAMsg_UnitOrder position
         * @property {boolean|null} [queue] CDOTAMsg_UnitOrder queue
         * @property {number|null} [sequence_number] CDOTAMsg_UnitOrder sequence_number
         * @property {number|null} [flags] CDOTAMsg_UnitOrder flags
         */
    
        /**
         * Constructs a new CDOTAMsg_UnitOrder.
         * @exports CDOTAMsg_UnitOrder
         * @classdesc Represents a CDOTAMsg_UnitOrder.
         * @implements ICDOTAMsg_UnitOrder
         * @constructor
         * @param {ICDOTAMsg_UnitOrder=} [properties] Properties to set
         */
        function CDOTAMsg_UnitOrder(properties) {
            this.units = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAMsg_UnitOrder issuer.
         * @member {number} issuer
         * @memberof CDOTAMsg_UnitOrder
         * @instance
         */
        CDOTAMsg_UnitOrder.prototype.issuer = -1;
    
        /**
         * CDOTAMsg_UnitOrder order_type.
         * @member {dotaunitorder_t} order_type
         * @memberof CDOTAMsg_UnitOrder
         * @instance
         */
        CDOTAMsg_UnitOrder.prototype.order_type = 0;
    
        /**
         * CDOTAMsg_UnitOrder units.
         * @member {Array.<number>} units
         * @memberof CDOTAMsg_UnitOrder
         * @instance
         */
        CDOTAMsg_UnitOrder.prototype.units = $util.emptyArray;
    
        /**
         * CDOTAMsg_UnitOrder target_index.
         * @member {number} target_index
         * @memberof CDOTAMsg_UnitOrder
         * @instance
         */
        CDOTAMsg_UnitOrder.prototype.target_index = 0;
    
        /**
         * CDOTAMsg_UnitOrder ability_index.
         * @member {number} ability_index
         * @memberof CDOTAMsg_UnitOrder
         * @instance
         */
        CDOTAMsg_UnitOrder.prototype.ability_index = 0;
    
        /**
         * CDOTAMsg_UnitOrder position.
         * @member {ICMsgVector|null|undefined} position
         * @memberof CDOTAMsg_UnitOrder
         * @instance
         */
        CDOTAMsg_UnitOrder.prototype.position = null;
    
        /**
         * CDOTAMsg_UnitOrder queue.
         * @member {boolean} queue
         * @memberof CDOTAMsg_UnitOrder
         * @instance
         */
        CDOTAMsg_UnitOrder.prototype.queue = false;
    
        /**
         * CDOTAMsg_UnitOrder sequence_number.
         * @member {number} sequence_number
         * @memberof CDOTAMsg_UnitOrder
         * @instance
         */
        CDOTAMsg_UnitOrder.prototype.sequence_number = 0;
    
        /**
         * CDOTAMsg_UnitOrder flags.
         * @member {number} flags
         * @memberof CDOTAMsg_UnitOrder
         * @instance
         */
        CDOTAMsg_UnitOrder.prototype.flags = 0;
    
        /**
         * Creates a new CDOTAMsg_UnitOrder instance using the specified properties.
         * @function create
         * @memberof CDOTAMsg_UnitOrder
         * @static
         * @param {ICDOTAMsg_UnitOrder=} [properties] Properties to set
         * @returns {CDOTAMsg_UnitOrder} CDOTAMsg_UnitOrder instance
         */
        CDOTAMsg_UnitOrder.create = function create(properties) {
            return new CDOTAMsg_UnitOrder(properties);
        };
    
        /**
         * Encodes the specified CDOTAMsg_UnitOrder message. Does not implicitly {@link CDOTAMsg_UnitOrder.verify|verify} messages.
         * @function encode
         * @memberof CDOTAMsg_UnitOrder
         * @static
         * @param {ICDOTAMsg_UnitOrder} message CDOTAMsg_UnitOrder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_UnitOrder.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.issuer != null && Object.hasOwnProperty.call(message, "issuer"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.issuer);
            if (message.order_type != null && Object.hasOwnProperty.call(message, "order_type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.order_type);
            if (message.units != null && message.units.length)
                for (var i = 0; i < message.units.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.units[i]);
            if (message.target_index != null && Object.hasOwnProperty.call(message, "target_index"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.target_index);
            if (message.ability_index != null && Object.hasOwnProperty.call(message, "ability_index"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.ability_index);
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                $root.CMsgVector.encode(message.position, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.queue != null && Object.hasOwnProperty.call(message, "queue"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.queue);
            if (message.sequence_number != null && Object.hasOwnProperty.call(message, "sequence_number"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.sequence_number);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.flags);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAMsg_UnitOrder message, length delimited. Does not implicitly {@link CDOTAMsg_UnitOrder.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAMsg_UnitOrder
         * @static
         * @param {ICDOTAMsg_UnitOrder} message CDOTAMsg_UnitOrder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_UnitOrder.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAMsg_UnitOrder message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAMsg_UnitOrder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAMsg_UnitOrder} CDOTAMsg_UnitOrder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_UnitOrder.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAMsg_UnitOrder();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.issuer = reader.sint32();
                    break;
                case 2:
                    message.order_type = reader.int32();
                    break;
                case 3:
                    if (!(message.units && message.units.length))
                        message.units = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.units.push(reader.int32());
                    } else
                        message.units.push(reader.int32());
                    break;
                case 4:
                    message.target_index = reader.int32();
                    break;
                case 5:
                    message.ability_index = reader.int32();
                    break;
                case 6:
                    message.position = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.queue = reader.bool();
                    break;
                case 8:
                    message.sequence_number = reader.int32();
                    break;
                case 9:
                    message.flags = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAMsg_UnitOrder message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAMsg_UnitOrder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAMsg_UnitOrder} CDOTAMsg_UnitOrder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_UnitOrder.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAMsg_UnitOrder message.
         * @function verify
         * @memberof CDOTAMsg_UnitOrder
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAMsg_UnitOrder.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.issuer != null && message.hasOwnProperty("issuer"))
                if (!$util.isInteger(message.issuer))
                    return "issuer: integer expected";
            if (message.order_type != null && message.hasOwnProperty("order_type"))
                switch (message.order_type) {
                default:
                    return "order_type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                    break;
                }
            if (message.units != null && message.hasOwnProperty("units")) {
                if (!Array.isArray(message.units))
                    return "units: array expected";
                for (var i = 0; i < message.units.length; ++i)
                    if (!$util.isInteger(message.units[i]))
                        return "units: integer[] expected";
            }
            if (message.target_index != null && message.hasOwnProperty("target_index"))
                if (!$util.isInteger(message.target_index))
                    return "target_index: integer expected";
            if (message.ability_index != null && message.hasOwnProperty("ability_index"))
                if (!$util.isInteger(message.ability_index))
                    return "ability_index: integer expected";
            if (message.position != null && message.hasOwnProperty("position")) {
                var error = $root.CMsgVector.verify(message.position);
                if (error)
                    return "position." + error;
            }
            if (message.queue != null && message.hasOwnProperty("queue"))
                if (typeof message.queue !== "boolean")
                    return "queue: boolean expected";
            if (message.sequence_number != null && message.hasOwnProperty("sequence_number"))
                if (!$util.isInteger(message.sequence_number))
                    return "sequence_number: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAMsg_UnitOrder message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAMsg_UnitOrder
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAMsg_UnitOrder} CDOTAMsg_UnitOrder
         */
        CDOTAMsg_UnitOrder.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAMsg_UnitOrder)
                return object;
            var message = new $root.CDOTAMsg_UnitOrder();
            if (object.issuer != null)
                message.issuer = object.issuer | 0;
            switch (object.order_type) {
            case "DOTA_UNIT_ORDER_NONE":
            case 0:
                message.order_type = 0;
                break;
            case "DOTA_UNIT_ORDER_MOVE_TO_POSITION":
            case 1:
                message.order_type = 1;
                break;
            case "DOTA_UNIT_ORDER_MOVE_TO_TARGET":
            case 2:
                message.order_type = 2;
                break;
            case "DOTA_UNIT_ORDER_ATTACK_MOVE":
            case 3:
                message.order_type = 3;
                break;
            case "DOTA_UNIT_ORDER_ATTACK_TARGET":
            case 4:
                message.order_type = 4;
                break;
            case "DOTA_UNIT_ORDER_CAST_POSITION":
            case 5:
                message.order_type = 5;
                break;
            case "DOTA_UNIT_ORDER_CAST_TARGET":
            case 6:
                message.order_type = 6;
                break;
            case "DOTA_UNIT_ORDER_CAST_TARGET_TREE":
            case 7:
                message.order_type = 7;
                break;
            case "DOTA_UNIT_ORDER_CAST_NO_TARGET":
            case 8:
                message.order_type = 8;
                break;
            case "DOTA_UNIT_ORDER_CAST_TOGGLE":
            case 9:
                message.order_type = 9;
                break;
            case "DOTA_UNIT_ORDER_HOLD_POSITION":
            case 10:
                message.order_type = 10;
                break;
            case "DOTA_UNIT_ORDER_TRAIN_ABILITY":
            case 11:
                message.order_type = 11;
                break;
            case "DOTA_UNIT_ORDER_DROP_ITEM":
            case 12:
                message.order_type = 12;
                break;
            case "DOTA_UNIT_ORDER_GIVE_ITEM":
            case 13:
                message.order_type = 13;
                break;
            case "DOTA_UNIT_ORDER_PICKUP_ITEM":
            case 14:
                message.order_type = 14;
                break;
            case "DOTA_UNIT_ORDER_PICKUP_RUNE":
            case 15:
                message.order_type = 15;
                break;
            case "DOTA_UNIT_ORDER_PURCHASE_ITEM":
            case 16:
                message.order_type = 16;
                break;
            case "DOTA_UNIT_ORDER_SELL_ITEM":
            case 17:
                message.order_type = 17;
                break;
            case "DOTA_UNIT_ORDER_DISASSEMBLE_ITEM":
            case 18:
                message.order_type = 18;
                break;
            case "DOTA_UNIT_ORDER_MOVE_ITEM":
            case 19:
                message.order_type = 19;
                break;
            case "DOTA_UNIT_ORDER_CAST_TOGGLE_AUTO":
            case 20:
                message.order_type = 20;
                break;
            case "DOTA_UNIT_ORDER_STOP":
            case 21:
                message.order_type = 21;
                break;
            case "DOTA_UNIT_ORDER_TAUNT":
            case 22:
                message.order_type = 22;
                break;
            case "DOTA_UNIT_ORDER_BUYBACK":
            case 23:
                message.order_type = 23;
                break;
            case "DOTA_UNIT_ORDER_GLYPH":
            case 24:
                message.order_type = 24;
                break;
            case "DOTA_UNIT_ORDER_EJECT_ITEM_FROM_STASH":
            case 25:
                message.order_type = 25;
                break;
            case "DOTA_UNIT_ORDER_CAST_RUNE":
            case 26:
                message.order_type = 26;
                break;
            case "DOTA_UNIT_ORDER_PING_ABILITY":
            case 27:
                message.order_type = 27;
                break;
            case "DOTA_UNIT_ORDER_MOVE_TO_DIRECTION":
            case 28:
                message.order_type = 28;
                break;
            case "DOTA_UNIT_ORDER_PATROL":
            case 29:
                message.order_type = 29;
                break;
            case "DOTA_UNIT_ORDER_VECTOR_TARGET_POSITION":
            case 30:
                message.order_type = 30;
                break;
            case "DOTA_UNIT_ORDER_RADAR":
            case 31:
                message.order_type = 31;
                break;
            case "DOTA_UNIT_ORDER_SET_ITEM_COMBINE_LOCK":
            case 32:
                message.order_type = 32;
                break;
            case "DOTA_UNIT_ORDER_CONTINUE":
            case 33:
                message.order_type = 33;
                break;
            case "DOTA_UNIT_ORDER_VECTOR_TARGET_CANCELED":
            case 34:
                message.order_type = 34;
                break;
            case "DOTA_UNIT_ORDER_CAST_RIVER_PAINT":
            case 35:
                message.order_type = 35;
                break;
            case "DOTA_UNIT_ORDER_PREGAME_ADJUST_ITEM_ASSIGNMENT":
            case 36:
                message.order_type = 36;
                break;
            case "DOTA_UNIT_ORDER_DROP_ITEM_AT_FOUNTAIN":
            case 37:
                message.order_type = 37;
                break;
            case "DOTA_UNIT_ORDER_TAKE_ITEM_FROM_NEUTRAL_ITEM_STASH":
            case 38:
                message.order_type = 38;
                break;
            }
            if (object.units) {
                if (!Array.isArray(object.units))
                    throw TypeError(".CDOTAMsg_UnitOrder.units: array expected");
                message.units = [];
                for (var i = 0; i < object.units.length; ++i)
                    message.units[i] = object.units[i] | 0;
            }
            if (object.target_index != null)
                message.target_index = object.target_index | 0;
            if (object.ability_index != null)
                message.ability_index = object.ability_index | 0;
            if (object.position != null) {
                if (typeof object.position !== "object")
                    throw TypeError(".CDOTAMsg_UnitOrder.position: object expected");
                message.position = $root.CMsgVector.fromObject(object.position);
            }
            if (object.queue != null)
                message.queue = Boolean(object.queue);
            if (object.sequence_number != null)
                message.sequence_number = object.sequence_number | 0;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAMsg_UnitOrder message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAMsg_UnitOrder
         * @static
         * @param {CDOTAMsg_UnitOrder} message CDOTAMsg_UnitOrder
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAMsg_UnitOrder.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.units = [];
            if (options.defaults) {
                object.issuer = -1;
                object.order_type = options.enums === String ? "DOTA_UNIT_ORDER_NONE" : 0;
                object.target_index = 0;
                object.ability_index = 0;
                object.position = null;
                object.queue = false;
                object.sequence_number = 0;
                object.flags = 0;
            }
            if (message.issuer != null && message.hasOwnProperty("issuer"))
                object.issuer = message.issuer;
            if (message.order_type != null && message.hasOwnProperty("order_type"))
                object.order_type = options.enums === String ? $root.dotaunitorder_t[message.order_type] : message.order_type;
            if (message.units && message.units.length) {
                object.units = [];
                for (var j = 0; j < message.units.length; ++j)
                    object.units[j] = message.units[j];
            }
            if (message.target_index != null && message.hasOwnProperty("target_index"))
                object.target_index = message.target_index;
            if (message.ability_index != null && message.hasOwnProperty("ability_index"))
                object.ability_index = message.ability_index;
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = $root.CMsgVector.toObject(message.position, options);
            if (message.queue != null && message.hasOwnProperty("queue"))
                object.queue = message.queue;
            if (message.sequence_number != null && message.hasOwnProperty("sequence_number"))
                object.sequence_number = message.sequence_number;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            return object;
        };
    
        /**
         * Converts this CDOTAMsg_UnitOrder to JSON.
         * @function toJSON
         * @memberof CDOTAMsg_UnitOrder
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAMsg_UnitOrder.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAMsg_UnitOrder;
    })();
    
    $root.VersusScene_PlayActivity = (function() {
    
        /**
         * Properties of a VersusScene_PlayActivity.
         * @exports IVersusScene_PlayActivity
         * @interface IVersusScene_PlayActivity
         * @property {Array.<VersusScene_PlayActivity.IActivityInfo>|null} [activities] VersusScene_PlayActivity activities
         * @property {number|null} [playback_rate] VersusScene_PlayActivity playback_rate
         */
    
        /**
         * Constructs a new VersusScene_PlayActivity.
         * @exports VersusScene_PlayActivity
         * @classdesc Represents a VersusScene_PlayActivity.
         * @implements IVersusScene_PlayActivity
         * @constructor
         * @param {IVersusScene_PlayActivity=} [properties] Properties to set
         */
        function VersusScene_PlayActivity(properties) {
            this.activities = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * VersusScene_PlayActivity activities.
         * @member {Array.<VersusScene_PlayActivity.IActivityInfo>} activities
         * @memberof VersusScene_PlayActivity
         * @instance
         */
        VersusScene_PlayActivity.prototype.activities = $util.emptyArray;
    
        /**
         * VersusScene_PlayActivity playback_rate.
         * @member {number} playback_rate
         * @memberof VersusScene_PlayActivity
         * @instance
         */
        VersusScene_PlayActivity.prototype.playback_rate = 0;
    
        /**
         * Creates a new VersusScene_PlayActivity instance using the specified properties.
         * @function create
         * @memberof VersusScene_PlayActivity
         * @static
         * @param {IVersusScene_PlayActivity=} [properties] Properties to set
         * @returns {VersusScene_PlayActivity} VersusScene_PlayActivity instance
         */
        VersusScene_PlayActivity.create = function create(properties) {
            return new VersusScene_PlayActivity(properties);
        };
    
        /**
         * Encodes the specified VersusScene_PlayActivity message. Does not implicitly {@link VersusScene_PlayActivity.verify|verify} messages.
         * @function encode
         * @memberof VersusScene_PlayActivity
         * @static
         * @param {IVersusScene_PlayActivity} message VersusScene_PlayActivity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersusScene_PlayActivity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.activities != null && message.activities.length)
                for (var i = 0; i < message.activities.length; ++i)
                    $root.VersusScene_PlayActivity.ActivityInfo.encode(message.activities[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.playback_rate != null && Object.hasOwnProperty.call(message, "playback_rate"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.playback_rate);
            return writer;
        };
    
        /**
         * Encodes the specified VersusScene_PlayActivity message, length delimited. Does not implicitly {@link VersusScene_PlayActivity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof VersusScene_PlayActivity
         * @static
         * @param {IVersusScene_PlayActivity} message VersusScene_PlayActivity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersusScene_PlayActivity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a VersusScene_PlayActivity message from the specified reader or buffer.
         * @function decode
         * @memberof VersusScene_PlayActivity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {VersusScene_PlayActivity} VersusScene_PlayActivity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersusScene_PlayActivity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.VersusScene_PlayActivity();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.activities && message.activities.length))
                        message.activities = [];
                    message.activities.push($root.VersusScene_PlayActivity.ActivityInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.playback_rate = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a VersusScene_PlayActivity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof VersusScene_PlayActivity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {VersusScene_PlayActivity} VersusScene_PlayActivity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersusScene_PlayActivity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a VersusScene_PlayActivity message.
         * @function verify
         * @memberof VersusScene_PlayActivity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VersusScene_PlayActivity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.activities != null && message.hasOwnProperty("activities")) {
                if (!Array.isArray(message.activities))
                    return "activities: array expected";
                for (var i = 0; i < message.activities.length; ++i) {
                    var error = $root.VersusScene_PlayActivity.ActivityInfo.verify(message.activities[i]);
                    if (error)
                        return "activities." + error;
                }
            }
            if (message.playback_rate != null && message.hasOwnProperty("playback_rate"))
                if (typeof message.playback_rate !== "number")
                    return "playback_rate: number expected";
            return null;
        };
    
        /**
         * Creates a VersusScene_PlayActivity message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof VersusScene_PlayActivity
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {VersusScene_PlayActivity} VersusScene_PlayActivity
         */
        VersusScene_PlayActivity.fromObject = function fromObject(object) {
            if (object instanceof $root.VersusScene_PlayActivity)
                return object;
            var message = new $root.VersusScene_PlayActivity();
            if (object.activities) {
                if (!Array.isArray(object.activities))
                    throw TypeError(".VersusScene_PlayActivity.activities: array expected");
                message.activities = [];
                for (var i = 0; i < object.activities.length; ++i) {
                    if (typeof object.activities[i] !== "object")
                        throw TypeError(".VersusScene_PlayActivity.activities: object expected");
                    message.activities[i] = $root.VersusScene_PlayActivity.ActivityInfo.fromObject(object.activities[i]);
                }
            }
            if (object.playback_rate != null)
                message.playback_rate = Number(object.playback_rate);
            return message;
        };
    
        /**
         * Creates a plain object from a VersusScene_PlayActivity message. Also converts values to other types if specified.
         * @function toObject
         * @memberof VersusScene_PlayActivity
         * @static
         * @param {VersusScene_PlayActivity} message VersusScene_PlayActivity
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VersusScene_PlayActivity.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.activities = [];
            if (options.defaults)
                object.playback_rate = 0;
            if (message.activities && message.activities.length) {
                object.activities = [];
                for (var j = 0; j < message.activities.length; ++j)
                    object.activities[j] = $root.VersusScene_PlayActivity.ActivityInfo.toObject(message.activities[j], options);
            }
            if (message.playback_rate != null && message.hasOwnProperty("playback_rate"))
                object.playback_rate = options.json && !isFinite(message.playback_rate) ? String(message.playback_rate) : message.playback_rate;
            return object;
        };
    
        /**
         * Converts this VersusScene_PlayActivity to JSON.
         * @function toJSON
         * @memberof VersusScene_PlayActivity
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VersusScene_PlayActivity.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        VersusScene_PlayActivity.ActivityInfo = (function() {
    
            /**
             * Properties of an ActivityInfo.
             * @memberof VersusScene_PlayActivity
             * @interface IActivityInfo
             * @property {string|null} [activity] ActivityInfo activity
             * @property {boolean|null} [disable_auto_kill] ActivityInfo disable_auto_kill
             * @property {boolean|null} [force_looping] ActivityInfo force_looping
             */
    
            /**
             * Constructs a new ActivityInfo.
             * @memberof VersusScene_PlayActivity
             * @classdesc Represents an ActivityInfo.
             * @implements IActivityInfo
             * @constructor
             * @param {VersusScene_PlayActivity.IActivityInfo=} [properties] Properties to set
             */
            function ActivityInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ActivityInfo activity.
             * @member {string} activity
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @instance
             */
            ActivityInfo.prototype.activity = "";
    
            /**
             * ActivityInfo disable_auto_kill.
             * @member {boolean} disable_auto_kill
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @instance
             */
            ActivityInfo.prototype.disable_auto_kill = false;
    
            /**
             * ActivityInfo force_looping.
             * @member {boolean} force_looping
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @instance
             */
            ActivityInfo.prototype.force_looping = false;
    
            /**
             * Creates a new ActivityInfo instance using the specified properties.
             * @function create
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @static
             * @param {VersusScene_PlayActivity.IActivityInfo=} [properties] Properties to set
             * @returns {VersusScene_PlayActivity.ActivityInfo} ActivityInfo instance
             */
            ActivityInfo.create = function create(properties) {
                return new ActivityInfo(properties);
            };
    
            /**
             * Encodes the specified ActivityInfo message. Does not implicitly {@link VersusScene_PlayActivity.ActivityInfo.verify|verify} messages.
             * @function encode
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @static
             * @param {VersusScene_PlayActivity.IActivityInfo} message ActivityInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActivityInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.activity != null && Object.hasOwnProperty.call(message, "activity"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.activity);
                if (message.disable_auto_kill != null && Object.hasOwnProperty.call(message, "disable_auto_kill"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.disable_auto_kill);
                if (message.force_looping != null && Object.hasOwnProperty.call(message, "force_looping"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.force_looping);
                return writer;
            };
    
            /**
             * Encodes the specified ActivityInfo message, length delimited. Does not implicitly {@link VersusScene_PlayActivity.ActivityInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @static
             * @param {VersusScene_PlayActivity.IActivityInfo} message ActivityInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActivityInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an ActivityInfo message from the specified reader or buffer.
             * @function decode
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {VersusScene_PlayActivity.ActivityInfo} ActivityInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActivityInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.VersusScene_PlayActivity.ActivityInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.activity = reader.string();
                        break;
                    case 2:
                        message.disable_auto_kill = reader.bool();
                        break;
                    case 3:
                        message.force_looping = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an ActivityInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {VersusScene_PlayActivity.ActivityInfo} ActivityInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActivityInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an ActivityInfo message.
             * @function verify
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActivityInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.activity != null && message.hasOwnProperty("activity"))
                    if (!$util.isString(message.activity))
                        return "activity: string expected";
                if (message.disable_auto_kill != null && message.hasOwnProperty("disable_auto_kill"))
                    if (typeof message.disable_auto_kill !== "boolean")
                        return "disable_auto_kill: boolean expected";
                if (message.force_looping != null && message.hasOwnProperty("force_looping"))
                    if (typeof message.force_looping !== "boolean")
                        return "force_looping: boolean expected";
                return null;
            };
    
            /**
             * Creates an ActivityInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {VersusScene_PlayActivity.ActivityInfo} ActivityInfo
             */
            ActivityInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.VersusScene_PlayActivity.ActivityInfo)
                    return object;
                var message = new $root.VersusScene_PlayActivity.ActivityInfo();
                if (object.activity != null)
                    message.activity = String(object.activity);
                if (object.disable_auto_kill != null)
                    message.disable_auto_kill = Boolean(object.disable_auto_kill);
                if (object.force_looping != null)
                    message.force_looping = Boolean(object.force_looping);
                return message;
            };
    
            /**
             * Creates a plain object from an ActivityInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @static
             * @param {VersusScene_PlayActivity.ActivityInfo} message ActivityInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ActivityInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.activity = "";
                    object.disable_auto_kill = false;
                    object.force_looping = false;
                }
                if (message.activity != null && message.hasOwnProperty("activity"))
                    object.activity = message.activity;
                if (message.disable_auto_kill != null && message.hasOwnProperty("disable_auto_kill"))
                    object.disable_auto_kill = message.disable_auto_kill;
                if (message.force_looping != null && message.hasOwnProperty("force_looping"))
                    object.force_looping = message.force_looping;
                return object;
            };
    
            /**
             * Converts this ActivityInfo to JSON.
             * @function toJSON
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ActivityInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ActivityInfo;
        })();
    
        return VersusScene_PlayActivity;
    })();
    
    $root.VersusScene_ChatWheel = (function() {
    
        /**
         * Properties of a VersusScene_ChatWheel.
         * @exports IVersusScene_ChatWheel
         * @interface IVersusScene_ChatWheel
         * @property {number|null} [chat_message_id] VersusScene_ChatWheel chat_message_id
         * @property {number|null} [emoticon_id] VersusScene_ChatWheel emoticon_id
         */
    
        /**
         * Constructs a new VersusScene_ChatWheel.
         * @exports VersusScene_ChatWheel
         * @classdesc Represents a VersusScene_ChatWheel.
         * @implements IVersusScene_ChatWheel
         * @constructor
         * @param {IVersusScene_ChatWheel=} [properties] Properties to set
         */
        function VersusScene_ChatWheel(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * VersusScene_ChatWheel chat_message_id.
         * @member {number} chat_message_id
         * @memberof VersusScene_ChatWheel
         * @instance
         */
        VersusScene_ChatWheel.prototype.chat_message_id = 0;
    
        /**
         * VersusScene_ChatWheel emoticon_id.
         * @member {number} emoticon_id
         * @memberof VersusScene_ChatWheel
         * @instance
         */
        VersusScene_ChatWheel.prototype.emoticon_id = 0;
    
        /**
         * Creates a new VersusScene_ChatWheel instance using the specified properties.
         * @function create
         * @memberof VersusScene_ChatWheel
         * @static
         * @param {IVersusScene_ChatWheel=} [properties] Properties to set
         * @returns {VersusScene_ChatWheel} VersusScene_ChatWheel instance
         */
        VersusScene_ChatWheel.create = function create(properties) {
            return new VersusScene_ChatWheel(properties);
        };
    
        /**
         * Encodes the specified VersusScene_ChatWheel message. Does not implicitly {@link VersusScene_ChatWheel.verify|verify} messages.
         * @function encode
         * @memberof VersusScene_ChatWheel
         * @static
         * @param {IVersusScene_ChatWheel} message VersusScene_ChatWheel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersusScene_ChatWheel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chat_message_id != null && Object.hasOwnProperty.call(message, "chat_message_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.chat_message_id);
            if (message.emoticon_id != null && Object.hasOwnProperty.call(message, "emoticon_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.emoticon_id);
            return writer;
        };
    
        /**
         * Encodes the specified VersusScene_ChatWheel message, length delimited. Does not implicitly {@link VersusScene_ChatWheel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof VersusScene_ChatWheel
         * @static
         * @param {IVersusScene_ChatWheel} message VersusScene_ChatWheel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersusScene_ChatWheel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a VersusScene_ChatWheel message from the specified reader or buffer.
         * @function decode
         * @memberof VersusScene_ChatWheel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {VersusScene_ChatWheel} VersusScene_ChatWheel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersusScene_ChatWheel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.VersusScene_ChatWheel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chat_message_id = reader.uint32();
                    break;
                case 2:
                    message.emoticon_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a VersusScene_ChatWheel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof VersusScene_ChatWheel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {VersusScene_ChatWheel} VersusScene_ChatWheel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersusScene_ChatWheel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a VersusScene_ChatWheel message.
         * @function verify
         * @memberof VersusScene_ChatWheel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VersusScene_ChatWheel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chat_message_id != null && message.hasOwnProperty("chat_message_id"))
                if (!$util.isInteger(message.chat_message_id))
                    return "chat_message_id: integer expected";
            if (message.emoticon_id != null && message.hasOwnProperty("emoticon_id"))
                if (!$util.isInteger(message.emoticon_id))
                    return "emoticon_id: integer expected";
            return null;
        };
    
        /**
         * Creates a VersusScene_ChatWheel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof VersusScene_ChatWheel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {VersusScene_ChatWheel} VersusScene_ChatWheel
         */
        VersusScene_ChatWheel.fromObject = function fromObject(object) {
            if (object instanceof $root.VersusScene_ChatWheel)
                return object;
            var message = new $root.VersusScene_ChatWheel();
            if (object.chat_message_id != null)
                message.chat_message_id = object.chat_message_id >>> 0;
            if (object.emoticon_id != null)
                message.emoticon_id = object.emoticon_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a VersusScene_ChatWheel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof VersusScene_ChatWheel
         * @static
         * @param {VersusScene_ChatWheel} message VersusScene_ChatWheel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VersusScene_ChatWheel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.chat_message_id = 0;
                object.emoticon_id = 0;
            }
            if (message.chat_message_id != null && message.hasOwnProperty("chat_message_id"))
                object.chat_message_id = message.chat_message_id;
            if (message.emoticon_id != null && message.hasOwnProperty("emoticon_id"))
                object.emoticon_id = message.emoticon_id;
            return object;
        };
    
        /**
         * Converts this VersusScene_ChatWheel to JSON.
         * @function toJSON
         * @memberof VersusScene_ChatWheel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VersusScene_ChatWheel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return VersusScene_ChatWheel;
    })();
    
    $root.VersusScene_PlaybackRate = (function() {
    
        /**
         * Properties of a VersusScene_PlaybackRate.
         * @exports IVersusScene_PlaybackRate
         * @interface IVersusScene_PlaybackRate
         * @property {number|null} [rate] VersusScene_PlaybackRate rate
         */
    
        /**
         * Constructs a new VersusScene_PlaybackRate.
         * @exports VersusScene_PlaybackRate
         * @classdesc Represents a VersusScene_PlaybackRate.
         * @implements IVersusScene_PlaybackRate
         * @constructor
         * @param {IVersusScene_PlaybackRate=} [properties] Properties to set
         */
        function VersusScene_PlaybackRate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * VersusScene_PlaybackRate rate.
         * @member {number} rate
         * @memberof VersusScene_PlaybackRate
         * @instance
         */
        VersusScene_PlaybackRate.prototype.rate = 0;
    
        /**
         * Creates a new VersusScene_PlaybackRate instance using the specified properties.
         * @function create
         * @memberof VersusScene_PlaybackRate
         * @static
         * @param {IVersusScene_PlaybackRate=} [properties] Properties to set
         * @returns {VersusScene_PlaybackRate} VersusScene_PlaybackRate instance
         */
        VersusScene_PlaybackRate.create = function create(properties) {
            return new VersusScene_PlaybackRate(properties);
        };
    
        /**
         * Encodes the specified VersusScene_PlaybackRate message. Does not implicitly {@link VersusScene_PlaybackRate.verify|verify} messages.
         * @function encode
         * @memberof VersusScene_PlaybackRate
         * @static
         * @param {IVersusScene_PlaybackRate} message VersusScene_PlaybackRate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersusScene_PlaybackRate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rate != null && Object.hasOwnProperty.call(message, "rate"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.rate);
            return writer;
        };
    
        /**
         * Encodes the specified VersusScene_PlaybackRate message, length delimited. Does not implicitly {@link VersusScene_PlaybackRate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof VersusScene_PlaybackRate
         * @static
         * @param {IVersusScene_PlaybackRate} message VersusScene_PlaybackRate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersusScene_PlaybackRate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a VersusScene_PlaybackRate message from the specified reader or buffer.
         * @function decode
         * @memberof VersusScene_PlaybackRate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {VersusScene_PlaybackRate} VersusScene_PlaybackRate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersusScene_PlaybackRate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.VersusScene_PlaybackRate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rate = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a VersusScene_PlaybackRate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof VersusScene_PlaybackRate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {VersusScene_PlaybackRate} VersusScene_PlaybackRate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersusScene_PlaybackRate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a VersusScene_PlaybackRate message.
         * @function verify
         * @memberof VersusScene_PlaybackRate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VersusScene_PlaybackRate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rate != null && message.hasOwnProperty("rate"))
                if (typeof message.rate !== "number")
                    return "rate: number expected";
            return null;
        };
    
        /**
         * Creates a VersusScene_PlaybackRate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof VersusScene_PlaybackRate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {VersusScene_PlaybackRate} VersusScene_PlaybackRate
         */
        VersusScene_PlaybackRate.fromObject = function fromObject(object) {
            if (object instanceof $root.VersusScene_PlaybackRate)
                return object;
            var message = new $root.VersusScene_PlaybackRate();
            if (object.rate != null)
                message.rate = Number(object.rate);
            return message;
        };
    
        /**
         * Creates a plain object from a VersusScene_PlaybackRate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof VersusScene_PlaybackRate
         * @static
         * @param {VersusScene_PlaybackRate} message VersusScene_PlaybackRate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VersusScene_PlaybackRate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.rate = 0;
            if (message.rate != null && message.hasOwnProperty("rate"))
                object.rate = options.json && !isFinite(message.rate) ? String(message.rate) : message.rate;
            return object;
        };
    
        /**
         * Converts this VersusScene_PlaybackRate to JSON.
         * @function toJSON
         * @memberof VersusScene_PlaybackRate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VersusScene_PlaybackRate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return VersusScene_PlaybackRate;
    })();

    return $root;
});
