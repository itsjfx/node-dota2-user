/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { CSOEconItem } from "./base_gcmessages";
import {
  CMatchClip,
  CMsgArcanaVoteMatchVotes,
  CMsgDOTAMatch,
  CMsgDOTASDOHeroStatsHistory,
  CMsgDOTATriviaQuestion,
  CMsgGlobalMapStats,
  CMsgMapStatsSnapshot,
  CMsgPlayerHeroRecentAccomplishments,
  CMsgPlayerRecentAccomplishments,
  CMsgRecentMatchInfo,
  CMsgStickerbook,
  CMsgStickerbookPage,
  CMsgStickerbookSticker,
  CMsgStickerbookTeamPageOrderSequence,
  CMsgStickerHeroes,
  CMsgSuccessfulHero,
  CMsgUnderDraftData,
  CPartySearchClientParty,
  EHeroRelicRarity,
  eHeroRelicRarityFromJSON,
  eHeroRelicRarityToJSON,
  EOverwatchConviction,
  eOverwatchConvictionFromJSON,
  eOverwatchConvictionToJSON,
  EStickerbookPageType,
  eStickerbookPageTypeFromJSON,
  eStickerbookPageTypeToJSON,
} from "./dota_gcmessages_common";
import {
  CSODOTALobby_State,
  cSODOTALobby_StateFromJSON,
  cSODOTALobby_StateToJSON,
} from "./dota_gcmessages_common_lobby";
import {
  CSODOTAParty_State,
  cSODOTAParty_StateFromJSON,
  cSODOTAParty_StateToJSON,
} from "./dota_gcmessages_common_match_management";
import {
  DOTAGameMode,
  dOTAGameModeFromJSON,
  dOTAGameModeToJSON,
  DOTAMatchVote,
  dOTAMatchVoteFromJSON,
  dOTAMatchVoteToJSON,
  DOTASelectionPriorityChoice,
  dOTASelectionPriorityChoiceFromJSON,
  dOTASelectionPriorityChoiceToJSON,
  EDPCFavoriteType,
  eDPCFavoriteTypeFromJSON,
  eDPCFavoriteTypeToJSON,
  EEvent,
  eEventFromJSON,
  eEventToJSON,
  ELeagueRegion,
  eLeagueRegionFromJSON,
  eLeagueRegionToJSON,
  EMatchGroupServerStatus,
  eMatchGroupServerStatusFromJSON,
  eMatchGroupServerStatusToJSON,
  EOverwatchReportReason,
  eOverwatchReportReasonFromJSON,
  eOverwatchReportReasonToJSON,
  EProfileCardSlotType,
  eProfileCardSlotTypeFromJSON,
  eProfileCardSlotTypeToJSON,
  ERankType,
  eRankTypeFromJSON,
  eRankTypeToJSON,
  MatchType,
  matchTypeFromJSON,
  matchTypeToJSON,
} from "./dota_shared_enums";
import { CExtraMsgBlock } from "./gcsdk_gcmessages";

export enum CMsgDOTARequestMatchesSkillLevel {
  CMsgDOTARequestMatches_SkillLevel_Any = 0,
  CMsgDOTARequestMatches_SkillLevel_Normal = 1,
  CMsgDOTARequestMatches_SkillLevel_High = 2,
  CMsgDOTARequestMatches_SkillLevel_VeryHigh = 3,
}

export function cMsgDOTARequestMatchesSkillLevelFromJSON(object: any): CMsgDOTARequestMatchesSkillLevel {
  switch (object) {
    case 0:
    case "CMsgDOTARequestMatches_SkillLevel_Any":
      return CMsgDOTARequestMatchesSkillLevel.CMsgDOTARequestMatches_SkillLevel_Any;
    case 1:
    case "CMsgDOTARequestMatches_SkillLevel_Normal":
      return CMsgDOTARequestMatchesSkillLevel.CMsgDOTARequestMatches_SkillLevel_Normal;
    case 2:
    case "CMsgDOTARequestMatches_SkillLevel_High":
      return CMsgDOTARequestMatchesSkillLevel.CMsgDOTARequestMatches_SkillLevel_High;
    case 3:
    case "CMsgDOTARequestMatches_SkillLevel_VeryHigh":
      return CMsgDOTARequestMatchesSkillLevel.CMsgDOTARequestMatches_SkillLevel_VeryHigh;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTARequestMatchesSkillLevel",
      );
  }
}

export function cMsgDOTARequestMatchesSkillLevelToJSON(object: CMsgDOTARequestMatchesSkillLevel): string {
  switch (object) {
    case CMsgDOTARequestMatchesSkillLevel.CMsgDOTARequestMatches_SkillLevel_Any:
      return "CMsgDOTARequestMatches_SkillLevel_Any";
    case CMsgDOTARequestMatchesSkillLevel.CMsgDOTARequestMatches_SkillLevel_Normal:
      return "CMsgDOTARequestMatches_SkillLevel_Normal";
    case CMsgDOTARequestMatchesSkillLevel.CMsgDOTARequestMatches_SkillLevel_High:
      return "CMsgDOTARequestMatches_SkillLevel_High";
    case CMsgDOTARequestMatchesSkillLevel.CMsgDOTARequestMatches_SkillLevel_VeryHigh:
      return "CMsgDOTARequestMatches_SkillLevel_VeryHigh";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTARequestMatchesSkillLevel",
      );
  }
}

export enum DOTAWatchReplayType {
  DOTA_WATCH_REPLAY_NORMAL = 0,
  DOTA_WATCH_REPLAY_HIGHLIGHTS = 1,
}

export function dOTAWatchReplayTypeFromJSON(object: any): DOTAWatchReplayType {
  switch (object) {
    case 0:
    case "DOTA_WATCH_REPLAY_NORMAL":
      return DOTAWatchReplayType.DOTA_WATCH_REPLAY_NORMAL;
    case 1:
    case "DOTA_WATCH_REPLAY_HIGHLIGHTS":
      return DOTAWatchReplayType.DOTA_WATCH_REPLAY_HIGHLIGHTS;
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum DOTAWatchReplayType");
  }
}

export function dOTAWatchReplayTypeToJSON(object: DOTAWatchReplayType): string {
  switch (object) {
    case DOTAWatchReplayType.DOTA_WATCH_REPLAY_NORMAL:
      return "DOTA_WATCH_REPLAY_NORMAL";
    case DOTAWatchReplayType.DOTA_WATCH_REPLAY_HIGHLIGHTS:
      return "DOTA_WATCH_REPLAY_HIGHLIGHTS";
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum DOTAWatchReplayType");
  }
}

export enum EItemEditorReservationResult {
  k_EItemEditorReservationResult_OK = 1,
  k_EItemEditorReservationResult_AlreadyExists = 2,
  k_EItemEditorReservationResult_Reserved = 3,
  k_EItemEditorReservationResult_TimedOut = 4,
}

export function eItemEditorReservationResultFromJSON(object: any): EItemEditorReservationResult {
  switch (object) {
    case 1:
    case "k_EItemEditorReservationResult_OK":
      return EItemEditorReservationResult.k_EItemEditorReservationResult_OK;
    case 2:
    case "k_EItemEditorReservationResult_AlreadyExists":
      return EItemEditorReservationResult.k_EItemEditorReservationResult_AlreadyExists;
    case 3:
    case "k_EItemEditorReservationResult_Reserved":
      return EItemEditorReservationResult.k_EItemEditorReservationResult_Reserved;
    case 4:
    case "k_EItemEditorReservationResult_TimedOut":
      return EItemEditorReservationResult.k_EItemEditorReservationResult_TimedOut;
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum EItemEditorReservationResult");
  }
}

export function eItemEditorReservationResultToJSON(object: EItemEditorReservationResult): string {
  switch (object) {
    case EItemEditorReservationResult.k_EItemEditorReservationResult_OK:
      return "k_EItemEditorReservationResult_OK";
    case EItemEditorReservationResult.k_EItemEditorReservationResult_AlreadyExists:
      return "k_EItemEditorReservationResult_AlreadyExists";
    case EItemEditorReservationResult.k_EItemEditorReservationResult_Reserved:
      return "k_EItemEditorReservationResult_Reserved";
    case EItemEditorReservationResult.k_EItemEditorReservationResult_TimedOut:
      return "k_EItemEditorReservationResult_TimedOut";
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum EItemEditorReservationResult");
  }
}

export enum EWeekendTourneyRichPresenceEvent {
  k_EWeekendTourneyRichPresenceEvent_None = 0,
  k_EWeekendTourneyRichPresenceEvent_StartedMatch = 1,
  k_EWeekendTourneyRichPresenceEvent_WonMatch = 2,
  k_EWeekendTourneyRichPresenceEvent_Eliminated = 3,
}

export function eWeekendTourneyRichPresenceEventFromJSON(object: any): EWeekendTourneyRichPresenceEvent {
  switch (object) {
    case 0:
    case "k_EWeekendTourneyRichPresenceEvent_None":
      return EWeekendTourneyRichPresenceEvent.k_EWeekendTourneyRichPresenceEvent_None;
    case 1:
    case "k_EWeekendTourneyRichPresenceEvent_StartedMatch":
      return EWeekendTourneyRichPresenceEvent.k_EWeekendTourneyRichPresenceEvent_StartedMatch;
    case 2:
    case "k_EWeekendTourneyRichPresenceEvent_WonMatch":
      return EWeekendTourneyRichPresenceEvent.k_EWeekendTourneyRichPresenceEvent_WonMatch;
    case 3:
    case "k_EWeekendTourneyRichPresenceEvent_Eliminated":
      return EWeekendTourneyRichPresenceEvent.k_EWeekendTourneyRichPresenceEvent_Eliminated;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum EWeekendTourneyRichPresenceEvent",
      );
  }
}

export function eWeekendTourneyRichPresenceEventToJSON(object: EWeekendTourneyRichPresenceEvent): string {
  switch (object) {
    case EWeekendTourneyRichPresenceEvent.k_EWeekendTourneyRichPresenceEvent_None:
      return "k_EWeekendTourneyRichPresenceEvent_None";
    case EWeekendTourneyRichPresenceEvent.k_EWeekendTourneyRichPresenceEvent_StartedMatch:
      return "k_EWeekendTourneyRichPresenceEvent_StartedMatch";
    case EWeekendTourneyRichPresenceEvent.k_EWeekendTourneyRichPresenceEvent_WonMatch:
      return "k_EWeekendTourneyRichPresenceEvent_WonMatch";
    case EWeekendTourneyRichPresenceEvent.k_EWeekendTourneyRichPresenceEvent_Eliminated:
      return "k_EWeekendTourneyRichPresenceEvent_Eliminated";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum EWeekendTourneyRichPresenceEvent",
      );
  }
}

export enum EDOTATriviaAnswerResult {
  k_EDOTATriviaAnswerResult_Success = 0,
  k_EDOTATriviaAnswerResult_InvalidQuestion = 1,
  k_EDOTATriviaAnswerResult_InvalidAnswer = 2,
  k_EDOTATriviaAnswerResult_QuestionLocked = 3,
  k_EDOTATriviaAnswerResult_AlreadyAnswered = 4,
  k_EDOTATriviaAnswerResult_TriviaDisabled = 5,
}

export function eDOTATriviaAnswerResultFromJSON(object: any): EDOTATriviaAnswerResult {
  switch (object) {
    case 0:
    case "k_EDOTATriviaAnswerResult_Success":
      return EDOTATriviaAnswerResult.k_EDOTATriviaAnswerResult_Success;
    case 1:
    case "k_EDOTATriviaAnswerResult_InvalidQuestion":
      return EDOTATriviaAnswerResult.k_EDOTATriviaAnswerResult_InvalidQuestion;
    case 2:
    case "k_EDOTATriviaAnswerResult_InvalidAnswer":
      return EDOTATriviaAnswerResult.k_EDOTATriviaAnswerResult_InvalidAnswer;
    case 3:
    case "k_EDOTATriviaAnswerResult_QuestionLocked":
      return EDOTATriviaAnswerResult.k_EDOTATriviaAnswerResult_QuestionLocked;
    case 4:
    case "k_EDOTATriviaAnswerResult_AlreadyAnswered":
      return EDOTATriviaAnswerResult.k_EDOTATriviaAnswerResult_AlreadyAnswered;
    case 5:
    case "k_EDOTATriviaAnswerResult_TriviaDisabled":
      return EDOTATriviaAnswerResult.k_EDOTATriviaAnswerResult_TriviaDisabled;
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum EDOTATriviaAnswerResult");
  }
}

export function eDOTATriviaAnswerResultToJSON(object: EDOTATriviaAnswerResult): string {
  switch (object) {
    case EDOTATriviaAnswerResult.k_EDOTATriviaAnswerResult_Success:
      return "k_EDOTATriviaAnswerResult_Success";
    case EDOTATriviaAnswerResult.k_EDOTATriviaAnswerResult_InvalidQuestion:
      return "k_EDOTATriviaAnswerResult_InvalidQuestion";
    case EDOTATriviaAnswerResult.k_EDOTATriviaAnswerResult_InvalidAnswer:
      return "k_EDOTATriviaAnswerResult_InvalidAnswer";
    case EDOTATriviaAnswerResult.k_EDOTATriviaAnswerResult_QuestionLocked:
      return "k_EDOTATriviaAnswerResult_QuestionLocked";
    case EDOTATriviaAnswerResult.k_EDOTATriviaAnswerResult_AlreadyAnswered:
      return "k_EDOTATriviaAnswerResult_AlreadyAnswered";
    case EDOTATriviaAnswerResult.k_EDOTATriviaAnswerResult_TriviaDisabled:
      return "k_EDOTATriviaAnswerResult_TriviaDisabled";
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum EDOTATriviaAnswerResult");
  }
}

export enum EPurchaseHeroRelicResult {
  k_EPurchaseHeroRelicResult_Success = 0,
  k_EPurchaseHeroRelicResult_FailedToSend = 1,
  k_EPurchaseHeroRelicResult_NotEnoughPoints = 2,
  k_EPurchaseHeroRelicResult_InternalServerError = 3,
  k_EPurchaseHeroRelicResult_PurchaseNotAllowed = 4,
  k_EPurchaseHeroRelicResult_InvalidRelic = 5,
  k_EPurchaseHeroRelicResult_AlreadyOwned = 6,
  k_EPurchaseHeroRelicResult_InvalidRarity = 7,
}

export function ePurchaseHeroRelicResultFromJSON(object: any): EPurchaseHeroRelicResult {
  switch (object) {
    case 0:
    case "k_EPurchaseHeroRelicResult_Success":
      return EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_Success;
    case 1:
    case "k_EPurchaseHeroRelicResult_FailedToSend":
      return EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_FailedToSend;
    case 2:
    case "k_EPurchaseHeroRelicResult_NotEnoughPoints":
      return EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_NotEnoughPoints;
    case 3:
    case "k_EPurchaseHeroRelicResult_InternalServerError":
      return EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_InternalServerError;
    case 4:
    case "k_EPurchaseHeroRelicResult_PurchaseNotAllowed":
      return EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_PurchaseNotAllowed;
    case 5:
    case "k_EPurchaseHeroRelicResult_InvalidRelic":
      return EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_InvalidRelic;
    case 6:
    case "k_EPurchaseHeroRelicResult_AlreadyOwned":
      return EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_AlreadyOwned;
    case 7:
    case "k_EPurchaseHeroRelicResult_InvalidRarity":
      return EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_InvalidRarity;
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum EPurchaseHeroRelicResult");
  }
}

export function ePurchaseHeroRelicResultToJSON(object: EPurchaseHeroRelicResult): string {
  switch (object) {
    case EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_Success:
      return "k_EPurchaseHeroRelicResult_Success";
    case EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_FailedToSend:
      return "k_EPurchaseHeroRelicResult_FailedToSend";
    case EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_NotEnoughPoints:
      return "k_EPurchaseHeroRelicResult_NotEnoughPoints";
    case EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_InternalServerError:
      return "k_EPurchaseHeroRelicResult_InternalServerError";
    case EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_PurchaseNotAllowed:
      return "k_EPurchaseHeroRelicResult_PurchaseNotAllowed";
    case EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_InvalidRelic:
      return "k_EPurchaseHeroRelicResult_InvalidRelic";
    case EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_AlreadyOwned:
      return "k_EPurchaseHeroRelicResult_AlreadyOwned";
    case EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_InvalidRarity:
      return "k_EPurchaseHeroRelicResult_InvalidRarity";
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum EPurchaseHeroRelicResult");
  }
}

export enum EDevEventRequestResult {
  k_EDevEventRequestResult_Success = 0,
  k_EDevEventRequestResult_NotAllowed = 1,
  k_EDevEventRequestResult_InvalidEvent = 2,
  k_EDevEventRequestResult_SqlFailure = 3,
  k_EDevEventRequestResult_Timeout = 4,
  k_EDevEventRequestResult_LockFailure = 5,
  k_EDevEventRequestResult_SDOLoadFailure = 6,
}

export function eDevEventRequestResultFromJSON(object: any): EDevEventRequestResult {
  switch (object) {
    case 0:
    case "k_EDevEventRequestResult_Success":
      return EDevEventRequestResult.k_EDevEventRequestResult_Success;
    case 1:
    case "k_EDevEventRequestResult_NotAllowed":
      return EDevEventRequestResult.k_EDevEventRequestResult_NotAllowed;
    case 2:
    case "k_EDevEventRequestResult_InvalidEvent":
      return EDevEventRequestResult.k_EDevEventRequestResult_InvalidEvent;
    case 3:
    case "k_EDevEventRequestResult_SqlFailure":
      return EDevEventRequestResult.k_EDevEventRequestResult_SqlFailure;
    case 4:
    case "k_EDevEventRequestResult_Timeout":
      return EDevEventRequestResult.k_EDevEventRequestResult_Timeout;
    case 5:
    case "k_EDevEventRequestResult_LockFailure":
      return EDevEventRequestResult.k_EDevEventRequestResult_LockFailure;
    case 6:
    case "k_EDevEventRequestResult_SDOLoadFailure":
      return EDevEventRequestResult.k_EDevEventRequestResult_SDOLoadFailure;
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum EDevEventRequestResult");
  }
}

export function eDevEventRequestResultToJSON(object: EDevEventRequestResult): string {
  switch (object) {
    case EDevEventRequestResult.k_EDevEventRequestResult_Success:
      return "k_EDevEventRequestResult_Success";
    case EDevEventRequestResult.k_EDevEventRequestResult_NotAllowed:
      return "k_EDevEventRequestResult_NotAllowed";
    case EDevEventRequestResult.k_EDevEventRequestResult_InvalidEvent:
      return "k_EDevEventRequestResult_InvalidEvent";
    case EDevEventRequestResult.k_EDevEventRequestResult_SqlFailure:
      return "k_EDevEventRequestResult_SqlFailure";
    case EDevEventRequestResult.k_EDevEventRequestResult_Timeout:
      return "k_EDevEventRequestResult_Timeout";
    case EDevEventRequestResult.k_EDevEventRequestResult_LockFailure:
      return "k_EDevEventRequestResult_LockFailure";
    case EDevEventRequestResult.k_EDevEventRequestResult_SDOLoadFailure:
      return "k_EDevEventRequestResult_SDOLoadFailure";
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum EDevEventRequestResult");
  }
}

export enum ESupportEventRequestResult {
  k_ESupportEventRequestResult_Success = 0,
  k_ESupportEventRequestResult_Timeout = 1,
  k_ESupportEventRequestResult_CantLockSOCache = 2,
  k_ESupportEventRequestResult_ItemNotInInventory = 3,
  k_ESupportEventRequestResult_InvalidItemDef = 4,
  k_ESupportEventRequestResult_InvalidEvent = 5,
  k_ESupportEventRequestResult_EventExpired = 6,
  k_ESupportEventRequestResult_InvalidSupportAccount = 7,
  k_ESupportEventRequestResult_InvalidSupportMessage = 8,
  k_ESupportEventRequestResult_InvalidEventPoints = 9,
  k_ESupportEventRequestResult_InvalidPremiumPoints = 10,
  k_ESupportEventRequestResult_InvalidActionID = 11,
  k_ESupportEventRequestResult_InvalidActionScore = 12,
  k_ESupportEventRequestResult_TransactionFailed = 13,
}

export function eSupportEventRequestResultFromJSON(object: any): ESupportEventRequestResult {
  switch (object) {
    case 0:
    case "k_ESupportEventRequestResult_Success":
      return ESupportEventRequestResult.k_ESupportEventRequestResult_Success;
    case 1:
    case "k_ESupportEventRequestResult_Timeout":
      return ESupportEventRequestResult.k_ESupportEventRequestResult_Timeout;
    case 2:
    case "k_ESupportEventRequestResult_CantLockSOCache":
      return ESupportEventRequestResult.k_ESupportEventRequestResult_CantLockSOCache;
    case 3:
    case "k_ESupportEventRequestResult_ItemNotInInventory":
      return ESupportEventRequestResult.k_ESupportEventRequestResult_ItemNotInInventory;
    case 4:
    case "k_ESupportEventRequestResult_InvalidItemDef":
      return ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidItemDef;
    case 5:
    case "k_ESupportEventRequestResult_InvalidEvent":
      return ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidEvent;
    case 6:
    case "k_ESupportEventRequestResult_EventExpired":
      return ESupportEventRequestResult.k_ESupportEventRequestResult_EventExpired;
    case 7:
    case "k_ESupportEventRequestResult_InvalidSupportAccount":
      return ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidSupportAccount;
    case 8:
    case "k_ESupportEventRequestResult_InvalidSupportMessage":
      return ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidSupportMessage;
    case 9:
    case "k_ESupportEventRequestResult_InvalidEventPoints":
      return ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidEventPoints;
    case 10:
    case "k_ESupportEventRequestResult_InvalidPremiumPoints":
      return ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidPremiumPoints;
    case 11:
    case "k_ESupportEventRequestResult_InvalidActionID":
      return ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidActionID;
    case 12:
    case "k_ESupportEventRequestResult_InvalidActionScore":
      return ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidActionScore;
    case 13:
    case "k_ESupportEventRequestResult_TransactionFailed":
      return ESupportEventRequestResult.k_ESupportEventRequestResult_TransactionFailed;
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum ESupportEventRequestResult");
  }
}

export function eSupportEventRequestResultToJSON(object: ESupportEventRequestResult): string {
  switch (object) {
    case ESupportEventRequestResult.k_ESupportEventRequestResult_Success:
      return "k_ESupportEventRequestResult_Success";
    case ESupportEventRequestResult.k_ESupportEventRequestResult_Timeout:
      return "k_ESupportEventRequestResult_Timeout";
    case ESupportEventRequestResult.k_ESupportEventRequestResult_CantLockSOCache:
      return "k_ESupportEventRequestResult_CantLockSOCache";
    case ESupportEventRequestResult.k_ESupportEventRequestResult_ItemNotInInventory:
      return "k_ESupportEventRequestResult_ItemNotInInventory";
    case ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidItemDef:
      return "k_ESupportEventRequestResult_InvalidItemDef";
    case ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidEvent:
      return "k_ESupportEventRequestResult_InvalidEvent";
    case ESupportEventRequestResult.k_ESupportEventRequestResult_EventExpired:
      return "k_ESupportEventRequestResult_EventExpired";
    case ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidSupportAccount:
      return "k_ESupportEventRequestResult_InvalidSupportAccount";
    case ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidSupportMessage:
      return "k_ESupportEventRequestResult_InvalidSupportMessage";
    case ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidEventPoints:
      return "k_ESupportEventRequestResult_InvalidEventPoints";
    case ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidPremiumPoints:
      return "k_ESupportEventRequestResult_InvalidPremiumPoints";
    case ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidActionID:
      return "k_ESupportEventRequestResult_InvalidActionID";
    case ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidActionScore:
      return "k_ESupportEventRequestResult_InvalidActionScore";
    case ESupportEventRequestResult.k_ESupportEventRequestResult_TransactionFailed:
      return "k_ESupportEventRequestResult_TransactionFailed";
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum ESupportEventRequestResult");
  }
}

export enum EUnderDraftResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eNoGold = 2,
  k_eInvalidSlot = 3,
  k_eNoBenchSpace = 4,
  k_eNoTickets = 5,
  k_eEventNotOwned = 6,
  k_eInvalidReward = 7,
  k_eHasBigReward = 8,
  k_eNoGCConnection = 9,
  k_eTooBusy = 10,
  k_eCantRollBack = 11,
}

export function eUnderDraftResponseFromJSON(object: any): EUnderDraftResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return EUnderDraftResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return EUnderDraftResponse.k_eSuccess;
    case 2:
    case "k_eNoGold":
      return EUnderDraftResponse.k_eNoGold;
    case 3:
    case "k_eInvalidSlot":
      return EUnderDraftResponse.k_eInvalidSlot;
    case 4:
    case "k_eNoBenchSpace":
      return EUnderDraftResponse.k_eNoBenchSpace;
    case 5:
    case "k_eNoTickets":
      return EUnderDraftResponse.k_eNoTickets;
    case 6:
    case "k_eEventNotOwned":
      return EUnderDraftResponse.k_eEventNotOwned;
    case 7:
    case "k_eInvalidReward":
      return EUnderDraftResponse.k_eInvalidReward;
    case 8:
    case "k_eHasBigReward":
      return EUnderDraftResponse.k_eHasBigReward;
    case 9:
    case "k_eNoGCConnection":
      return EUnderDraftResponse.k_eNoGCConnection;
    case 10:
    case "k_eTooBusy":
      return EUnderDraftResponse.k_eTooBusy;
    case 11:
    case "k_eCantRollBack":
      return EUnderDraftResponse.k_eCantRollBack;
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum EUnderDraftResponse");
  }
}

export function eUnderDraftResponseToJSON(object: EUnderDraftResponse): string {
  switch (object) {
    case EUnderDraftResponse.k_eInternalError:
      return "k_eInternalError";
    case EUnderDraftResponse.k_eSuccess:
      return "k_eSuccess";
    case EUnderDraftResponse.k_eNoGold:
      return "k_eNoGold";
    case EUnderDraftResponse.k_eInvalidSlot:
      return "k_eInvalidSlot";
    case EUnderDraftResponse.k_eNoBenchSpace:
      return "k_eNoBenchSpace";
    case EUnderDraftResponse.k_eNoTickets:
      return "k_eNoTickets";
    case EUnderDraftResponse.k_eEventNotOwned:
      return "k_eEventNotOwned";
    case EUnderDraftResponse.k_eInvalidReward:
      return "k_eInvalidReward";
    case EUnderDraftResponse.k_eHasBigReward:
      return "k_eHasBigReward";
    case EUnderDraftResponse.k_eNoGCConnection:
      return "k_eNoGCConnection";
    case EUnderDraftResponse.k_eTooBusy:
      return "k_eTooBusy";
    case EUnderDraftResponse.k_eCantRollBack:
      return "k_eCantRollBack";
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum EUnderDraftResponse");
  }
}

export enum EDOTADraftTriviaAnswerResult {
  k_EDOTADraftTriviaAnswerResult_Success = 0,
  k_EDOTADraftTriviaAnswerResult_InvalidMatchID = 1,
  k_EDOTADraftTriviaAnswerResult_AlreadyAnswered = 2,
  k_EDOTADraftTriviaAnswerResult_InternalError = 3,
  k_EDOTADraftTriviaAnswerResult_TriviaDisabled = 4,
  k_EDOTADraftTriviaAnswerResult_GCDown = 5,
}

export function eDOTADraftTriviaAnswerResultFromJSON(object: any): EDOTADraftTriviaAnswerResult {
  switch (object) {
    case 0:
    case "k_EDOTADraftTriviaAnswerResult_Success":
      return EDOTADraftTriviaAnswerResult.k_EDOTADraftTriviaAnswerResult_Success;
    case 1:
    case "k_EDOTADraftTriviaAnswerResult_InvalidMatchID":
      return EDOTADraftTriviaAnswerResult.k_EDOTADraftTriviaAnswerResult_InvalidMatchID;
    case 2:
    case "k_EDOTADraftTriviaAnswerResult_AlreadyAnswered":
      return EDOTADraftTriviaAnswerResult.k_EDOTADraftTriviaAnswerResult_AlreadyAnswered;
    case 3:
    case "k_EDOTADraftTriviaAnswerResult_InternalError":
      return EDOTADraftTriviaAnswerResult.k_EDOTADraftTriviaAnswerResult_InternalError;
    case 4:
    case "k_EDOTADraftTriviaAnswerResult_TriviaDisabled":
      return EDOTADraftTriviaAnswerResult.k_EDOTADraftTriviaAnswerResult_TriviaDisabled;
    case 5:
    case "k_EDOTADraftTriviaAnswerResult_GCDown":
      return EDOTADraftTriviaAnswerResult.k_EDOTADraftTriviaAnswerResult_GCDown;
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum EDOTADraftTriviaAnswerResult");
  }
}

export function eDOTADraftTriviaAnswerResultToJSON(object: EDOTADraftTriviaAnswerResult): string {
  switch (object) {
    case EDOTADraftTriviaAnswerResult.k_EDOTADraftTriviaAnswerResult_Success:
      return "k_EDOTADraftTriviaAnswerResult_Success";
    case EDOTADraftTriviaAnswerResult.k_EDOTADraftTriviaAnswerResult_InvalidMatchID:
      return "k_EDOTADraftTriviaAnswerResult_InvalidMatchID";
    case EDOTADraftTriviaAnswerResult.k_EDOTADraftTriviaAnswerResult_AlreadyAnswered:
      return "k_EDOTADraftTriviaAnswerResult_AlreadyAnswered";
    case EDOTADraftTriviaAnswerResult.k_EDOTADraftTriviaAnswerResult_InternalError:
      return "k_EDOTADraftTriviaAnswerResult_InternalError";
    case EDOTADraftTriviaAnswerResult.k_EDOTADraftTriviaAnswerResult_TriviaDisabled:
      return "k_EDOTADraftTriviaAnswerResult_TriviaDisabled";
    case EDOTADraftTriviaAnswerResult.k_EDOTADraftTriviaAnswerResult_GCDown:
      return "k_EDOTADraftTriviaAnswerResult_GCDown";
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum EDOTADraftTriviaAnswerResult");
  }
}

export interface CMsgClientSuspended {
  timeEnd: number;
}

export interface CMsgBalancedShuffleLobby {
}

export interface CMsgInitialQuestionnaireResponse {
  initialSkill: number;
}

export interface CMsgDOTARequestMatchesResponse {
  matches: CMsgDOTAMatch[];
  series: CMsgDOTARequestMatchesResponse_Series[];
  requestId: number;
  totalResults: number;
  resultsRemaining: number;
}

export interface CMsgDOTARequestMatchesResponse_Series {
  matches: CMsgDOTAMatch[];
  seriesId: number;
  seriesType: number;
}

export interface CMsgDOTAPopup {
  id: CMsgDOTAPopup_PopupID;
  customText: string;
  intData: number;
  popupData: Buffer;
  locTokenHeader: string;
  locTokenMsg: string;
  varNames: string[];
  varValues: string[];
  debugText: string;
}

export enum CMsgDOTAPopup_PopupID {
  NONE = -1,
  KICKED_FROM_LOBBY = 0,
  KICKED_FROM_PARTY = 1,
  KICKED_FROM_TEAM = 2,
  TEAM_WAS_DISBANDED = 3,
  TEAM_MATCHMAKE_ALREADY_MATCH = 4,
  TEAM_MATCHMAKE_ALREADY_FINDING = 5,
  TEAM_MATCHMAKE_FULL = 6,
  TEAM_MATCHMAKE_FAIL_ADD = 7,
  TEAM_MATCHMAKE_FAIL_ADD_CURRENT = 8,
  TEAM_MATCHMAKE_FAILED_TEAM_MEMBER = 9,
  TEAM_MATCHMAKE_ALREADY_GAME = 10,
  TEAM_MATCHMAKE_FAIL_GET_PARTY = 11,
  MATCHMAKING_DISABLED = 12,
  INVITE_DENIED = 13,
  PARTY_FULL = 14,
  MADE_ADMIN = 15,
  NEED_TO_PURCHASE = 16,
  SIGNON_MESSAGE = 17,
  MATCHMAKING_REGION_OFFLINE = 19,
  TOURNAMENT_GAME_NOT_FOUND = 21,
  TOURNAMENT_GAME_HAS_LOBBY_ID = 22,
  TOURNAMENT_GAME_HAS_MATCH_ID = 23,
  TOURNAMENT_GAME_HAS_NO_RADIANT_TEAM = 24,
  TOURNAMENT_GAME_HAS_NO_DIRE_TEAM = 25,
  TOURNAMENT_GAME_SQL_UPDATE_FAILED = 26,
  NOT_LEAGUE_ADMIN = 27,
  IN_ANOTHER_GAME = 29,
  PARTY_MEMBER_IN_ANOTHER_GAME = 30,
  PARTY_MEMBER_IN_LOW_PRIORITY = 31,
  CLIENT_OUT_OF_DATE = 32,
  SAVE_GAME_CORRUPT = 38,
  INSUFFICIENT_INGOTS = 39,
  COMPETITIVE_MM_NOT_ENOUGH_PLAY_TIME_PLAY_MORE_CASUAL = 42,
  PARTY_LEADER_JOINED_LOBBY = 44,
  WEEKEND_TOURNEY_UNMATCHED = 48,
  POST_MATCH_SURVEY = 49,
  TROPHY_AWARDED = 50,
  TROPHY_LEVEL_UP = 51,
  ALL_HERO_CHALLENGE_PROGRESS = 52,
  NEED_INITIAL_SKILL = 53,
  NEED_INITIAL_SKILL_IN_PARTY = 54,
  TARGET_ENGINE_MISMATCH = 55,
  VAC_NOT_VERIFIED = 56,
  KICKED_FROM_QUEUE_EVENT_STARTING = 57,
  KICKED_FROM_QUEUE_EVENT_ENDING = 58,
  LOBBY_FULL = 62,
  EVENT_POINTS_EARNED = 63,
  CUSTOM_GAME_INCORRECT_VERSION = 64,
  LIMITED_USER_CHAT = 66,
  EVENT_PREMIUM_POINTS_EARNED = 67,
  LOBBY_MVP_AWARDED = 68,
  LOW_BADGE_LEVEL_CHAT = 71,
  LOW_WINS_CHAT = 72,
  UNVERIFIED_USER_CHAT = 73,
  PARTY_STARTED_FINDING_EVENT_MATCH = 74,
  GENERIC_INFO = 69,
  GENERIC_ERROR = 70,
  RANK_TIER_UPDATED = 75,
  CUSTOM_GAME_COOLDOWN_RESTRICTED = 76,
  CREATE_LOBBY_FAILED_TOO_MUCH_PLAYTIME = 77,
  CUSTOM_GAME_TOO_FEW_GAMES = 78,
}

export function cMsgDOTAPopup_PopupIDFromJSON(object: any): CMsgDOTAPopup_PopupID {
  switch (object) {
    case -1:
    case "NONE":
      return CMsgDOTAPopup_PopupID.NONE;
    case 0:
    case "KICKED_FROM_LOBBY":
      return CMsgDOTAPopup_PopupID.KICKED_FROM_LOBBY;
    case 1:
    case "KICKED_FROM_PARTY":
      return CMsgDOTAPopup_PopupID.KICKED_FROM_PARTY;
    case 2:
    case "KICKED_FROM_TEAM":
      return CMsgDOTAPopup_PopupID.KICKED_FROM_TEAM;
    case 3:
    case "TEAM_WAS_DISBANDED":
      return CMsgDOTAPopup_PopupID.TEAM_WAS_DISBANDED;
    case 4:
    case "TEAM_MATCHMAKE_ALREADY_MATCH":
      return CMsgDOTAPopup_PopupID.TEAM_MATCHMAKE_ALREADY_MATCH;
    case 5:
    case "TEAM_MATCHMAKE_ALREADY_FINDING":
      return CMsgDOTAPopup_PopupID.TEAM_MATCHMAKE_ALREADY_FINDING;
    case 6:
    case "TEAM_MATCHMAKE_FULL":
      return CMsgDOTAPopup_PopupID.TEAM_MATCHMAKE_FULL;
    case 7:
    case "TEAM_MATCHMAKE_FAIL_ADD":
      return CMsgDOTAPopup_PopupID.TEAM_MATCHMAKE_FAIL_ADD;
    case 8:
    case "TEAM_MATCHMAKE_FAIL_ADD_CURRENT":
      return CMsgDOTAPopup_PopupID.TEAM_MATCHMAKE_FAIL_ADD_CURRENT;
    case 9:
    case "TEAM_MATCHMAKE_FAILED_TEAM_MEMBER":
      return CMsgDOTAPopup_PopupID.TEAM_MATCHMAKE_FAILED_TEAM_MEMBER;
    case 10:
    case "TEAM_MATCHMAKE_ALREADY_GAME":
      return CMsgDOTAPopup_PopupID.TEAM_MATCHMAKE_ALREADY_GAME;
    case 11:
    case "TEAM_MATCHMAKE_FAIL_GET_PARTY":
      return CMsgDOTAPopup_PopupID.TEAM_MATCHMAKE_FAIL_GET_PARTY;
    case 12:
    case "MATCHMAKING_DISABLED":
      return CMsgDOTAPopup_PopupID.MATCHMAKING_DISABLED;
    case 13:
    case "INVITE_DENIED":
      return CMsgDOTAPopup_PopupID.INVITE_DENIED;
    case 14:
    case "PARTY_FULL":
      return CMsgDOTAPopup_PopupID.PARTY_FULL;
    case 15:
    case "MADE_ADMIN":
      return CMsgDOTAPopup_PopupID.MADE_ADMIN;
    case 16:
    case "NEED_TO_PURCHASE":
      return CMsgDOTAPopup_PopupID.NEED_TO_PURCHASE;
    case 17:
    case "SIGNON_MESSAGE":
      return CMsgDOTAPopup_PopupID.SIGNON_MESSAGE;
    case 19:
    case "MATCHMAKING_REGION_OFFLINE":
      return CMsgDOTAPopup_PopupID.MATCHMAKING_REGION_OFFLINE;
    case 21:
    case "TOURNAMENT_GAME_NOT_FOUND":
      return CMsgDOTAPopup_PopupID.TOURNAMENT_GAME_NOT_FOUND;
    case 22:
    case "TOURNAMENT_GAME_HAS_LOBBY_ID":
      return CMsgDOTAPopup_PopupID.TOURNAMENT_GAME_HAS_LOBBY_ID;
    case 23:
    case "TOURNAMENT_GAME_HAS_MATCH_ID":
      return CMsgDOTAPopup_PopupID.TOURNAMENT_GAME_HAS_MATCH_ID;
    case 24:
    case "TOURNAMENT_GAME_HAS_NO_RADIANT_TEAM":
      return CMsgDOTAPopup_PopupID.TOURNAMENT_GAME_HAS_NO_RADIANT_TEAM;
    case 25:
    case "TOURNAMENT_GAME_HAS_NO_DIRE_TEAM":
      return CMsgDOTAPopup_PopupID.TOURNAMENT_GAME_HAS_NO_DIRE_TEAM;
    case 26:
    case "TOURNAMENT_GAME_SQL_UPDATE_FAILED":
      return CMsgDOTAPopup_PopupID.TOURNAMENT_GAME_SQL_UPDATE_FAILED;
    case 27:
    case "NOT_LEAGUE_ADMIN":
      return CMsgDOTAPopup_PopupID.NOT_LEAGUE_ADMIN;
    case 29:
    case "IN_ANOTHER_GAME":
      return CMsgDOTAPopup_PopupID.IN_ANOTHER_GAME;
    case 30:
    case "PARTY_MEMBER_IN_ANOTHER_GAME":
      return CMsgDOTAPopup_PopupID.PARTY_MEMBER_IN_ANOTHER_GAME;
    case 31:
    case "PARTY_MEMBER_IN_LOW_PRIORITY":
      return CMsgDOTAPopup_PopupID.PARTY_MEMBER_IN_LOW_PRIORITY;
    case 32:
    case "CLIENT_OUT_OF_DATE":
      return CMsgDOTAPopup_PopupID.CLIENT_OUT_OF_DATE;
    case 38:
    case "SAVE_GAME_CORRUPT":
      return CMsgDOTAPopup_PopupID.SAVE_GAME_CORRUPT;
    case 39:
    case "INSUFFICIENT_INGOTS":
      return CMsgDOTAPopup_PopupID.INSUFFICIENT_INGOTS;
    case 42:
    case "COMPETITIVE_MM_NOT_ENOUGH_PLAY_TIME_PLAY_MORE_CASUAL":
      return CMsgDOTAPopup_PopupID.COMPETITIVE_MM_NOT_ENOUGH_PLAY_TIME_PLAY_MORE_CASUAL;
    case 44:
    case "PARTY_LEADER_JOINED_LOBBY":
      return CMsgDOTAPopup_PopupID.PARTY_LEADER_JOINED_LOBBY;
    case 48:
    case "WEEKEND_TOURNEY_UNMATCHED":
      return CMsgDOTAPopup_PopupID.WEEKEND_TOURNEY_UNMATCHED;
    case 49:
    case "POST_MATCH_SURVEY":
      return CMsgDOTAPopup_PopupID.POST_MATCH_SURVEY;
    case 50:
    case "TROPHY_AWARDED":
      return CMsgDOTAPopup_PopupID.TROPHY_AWARDED;
    case 51:
    case "TROPHY_LEVEL_UP":
      return CMsgDOTAPopup_PopupID.TROPHY_LEVEL_UP;
    case 52:
    case "ALL_HERO_CHALLENGE_PROGRESS":
      return CMsgDOTAPopup_PopupID.ALL_HERO_CHALLENGE_PROGRESS;
    case 53:
    case "NEED_INITIAL_SKILL":
      return CMsgDOTAPopup_PopupID.NEED_INITIAL_SKILL;
    case 54:
    case "NEED_INITIAL_SKILL_IN_PARTY":
      return CMsgDOTAPopup_PopupID.NEED_INITIAL_SKILL_IN_PARTY;
    case 55:
    case "TARGET_ENGINE_MISMATCH":
      return CMsgDOTAPopup_PopupID.TARGET_ENGINE_MISMATCH;
    case 56:
    case "VAC_NOT_VERIFIED":
      return CMsgDOTAPopup_PopupID.VAC_NOT_VERIFIED;
    case 57:
    case "KICKED_FROM_QUEUE_EVENT_STARTING":
      return CMsgDOTAPopup_PopupID.KICKED_FROM_QUEUE_EVENT_STARTING;
    case 58:
    case "KICKED_FROM_QUEUE_EVENT_ENDING":
      return CMsgDOTAPopup_PopupID.KICKED_FROM_QUEUE_EVENT_ENDING;
    case 62:
    case "LOBBY_FULL":
      return CMsgDOTAPopup_PopupID.LOBBY_FULL;
    case 63:
    case "EVENT_POINTS_EARNED":
      return CMsgDOTAPopup_PopupID.EVENT_POINTS_EARNED;
    case 64:
    case "CUSTOM_GAME_INCORRECT_VERSION":
      return CMsgDOTAPopup_PopupID.CUSTOM_GAME_INCORRECT_VERSION;
    case 66:
    case "LIMITED_USER_CHAT":
      return CMsgDOTAPopup_PopupID.LIMITED_USER_CHAT;
    case 67:
    case "EVENT_PREMIUM_POINTS_EARNED":
      return CMsgDOTAPopup_PopupID.EVENT_PREMIUM_POINTS_EARNED;
    case 68:
    case "LOBBY_MVP_AWARDED":
      return CMsgDOTAPopup_PopupID.LOBBY_MVP_AWARDED;
    case 71:
    case "LOW_BADGE_LEVEL_CHAT":
      return CMsgDOTAPopup_PopupID.LOW_BADGE_LEVEL_CHAT;
    case 72:
    case "LOW_WINS_CHAT":
      return CMsgDOTAPopup_PopupID.LOW_WINS_CHAT;
    case 73:
    case "UNVERIFIED_USER_CHAT":
      return CMsgDOTAPopup_PopupID.UNVERIFIED_USER_CHAT;
    case 74:
    case "PARTY_STARTED_FINDING_EVENT_MATCH":
      return CMsgDOTAPopup_PopupID.PARTY_STARTED_FINDING_EVENT_MATCH;
    case 69:
    case "GENERIC_INFO":
      return CMsgDOTAPopup_PopupID.GENERIC_INFO;
    case 70:
    case "GENERIC_ERROR":
      return CMsgDOTAPopup_PopupID.GENERIC_ERROR;
    case 75:
    case "RANK_TIER_UPDATED":
      return CMsgDOTAPopup_PopupID.RANK_TIER_UPDATED;
    case 76:
    case "CUSTOM_GAME_COOLDOWN_RESTRICTED":
      return CMsgDOTAPopup_PopupID.CUSTOM_GAME_COOLDOWN_RESTRICTED;
    case 77:
    case "CREATE_LOBBY_FAILED_TOO_MUCH_PLAYTIME":
      return CMsgDOTAPopup_PopupID.CREATE_LOBBY_FAILED_TOO_MUCH_PLAYTIME;
    case 78:
    case "CUSTOM_GAME_TOO_FEW_GAMES":
      return CMsgDOTAPopup_PopupID.CUSTOM_GAME_TOO_FEW_GAMES;
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum CMsgDOTAPopup_PopupID");
  }
}

export function cMsgDOTAPopup_PopupIDToJSON(object: CMsgDOTAPopup_PopupID): string {
  switch (object) {
    case CMsgDOTAPopup_PopupID.NONE:
      return "NONE";
    case CMsgDOTAPopup_PopupID.KICKED_FROM_LOBBY:
      return "KICKED_FROM_LOBBY";
    case CMsgDOTAPopup_PopupID.KICKED_FROM_PARTY:
      return "KICKED_FROM_PARTY";
    case CMsgDOTAPopup_PopupID.KICKED_FROM_TEAM:
      return "KICKED_FROM_TEAM";
    case CMsgDOTAPopup_PopupID.TEAM_WAS_DISBANDED:
      return "TEAM_WAS_DISBANDED";
    case CMsgDOTAPopup_PopupID.TEAM_MATCHMAKE_ALREADY_MATCH:
      return "TEAM_MATCHMAKE_ALREADY_MATCH";
    case CMsgDOTAPopup_PopupID.TEAM_MATCHMAKE_ALREADY_FINDING:
      return "TEAM_MATCHMAKE_ALREADY_FINDING";
    case CMsgDOTAPopup_PopupID.TEAM_MATCHMAKE_FULL:
      return "TEAM_MATCHMAKE_FULL";
    case CMsgDOTAPopup_PopupID.TEAM_MATCHMAKE_FAIL_ADD:
      return "TEAM_MATCHMAKE_FAIL_ADD";
    case CMsgDOTAPopup_PopupID.TEAM_MATCHMAKE_FAIL_ADD_CURRENT:
      return "TEAM_MATCHMAKE_FAIL_ADD_CURRENT";
    case CMsgDOTAPopup_PopupID.TEAM_MATCHMAKE_FAILED_TEAM_MEMBER:
      return "TEAM_MATCHMAKE_FAILED_TEAM_MEMBER";
    case CMsgDOTAPopup_PopupID.TEAM_MATCHMAKE_ALREADY_GAME:
      return "TEAM_MATCHMAKE_ALREADY_GAME";
    case CMsgDOTAPopup_PopupID.TEAM_MATCHMAKE_FAIL_GET_PARTY:
      return "TEAM_MATCHMAKE_FAIL_GET_PARTY";
    case CMsgDOTAPopup_PopupID.MATCHMAKING_DISABLED:
      return "MATCHMAKING_DISABLED";
    case CMsgDOTAPopup_PopupID.INVITE_DENIED:
      return "INVITE_DENIED";
    case CMsgDOTAPopup_PopupID.PARTY_FULL:
      return "PARTY_FULL";
    case CMsgDOTAPopup_PopupID.MADE_ADMIN:
      return "MADE_ADMIN";
    case CMsgDOTAPopup_PopupID.NEED_TO_PURCHASE:
      return "NEED_TO_PURCHASE";
    case CMsgDOTAPopup_PopupID.SIGNON_MESSAGE:
      return "SIGNON_MESSAGE";
    case CMsgDOTAPopup_PopupID.MATCHMAKING_REGION_OFFLINE:
      return "MATCHMAKING_REGION_OFFLINE";
    case CMsgDOTAPopup_PopupID.TOURNAMENT_GAME_NOT_FOUND:
      return "TOURNAMENT_GAME_NOT_FOUND";
    case CMsgDOTAPopup_PopupID.TOURNAMENT_GAME_HAS_LOBBY_ID:
      return "TOURNAMENT_GAME_HAS_LOBBY_ID";
    case CMsgDOTAPopup_PopupID.TOURNAMENT_GAME_HAS_MATCH_ID:
      return "TOURNAMENT_GAME_HAS_MATCH_ID";
    case CMsgDOTAPopup_PopupID.TOURNAMENT_GAME_HAS_NO_RADIANT_TEAM:
      return "TOURNAMENT_GAME_HAS_NO_RADIANT_TEAM";
    case CMsgDOTAPopup_PopupID.TOURNAMENT_GAME_HAS_NO_DIRE_TEAM:
      return "TOURNAMENT_GAME_HAS_NO_DIRE_TEAM";
    case CMsgDOTAPopup_PopupID.TOURNAMENT_GAME_SQL_UPDATE_FAILED:
      return "TOURNAMENT_GAME_SQL_UPDATE_FAILED";
    case CMsgDOTAPopup_PopupID.NOT_LEAGUE_ADMIN:
      return "NOT_LEAGUE_ADMIN";
    case CMsgDOTAPopup_PopupID.IN_ANOTHER_GAME:
      return "IN_ANOTHER_GAME";
    case CMsgDOTAPopup_PopupID.PARTY_MEMBER_IN_ANOTHER_GAME:
      return "PARTY_MEMBER_IN_ANOTHER_GAME";
    case CMsgDOTAPopup_PopupID.PARTY_MEMBER_IN_LOW_PRIORITY:
      return "PARTY_MEMBER_IN_LOW_PRIORITY";
    case CMsgDOTAPopup_PopupID.CLIENT_OUT_OF_DATE:
      return "CLIENT_OUT_OF_DATE";
    case CMsgDOTAPopup_PopupID.SAVE_GAME_CORRUPT:
      return "SAVE_GAME_CORRUPT";
    case CMsgDOTAPopup_PopupID.INSUFFICIENT_INGOTS:
      return "INSUFFICIENT_INGOTS";
    case CMsgDOTAPopup_PopupID.COMPETITIVE_MM_NOT_ENOUGH_PLAY_TIME_PLAY_MORE_CASUAL:
      return "COMPETITIVE_MM_NOT_ENOUGH_PLAY_TIME_PLAY_MORE_CASUAL";
    case CMsgDOTAPopup_PopupID.PARTY_LEADER_JOINED_LOBBY:
      return "PARTY_LEADER_JOINED_LOBBY";
    case CMsgDOTAPopup_PopupID.WEEKEND_TOURNEY_UNMATCHED:
      return "WEEKEND_TOURNEY_UNMATCHED";
    case CMsgDOTAPopup_PopupID.POST_MATCH_SURVEY:
      return "POST_MATCH_SURVEY";
    case CMsgDOTAPopup_PopupID.TROPHY_AWARDED:
      return "TROPHY_AWARDED";
    case CMsgDOTAPopup_PopupID.TROPHY_LEVEL_UP:
      return "TROPHY_LEVEL_UP";
    case CMsgDOTAPopup_PopupID.ALL_HERO_CHALLENGE_PROGRESS:
      return "ALL_HERO_CHALLENGE_PROGRESS";
    case CMsgDOTAPopup_PopupID.NEED_INITIAL_SKILL:
      return "NEED_INITIAL_SKILL";
    case CMsgDOTAPopup_PopupID.NEED_INITIAL_SKILL_IN_PARTY:
      return "NEED_INITIAL_SKILL_IN_PARTY";
    case CMsgDOTAPopup_PopupID.TARGET_ENGINE_MISMATCH:
      return "TARGET_ENGINE_MISMATCH";
    case CMsgDOTAPopup_PopupID.VAC_NOT_VERIFIED:
      return "VAC_NOT_VERIFIED";
    case CMsgDOTAPopup_PopupID.KICKED_FROM_QUEUE_EVENT_STARTING:
      return "KICKED_FROM_QUEUE_EVENT_STARTING";
    case CMsgDOTAPopup_PopupID.KICKED_FROM_QUEUE_EVENT_ENDING:
      return "KICKED_FROM_QUEUE_EVENT_ENDING";
    case CMsgDOTAPopup_PopupID.LOBBY_FULL:
      return "LOBBY_FULL";
    case CMsgDOTAPopup_PopupID.EVENT_POINTS_EARNED:
      return "EVENT_POINTS_EARNED";
    case CMsgDOTAPopup_PopupID.CUSTOM_GAME_INCORRECT_VERSION:
      return "CUSTOM_GAME_INCORRECT_VERSION";
    case CMsgDOTAPopup_PopupID.LIMITED_USER_CHAT:
      return "LIMITED_USER_CHAT";
    case CMsgDOTAPopup_PopupID.EVENT_PREMIUM_POINTS_EARNED:
      return "EVENT_PREMIUM_POINTS_EARNED";
    case CMsgDOTAPopup_PopupID.LOBBY_MVP_AWARDED:
      return "LOBBY_MVP_AWARDED";
    case CMsgDOTAPopup_PopupID.LOW_BADGE_LEVEL_CHAT:
      return "LOW_BADGE_LEVEL_CHAT";
    case CMsgDOTAPopup_PopupID.LOW_WINS_CHAT:
      return "LOW_WINS_CHAT";
    case CMsgDOTAPopup_PopupID.UNVERIFIED_USER_CHAT:
      return "UNVERIFIED_USER_CHAT";
    case CMsgDOTAPopup_PopupID.PARTY_STARTED_FINDING_EVENT_MATCH:
      return "PARTY_STARTED_FINDING_EVENT_MATCH";
    case CMsgDOTAPopup_PopupID.GENERIC_INFO:
      return "GENERIC_INFO";
    case CMsgDOTAPopup_PopupID.GENERIC_ERROR:
      return "GENERIC_ERROR";
    case CMsgDOTAPopup_PopupID.RANK_TIER_UPDATED:
      return "RANK_TIER_UPDATED";
    case CMsgDOTAPopup_PopupID.CUSTOM_GAME_COOLDOWN_RESTRICTED:
      return "CUSTOM_GAME_COOLDOWN_RESTRICTED";
    case CMsgDOTAPopup_PopupID.CREATE_LOBBY_FAILED_TOO_MUCH_PLAYTIME:
      return "CREATE_LOBBY_FAILED_TOO_MUCH_PLAYTIME";
    case CMsgDOTAPopup_PopupID.CUSTOM_GAME_TOO_FEW_GAMES:
      return "CUSTOM_GAME_TOO_FEW_GAMES";
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum CMsgDOTAPopup_PopupID");
  }
}

export interface CMsgDOTAReportsRemainingRequest {
}

export interface CMsgDOTAReportsRemainingResponse {
  numPositiveReportsRemaining: number;
  numNegativeReportsRemaining: number;
  numPositiveReportsTotal: number;
  numNegativeReportsTotal: number;
  numCommsReportsRemaining: number;
  numCommsReportsTotal: number;
}

export interface CMsgDOTASubmitPlayerReport {
  targetAccountId: number;
  reportFlags: number;
  lobbyId: string;
  comment: string;
}

export interface CMsgDOTASubmitPlayerReportResponse {
  targetAccountId: number;
  reportFlags: number;
  debugMessage: string;
  enumResult: CMsgDOTASubmitPlayerReportResponse_EResult;
}

export enum CMsgDOTASubmitPlayerReportResponse_EResult {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eDuplicateReport = 2,
  k_eMixedReportFlags = 3,
  k_eTooLate = 4,
  k_eInvalidPregameReport = 5,
  k_eHasntChatted = 6,
  k_eInvalid = 7,
  k_eOwnership = 8,
  k_eMissingRequirements = 9,
  k_eInvalidRoleReport = 10,
  k_eInvalidCoachReport = 11,
  k_eNoRemainingReports = 12,
  k_eInvalidMember = 13,
}

export function cMsgDOTASubmitPlayerReportResponse_EResultFromJSON(
  object: any,
): CMsgDOTASubmitPlayerReportResponse_EResult {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgDOTASubmitPlayerReportResponse_EResult.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgDOTASubmitPlayerReportResponse_EResult.k_eSuccess;
    case 2:
    case "k_eDuplicateReport":
      return CMsgDOTASubmitPlayerReportResponse_EResult.k_eDuplicateReport;
    case 3:
    case "k_eMixedReportFlags":
      return CMsgDOTASubmitPlayerReportResponse_EResult.k_eMixedReportFlags;
    case 4:
    case "k_eTooLate":
      return CMsgDOTASubmitPlayerReportResponse_EResult.k_eTooLate;
    case 5:
    case "k_eInvalidPregameReport":
      return CMsgDOTASubmitPlayerReportResponse_EResult.k_eInvalidPregameReport;
    case 6:
    case "k_eHasntChatted":
      return CMsgDOTASubmitPlayerReportResponse_EResult.k_eHasntChatted;
    case 7:
    case "k_eInvalid":
      return CMsgDOTASubmitPlayerReportResponse_EResult.k_eInvalid;
    case 8:
    case "k_eOwnership":
      return CMsgDOTASubmitPlayerReportResponse_EResult.k_eOwnership;
    case 9:
    case "k_eMissingRequirements":
      return CMsgDOTASubmitPlayerReportResponse_EResult.k_eMissingRequirements;
    case 10:
    case "k_eInvalidRoleReport":
      return CMsgDOTASubmitPlayerReportResponse_EResult.k_eInvalidRoleReport;
    case 11:
    case "k_eInvalidCoachReport":
      return CMsgDOTASubmitPlayerReportResponse_EResult.k_eInvalidCoachReport;
    case 12:
    case "k_eNoRemainingReports":
      return CMsgDOTASubmitPlayerReportResponse_EResult.k_eNoRemainingReports;
    case 13:
    case "k_eInvalidMember":
      return CMsgDOTASubmitPlayerReportResponse_EResult.k_eInvalidMember;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTASubmitPlayerReportResponse_EResult",
      );
  }
}

export function cMsgDOTASubmitPlayerReportResponse_EResultToJSON(
  object: CMsgDOTASubmitPlayerReportResponse_EResult,
): string {
  switch (object) {
    case CMsgDOTASubmitPlayerReportResponse_EResult.k_eInternalError:
      return "k_eInternalError";
    case CMsgDOTASubmitPlayerReportResponse_EResult.k_eSuccess:
      return "k_eSuccess";
    case CMsgDOTASubmitPlayerReportResponse_EResult.k_eDuplicateReport:
      return "k_eDuplicateReport";
    case CMsgDOTASubmitPlayerReportResponse_EResult.k_eMixedReportFlags:
      return "k_eMixedReportFlags";
    case CMsgDOTASubmitPlayerReportResponse_EResult.k_eTooLate:
      return "k_eTooLate";
    case CMsgDOTASubmitPlayerReportResponse_EResult.k_eInvalidPregameReport:
      return "k_eInvalidPregameReport";
    case CMsgDOTASubmitPlayerReportResponse_EResult.k_eHasntChatted:
      return "k_eHasntChatted";
    case CMsgDOTASubmitPlayerReportResponse_EResult.k_eInvalid:
      return "k_eInvalid";
    case CMsgDOTASubmitPlayerReportResponse_EResult.k_eOwnership:
      return "k_eOwnership";
    case CMsgDOTASubmitPlayerReportResponse_EResult.k_eMissingRequirements:
      return "k_eMissingRequirements";
    case CMsgDOTASubmitPlayerReportResponse_EResult.k_eInvalidRoleReport:
      return "k_eInvalidRoleReport";
    case CMsgDOTASubmitPlayerReportResponse_EResult.k_eInvalidCoachReport:
      return "k_eInvalidCoachReport";
    case CMsgDOTASubmitPlayerReportResponse_EResult.k_eNoRemainingReports:
      return "k_eNoRemainingReports";
    case CMsgDOTASubmitPlayerReportResponse_EResult.k_eInvalidMember:
      return "k_eInvalidMember";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTASubmitPlayerReportResponse_EResult",
      );
  }
}

export interface CMsgDOTASubmitPlayerAvoidRequest {
  targetAccountId: number;
  lobbyId: string;
  userNote: string;
}

export interface CMsgDOTASubmitPlayerAvoidRequestResponse {
  targetAccountId: number;
  result: number;
  debugMessage: string;
}

export interface CMsgDOTASubmitLobbyMVPVote {
  targetAccountId: number;
}

export interface CMsgDOTASubmitLobbyMVPVoteResponse {
  targetAccountId: number;
  eresult: number;
}

export interface CMsgDOTALobbyMVPAwarded {
  matchId: string;
  mvpAccountId: number[];
}

export interface CMsgDOTAKickedFromMatchmakingQueue {
  matchType: MatchType;
}

export interface CMsgGCMatchDetailsRequest {
  matchId: string;
}

export interface CMsgGCMatchDetailsResponse {
  result: number;
  match: CMsgDOTAMatch | undefined;
  vote: DOTAMatchVote;
}

export interface CMsgDOTAProfileTickets {
  result: number;
  accountId: number;
  leaguePasses: CMsgDOTAProfileTickets_LeaguePass[];
}

export interface CMsgDOTAProfileTickets_LeaguePass {
  leagueId: number;
  itemDef: number;
}

export interface CMsgClientToGCGetProfileTickets {
  accountId: number;
}

export interface CMsgGCToClientPartySearchInvites {
  invites: CMsgGCToClientPartySearchInvite[];
}

export interface CMsgDOTAWelcome {
  storeItemHash: number;
  timeplayedconsecutively: number;
  allow3rdPartyMatchHistory: boolean;
  lastIpAddress: number;
  profilePrivate: boolean;
  currency: number;
  shouldRequestPlayerOrigin: boolean;
  gcSocacheFileVersion: number;
  isPerfectWorldTestAccount: boolean;
  extraMessages: CMsgDOTAWelcome_CExtraMsg[];
  minimumRecentItemId: string;
  activeEvent: EEvent;
  additionalUserMessage: number;
  customGameWhitelistVersion: number;
  partySearchFriendInvites: CMsgGCToClientPartySearchInvites | undefined;
  remainingPlaytime: number;
  disableGuildPersonaInfo: boolean;
  extraMessageBlocks: CExtraMsgBlock[];
}

export interface CMsgDOTAWelcome_CExtraMsg {
  id: number;
  contents: Buffer;
}

export interface CSODOTAGameHeroFavorites {
  accountId: number;
  heroId: number;
}

export interface CMsgDOTAMatchVotes {
  matchId: string;
  votes: CMsgDOTAMatchVotes_PlayerVote[];
}

export interface CMsgDOTAMatchVotes_PlayerVote {
  accountId: number;
  vote: number;
}

export interface CMsgMatchmakingMatchGroupInfo {
  playersSearching: number;
  autoRegionSelectPingPenalty: number;
  autoRegionSelectPingPenaltyCustom: number;
  status: EMatchGroupServerStatus;
}

export interface CMsgDOTAMatchmakingStatsRequest {
}

export interface CMsgDOTAMatchmakingStatsResponse {
  matchgroupsVersion: number;
  legacySearchingPlayersByGroupSource2: number[];
  matchGroups: CMsgMatchmakingMatchGroupInfo[];
}

export interface CMsgDOTAUpdateMatchmakingStats {
  stats: CMsgDOTAMatchmakingStatsResponse | undefined;
}

export interface CMsgDOTAUpdateMatchManagementStats {
  stats: CMsgDOTAMatchmakingStatsResponse | undefined;
}

export interface CMsgDOTASetMatchHistoryAccess {
  allow3rdPartyMatchHistory: boolean;
}

export interface CMsgDOTASetMatchHistoryAccessResponse {
  eresult: number;
}

export interface CMsgDOTANotifyAccountFlagsChange {
  accountid: number;
  accountFlags: number;
}

export interface CMsgDOTASetProfilePrivacy {
  profilePrivate: boolean;
}

export interface CMsgDOTASetProfilePrivacyResponse {
  eresult: number;
}

export interface CMsgUpgradeLeagueItem {
  matchId: string;
  leagueId: number;
}

export interface CMsgUpgradeLeagueItemResponse {
}

export interface CMsgGCWatchDownloadedReplay {
  matchId: string;
  watchType: DOTAWatchReplayType;
}

export interface CMsgClientsRejoinChatChannels {
}

export interface CMsgGCGetHeroStandings {
}

export interface CMsgGCGetHeroStandingsResponse {
  standings: CMsgGCGetHeroStandingsResponse_Hero[];
}

export interface CMsgGCGetHeroStandingsResponse_Hero {
  heroId: number;
  wins: number;
  losses: number;
  winStreak: number;
  bestWinStreak: number;
  avgKills: number;
  avgDeaths: number;
  avgAssists: number;
  avgGpm: number;
  avgXpm: number;
  bestKills: number;
  bestAssists: number;
  bestGpm: number;
  bestXpm: number;
  performance: number;
  winsWithAlly: number;
  lossesWithAlly: number;
  winsAgainstEnemy: number;
  lossesAgainstEnemy: number;
  networthPeak: number;
  lasthitPeak: number;
  denyPeak: number;
  damagePeak: number;
  longestGamePeak: number;
  healingPeak: number;
  avgLasthits: number;
  avgDenies: number;
}

export interface CMatchPlayerTimedStatAverages {
  kills: number;
  deaths: number;
  assists: number;
  netWorth: number;
  lastHits: number;
  denies: number;
  itemValue: number;
  supportGoldSpent: number;
  campsStacked: number;
  wardsPlaced: number;
  dewards: number;
  tripleKills: number;
  rampages: number;
}

export interface CMatchPlayerTimedStatStdDeviations {
  kills: number;
  deaths: number;
  assists: number;
  netWorth: number;
  lastHits: number;
  denies: number;
  itemValue: number;
  supportGoldSpent: number;
  campsStacked: number;
  wardsPlaced: number;
  dewards: number;
  tripleKills: number;
  rampages: number;
}

export interface CMsgGCGetHeroTimedStatsResponse {
  heroId: number;
  rankChunkedStats: CMsgGCGetHeroTimedStatsResponse_RankChunkedStats[];
}

export interface CMsgGCGetHeroTimedStatsResponse_TimedStatsContainer {
  time: number;
  allStats: CMatchPlayerTimedStatAverages | undefined;
  winningStats: CMatchPlayerTimedStatAverages | undefined;
  losingStats: CMatchPlayerTimedStatAverages | undefined;
  winningStddevs: CMatchPlayerTimedStatStdDeviations | undefined;
  losingStddevs: CMatchPlayerTimedStatStdDeviations | undefined;
}

export interface CMsgGCGetHeroTimedStatsResponse_RankChunkedStats {
  rankChunk: number;
  timedStats: CMsgGCGetHeroTimedStatsResponse_TimedStatsContainer[];
}

export interface CMsgGCItemEditorReservationsRequest {
}

export interface CMsgGCItemEditorReservation {
  defIndex: number;
  name: string;
}

export interface CMsgGCItemEditorReservationsResponse {
  reservations: CMsgGCItemEditorReservation[];
}

export interface CMsgGCItemEditorReserveItemDef {
  defIndex: number;
  username: string;
}

export interface CMsgGCItemEditorReserveItemDefResponse {
  defIndex: number;
  username: string;
  result: number;
}

export interface CMsgGCItemEditorReleaseReservation {
  defIndex: number;
  username: string;
}

export interface CMsgGCItemEditorReleaseReservationResponse {
  defIndex: number;
  released: boolean;
}

export interface CMsgDOTARewardTutorialPrizes {
  locationId: number;
  trackingOnly: boolean;
}

export interface CMsgFlipLobbyTeams {
}

export interface CMsgGCLobbyUpdateBroadcastChannelInfo {
  channelId: number;
  countryCode: string;
  description: string;
  languageCode: string;
}

export interface CMsgDOTAClaimEventActionData {
  grantItemGiftData: CMsgDOTAClaimEventActionData_GrantItemGiftData | undefined;
}

export interface CMsgDOTAClaimEventActionData_GrantItemGiftData {
  giveToAccountId: number;
  giftMessage: string;
}

export interface CMsgDOTAClaimEventAction {
  eventId: number;
  actionId: number;
  quantity: number;
  data: CMsgDOTAClaimEventActionData | undefined;
}

export interface CMsgDOTAClaimEventActionResponse {
  result: CMsgDOTAClaimEventActionResponse_ResultCode;
  rewardResults: CMsgDOTAClaimEventActionResponse_GrantedRewardData[];
}

export enum CMsgDOTAClaimEventActionResponse_ResultCode {
  Success = 0,
  InvalidEvent = 1,
  EventNotActive = 2,
  InvalidAction = 3,
  ServerError = 4,
  InsufficientPoints = 5,
  InsufficentLevel = 6,
  AlreadyClaimed = 7,
  SDOLockFailure = 8,
  SDOLoadFailure = 9,
  EventNotOwned = 10,
  Timeout = 11,
  RequiresPlusSubscription = 12,
  InvalidItem = 13,
  AsyncRewards = 14,
}

export function cMsgDOTAClaimEventActionResponse_ResultCodeFromJSON(
  object: any,
): CMsgDOTAClaimEventActionResponse_ResultCode {
  switch (object) {
    case 0:
    case "Success":
      return CMsgDOTAClaimEventActionResponse_ResultCode.Success;
    case 1:
    case "InvalidEvent":
      return CMsgDOTAClaimEventActionResponse_ResultCode.InvalidEvent;
    case 2:
    case "EventNotActive":
      return CMsgDOTAClaimEventActionResponse_ResultCode.EventNotActive;
    case 3:
    case "InvalidAction":
      return CMsgDOTAClaimEventActionResponse_ResultCode.InvalidAction;
    case 4:
    case "ServerError":
      return CMsgDOTAClaimEventActionResponse_ResultCode.ServerError;
    case 5:
    case "InsufficientPoints":
      return CMsgDOTAClaimEventActionResponse_ResultCode.InsufficientPoints;
    case 6:
    case "InsufficentLevel":
      return CMsgDOTAClaimEventActionResponse_ResultCode.InsufficentLevel;
    case 7:
    case "AlreadyClaimed":
      return CMsgDOTAClaimEventActionResponse_ResultCode.AlreadyClaimed;
    case 8:
    case "SDOLockFailure":
      return CMsgDOTAClaimEventActionResponse_ResultCode.SDOLockFailure;
    case 9:
    case "SDOLoadFailure":
      return CMsgDOTAClaimEventActionResponse_ResultCode.SDOLoadFailure;
    case 10:
    case "EventNotOwned":
      return CMsgDOTAClaimEventActionResponse_ResultCode.EventNotOwned;
    case 11:
    case "Timeout":
      return CMsgDOTAClaimEventActionResponse_ResultCode.Timeout;
    case 12:
    case "RequiresPlusSubscription":
      return CMsgDOTAClaimEventActionResponse_ResultCode.RequiresPlusSubscription;
    case 13:
    case "InvalidItem":
      return CMsgDOTAClaimEventActionResponse_ResultCode.InvalidItem;
    case 14:
    case "AsyncRewards":
      return CMsgDOTAClaimEventActionResponse_ResultCode.AsyncRewards;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTAClaimEventActionResponse_ResultCode",
      );
  }
}

export function cMsgDOTAClaimEventActionResponse_ResultCodeToJSON(
  object: CMsgDOTAClaimEventActionResponse_ResultCode,
): string {
  switch (object) {
    case CMsgDOTAClaimEventActionResponse_ResultCode.Success:
      return "Success";
    case CMsgDOTAClaimEventActionResponse_ResultCode.InvalidEvent:
      return "InvalidEvent";
    case CMsgDOTAClaimEventActionResponse_ResultCode.EventNotActive:
      return "EventNotActive";
    case CMsgDOTAClaimEventActionResponse_ResultCode.InvalidAction:
      return "InvalidAction";
    case CMsgDOTAClaimEventActionResponse_ResultCode.ServerError:
      return "ServerError";
    case CMsgDOTAClaimEventActionResponse_ResultCode.InsufficientPoints:
      return "InsufficientPoints";
    case CMsgDOTAClaimEventActionResponse_ResultCode.InsufficentLevel:
      return "InsufficentLevel";
    case CMsgDOTAClaimEventActionResponse_ResultCode.AlreadyClaimed:
      return "AlreadyClaimed";
    case CMsgDOTAClaimEventActionResponse_ResultCode.SDOLockFailure:
      return "SDOLockFailure";
    case CMsgDOTAClaimEventActionResponse_ResultCode.SDOLoadFailure:
      return "SDOLoadFailure";
    case CMsgDOTAClaimEventActionResponse_ResultCode.EventNotOwned:
      return "EventNotOwned";
    case CMsgDOTAClaimEventActionResponse_ResultCode.Timeout:
      return "Timeout";
    case CMsgDOTAClaimEventActionResponse_ResultCode.RequiresPlusSubscription:
      return "RequiresPlusSubscription";
    case CMsgDOTAClaimEventActionResponse_ResultCode.InvalidItem:
      return "InvalidItem";
    case CMsgDOTAClaimEventActionResponse_ResultCode.AsyncRewards:
      return "AsyncRewards";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTAClaimEventActionResponse_ResultCode",
      );
  }
}

export interface CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {
  itemDef: number;
  itemCategory: number;
}

export interface CMsgDOTAClaimEventActionResponse_LootListRewardData {
  itemDef: number[];
}

export interface CMsgDOTAClaimEventActionResponse_ActionListRewardData {
  actionId: number;
  resultRewardData: Buffer;
}

export interface CMsgDOTAClaimEventActionResponse_GrantedRewardData {
  grantIndex: number;
  scoreIndex: number;
  rewardIndex: number;
  rewardData: Buffer;
}

export interface CMsgClientToGCClaimEventActionUsingItem {
  eventId: number;
  actionId: number;
  itemId: string;
  quantity: number;
}

export interface CMsgClientToGCClaimEventActionUsingItemResponse {
  actionResults: CMsgDOTAClaimEventActionResponse | undefined;
}

export interface CMsgGCToClientClaimEventActionUsingItemCompleted {
  itemId: string;
  actionResults: CMsgDOTAClaimEventActionResponse | undefined;
}

export interface CMsgDOTAGetEventPoints {
  eventId: number;
  accountId: number;
}

export interface CMsgDOTAGetEventPointsResponse {
  totalPoints: number;
  totalPremiumPoints: number;
  eventId: number;
  points: number;
  premiumPoints: number;
  completedActions: CMsgDOTAGetEventPointsResponse_Action[];
  accountId: number;
  owned: boolean;
  auditAction: number;
  activeSeasonId: number;
}

export interface CMsgDOTAGetEventPointsResponse_Action {
  actionId: number;
  timesCompleted: number;
}

export interface CMsgDOTAGetPeriodicResource {
  accountId: number;
  periodicResourceId: number;
  timestamp: number;
}

export interface CMsgDOTAGetPeriodicResourceResponse {
  periodicResourceMax: number;
  periodicResourceUsed: number;
}

export interface CMsgDOTAPeriodicResourceUpdated {
  periodicResourceKey: CMsgDOTAGetPeriodicResource | undefined;
  periodicResourceValue: CMsgDOTAGetPeriodicResourceResponse | undefined;
}

export interface CMsgDOTACompendiumSelection {
  selectionIndex: number;
  selection: number;
  leagueid: number;
}

export interface CMsgDOTACompendiumSelectionResponse {
  eresult: number;
}

export interface CMsgDOTACompendiumData {
  selections: CMsgDOTACompendiumSelection[];
}

export interface CMsgDOTACompendiumDataRequest {
  accountId: number;
  leagueid: number;
}

export interface CMsgDOTACompendiumDataResponse {
  accountId: number;
  leagueid: number;
  result: number;
  compendiumData: CMsgDOTACompendiumData | undefined;
}

export interface CMsgDOTAGetPlayerMatchHistory {
  accountId: number;
  startAtMatchId: string;
  matchesRequested: number;
  heroId: number;
  requestId: number;
  includePracticeMatches: boolean;
  includeCustomGames: boolean;
  includeEventGames: boolean;
}

export interface CMsgDOTAGetPlayerMatchHistoryResponse {
  matches: CMsgDOTAGetPlayerMatchHistoryResponse_Match[];
  requestId: number;
}

export interface CMsgDOTAGetPlayerMatchHistoryResponse_Match {
  matchId: string;
  startTime: number;
  heroId: number;
  winner: boolean;
  gameMode: number;
  rankChange: number;
  previousRank: number;
  lobbyType: number;
  soloRank: boolean;
  abandon: boolean;
  duration: number;
  engine: number;
  activePlusSubscription: boolean;
  seasonalRank: boolean;
  tourneyId: number;
  tourneyRound: number;
  tourneyTier: number;
  tourneyDivision: number;
  teamId: number;
  teamName: string;
  ugcTeamUiLogo: string;
}

export interface CMsgGCNotificationsRequest {
}

export interface CMsgGCNotificationsNotification {
  id: string;
  type: number;
  timestamp: number;
  referenceA: number;
  referenceB: number;
  referenceC: number;
  message: string;
  unread: boolean;
}

export interface CMsgGCNotificationsUpdate {
  result: CMsgGCNotificationsUpdate_EResult;
  notifications: CMsgGCNotificationsNotification[];
}

export enum CMsgGCNotificationsUpdate_EResult {
  SUCCESS = 0,
  ERROR_UNSPECIFIED = 1,
}

export function cMsgGCNotificationsUpdate_EResultFromJSON(object: any): CMsgGCNotificationsUpdate_EResult {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgGCNotificationsUpdate_EResult.SUCCESS;
    case 1:
    case "ERROR_UNSPECIFIED":
      return CMsgGCNotificationsUpdate_EResult.ERROR_UNSPECIFIED;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCNotificationsUpdate_EResult",
      );
  }
}

export function cMsgGCNotificationsUpdate_EResultToJSON(object: CMsgGCNotificationsUpdate_EResult): string {
  switch (object) {
    case CMsgGCNotificationsUpdate_EResult.SUCCESS:
      return "SUCCESS";
    case CMsgGCNotificationsUpdate_EResult.ERROR_UNSPECIFIED:
      return "ERROR_UNSPECIFIED";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCNotificationsUpdate_EResult",
      );
  }
}

export interface CMsgGCNotificationsResponse {
  update: CMsgGCNotificationsUpdate | undefined;
}

export interface CMsgGCNotificationsMarkReadRequest {
}

export interface CMsgGCPlayerInfoSubmit {
  name: string;
  countryCode: string;
  fantasyRole: number;
  teamId: number;
  sponsor: string;
}

export interface CMsgGCPlayerInfoSubmitResponse {
  result: CMsgGCPlayerInfoSubmitResponse_EResult;
}

export enum CMsgGCPlayerInfoSubmitResponse_EResult {
  SUCCESS = 0,
  ERROR_UNSPECIFIED = 1,
  ERROR_INFO_LOCKED = 2,
  ERROR_NOT_MEMBER_OF_TEAM = 3,
}

export function cMsgGCPlayerInfoSubmitResponse_EResultFromJSON(object: any): CMsgGCPlayerInfoSubmitResponse_EResult {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgGCPlayerInfoSubmitResponse_EResult.SUCCESS;
    case 1:
    case "ERROR_UNSPECIFIED":
      return CMsgGCPlayerInfoSubmitResponse_EResult.ERROR_UNSPECIFIED;
    case 2:
    case "ERROR_INFO_LOCKED":
      return CMsgGCPlayerInfoSubmitResponse_EResult.ERROR_INFO_LOCKED;
    case 3:
    case "ERROR_NOT_MEMBER_OF_TEAM":
      return CMsgGCPlayerInfoSubmitResponse_EResult.ERROR_NOT_MEMBER_OF_TEAM;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCPlayerInfoSubmitResponse_EResult",
      );
  }
}

export function cMsgGCPlayerInfoSubmitResponse_EResultToJSON(object: CMsgGCPlayerInfoSubmitResponse_EResult): string {
  switch (object) {
    case CMsgGCPlayerInfoSubmitResponse_EResult.SUCCESS:
      return "SUCCESS";
    case CMsgGCPlayerInfoSubmitResponse_EResult.ERROR_UNSPECIFIED:
      return "ERROR_UNSPECIFIED";
    case CMsgGCPlayerInfoSubmitResponse_EResult.ERROR_INFO_LOCKED:
      return "ERROR_INFO_LOCKED";
    case CMsgGCPlayerInfoSubmitResponse_EResult.ERROR_NOT_MEMBER_OF_TEAM:
      return "ERROR_NOT_MEMBER_OF_TEAM";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCPlayerInfoSubmitResponse_EResult",
      );
  }
}

export interface CMsgDOTAEmoticonAccessSDO {
  accountId: number;
  unlockedEmoticons: Buffer;
}

export interface CMsgClientToGCEmoticonDataRequest {
}

export interface CMsgGCToClientEmoticonData {
  emoticonAccess: CMsgDOTAEmoticonAccessSDO | undefined;
}

export interface CMsgGCToClientTournamentItemDrop {
  itemDef: number;
  eventType: number;
}

export interface CMsgClientToGCGetAllHeroOrder {
}

export interface CMsgClientToGCGetAllHeroOrderResponse {
  heroIds: number[];
}

export interface CMsgClientToGCGetAllHeroProgress {
  accountId: number;
}

export interface CMsgClientToGCGetAllHeroProgressResponse {
  accountId: number;
  currHeroId: number;
  lapsCompleted: number;
  currHeroGames: number;
  currLapTimeStarted: number;
  currLapGames: number;
  bestLapGames: number;
  bestLapTime: number;
  lapHeroesCompleted: number;
  lapHeroesRemaining: number;
  nextHeroId: number;
  prevHeroId: number;
  prevHeroGames: number;
  prevAvgTries: number;
  currAvgTries: number;
  nextAvgTries: number;
  fullLapAvgTries: number;
  currLapAvgTries: number;
  profileName: string;
  startHeroId: number;
}

export interface CMsgClientToGCGetTrophyList {
  accountId: number;
}

export interface CMsgClientToGCGetTrophyListResponse {
  trophies: CMsgClientToGCGetTrophyListResponse_Trophy[];
}

export interface CMsgClientToGCGetTrophyListResponse_Trophy {
  trophyId: number;
  trophyScore: number;
  lastUpdated: number;
}

export interface CMsgGCToClientTrophyAwarded {
  trophyId: number;
  trophyScore: number;
  trophyOldScore: number;
  lastUpdated: number;
}

export interface CMsgClientToGCRankRequest {
  rankType: ERankType;
}

export interface CMsgGCToClientRankResponse {
  result: CMsgGCToClientRankResponse_EResultCode;
  rankValue: number;
  rankData1: number;
  rankData2: number;
  rankData3: number;
}

export enum CMsgGCToClientRankResponse_EResultCode {
  k_Succeeded = 0,
  k_Failed = 1,
  k_InvalidRankType = 2,
}

export function cMsgGCToClientRankResponse_EResultCodeFromJSON(object: any): CMsgGCToClientRankResponse_EResultCode {
  switch (object) {
    case 0:
    case "k_Succeeded":
      return CMsgGCToClientRankResponse_EResultCode.k_Succeeded;
    case 1:
    case "k_Failed":
      return CMsgGCToClientRankResponse_EResultCode.k_Failed;
    case 2:
    case "k_InvalidRankType":
      return CMsgGCToClientRankResponse_EResultCode.k_InvalidRankType;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientRankResponse_EResultCode",
      );
  }
}

export function cMsgGCToClientRankResponse_EResultCodeToJSON(object: CMsgGCToClientRankResponse_EResultCode): string {
  switch (object) {
    case CMsgGCToClientRankResponse_EResultCode.k_Succeeded:
      return "k_Succeeded";
    case CMsgGCToClientRankResponse_EResultCode.k_Failed:
      return "k_Failed";
    case CMsgGCToClientRankResponse_EResultCode.k_InvalidRankType:
      return "k_InvalidRankType";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientRankResponse_EResultCode",
      );
  }
}

export interface CMsgGCToClientRankUpdate {
  rankType: ERankType;
  rankInfo: CMsgGCToClientRankResponse | undefined;
}

export interface CMsgClientToGCGetProfileCard {
  accountId: number;
}

export interface CMsgClientToGCSetProfileCardSlots {
  slots: CMsgClientToGCSetProfileCardSlots_CardSlot[];
}

export interface CMsgClientToGCSetProfileCardSlots_CardSlot {
  slotId: number;
  slotType: EProfileCardSlotType;
  slotValue: string;
}

export interface CMsgClientToGCGetProfileCardStats {
}

export interface CMsgClientToGCCreateHeroStatue {
  sourceItemId: string;
  heroId: number;
  sequenceName: string;
  cycle: number;
  wearables: number[];
  inscription: string;
  styles: number[];
  reforgerItemId: string;
  tournamentDrop: boolean;
}

export interface CMsgGCToClientHeroStatueCreateResult {
  resultingItemId: string;
}

export interface CMsgClientToGCPlayerStatsRequest {
  accountId: number;
}

export interface CMsgGCToClientPlayerStatsResponse {
  accountId: number;
  playerStats: number[];
  matchCount: number;
  meanGpm: number;
  meanXppm: number;
  meanLasthits: number;
  rampages: number;
  tripleKills: number;
  firstBloodClaimed: number;
  firstBloodGiven: number;
  couriersKilled: number;
  aegisesSnatched: number;
  cheesesEaten: number;
  creepsStacked: number;
  fightScore: number;
  farmScore: number;
  supportScore: number;
  pushScore: number;
  versatilityScore: number;
  meanNetworth: number;
  meanDamage: number;
  meanHeals: number;
  rapiersPurchased: number;
}

export interface CMsgClientToGCCustomGamesFriendsPlayedRequest {
}

export interface CMsgGCToClientCustomGamesFriendsPlayedResponse {
  accountId: number;
  games: CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame[];
}

export interface CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame {
  customGameId: string;
  accountIds: number[];
}

export interface CMsgClientToGCSocialFeedPostCommentRequest {
  eventId: string;
  comment: string;
}

export interface CMsgGCToClientSocialFeedPostCommentResponse {
  success: boolean;
}

export interface CMsgClientToGCSocialFeedPostMessageRequest {
  message: string;
  matchId: string;
  matchTimestamp: number;
}

export interface CMsgGCToClientSocialFeedPostMessageResponse {
  success: boolean;
}

export interface CMsgClientToGCFriendsPlayedCustomGameRequest {
  customGameId: string;
}

export interface CMsgGCToClientFriendsPlayedCustomGameResponse {
  customGameId: string;
  accountIds: number[];
}

export interface CMsgDOTAPartyRichPresence {
  partyId: string;
  partyState: CSODOTAParty_State;
  open: boolean;
  lowPriority: boolean;
  teamId: number;
  teamName: string;
  ugcTeamUiLogo: string;
  members: CMsgDOTAPartyRichPresence_Member[];
  weekendTourney: CMsgDOTAPartyRichPresence_WeekendTourney | undefined;
}

export interface CMsgDOTAPartyRichPresence_Member {
  steamId: string;
  coach: boolean;
}

export interface CMsgDOTAPartyRichPresence_WeekendTourney {
  division: number;
  skillLevel: number;
  round: number;
  tournamentId: number;
  stateSeqNum: number;
  event: EWeekendTourneyRichPresenceEvent;
  eventRound: number;
}

export interface CMsgDOTALobbyRichPresence {
  lobbyId: string;
  lobbyState: CSODOTALobby_State;
  password: boolean;
  gameMode: DOTAGameMode;
  memberCount: number;
  maxMemberCount: number;
  customGameId: string;
  name: string;
  lobbyType: number;
}

export interface CMsgDOTACustomGameListenServerStartedLoading {
  lobbyId: string;
  customGameId: string;
  lobbyMembers: number[];
  startTime: number;
}

export interface CMsgDOTACustomGameClientFinishedLoading {
  lobbyId: string;
  loadingDuration: number;
  resultCode: number;
  resultString: string;
  signonStates: number;
  comment: string;
}

export interface CMsgClientToGCApplyGemCombiner {
  itemId1: string;
  itemId2: string;
}

export interface CMsgClientToGCH264Unsupported {
}

export interface CMsgClientToGCGetQuestProgress {
  questIds: number[];
}

export interface CMsgClientToGCGetQuestProgressResponse {
  success: boolean;
  quests: CMsgClientToGCGetQuestProgressResponse_Quest[];
}

export interface CMsgClientToGCGetQuestProgressResponse_Challenge {
  challengeId: number;
  timeCompleted: number;
  attempts: number;
  heroId: number;
  templateId: number;
  questRank: number;
}

export interface CMsgClientToGCGetQuestProgressResponse_Quest {
  questId: number;
  completedChallenges: CMsgClientToGCGetQuestProgressResponse_Challenge[];
}

export interface CMsgGCToClientMatchSignedOut {
  matchId: string;
}

export interface CMsgGCGetHeroStatsHistory {
  heroId: number;
}

export interface CMsgGCGetHeroStatsHistoryResponse {
  heroId: number;
  records: CMsgDOTASDOHeroStatsHistory[];
}

export interface CMsgPlayerConductScorecardRequest {
}

export interface CMsgPlayerConductScorecard {
  accountId: number;
  matchId: string;
  seqNum: number;
  reasons: number;
  matchesInReport: number;
  matchesClean: number;
  matchesReported: number;
  matchesAbandoned: number;
  reportsCount: number;
  reportsParties: number;
  commendCount: number;
  date: number;
  rawBehaviorScore: number;
  oldRawBehaviorScore: number;
  commsReports: number;
  commsParties: number;
  behaviorRating: CMsgPlayerConductScorecard_EBehaviorRating;
}

export enum CMsgPlayerConductScorecard_EBehaviorRating {
  k_eBehaviorGood = 0,
  k_eBehaviorWarning = 1,
  k_eBehaviorBad = 2,
}

export function cMsgPlayerConductScorecard_EBehaviorRatingFromJSON(
  object: any,
): CMsgPlayerConductScorecard_EBehaviorRating {
  switch (object) {
    case 0:
    case "k_eBehaviorGood":
      return CMsgPlayerConductScorecard_EBehaviorRating.k_eBehaviorGood;
    case 1:
    case "k_eBehaviorWarning":
      return CMsgPlayerConductScorecard_EBehaviorRating.k_eBehaviorWarning;
    case 2:
    case "k_eBehaviorBad":
      return CMsgPlayerConductScorecard_EBehaviorRating.k_eBehaviorBad;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgPlayerConductScorecard_EBehaviorRating",
      );
  }
}

export function cMsgPlayerConductScorecard_EBehaviorRatingToJSON(
  object: CMsgPlayerConductScorecard_EBehaviorRating,
): string {
  switch (object) {
    case CMsgPlayerConductScorecard_EBehaviorRating.k_eBehaviorGood:
      return "k_eBehaviorGood";
    case CMsgPlayerConductScorecard_EBehaviorRating.k_eBehaviorWarning:
      return "k_eBehaviorWarning";
    case CMsgPlayerConductScorecard_EBehaviorRating.k_eBehaviorBad:
      return "k_eBehaviorBad";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgPlayerConductScorecard_EBehaviorRating",
      );
  }
}

export interface CMsgClientToGCWageringRequest {
  eventId: number;
}

export interface CMsgGCToClientWageringResponse {
  coinsRemaining: number;
  totalPointsWon: number;
  totalPointsWagered: number;
  totalPointsTipped: number;
  successRate: number;
  totalGamesWagered: number;
  coinsMax: number;
  rankWagersRemaining: number;
  rankWagersMax: number;
  predictionTokensRemaining: number;
  predictionTokensMax: number;
  bountiesRemaining: number;
  bountiesMax: number;
}

export interface CMsgGCToClientWageringUpdate {
  eventId: number;
  wageringInfo: CMsgGCToClientWageringResponse | undefined;
}

export interface CMsgGCToClientArcanaVotesUpdate {
  eventId: number;
  arcanaVotes: CMsgClientToGCRequestArcanaVotesRemainingResponse | undefined;
}

export interface CMsgClientToGCGetEventGoals {
  eventIds: EEvent[];
}

export interface CMsgEventGoals {
  eventGoals: CMsgEventGoals_EventGoal[];
}

export interface CMsgEventGoals_EventGoal {
  eventId: EEvent;
  goalId: number;
  value: string;
}

export interface CMsgGCToGCLeaguePredictions {
  leagueId: number;
}

export interface CMsgPredictionRankings {
  predictions: CMsgPredictionRankings_Prediction[];
}

export interface CMsgPredictionRankings_PredictionLine {
  answerId: number;
  answerName: string;
  answerLogo: string;
  answerValue: number;
}

export interface CMsgPredictionRankings_Prediction {
  selectionId: number;
  predictionLines: CMsgPredictionRankings_PredictionLine[];
}

export interface CMsgPredictionResults {
  results: CMsgPredictionResults_Result[];
}

export interface CMsgPredictionResults_ResultBreakdown {
  answerSelection: number;
  answerValue: number;
}

export interface CMsgPredictionResults_Result {
  selectionId: number;
  resultBreakdown: CMsgPredictionResults_ResultBreakdown[];
}

export interface CMsgClientToGCHasPlayerVotedForMVP {
  matchId: string;
}

export interface CMsgClientToGCHasPlayerVotedForMVPResponse {
  result: boolean;
}

export interface CMsgClientToGCVoteForMVP {
  matchId: string;
  accountId: number;
}

export interface CMsgClientToGCVoteForMVPResponse {
  result: boolean;
}

export interface CMsgClientToGCMVPVoteTimeout {
  matchId: string;
}

export interface CMsgClientToGCMVPVoteTimeoutResponse {
  result: boolean;
}

export interface CMsgClientToGCTeammateStatsRequest {
}

export interface CMsgClientToGCTeammateStatsResponse {
  success: boolean;
  teammateStats: CMsgClientToGCTeammateStatsResponse_TeammateStat[];
}

export interface CMsgClientToGCTeammateStatsResponse_TeammateStat {
  accountId: number;
  games: number;
  wins: number;
  mostRecentGameTimestamp: number;
  mostRecentGameMatchId: string;
  performance: number;
}

export interface CMsgClientToGCVoteForArcana {
  matches: CMsgArcanaVoteMatchVotes[];
}

export interface CMsgClientToGCVoteForArcanaResponse {
  result: CMsgClientToGCVoteForArcanaResponse_Result;
}

export enum CMsgClientToGCVoteForArcanaResponse_Result {
  SUCCEEDED = 0,
  VOTING_NOT_ENABLED_FOR_ROUND = 1,
  UNKNOWN_FAILURE = 2,
}

export function cMsgClientToGCVoteForArcanaResponse_ResultFromJSON(
  object: any,
): CMsgClientToGCVoteForArcanaResponse_Result {
  switch (object) {
    case 0:
    case "SUCCEEDED":
      return CMsgClientToGCVoteForArcanaResponse_Result.SUCCEEDED;
    case 1:
    case "VOTING_NOT_ENABLED_FOR_ROUND":
      return CMsgClientToGCVoteForArcanaResponse_Result.VOTING_NOT_ENABLED_FOR_ROUND;
    case 2:
    case "UNKNOWN_FAILURE":
      return CMsgClientToGCVoteForArcanaResponse_Result.UNKNOWN_FAILURE;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCVoteForArcanaResponse_Result",
      );
  }
}

export function cMsgClientToGCVoteForArcanaResponse_ResultToJSON(
  object: CMsgClientToGCVoteForArcanaResponse_Result,
): string {
  switch (object) {
    case CMsgClientToGCVoteForArcanaResponse_Result.SUCCEEDED:
      return "SUCCEEDED";
    case CMsgClientToGCVoteForArcanaResponse_Result.VOTING_NOT_ENABLED_FOR_ROUND:
      return "VOTING_NOT_ENABLED_FOR_ROUND";
    case CMsgClientToGCVoteForArcanaResponse_Result.UNKNOWN_FAILURE:
      return "UNKNOWN_FAILURE";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCVoteForArcanaResponse_Result",
      );
  }
}

export interface CMsgClientToGCRequestArcanaVotesRemaining {
}

export interface CMsgClientToGCRequestArcanaVotesRemainingResponse {
  result: boolean;
  votesRemaining: number;
  votesTotal: number;
  matchesPreviouslyVotedFor: CMsgArcanaVoteMatchVotes[];
}

export interface CMsgClientToGCRequestEventPointLogV2 {
  eventId: number;
}

export interface CMsgClientToGCRequestEventPointLogResponseV2 {
  result: boolean;
  eventId: EEvent;
  logEntries: CMsgClientToGCRequestEventPointLogResponseV2_LogEntry[];
}

export interface CMsgClientToGCRequestEventPointLogResponseV2_LogEntry {
  timestamp: number;
  auditAction: number;
  eventPoints: number;
  auditData: string;
}

export interface CMsgClientToGCPublishUserStat {
  userStatsEvent: number;
  referenceData: string;
}

export interface CMsgClientToGCRequestSlarkGameResult {
  eventId: EEvent;
  slotChosen: number;
  week: number;
}

export interface CMsgClientToGCRequestSlarkGameResultResponse {
  pointsWon: number;
  auraWon: boolean;
}

export interface CMsgGCToClientQuestProgressUpdated {
  questId: number;
  completedChallenges: CMsgGCToClientQuestProgressUpdated_Challenge[];
}

export interface CMsgGCToClientQuestProgressUpdated_Challenge {
  challengeId: number;
  timeCompleted: number;
  attempts: number;
  heroId: number;
  templateId: number;
  questRank: number;
  maxQuestRank: number;
}

export interface CMsgDOTARedeemItem {
  currencyId: string;
  purchaseDef: number;
}

export interface CMsgDOTARedeemItemResponse {
  response: CMsgDOTARedeemItemResponse_EResultCode;
}

export enum CMsgDOTARedeemItemResponse_EResultCode {
  k_Succeeded = 0,
  k_Failed = 1,
}

export function cMsgDOTARedeemItemResponse_EResultCodeFromJSON(object: any): CMsgDOTARedeemItemResponse_EResultCode {
  switch (object) {
    case 0:
    case "k_Succeeded":
      return CMsgDOTARedeemItemResponse_EResultCode.k_Succeeded;
    case 1:
    case "k_Failed":
      return CMsgDOTARedeemItemResponse_EResultCode.k_Failed;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTARedeemItemResponse_EResultCode",
      );
  }
}

export function cMsgDOTARedeemItemResponse_EResultCodeToJSON(object: CMsgDOTARedeemItemResponse_EResultCode): string {
  switch (object) {
    case CMsgDOTARedeemItemResponse_EResultCode.k_Succeeded:
      return "k_Succeeded";
    case CMsgDOTARedeemItemResponse_EResultCode.k_Failed:
      return "k_Failed";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTARedeemItemResponse_EResultCode",
      );
  }
}

export interface CMsgClientToGCSelectCompendiumInGamePrediction {
  matchId: string;
  predictions: CMsgClientToGCSelectCompendiumInGamePrediction_Prediction[];
  leagueId: number;
}

export interface CMsgClientToGCSelectCompendiumInGamePrediction_Prediction {
  predictionId: number;
  predictionValue: number;
}

export interface CMsgClientToGCSelectCompendiumInGamePredictionResponse {
  result: CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult;
}

export enum CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult {
  SUCCESS = 0,
  INVALID_MATCH = 1,
  PREDICTIONS_ARE_CLOSED = 2,
  OTHER_ERROR = 3,
}

export function cMsgClientToGCSelectCompendiumInGamePredictionResponse_EResultFromJSON(
  object: any,
): CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult.SUCCESS;
    case 1:
    case "INVALID_MATCH":
      return CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult.INVALID_MATCH;
    case 2:
    case "PREDICTIONS_ARE_CLOSED":
      return CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult.PREDICTIONS_ARE_CLOSED;
    case 3:
    case "OTHER_ERROR":
      return CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult.OTHER_ERROR;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object +
          " for enum CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult",
      );
  }
}

export function cMsgClientToGCSelectCompendiumInGamePredictionResponse_EResultToJSON(
  object: CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult,
): string {
  switch (object) {
    case CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult.SUCCESS:
      return "SUCCESS";
    case CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult.INVALID_MATCH:
      return "INVALID_MATCH";
    case CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult.PREDICTIONS_ARE_CLOSED:
      return "PREDICTIONS_ARE_CLOSED";
    case CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult.OTHER_ERROR:
      return "OTHER_ERROR";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object +
          " for enum CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult",
      );
  }
}

export interface CMsgClientToGCOpenPlayerCardPack {
  playerCardPackItemId: string;
  teamId: number;
  deprecatedLeagueId: number;
  region: ELeagueRegion;
}

export interface CMsgClientToGCOpenPlayerCardPackResponse {
  result: CMsgClientToGCOpenPlayerCardPackResponse_Result;
  playerCardItemIds: string[];
}

export enum CMsgClientToGCOpenPlayerCardPackResponse_Result {
  SUCCESS = 1,
  ERROR_INTERNAL = 2,
  ERROR_FAILED_TO_FIND_PACK = 3,
  ERROR_ITEM_NOT_CARD_PACK = 4,
  ERROR_FAILED_CARD_CREATE = 5,
  ERROR_INVALID_TEAM_ID_ATTRIBUTE = 6,
  ERROR_INVALID_TEAM_ID = 7,
}

export function cMsgClientToGCOpenPlayerCardPackResponse_ResultFromJSON(
  object: any,
): CMsgClientToGCOpenPlayerCardPackResponse_Result {
  switch (object) {
    case 1:
    case "SUCCESS":
      return CMsgClientToGCOpenPlayerCardPackResponse_Result.SUCCESS;
    case 2:
    case "ERROR_INTERNAL":
      return CMsgClientToGCOpenPlayerCardPackResponse_Result.ERROR_INTERNAL;
    case 3:
    case "ERROR_FAILED_TO_FIND_PACK":
      return CMsgClientToGCOpenPlayerCardPackResponse_Result.ERROR_FAILED_TO_FIND_PACK;
    case 4:
    case "ERROR_ITEM_NOT_CARD_PACK":
      return CMsgClientToGCOpenPlayerCardPackResponse_Result.ERROR_ITEM_NOT_CARD_PACK;
    case 5:
    case "ERROR_FAILED_CARD_CREATE":
      return CMsgClientToGCOpenPlayerCardPackResponse_Result.ERROR_FAILED_CARD_CREATE;
    case 6:
    case "ERROR_INVALID_TEAM_ID_ATTRIBUTE":
      return CMsgClientToGCOpenPlayerCardPackResponse_Result.ERROR_INVALID_TEAM_ID_ATTRIBUTE;
    case 7:
    case "ERROR_INVALID_TEAM_ID":
      return CMsgClientToGCOpenPlayerCardPackResponse_Result.ERROR_INVALID_TEAM_ID;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOpenPlayerCardPackResponse_Result",
      );
  }
}

export function cMsgClientToGCOpenPlayerCardPackResponse_ResultToJSON(
  object: CMsgClientToGCOpenPlayerCardPackResponse_Result,
): string {
  switch (object) {
    case CMsgClientToGCOpenPlayerCardPackResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgClientToGCOpenPlayerCardPackResponse_Result.ERROR_INTERNAL:
      return "ERROR_INTERNAL";
    case CMsgClientToGCOpenPlayerCardPackResponse_Result.ERROR_FAILED_TO_FIND_PACK:
      return "ERROR_FAILED_TO_FIND_PACK";
    case CMsgClientToGCOpenPlayerCardPackResponse_Result.ERROR_ITEM_NOT_CARD_PACK:
      return "ERROR_ITEM_NOT_CARD_PACK";
    case CMsgClientToGCOpenPlayerCardPackResponse_Result.ERROR_FAILED_CARD_CREATE:
      return "ERROR_FAILED_CARD_CREATE";
    case CMsgClientToGCOpenPlayerCardPackResponse_Result.ERROR_INVALID_TEAM_ID_ATTRIBUTE:
      return "ERROR_INVALID_TEAM_ID_ATTRIBUTE";
    case CMsgClientToGCOpenPlayerCardPackResponse_Result.ERROR_INVALID_TEAM_ID:
      return "ERROR_INVALID_TEAM_ID";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOpenPlayerCardPackResponse_Result",
      );
  }
}

export interface CMsgClientToGCRecyclePlayerCard {
  playerCardItemIds: string[];
  eventId: number;
}

export interface CMsgClientToGCRecyclePlayerCardResponse {
  result: CMsgClientToGCRecyclePlayerCardResponse_Result;
  dustAmount: number;
}

export enum CMsgClientToGCRecyclePlayerCardResponse_Result {
  SUCCESS = 1,
  ERROR_INTERNAL = 2,
  ERROR_FAILED_TO_FIND_PLAYER_CARD = 3,
  ERROR_ITEM_NOT_PLAYER_CARD = 4,
  ERROR_FAILED_DUST_CARD_CREATE = 5,
  ERROR_CARD_LOCKED = 6,
  ERROR_NO_CARDS_SPECIFIED = 7,
}

export function cMsgClientToGCRecyclePlayerCardResponse_ResultFromJSON(
  object: any,
): CMsgClientToGCRecyclePlayerCardResponse_Result {
  switch (object) {
    case 1:
    case "SUCCESS":
      return CMsgClientToGCRecyclePlayerCardResponse_Result.SUCCESS;
    case 2:
    case "ERROR_INTERNAL":
      return CMsgClientToGCRecyclePlayerCardResponse_Result.ERROR_INTERNAL;
    case 3:
    case "ERROR_FAILED_TO_FIND_PLAYER_CARD":
      return CMsgClientToGCRecyclePlayerCardResponse_Result.ERROR_FAILED_TO_FIND_PLAYER_CARD;
    case 4:
    case "ERROR_ITEM_NOT_PLAYER_CARD":
      return CMsgClientToGCRecyclePlayerCardResponse_Result.ERROR_ITEM_NOT_PLAYER_CARD;
    case 5:
    case "ERROR_FAILED_DUST_CARD_CREATE":
      return CMsgClientToGCRecyclePlayerCardResponse_Result.ERROR_FAILED_DUST_CARD_CREATE;
    case 6:
    case "ERROR_CARD_LOCKED":
      return CMsgClientToGCRecyclePlayerCardResponse_Result.ERROR_CARD_LOCKED;
    case 7:
    case "ERROR_NO_CARDS_SPECIFIED":
      return CMsgClientToGCRecyclePlayerCardResponse_Result.ERROR_NO_CARDS_SPECIFIED;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCRecyclePlayerCardResponse_Result",
      );
  }
}

export function cMsgClientToGCRecyclePlayerCardResponse_ResultToJSON(
  object: CMsgClientToGCRecyclePlayerCardResponse_Result,
): string {
  switch (object) {
    case CMsgClientToGCRecyclePlayerCardResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgClientToGCRecyclePlayerCardResponse_Result.ERROR_INTERNAL:
      return "ERROR_INTERNAL";
    case CMsgClientToGCRecyclePlayerCardResponse_Result.ERROR_FAILED_TO_FIND_PLAYER_CARD:
      return "ERROR_FAILED_TO_FIND_PLAYER_CARD";
    case CMsgClientToGCRecyclePlayerCardResponse_Result.ERROR_ITEM_NOT_PLAYER_CARD:
      return "ERROR_ITEM_NOT_PLAYER_CARD";
    case CMsgClientToGCRecyclePlayerCardResponse_Result.ERROR_FAILED_DUST_CARD_CREATE:
      return "ERROR_FAILED_DUST_CARD_CREATE";
    case CMsgClientToGCRecyclePlayerCardResponse_Result.ERROR_CARD_LOCKED:
      return "ERROR_CARD_LOCKED";
    case CMsgClientToGCRecyclePlayerCardResponse_Result.ERROR_NO_CARDS_SPECIFIED:
      return "ERROR_NO_CARDS_SPECIFIED";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCRecyclePlayerCardResponse_Result",
      );
  }
}

export interface CMsgClientToGCCreatePlayerCardPack {
  cardDustItemId: string;
  eventId: number;
  premiumPack: boolean;
}

export interface CMsgClientToGCCreatePlayerCardPackResponse {
  result: CMsgClientToGCCreatePlayerCardPackResponse_Result;
}

export enum CMsgClientToGCCreatePlayerCardPackResponse_Result {
  SUCCESS = 1,
  ERROR_INTERNAL = 2,
  ERROR_INSUFFICIENT_DUST = 3,
  ERROR_ITEM_NOT_DUST_ITEM = 4,
  ERROR_FAILED_CARD_PACK_CREATE = 5,
  ERROR_NO_CARD_PACK = 6,
  ERROR_NOT_AVAILABLE = 7,
}

export function cMsgClientToGCCreatePlayerCardPackResponse_ResultFromJSON(
  object: any,
): CMsgClientToGCCreatePlayerCardPackResponse_Result {
  switch (object) {
    case 1:
    case "SUCCESS":
      return CMsgClientToGCCreatePlayerCardPackResponse_Result.SUCCESS;
    case 2:
    case "ERROR_INTERNAL":
      return CMsgClientToGCCreatePlayerCardPackResponse_Result.ERROR_INTERNAL;
    case 3:
    case "ERROR_INSUFFICIENT_DUST":
      return CMsgClientToGCCreatePlayerCardPackResponse_Result.ERROR_INSUFFICIENT_DUST;
    case 4:
    case "ERROR_ITEM_NOT_DUST_ITEM":
      return CMsgClientToGCCreatePlayerCardPackResponse_Result.ERROR_ITEM_NOT_DUST_ITEM;
    case 5:
    case "ERROR_FAILED_CARD_PACK_CREATE":
      return CMsgClientToGCCreatePlayerCardPackResponse_Result.ERROR_FAILED_CARD_PACK_CREATE;
    case 6:
    case "ERROR_NO_CARD_PACK":
      return CMsgClientToGCCreatePlayerCardPackResponse_Result.ERROR_NO_CARD_PACK;
    case 7:
    case "ERROR_NOT_AVAILABLE":
      return CMsgClientToGCCreatePlayerCardPackResponse_Result.ERROR_NOT_AVAILABLE;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCCreatePlayerCardPackResponse_Result",
      );
  }
}

export function cMsgClientToGCCreatePlayerCardPackResponse_ResultToJSON(
  object: CMsgClientToGCCreatePlayerCardPackResponse_Result,
): string {
  switch (object) {
    case CMsgClientToGCCreatePlayerCardPackResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgClientToGCCreatePlayerCardPackResponse_Result.ERROR_INTERNAL:
      return "ERROR_INTERNAL";
    case CMsgClientToGCCreatePlayerCardPackResponse_Result.ERROR_INSUFFICIENT_DUST:
      return "ERROR_INSUFFICIENT_DUST";
    case CMsgClientToGCCreatePlayerCardPackResponse_Result.ERROR_ITEM_NOT_DUST_ITEM:
      return "ERROR_ITEM_NOT_DUST_ITEM";
    case CMsgClientToGCCreatePlayerCardPackResponse_Result.ERROR_FAILED_CARD_PACK_CREATE:
      return "ERROR_FAILED_CARD_PACK_CREATE";
    case CMsgClientToGCCreatePlayerCardPackResponse_Result.ERROR_NO_CARD_PACK:
      return "ERROR_NO_CARD_PACK";
    case CMsgClientToGCCreatePlayerCardPackResponse_Result.ERROR_NOT_AVAILABLE:
      return "ERROR_NOT_AVAILABLE";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCCreatePlayerCardPackResponse_Result",
      );
  }
}

export interface CMsgClientToGCCreateTeamPlayerCardPack {
  cardDustItemId: string;
  eventId: number;
  premiumPack: boolean;
  teamId: number;
}

export interface CMsgClientToGCCreateTeamPlayerCardPackResponse {
  result: CMsgClientToGCCreateTeamPlayerCardPackResponse_Result;
}

export enum CMsgClientToGCCreateTeamPlayerCardPackResponse_Result {
  SUCCESS = 1,
  ERROR_INTERNAL = 2,
  ERROR_INSUFFICIENT_DUST = 3,
  ERROR_ITEM_NOT_DUST_ITEM = 4,
  ERROR_FAILED_CARD_PACK_CREATE = 5,
  ERROR_NO_CARD_PACK = 6,
  ERROR_NOT_AVAILABLE = 7,
}

export function cMsgClientToGCCreateTeamPlayerCardPackResponse_ResultFromJSON(
  object: any,
): CMsgClientToGCCreateTeamPlayerCardPackResponse_Result {
  switch (object) {
    case 1:
    case "SUCCESS":
      return CMsgClientToGCCreateTeamPlayerCardPackResponse_Result.SUCCESS;
    case 2:
    case "ERROR_INTERNAL":
      return CMsgClientToGCCreateTeamPlayerCardPackResponse_Result.ERROR_INTERNAL;
    case 3:
    case "ERROR_INSUFFICIENT_DUST":
      return CMsgClientToGCCreateTeamPlayerCardPackResponse_Result.ERROR_INSUFFICIENT_DUST;
    case 4:
    case "ERROR_ITEM_NOT_DUST_ITEM":
      return CMsgClientToGCCreateTeamPlayerCardPackResponse_Result.ERROR_ITEM_NOT_DUST_ITEM;
    case 5:
    case "ERROR_FAILED_CARD_PACK_CREATE":
      return CMsgClientToGCCreateTeamPlayerCardPackResponse_Result.ERROR_FAILED_CARD_PACK_CREATE;
    case 6:
    case "ERROR_NO_CARD_PACK":
      return CMsgClientToGCCreateTeamPlayerCardPackResponse_Result.ERROR_NO_CARD_PACK;
    case 7:
    case "ERROR_NOT_AVAILABLE":
      return CMsgClientToGCCreateTeamPlayerCardPackResponse_Result.ERROR_NOT_AVAILABLE;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCCreateTeamPlayerCardPackResponse_Result",
      );
  }
}

export function cMsgClientToGCCreateTeamPlayerCardPackResponse_ResultToJSON(
  object: CMsgClientToGCCreateTeamPlayerCardPackResponse_Result,
): string {
  switch (object) {
    case CMsgClientToGCCreateTeamPlayerCardPackResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgClientToGCCreateTeamPlayerCardPackResponse_Result.ERROR_INTERNAL:
      return "ERROR_INTERNAL";
    case CMsgClientToGCCreateTeamPlayerCardPackResponse_Result.ERROR_INSUFFICIENT_DUST:
      return "ERROR_INSUFFICIENT_DUST";
    case CMsgClientToGCCreateTeamPlayerCardPackResponse_Result.ERROR_ITEM_NOT_DUST_ITEM:
      return "ERROR_ITEM_NOT_DUST_ITEM";
    case CMsgClientToGCCreateTeamPlayerCardPackResponse_Result.ERROR_FAILED_CARD_PACK_CREATE:
      return "ERROR_FAILED_CARD_PACK_CREATE";
    case CMsgClientToGCCreateTeamPlayerCardPackResponse_Result.ERROR_NO_CARD_PACK:
      return "ERROR_NO_CARD_PACK";
    case CMsgClientToGCCreateTeamPlayerCardPackResponse_Result.ERROR_NOT_AVAILABLE:
      return "ERROR_NOT_AVAILABLE";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCCreateTeamPlayerCardPackResponse_Result",
      );
  }
}

export interface CMsgGCToClientBattlePassRollupInternational2016 {
  battlePassLevel: number;
  questlines: CMsgGCToClientBattlePassRollupInternational2016_Questlines[];
  wagering: CMsgGCToClientBattlePassRollupInternational2016_Wagering | undefined;
  achievements: CMsgGCToClientBattlePassRollupInternational2016_Achievements | undefined;
  battleCup: CMsgGCToClientBattlePassRollupInternational2016_BattleCup | undefined;
  predictions: CMsgGCToClientBattlePassRollupInternational2016_Predictions | undefined;
  bracket: CMsgGCToClientBattlePassRollupInternational2016_Bracket | undefined;
  playerCards: CMsgGCToClientBattlePassRollupInternational2016_PlayerCard[];
  fantasyChallenge: CMsgGCToClientBattlePassRollupInternational2016_FantasyChallenge | undefined;
}

export interface CMsgGCToClientBattlePassRollupInternational2016_Questlines {
  name: string;
  onestar: number;
  twostar: number;
  threestar: number;
  total: number;
}

export interface CMsgGCToClientBattlePassRollupInternational2016_Wagering {
  totalWagered: number;
  totalWon: number;
  averageWon: number;
  successRate: number;
  totalTips: number;
}

export interface CMsgGCToClientBattlePassRollupInternational2016_Achievements {
  completed: number;
  total: number;
  points: number;
}

export interface CMsgGCToClientBattlePassRollupInternational2016_BattleCup {
  wins: number;
  score: number;
}

export interface CMsgGCToClientBattlePassRollupInternational2016_Predictions {
  correct: number;
  total: number;
  points: number;
}

export interface CMsgGCToClientBattlePassRollupInternational2016_Bracket {
  correct: number;
  points: number;
}

export interface CMsgGCToClientBattlePassRollupInternational2016_PlayerCard {
  accountId: number;
  quality: number;
}

export interface CMsgGCToClientBattlePassRollupInternational2016_FantasyChallenge {
  totalScore: number;
  percentile: number;
}

export interface CMsgGCToClientBattlePassRollupFall2016 {
  battlePassLevel: number;
  questlines: CMsgGCToClientBattlePassRollupFall2016_Questlines[];
  wagering: CMsgGCToClientBattlePassRollupFall2016_Wagering | undefined;
  achievements: CMsgGCToClientBattlePassRollupFall2016_Achievements | undefined;
  battleCup: CMsgGCToClientBattlePassRollupFall2016_BattleCup | undefined;
  predictions: CMsgGCToClientBattlePassRollupFall2016_Predictions | undefined;
  bracket: CMsgGCToClientBattlePassRollupFall2016_Bracket | undefined;
  playerCards: CMsgGCToClientBattlePassRollupFall2016_PlayerCard[];
  fantasyChallenge: CMsgGCToClientBattlePassRollupFall2016_FantasyChallenge | undefined;
}

export interface CMsgGCToClientBattlePassRollupFall2016_Questlines {
  name: string;
  onestar: number;
  twostar: number;
  threestar: number;
  total: number;
}

export interface CMsgGCToClientBattlePassRollupFall2016_Wagering {
  totalWagered: number;
  totalWon: number;
  averageWon: number;
  successRate: number;
  totalTips: number;
}

export interface CMsgGCToClientBattlePassRollupFall2016_Achievements {
  completed: number;
  total: number;
  points: number;
}

export interface CMsgGCToClientBattlePassRollupFall2016_BattleCup {
  wins: number;
  score: number;
}

export interface CMsgGCToClientBattlePassRollupFall2016_Predictions {
  correct: number;
  total: number;
  points: number;
}

export interface CMsgGCToClientBattlePassRollupFall2016_Bracket {
  correct: number;
  points: number;
}

export interface CMsgGCToClientBattlePassRollupFall2016_PlayerCard {
  accountId: number;
  quality: number;
}

export interface CMsgGCToClientBattlePassRollupFall2016_FantasyChallenge {
  totalScore: number;
  percentile: number;
}

export interface CMsgGCToClientBattlePassRollupWinter2017 {
  battlePassLevel: number;
  questlines: CMsgGCToClientBattlePassRollupWinter2017_Questlines[];
  wagering: CMsgGCToClientBattlePassRollupWinter2017_Wagering | undefined;
  achievements: CMsgGCToClientBattlePassRollupWinter2017_Achievements | undefined;
  battleCup: CMsgGCToClientBattlePassRollupWinter2017_BattleCup | undefined;
  predictions: CMsgGCToClientBattlePassRollupWinter2017_Predictions | undefined;
  bracket: CMsgGCToClientBattlePassRollupWinter2017_Bracket | undefined;
  playerCards: CMsgGCToClientBattlePassRollupWinter2017_PlayerCard[];
  fantasyChallenge: CMsgGCToClientBattlePassRollupWinter2017_FantasyChallenge | undefined;
}

export interface CMsgGCToClientBattlePassRollupWinter2017_Questlines {
  name: string;
  onestar: number;
  twostar: number;
  threestar: number;
  total: number;
}

export interface CMsgGCToClientBattlePassRollupWinter2017_Wagering {
  totalWagered: number;
  totalWon: number;
  averageWon: number;
  successRate: number;
  totalTips: number;
}

export interface CMsgGCToClientBattlePassRollupWinter2017_Achievements {
  completed: number;
  total: number;
  points: number;
}

export interface CMsgGCToClientBattlePassRollupWinter2017_BattleCup {
  wins: number;
  score: number;
}

export interface CMsgGCToClientBattlePassRollupWinter2017_Predictions {
  correct: number;
  total: number;
  points: number;
}

export interface CMsgGCToClientBattlePassRollupWinter2017_Bracket {
  correct: number;
  points: number;
}

export interface CMsgGCToClientBattlePassRollupWinter2017_PlayerCard {
  accountId: number;
  quality: number;
}

export interface CMsgGCToClientBattlePassRollupWinter2017_FantasyChallenge {
  totalScore: number;
  percentile: number;
}

export interface CMsgGCToClientBattlePassRollupTI7 {
  battlePassLevel: number;
  questlines: CMsgGCToClientBattlePassRollupTI7_Questlines[];
  wagering: CMsgGCToClientBattlePassRollupTI7_Wagering | undefined;
  achievements: CMsgGCToClientBattlePassRollupTI7_Achievements | undefined;
  battleCup: CMsgGCToClientBattlePassRollupTI7_BattleCup | undefined;
  predictions: CMsgGCToClientBattlePassRollupTI7_Predictions | undefined;
  bracket: CMsgGCToClientBattlePassRollupTI7_Bracket | undefined;
  playerCards: CMsgGCToClientBattlePassRollupTI7_PlayerCard[];
  fantasyChallenge: CMsgGCToClientBattlePassRollupTI7_FantasyChallenge | undefined;
}

export interface CMsgGCToClientBattlePassRollupTI7_Questlines {
  name: string;
  onestar: number;
  twostar: number;
  threestar: number;
  total: number;
}

export interface CMsgGCToClientBattlePassRollupTI7_Wagering {
  totalWagered: number;
  totalWon: number;
  averageWon: number;
  successRate: number;
  totalTips: number;
}

export interface CMsgGCToClientBattlePassRollupTI7_Achievements {
  completed: number;
  total: number;
  points: number;
}

export interface CMsgGCToClientBattlePassRollupTI7_BattleCup {
  wins: number;
  score: number;
}

export interface CMsgGCToClientBattlePassRollupTI7_Predictions {
  correct: number;
  total: number;
  points: number;
}

export interface CMsgGCToClientBattlePassRollupTI7_Bracket {
  correct: number;
  points: number;
}

export interface CMsgGCToClientBattlePassRollupTI7_PlayerCard {
  accountId: number;
  quality: number;
}

export interface CMsgGCToClientBattlePassRollupTI7_FantasyChallenge {
  totalScore: number;
  percentile: number;
}

export interface CMsgGCToClientBattlePassRollupTI8 {
  battlePassLevel: number;
  cavernCrawl: CMsgGCToClientBattlePassRollupTI8_CavernCrawl | undefined;
  wagering: CMsgGCToClientBattlePassRollupTI8_Wagering | undefined;
  achievements: CMsgGCToClientBattlePassRollupTI8_Achievements | undefined;
  predictions: CMsgGCToClientBattlePassRollupTI8_Predictions | undefined;
  bracket: CMsgGCToClientBattlePassRollupTI8_Bracket | undefined;
  playerCards: CMsgGCToClientBattlePassRollupTI8_PlayerCard[];
  fantasyChallenge: CMsgGCToClientBattlePassRollupTI8_FantasyChallenge | undefined;
}

export interface CMsgGCToClientBattlePassRollupTI8_CavernCrawl {
  roomsCleared: number;
  carryCompleted: boolean;
  supportCompleted: boolean;
  utilityCompleted: boolean;
}

export interface CMsgGCToClientBattlePassRollupTI8_Wagering {
  totalWagered: number;
  totalWon: number;
  averageWon: number;
  successRate: number;
  totalTips: number;
}

export interface CMsgGCToClientBattlePassRollupTI8_Achievements {
  completed: number;
  total: number;
  points: number;
}

export interface CMsgGCToClientBattlePassRollupTI8_Predictions {
  correct: number;
  total: number;
  points: number;
}

export interface CMsgGCToClientBattlePassRollupTI8_Bracket {
  correct: number;
  points: number;
}

export interface CMsgGCToClientBattlePassRollupTI8_PlayerCard {
  accountId: number;
  quality: number;
}

export interface CMsgGCToClientBattlePassRollupTI8_FantasyChallenge {
  totalScore: number;
  percentile: number;
}

export interface CMsgGCToClientBattlePassRollupTI9 {
  battlePassLevel: number;
}

export interface CMsgGCToClientBattlePassRollupTI10 {
  battlePassLevel: number;
}

export interface CMsgGCToClientBattlePassRollupRequest {
  eventId: number;
  accountId: number;
}

export interface CMsgGCToClientBattlePassRollupResponse {
  eventTi6: CMsgGCToClientBattlePassRollupInternational2016 | undefined;
  eventFall2016: CMsgGCToClientBattlePassRollupFall2016 | undefined;
  eventWinter2017: CMsgGCToClientBattlePassRollupWinter2017 | undefined;
  eventTi7: CMsgGCToClientBattlePassRollupTI7 | undefined;
  eventTi8: CMsgGCToClientBattlePassRollupTI8 | undefined;
  eventTi9: CMsgGCToClientBattlePassRollupTI9 | undefined;
  eventTi10: CMsgGCToClientBattlePassRollupTI10 | undefined;
}

export interface CMsgGCToClientBattlePassRollupListRequest {
  accountId: number;
}

export interface CMsgGCToClientBattlePassRollupListResponse {
  eventInfo: CMsgGCToClientBattlePassRollupListResponse_EventInfo[];
}

export interface CMsgGCToClientBattlePassRollupListResponse_EventInfo {
  eventId: number;
  level: number;
}

export interface CMsgClientToGCTransferSeasonalMMRRequest {
  isParty: boolean;
}

export interface CMsgClientToGCTransferSeasonalMMRResponse {
  success: boolean;
}

export interface CMsgGCToClientPlaytestStatus {
  active: boolean;
}

export interface CMsgClientToGCJoinPlaytest {
  clientVersion: number;
}

export interface CMsgClientToGCJoinPlaytestResponse {
  error: string;
}

export interface CMsgDOTASetFavoriteTeam {
  teamId: number;
  eventId: number;
}

export interface CMsgDOTATriviaCurrentQuestions {
  questions: CMsgDOTATriviaQuestion[];
  triviaEnabled: boolean;
}

export interface CMsgDOTASubmitTriviaQuestionAnswer {
  questionId: number;
  answerIndex: number;
}

export interface CMsgDOTASubmitTriviaQuestionAnswerResponse {
  result: EDOTATriviaAnswerResult;
}

export interface CMsgDOTAStartTriviaSession {
}

export interface CMsgDOTAStartTriviaSessionResponse {
  triviaEnabled: boolean;
  currentTimestamp: number;
}

export interface CMsgDOTAAnchorPhoneNumberRequest {
}

export interface CMsgDOTAAnchorPhoneNumberResponse {
  result: CMsgDOTAAnchorPhoneNumberResponse_Result;
}

export enum CMsgDOTAAnchorPhoneNumberResponse_Result {
  SUCCESS = 0,
  ERROR_UNKNOWN = 1,
  ERROR_NO_STEAM_PHONE = 2,
  ERROR_ALREADY_IN_USE = 3,
  ERROR_COOLDOWN_ACTIVE = 4,
  ERROR_GAC_ISSUE = 5,
}

export function cMsgDOTAAnchorPhoneNumberResponse_ResultFromJSON(
  object: any,
): CMsgDOTAAnchorPhoneNumberResponse_Result {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgDOTAAnchorPhoneNumberResponse_Result.SUCCESS;
    case 1:
    case "ERROR_UNKNOWN":
      return CMsgDOTAAnchorPhoneNumberResponse_Result.ERROR_UNKNOWN;
    case 2:
    case "ERROR_NO_STEAM_PHONE":
      return CMsgDOTAAnchorPhoneNumberResponse_Result.ERROR_NO_STEAM_PHONE;
    case 3:
    case "ERROR_ALREADY_IN_USE":
      return CMsgDOTAAnchorPhoneNumberResponse_Result.ERROR_ALREADY_IN_USE;
    case 4:
    case "ERROR_COOLDOWN_ACTIVE":
      return CMsgDOTAAnchorPhoneNumberResponse_Result.ERROR_COOLDOWN_ACTIVE;
    case 5:
    case "ERROR_GAC_ISSUE":
      return CMsgDOTAAnchorPhoneNumberResponse_Result.ERROR_GAC_ISSUE;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTAAnchorPhoneNumberResponse_Result",
      );
  }
}

export function cMsgDOTAAnchorPhoneNumberResponse_ResultToJSON(
  object: CMsgDOTAAnchorPhoneNumberResponse_Result,
): string {
  switch (object) {
    case CMsgDOTAAnchorPhoneNumberResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgDOTAAnchorPhoneNumberResponse_Result.ERROR_UNKNOWN:
      return "ERROR_UNKNOWN";
    case CMsgDOTAAnchorPhoneNumberResponse_Result.ERROR_NO_STEAM_PHONE:
      return "ERROR_NO_STEAM_PHONE";
    case CMsgDOTAAnchorPhoneNumberResponse_Result.ERROR_ALREADY_IN_USE:
      return "ERROR_ALREADY_IN_USE";
    case CMsgDOTAAnchorPhoneNumberResponse_Result.ERROR_COOLDOWN_ACTIVE:
      return "ERROR_COOLDOWN_ACTIVE";
    case CMsgDOTAAnchorPhoneNumberResponse_Result.ERROR_GAC_ISSUE:
      return "ERROR_GAC_ISSUE";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTAAnchorPhoneNumberResponse_Result",
      );
  }
}

export interface CMsgDOTAUnanchorPhoneNumberRequest {
}

export interface CMsgDOTAUnanchorPhoneNumberResponse {
  result: CMsgDOTAUnanchorPhoneNumberResponse_Result;
}

export enum CMsgDOTAUnanchorPhoneNumberResponse_Result {
  SUCCESS = 0,
  ERROR_UNKNOWN = 1,
}

export function cMsgDOTAUnanchorPhoneNumberResponse_ResultFromJSON(
  object: any,
): CMsgDOTAUnanchorPhoneNumberResponse_Result {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgDOTAUnanchorPhoneNumberResponse_Result.SUCCESS;
    case 1:
    case "ERROR_UNKNOWN":
      return CMsgDOTAUnanchorPhoneNumberResponse_Result.ERROR_UNKNOWN;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTAUnanchorPhoneNumberResponse_Result",
      );
  }
}

export function cMsgDOTAUnanchorPhoneNumberResponse_ResultToJSON(
  object: CMsgDOTAUnanchorPhoneNumberResponse_Result,
): string {
  switch (object) {
    case CMsgDOTAUnanchorPhoneNumberResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgDOTAUnanchorPhoneNumberResponse_Result.ERROR_UNKNOWN:
      return "ERROR_UNKNOWN";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTAUnanchorPhoneNumberResponse_Result",
      );
  }
}

export interface CMsgGCToClientCommendNotification {
  commenderAccountId: number;
  commenderName: string;
  flags: number;
}

export interface CMsgDOTAClientToGCQuickStatsRequest {
  playerAccountId: number;
  heroId: number;
  itemId: number;
  leagueId: number;
}

export interface CMsgDOTAClientToGCQuickStatsResponse {
  originalRequest: CMsgDOTAClientToGCQuickStatsRequest | undefined;
  heroStats: CMsgDOTAClientToGCQuickStatsResponse_SimpleStats | undefined;
  itemStats: CMsgDOTAClientToGCQuickStatsResponse_SimpleStats | undefined;
  itemHeroStats: CMsgDOTAClientToGCQuickStatsResponse_SimpleStats | undefined;
  itemPlayerStats: CMsgDOTAClientToGCQuickStatsResponse_SimpleStats | undefined;
  heroPlayerStats: CMsgDOTAClientToGCQuickStatsResponse_SimpleStats | undefined;
  fullSetStats: CMsgDOTAClientToGCQuickStatsResponse_SimpleStats | undefined;
}

export interface CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
  winPercent: number;
  pickPercent: number;
  winCount: number;
  pickCount: number;
}

export interface CMsgDOTASelectionPriorityChoiceRequest {
  choice: DOTASelectionPriorityChoice;
}

export interface CMsgDOTASelectionPriorityChoiceResponse {
  result: CMsgDOTASelectionPriorityChoiceResponse_Result;
}

export enum CMsgDOTASelectionPriorityChoiceResponse_Result {
  SUCCESS = 0,
  ERROR_UNKNOWN = 1,
}

export function cMsgDOTASelectionPriorityChoiceResponse_ResultFromJSON(
  object: any,
): CMsgDOTASelectionPriorityChoiceResponse_Result {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgDOTASelectionPriorityChoiceResponse_Result.SUCCESS;
    case 1:
    case "ERROR_UNKNOWN":
      return CMsgDOTASelectionPriorityChoiceResponse_Result.ERROR_UNKNOWN;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTASelectionPriorityChoiceResponse_Result",
      );
  }
}

export function cMsgDOTASelectionPriorityChoiceResponse_ResultToJSON(
  object: CMsgDOTASelectionPriorityChoiceResponse_Result,
): string {
  switch (object) {
    case CMsgDOTASelectionPriorityChoiceResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgDOTASelectionPriorityChoiceResponse_Result.ERROR_UNKNOWN:
      return "ERROR_UNKNOWN";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTASelectionPriorityChoiceResponse_Result",
      );
  }
}

export interface CMsgDOTAGameAutographReward {
  badgeId: string;
}

export interface CMsgDOTAGameAutographRewardResponse {
  result: CMsgDOTAGameAutographRewardResponse_Result;
}

export enum CMsgDOTAGameAutographRewardResponse_Result {
  SUCCESS = 0,
  ERROR_UNKNOWN = 1,
}

export function cMsgDOTAGameAutographRewardResponse_ResultFromJSON(
  object: any,
): CMsgDOTAGameAutographRewardResponse_Result {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgDOTAGameAutographRewardResponse_Result.SUCCESS;
    case 1:
    case "ERROR_UNKNOWN":
      return CMsgDOTAGameAutographRewardResponse_Result.ERROR_UNKNOWN;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTAGameAutographRewardResponse_Result",
      );
  }
}

export function cMsgDOTAGameAutographRewardResponse_ResultToJSON(
  object: CMsgDOTAGameAutographRewardResponse_Result,
): string {
  switch (object) {
    case CMsgDOTAGameAutographRewardResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgDOTAGameAutographRewardResponse_Result.ERROR_UNKNOWN:
      return "ERROR_UNKNOWN";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTAGameAutographRewardResponse_Result",
      );
  }
}

export interface CMsgDOTADestroyLobbyRequest {
}

export interface CMsgDOTADestroyLobbyResponse {
  result: CMsgDOTADestroyLobbyResponse_Result;
}

export enum CMsgDOTADestroyLobbyResponse_Result {
  SUCCESS = 0,
  ERROR_UNKNOWN = 1,
}

export function cMsgDOTADestroyLobbyResponse_ResultFromJSON(object: any): CMsgDOTADestroyLobbyResponse_Result {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgDOTADestroyLobbyResponse_Result.SUCCESS;
    case 1:
    case "ERROR_UNKNOWN":
      return CMsgDOTADestroyLobbyResponse_Result.ERROR_UNKNOWN;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTADestroyLobbyResponse_Result",
      );
  }
}

export function cMsgDOTADestroyLobbyResponse_ResultToJSON(object: CMsgDOTADestroyLobbyResponse_Result): string {
  switch (object) {
    case CMsgDOTADestroyLobbyResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgDOTADestroyLobbyResponse_Result.ERROR_UNKNOWN:
      return "ERROR_UNKNOWN";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTADestroyLobbyResponse_Result",
      );
  }
}

export interface CMsgDOTAGetRecentPlayTimeFriendsRequest {
}

export interface CMsgDOTAGetRecentPlayTimeFriendsResponse {
  accountIds: number[];
}

export interface CMsgPurchaseItemWithEventPoints {
  itemDef: number;
  quantity: number;
  eventId: EEvent;
  usePremiumPoints: boolean;
}

export interface CMsgPurchaseItemWithEventPointsResponse {
  result: CMsgPurchaseItemWithEventPointsResponse_Result;
}

export enum CMsgPurchaseItemWithEventPointsResponse_Result {
  SUCCESS = 0,
  UNKNOWN_EVENT = 1,
  UNKNOWN_ITEM = 2,
  BAD_QUANTITY = 3,
  NOT_PURCHASEABLE = 4,
  SDO_LOAD_FAILED = 5,
  NOT_ENOUGH_POINTS = 6,
  SQL_ERROR = 7,
  FAILED_TO_SEND = 8,
  SERVER_ERROR = 9,
  NOT_ALLOWED = 10,
  CANCELLED = 11,
  CLIENT_ERROR = 12,
  SUBSCRIPTION_REQUIRED = 13,
}

export function cMsgPurchaseItemWithEventPointsResponse_ResultFromJSON(
  object: any,
): CMsgPurchaseItemWithEventPointsResponse_Result {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgPurchaseItemWithEventPointsResponse_Result.SUCCESS;
    case 1:
    case "UNKNOWN_EVENT":
      return CMsgPurchaseItemWithEventPointsResponse_Result.UNKNOWN_EVENT;
    case 2:
    case "UNKNOWN_ITEM":
      return CMsgPurchaseItemWithEventPointsResponse_Result.UNKNOWN_ITEM;
    case 3:
    case "BAD_QUANTITY":
      return CMsgPurchaseItemWithEventPointsResponse_Result.BAD_QUANTITY;
    case 4:
    case "NOT_PURCHASEABLE":
      return CMsgPurchaseItemWithEventPointsResponse_Result.NOT_PURCHASEABLE;
    case 5:
    case "SDO_LOAD_FAILED":
      return CMsgPurchaseItemWithEventPointsResponse_Result.SDO_LOAD_FAILED;
    case 6:
    case "NOT_ENOUGH_POINTS":
      return CMsgPurchaseItemWithEventPointsResponse_Result.NOT_ENOUGH_POINTS;
    case 7:
    case "SQL_ERROR":
      return CMsgPurchaseItemWithEventPointsResponse_Result.SQL_ERROR;
    case 8:
    case "FAILED_TO_SEND":
      return CMsgPurchaseItemWithEventPointsResponse_Result.FAILED_TO_SEND;
    case 9:
    case "SERVER_ERROR":
      return CMsgPurchaseItemWithEventPointsResponse_Result.SERVER_ERROR;
    case 10:
    case "NOT_ALLOWED":
      return CMsgPurchaseItemWithEventPointsResponse_Result.NOT_ALLOWED;
    case 11:
    case "CANCELLED":
      return CMsgPurchaseItemWithEventPointsResponse_Result.CANCELLED;
    case 12:
    case "CLIENT_ERROR":
      return CMsgPurchaseItemWithEventPointsResponse_Result.CLIENT_ERROR;
    case 13:
    case "SUBSCRIPTION_REQUIRED":
      return CMsgPurchaseItemWithEventPointsResponse_Result.SUBSCRIPTION_REQUIRED;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgPurchaseItemWithEventPointsResponse_Result",
      );
  }
}

export function cMsgPurchaseItemWithEventPointsResponse_ResultToJSON(
  object: CMsgPurchaseItemWithEventPointsResponse_Result,
): string {
  switch (object) {
    case CMsgPurchaseItemWithEventPointsResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgPurchaseItemWithEventPointsResponse_Result.UNKNOWN_EVENT:
      return "UNKNOWN_EVENT";
    case CMsgPurchaseItemWithEventPointsResponse_Result.UNKNOWN_ITEM:
      return "UNKNOWN_ITEM";
    case CMsgPurchaseItemWithEventPointsResponse_Result.BAD_QUANTITY:
      return "BAD_QUANTITY";
    case CMsgPurchaseItemWithEventPointsResponse_Result.NOT_PURCHASEABLE:
      return "NOT_PURCHASEABLE";
    case CMsgPurchaseItemWithEventPointsResponse_Result.SDO_LOAD_FAILED:
      return "SDO_LOAD_FAILED";
    case CMsgPurchaseItemWithEventPointsResponse_Result.NOT_ENOUGH_POINTS:
      return "NOT_ENOUGH_POINTS";
    case CMsgPurchaseItemWithEventPointsResponse_Result.SQL_ERROR:
      return "SQL_ERROR";
    case CMsgPurchaseItemWithEventPointsResponse_Result.FAILED_TO_SEND:
      return "FAILED_TO_SEND";
    case CMsgPurchaseItemWithEventPointsResponse_Result.SERVER_ERROR:
      return "SERVER_ERROR";
    case CMsgPurchaseItemWithEventPointsResponse_Result.NOT_ALLOWED:
      return "NOT_ALLOWED";
    case CMsgPurchaseItemWithEventPointsResponse_Result.CANCELLED:
      return "CANCELLED";
    case CMsgPurchaseItemWithEventPointsResponse_Result.CLIENT_ERROR:
      return "CLIENT_ERROR";
    case CMsgPurchaseItemWithEventPointsResponse_Result.SUBSCRIPTION_REQUIRED:
      return "SUBSCRIPTION_REQUIRED";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgPurchaseItemWithEventPointsResponse_Result",
      );
  }
}

export interface CMsgPurchaseHeroRandomRelic {
  heroId: number;
  relicRarity: EHeroRelicRarity;
}

export interface CMsgPurchaseHeroRandomRelicResponse {
  result: EPurchaseHeroRelicResult;
  killEaterType: number;
}

export interface CMsgClientToGCRequestPlusWeeklyChallengeResult {
  eventId: EEvent;
  week: number;
}

export interface CMsgClientToGCRequestPlusWeeklyChallengeResultResponse {
}

export interface CMsgProfileRequest {
  accountId: number;
}

export interface CMsgProfileResponse {
  backgroundItem: CSOEconItem | undefined;
  featuredHeroes: CMsgProfileResponse_FeaturedHero[];
  recentMatches: CMsgProfileResponse_MatchInfo[];
  successfulHeroes: CMsgSuccessfulHero[];
  recentMatchDetails: CMsgRecentMatchInfo | undefined;
  result: CMsgProfileResponse_EResponse;
  stickerbookPage: CMsgStickerbookPage | undefined;
}

export enum CMsgProfileResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
}

export function cMsgProfileResponse_EResponseFromJSON(object: any): CMsgProfileResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgProfileResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgProfileResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgProfileResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgProfileResponse_EResponse.k_eDisabled;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgProfileResponse_EResponse",
      );
  }
}

export function cMsgProfileResponse_EResponseToJSON(object: CMsgProfileResponse_EResponse): string {
  switch (object) {
    case CMsgProfileResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgProfileResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgProfileResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgProfileResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgProfileResponse_EResponse",
      );
  }
}

export interface CMsgProfileResponse_FeaturedHero {
  heroId: number;
  equippedEconItems: CSOEconItem[];
  manuallySet: boolean;
  plusHeroXp: number;
  plusHeroRelicsItem: CSOEconItem | undefined;
}

export interface CMsgProfileResponse_MatchInfo {
  matchId: string;
  matchTimestamp: number;
  performanceRating: number;
  heroId: number;
  wonMatch: boolean;
}

export interface CMsgProfileUpdate {
  backgroundItemId: string;
  featuredHeroIds: number[];
}

export interface CMsgProfileUpdateResponse {
  result: CMsgProfileUpdateResponse_Result;
}

export enum CMsgProfileUpdateResponse_Result {
  SUCCESS = 0,
  FAILURE = 1,
  FAILURE_BAD_HERO1 = 2,
  FAILURE_BAD_HERO2 = 3,
  FAILURE_BAD_HERO3 = 4,
}

export function cMsgProfileUpdateResponse_ResultFromJSON(object: any): CMsgProfileUpdateResponse_Result {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgProfileUpdateResponse_Result.SUCCESS;
    case 1:
    case "FAILURE":
      return CMsgProfileUpdateResponse_Result.FAILURE;
    case 2:
    case "FAILURE_BAD_HERO1":
      return CMsgProfileUpdateResponse_Result.FAILURE_BAD_HERO1;
    case 3:
    case "FAILURE_BAD_HERO2":
      return CMsgProfileUpdateResponse_Result.FAILURE_BAD_HERO2;
    case 4:
    case "FAILURE_BAD_HERO3":
      return CMsgProfileUpdateResponse_Result.FAILURE_BAD_HERO3;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgProfileUpdateResponse_Result",
      );
  }
}

export function cMsgProfileUpdateResponse_ResultToJSON(object: CMsgProfileUpdateResponse_Result): string {
  switch (object) {
    case CMsgProfileUpdateResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgProfileUpdateResponse_Result.FAILURE:
      return "FAILURE";
    case CMsgProfileUpdateResponse_Result.FAILURE_BAD_HERO1:
      return "FAILURE_BAD_HERO1";
    case CMsgProfileUpdateResponse_Result.FAILURE_BAD_HERO2:
      return "FAILURE_BAD_HERO2";
    case CMsgProfileUpdateResponse_Result.FAILURE_BAD_HERO3:
      return "FAILURE_BAD_HERO3";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgProfileUpdateResponse_Result",
      );
  }
}

export interface CMsgTalentWinRates {
  lastRun: number;
  abilityId: number;
  gameCount: number;
  winCount: number;
}

export interface CMsgGlobalHeroAverages {
  lastRun: number;
  avgGoldPerMin: number;
  avgXpPerMin: number;
  avgKills: number;
  avgDeaths: number;
  avgAssists: number;
  avgLastHits: number;
  avgDenies: number;
  avgNetWorth: number;
}

export interface CMsgHeroGlobalDataRequest {
  heroId: number;
}

export interface CMsgHeroGlobalDataResponse {
  heroId: number;
  heroDataPerChunk: CMsgHeroGlobalDataResponse_HeroDataPerRankChunk[];
}

export interface CMsgHeroGlobalDataResponse_GraphData {
  day: number;
  winPercent: number;
  pickPercent: number;
  banPercent: number;
}

export interface CMsgHeroGlobalDataResponse_WeekData {
  week: number;
  winPercent: number;
  pickPercent: number;
  banPercent: number;
}

export interface CMsgHeroGlobalDataResponse_HeroDataPerRankChunk {
  rankChunk: number;
  talentWinRates: CMsgTalentWinRates[];
  heroAverages: CMsgGlobalHeroAverages | undefined;
  graphData: CMsgHeroGlobalDataResponse_GraphData[];
  weekData: CMsgHeroGlobalDataResponse_WeekData[];
}

export interface CMsgHeroGlobalDataAllHeroes {
  heroes: CMsgHeroGlobalDataResponse[];
}

export interface CMsgHeroGlobalDataHeroesAlliesAndEnemies {
  rankedHeroData: CMsgHeroGlobalDataHeroesAlliesAndEnemies_RankedHeroData[];
}

export interface CMsgHeroGlobalDataHeroesAlliesAndEnemies_HeroData {
  heroId: number;
  winRate: number;
  firstOtherHeroId: number;
  allyWinRate: number[];
  enemyWinRate: number[];
}

export interface CMsgHeroGlobalDataHeroesAlliesAndEnemies_RankedHeroData {
  rank: number;
  heroData: CMsgHeroGlobalDataHeroesAlliesAndEnemies_HeroData[];
}

export interface CMsgPrivateMetadataKeyRequest {
  matchId: string;
}

export interface CMsgPrivateMetadataKeyResponse {
  privateKey: number;
}

export interface CMsgActivatePlusFreeTrialResponse {
  result: CMsgActivatePlusFreeTrialResponse_Result;
}

export enum CMsgActivatePlusFreeTrialResponse_Result {
  SUCCESS = 0,
  ERROR_GENERIC = 1,
  ERROR_ALREADY_IN_FREE_TRIAL = 2,
  ERROR_ALREADY_USED_FREE_TRIAL = 3,
  ERROR_OFFER_NOT_VALID = 4,
}

export function cMsgActivatePlusFreeTrialResponse_ResultFromJSON(
  object: any,
): CMsgActivatePlusFreeTrialResponse_Result {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgActivatePlusFreeTrialResponse_Result.SUCCESS;
    case 1:
    case "ERROR_GENERIC":
      return CMsgActivatePlusFreeTrialResponse_Result.ERROR_GENERIC;
    case 2:
    case "ERROR_ALREADY_IN_FREE_TRIAL":
      return CMsgActivatePlusFreeTrialResponse_Result.ERROR_ALREADY_IN_FREE_TRIAL;
    case 3:
    case "ERROR_ALREADY_USED_FREE_TRIAL":
      return CMsgActivatePlusFreeTrialResponse_Result.ERROR_ALREADY_USED_FREE_TRIAL;
    case 4:
    case "ERROR_OFFER_NOT_VALID":
      return CMsgActivatePlusFreeTrialResponse_Result.ERROR_OFFER_NOT_VALID;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgActivatePlusFreeTrialResponse_Result",
      );
  }
}

export function cMsgActivatePlusFreeTrialResponse_ResultToJSON(
  object: CMsgActivatePlusFreeTrialResponse_Result,
): string {
  switch (object) {
    case CMsgActivatePlusFreeTrialResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgActivatePlusFreeTrialResponse_Result.ERROR_GENERIC:
      return "ERROR_GENERIC";
    case CMsgActivatePlusFreeTrialResponse_Result.ERROR_ALREADY_IN_FREE_TRIAL:
      return "ERROR_ALREADY_IN_FREE_TRIAL";
    case CMsgActivatePlusFreeTrialResponse_Result.ERROR_ALREADY_USED_FREE_TRIAL:
      return "ERROR_ALREADY_USED_FREE_TRIAL";
    case CMsgActivatePlusFreeTrialResponse_Result.ERROR_OFFER_NOT_VALID:
      return "ERROR_OFFER_NOT_VALID";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgActivatePlusFreeTrialResponse_Result",
      );
  }
}

export interface CMsgGCToClientCavernCrawlMapPathCompleted {
  eventId: number;
  heroIdCompleted: number;
  completedPaths: CMsgGCToClientCavernCrawlMapPathCompleted_CompletedPathInfo[];
  mapVariant: number;
}

export interface CMsgGCToClientCavernCrawlMapPathCompleted_CompletedPathInfo {
  pathIdCompleted: number;
  receivedUltraRareReward: boolean;
  halfCompleted: boolean;
}

export interface CMsgGCToClientCavernCrawlMapUpdated {
  eventId: number;
}

export interface CMsgClientToGCCavernCrawlClaimRoom {
  eventId: number;
  roomId: number;
  mapVariant: number;
}

export interface CMsgClientToGCCavernCrawlClaimRoomResponse {
  result: CMsgClientToGCCavernCrawlClaimRoomResponse_Result;
}

export enum CMsgClientToGCCavernCrawlClaimRoomResponse_Result {
  SUCCESS = 0,
  ERROR_UNKNOWN = 1,
  RECEIVED_ULTRA_RARE_REWARD = 2,
}

export function cMsgClientToGCCavernCrawlClaimRoomResponse_ResultFromJSON(
  object: any,
): CMsgClientToGCCavernCrawlClaimRoomResponse_Result {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgClientToGCCavernCrawlClaimRoomResponse_Result.SUCCESS;
    case 1:
    case "ERROR_UNKNOWN":
      return CMsgClientToGCCavernCrawlClaimRoomResponse_Result.ERROR_UNKNOWN;
    case 2:
    case "RECEIVED_ULTRA_RARE_REWARD":
      return CMsgClientToGCCavernCrawlClaimRoomResponse_Result.RECEIVED_ULTRA_RARE_REWARD;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCCavernCrawlClaimRoomResponse_Result",
      );
  }
}

export function cMsgClientToGCCavernCrawlClaimRoomResponse_ResultToJSON(
  object: CMsgClientToGCCavernCrawlClaimRoomResponse_Result,
): string {
  switch (object) {
    case CMsgClientToGCCavernCrawlClaimRoomResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgClientToGCCavernCrawlClaimRoomResponse_Result.ERROR_UNKNOWN:
      return "ERROR_UNKNOWN";
    case CMsgClientToGCCavernCrawlClaimRoomResponse_Result.RECEIVED_ULTRA_RARE_REWARD:
      return "RECEIVED_ULTRA_RARE_REWARD";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCCavernCrawlClaimRoomResponse_Result",
      );
  }
}

export interface CMsgClientToGCCavernCrawlUseItemOnRoom {
  eventId: number;
  roomId: number;
  itemType: number;
  mapVariant: number;
}

export interface CMsgClientToGCCavernCrawlUseItemOnRoomResponse {
  result: CMsgClientToGCCavernCrawlUseItemOnRoomResponse_Result;
}

export enum CMsgClientToGCCavernCrawlUseItemOnRoomResponse_Result {
  SUCCESS = 0,
  ERROR_UNKNOWN = 1,
  RECEIVED_ULTRA_RARE_REWARD = 2,
}

export function cMsgClientToGCCavernCrawlUseItemOnRoomResponse_ResultFromJSON(
  object: any,
): CMsgClientToGCCavernCrawlUseItemOnRoomResponse_Result {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgClientToGCCavernCrawlUseItemOnRoomResponse_Result.SUCCESS;
    case 1:
    case "ERROR_UNKNOWN":
      return CMsgClientToGCCavernCrawlUseItemOnRoomResponse_Result.ERROR_UNKNOWN;
    case 2:
    case "RECEIVED_ULTRA_RARE_REWARD":
      return CMsgClientToGCCavernCrawlUseItemOnRoomResponse_Result.RECEIVED_ULTRA_RARE_REWARD;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCCavernCrawlUseItemOnRoomResponse_Result",
      );
  }
}

export function cMsgClientToGCCavernCrawlUseItemOnRoomResponse_ResultToJSON(
  object: CMsgClientToGCCavernCrawlUseItemOnRoomResponse_Result,
): string {
  switch (object) {
    case CMsgClientToGCCavernCrawlUseItemOnRoomResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgClientToGCCavernCrawlUseItemOnRoomResponse_Result.ERROR_UNKNOWN:
      return "ERROR_UNKNOWN";
    case CMsgClientToGCCavernCrawlUseItemOnRoomResponse_Result.RECEIVED_ULTRA_RARE_REWARD:
      return "RECEIVED_ULTRA_RARE_REWARD";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCCavernCrawlUseItemOnRoomResponse_Result",
      );
  }
}

export interface CMsgClientToGCCavernCrawlUseItemOnPath {
  eventId: number;
  pathId: number;
  itemType: number;
  mapVariant: number;
}

export interface CMsgClientToGCCavernCrawlUseItemOnPathResponse {
  result: CMsgClientToGCCavernCrawlUseItemOnPathResponse_Result;
}

export enum CMsgClientToGCCavernCrawlUseItemOnPathResponse_Result {
  SUCCESS = 0,
  ERROR_UNKNOWN = 1,
  RECEIVED_ULTRA_RARE_REWARD = 2,
}

export function cMsgClientToGCCavernCrawlUseItemOnPathResponse_ResultFromJSON(
  object: any,
): CMsgClientToGCCavernCrawlUseItemOnPathResponse_Result {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgClientToGCCavernCrawlUseItemOnPathResponse_Result.SUCCESS;
    case 1:
    case "ERROR_UNKNOWN":
      return CMsgClientToGCCavernCrawlUseItemOnPathResponse_Result.ERROR_UNKNOWN;
    case 2:
    case "RECEIVED_ULTRA_RARE_REWARD":
      return CMsgClientToGCCavernCrawlUseItemOnPathResponse_Result.RECEIVED_ULTRA_RARE_REWARD;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCCavernCrawlUseItemOnPathResponse_Result",
      );
  }
}

export function cMsgClientToGCCavernCrawlUseItemOnPathResponse_ResultToJSON(
  object: CMsgClientToGCCavernCrawlUseItemOnPathResponse_Result,
): string {
  switch (object) {
    case CMsgClientToGCCavernCrawlUseItemOnPathResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgClientToGCCavernCrawlUseItemOnPathResponse_Result.ERROR_UNKNOWN:
      return "ERROR_UNKNOWN";
    case CMsgClientToGCCavernCrawlUseItemOnPathResponse_Result.RECEIVED_ULTRA_RARE_REWARD:
      return "RECEIVED_ULTRA_RARE_REWARD";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCCavernCrawlUseItemOnPathResponse_Result",
      );
  }
}

export interface CMsgClientToGCCavernCrawlRequestMapState {
  eventId: number;
}

export interface CMsgClientToGCCavernCrawlRequestMapStateResponse {
  result: CMsgClientToGCCavernCrawlRequestMapStateResponse_Result;
  availableMapVariantsMask: number;
  inventoryItem: CMsgClientToGCCavernCrawlRequestMapStateResponse_InventoryItem[];
  mapVariants: CMsgClientToGCCavernCrawlRequestMapStateResponse_MapVariant[];
}

export enum CMsgClientToGCCavernCrawlRequestMapStateResponse_Result {
  SUCCESS = 0,
  ERROR_UNKNOWN = 1,
  EVENT_NOT_OWNED = 2,
}

export function cMsgClientToGCCavernCrawlRequestMapStateResponse_ResultFromJSON(
  object: any,
): CMsgClientToGCCavernCrawlRequestMapStateResponse_Result {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgClientToGCCavernCrawlRequestMapStateResponse_Result.SUCCESS;
    case 1:
    case "ERROR_UNKNOWN":
      return CMsgClientToGCCavernCrawlRequestMapStateResponse_Result.ERROR_UNKNOWN;
    case 2:
    case "EVENT_NOT_OWNED":
      return CMsgClientToGCCavernCrawlRequestMapStateResponse_Result.EVENT_NOT_OWNED;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCCavernCrawlRequestMapStateResponse_Result",
      );
  }
}

export function cMsgClientToGCCavernCrawlRequestMapStateResponse_ResultToJSON(
  object: CMsgClientToGCCavernCrawlRequestMapStateResponse_Result,
): string {
  switch (object) {
    case CMsgClientToGCCavernCrawlRequestMapStateResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgClientToGCCavernCrawlRequestMapStateResponse_Result.ERROR_UNKNOWN:
      return "ERROR_UNKNOWN";
    case CMsgClientToGCCavernCrawlRequestMapStateResponse_Result.EVENT_NOT_OWNED:
      return "EVENT_NOT_OWNED";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCCavernCrawlRequestMapStateResponse_Result",
      );
  }
}

export interface CMsgClientToGCCavernCrawlRequestMapStateResponse_SwappedChallenge {
  pathId1: number;
  pathId2: number;
}

export interface CMsgClientToGCCavernCrawlRequestMapStateResponse_InventoryItem {
  itemType: number;
  count: number;
}

export interface CMsgClientToGCCavernCrawlRequestMapStateResponse_TreasureMap {
  mapRoomId: number;
  revealedRoomId: number;
}

export interface CMsgClientToGCCavernCrawlRequestMapStateResponse_MapVariant {
  mapVariant: number;
  claimedRooms1: string;
  claimedRooms2: string;
  revealedRooms1: string;
  revealedRooms2: string;
  completedPaths1: string;
  completedPaths2: string;
  completedPaths3: string;
  completedPaths4: string;
  halfCompletedPaths1: string;
  halfCompletedPaths2: string;
  halfCompletedPaths3: string;
  halfCompletedPaths4: string;
  swappedChallenge: CMsgClientToGCCavernCrawlRequestMapStateResponse_SwappedChallenge[];
  ultraRareRewardRoomNumber: number;
  treasureMap: CMsgClientToGCCavernCrawlRequestMapStateResponse_TreasureMap[];
}

export interface CMsgClientToGCCavernCrawlGetClaimedRoomCount {
  eventId: number;
}

export interface CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse {
  result: CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_Result;
  mapVariants: CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_MapVariant[];
  availableMapVariantsMask: number;
}

export enum CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_Result {
  SUCCESS = 0,
  ERROR_UNKNOWN = 1,
  EVENT_NOT_OWNED = 2,
}

export function cMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_ResultFromJSON(
  object: any,
): CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_Result {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_Result.SUCCESS;
    case 1:
    case "ERROR_UNKNOWN":
      return CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_Result.ERROR_UNKNOWN;
    case 2:
    case "EVENT_NOT_OWNED":
      return CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_Result.EVENT_NOT_OWNED;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_Result",
      );
  }
}

export function cMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_ResultToJSON(
  object: CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_Result,
): string {
  switch (object) {
    case CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_Result.ERROR_UNKNOWN:
      return "ERROR_UNKNOWN";
    case CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_Result.EVENT_NOT_OWNED:
      return "EVENT_NOT_OWNED";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_Result",
      );
  }
}

export interface CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_MapVariant {
  mapVariant: number;
  count: number;
}

export interface CMsgDOTAMutationList {
  mutations: CMsgDOTAMutationList_Mutation[];
}

export interface CMsgDOTAMutationList_Mutation {
  id: number;
  name: string;
  description: string;
}

export interface CMsgEventTipsSummaryRequest {
  eventId: EEvent;
  accountId: number;
}

export interface CMsgEventTipsSummaryResponse {
  result: boolean;
  tipsReceived: CMsgEventTipsSummaryResponse_Tipper[];
}

export interface CMsgEventTipsSummaryResponse_Tipper {
  tipperAccountId: number;
  tipCount: number;
}

export interface CMsgSocialFeedRequest {
  accountId: number;
  selfOnly: boolean;
}

export interface CMsgSocialFeedResponse {
  result: CMsgSocialFeedResponse_Result;
  feedEvents: CMsgSocialFeedResponse_FeedEvent[];
}

export enum CMsgSocialFeedResponse_Result {
  SUCCESS = 0,
  FAILED_TO_LOAD_FRIENDS = 1,
  FAILED_TO_LOAD_FEED_DATA = 2,
  FAILED_TO_LOAD_FEED_ENTRY = 3,
  FAILED_TO_LOAD_COMMENTS = 4,
  FAILED_TOO_MANY_REQUESTS = 5,
}

export function cMsgSocialFeedResponse_ResultFromJSON(object: any): CMsgSocialFeedResponse_Result {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgSocialFeedResponse_Result.SUCCESS;
    case 1:
    case "FAILED_TO_LOAD_FRIENDS":
      return CMsgSocialFeedResponse_Result.FAILED_TO_LOAD_FRIENDS;
    case 2:
    case "FAILED_TO_LOAD_FEED_DATA":
      return CMsgSocialFeedResponse_Result.FAILED_TO_LOAD_FEED_DATA;
    case 3:
    case "FAILED_TO_LOAD_FEED_ENTRY":
      return CMsgSocialFeedResponse_Result.FAILED_TO_LOAD_FEED_ENTRY;
    case 4:
    case "FAILED_TO_LOAD_COMMENTS":
      return CMsgSocialFeedResponse_Result.FAILED_TO_LOAD_COMMENTS;
    case 5:
    case "FAILED_TOO_MANY_REQUESTS":
      return CMsgSocialFeedResponse_Result.FAILED_TOO_MANY_REQUESTS;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgSocialFeedResponse_Result",
      );
  }
}

export function cMsgSocialFeedResponse_ResultToJSON(object: CMsgSocialFeedResponse_Result): string {
  switch (object) {
    case CMsgSocialFeedResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgSocialFeedResponse_Result.FAILED_TO_LOAD_FRIENDS:
      return "FAILED_TO_LOAD_FRIENDS";
    case CMsgSocialFeedResponse_Result.FAILED_TO_LOAD_FEED_DATA:
      return "FAILED_TO_LOAD_FEED_DATA";
    case CMsgSocialFeedResponse_Result.FAILED_TO_LOAD_FEED_ENTRY:
      return "FAILED_TO_LOAD_FEED_ENTRY";
    case CMsgSocialFeedResponse_Result.FAILED_TO_LOAD_COMMENTS:
      return "FAILED_TO_LOAD_COMMENTS";
    case CMsgSocialFeedResponse_Result.FAILED_TOO_MANY_REQUESTS:
      return "FAILED_TOO_MANY_REQUESTS";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgSocialFeedResponse_Result",
      );
  }
}

export interface CMsgSocialFeedResponse_FeedEvent {
  feedEventId: string;
  accountId: number;
  timestamp: number;
  commentCount: number;
  eventType: number;
  eventSubType: number;
  paramBigInt1: string;
  paramInt1: number;
  paramInt2: number;
  paramInt3: number;
  paramString: string;
}

export interface CMsgSocialFeedCommentsRequest {
  feedEventId: string;
}

export interface CMsgSocialFeedCommentsResponse {
  result: CMsgSocialFeedCommentsResponse_Result;
  feedComments: CMsgSocialFeedCommentsResponse_FeedComment[];
}

export enum CMsgSocialFeedCommentsResponse_Result {
  SUCCESS = 0,
  FAILED_TOO_MANY_REQUESTS = 1,
  FAILED_TO_LOAD_COMMENTS = 2,
}

export function cMsgSocialFeedCommentsResponse_ResultFromJSON(object: any): CMsgSocialFeedCommentsResponse_Result {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgSocialFeedCommentsResponse_Result.SUCCESS;
    case 1:
    case "FAILED_TOO_MANY_REQUESTS":
      return CMsgSocialFeedCommentsResponse_Result.FAILED_TOO_MANY_REQUESTS;
    case 2:
    case "FAILED_TO_LOAD_COMMENTS":
      return CMsgSocialFeedCommentsResponse_Result.FAILED_TO_LOAD_COMMENTS;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgSocialFeedCommentsResponse_Result",
      );
  }
}

export function cMsgSocialFeedCommentsResponse_ResultToJSON(object: CMsgSocialFeedCommentsResponse_Result): string {
  switch (object) {
    case CMsgSocialFeedCommentsResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgSocialFeedCommentsResponse_Result.FAILED_TOO_MANY_REQUESTS:
      return "FAILED_TOO_MANY_REQUESTS";
    case CMsgSocialFeedCommentsResponse_Result.FAILED_TO_LOAD_COMMENTS:
      return "FAILED_TO_LOAD_COMMENTS";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgSocialFeedCommentsResponse_Result",
      );
  }
}

export interface CMsgSocialFeedCommentsResponse_FeedComment {
  commenterAccountId: number;
  timestamp: number;
  commentText: string;
}

export interface CMsgClientToGCPlayerCardSpecificPurchaseRequest {
  playerAccountId: number;
  eventId: number;
  cardDustItemId: string;
}

export interface CMsgClientToGCPlayerCardSpecificPurchaseResponse {
  result: CMsgClientToGCPlayerCardSpecificPurchaseResponse_Result;
  itemId: string;
}

export enum CMsgClientToGCPlayerCardSpecificPurchaseResponse_Result {
  SUCCESS = 1,
  ERROR_INTERNAL = 2,
  ERROR_INSUFFICIENT_DUST = 3,
  ERROR_ITEM_NOT_DUST_ITEM = 4,
  ERROR_FAILED_CARD_PACK_CREATE = 5,
  ERROR_NOT_AVAILABLE = 6,
}

export function cMsgClientToGCPlayerCardSpecificPurchaseResponse_ResultFromJSON(
  object: any,
): CMsgClientToGCPlayerCardSpecificPurchaseResponse_Result {
  switch (object) {
    case 1:
    case "SUCCESS":
      return CMsgClientToGCPlayerCardSpecificPurchaseResponse_Result.SUCCESS;
    case 2:
    case "ERROR_INTERNAL":
      return CMsgClientToGCPlayerCardSpecificPurchaseResponse_Result.ERROR_INTERNAL;
    case 3:
    case "ERROR_INSUFFICIENT_DUST":
      return CMsgClientToGCPlayerCardSpecificPurchaseResponse_Result.ERROR_INSUFFICIENT_DUST;
    case 4:
    case "ERROR_ITEM_NOT_DUST_ITEM":
      return CMsgClientToGCPlayerCardSpecificPurchaseResponse_Result.ERROR_ITEM_NOT_DUST_ITEM;
    case 5:
    case "ERROR_FAILED_CARD_PACK_CREATE":
      return CMsgClientToGCPlayerCardSpecificPurchaseResponse_Result.ERROR_FAILED_CARD_PACK_CREATE;
    case 6:
    case "ERROR_NOT_AVAILABLE":
      return CMsgClientToGCPlayerCardSpecificPurchaseResponse_Result.ERROR_NOT_AVAILABLE;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCPlayerCardSpecificPurchaseResponse_Result",
      );
  }
}

export function cMsgClientToGCPlayerCardSpecificPurchaseResponse_ResultToJSON(
  object: CMsgClientToGCPlayerCardSpecificPurchaseResponse_Result,
): string {
  switch (object) {
    case CMsgClientToGCPlayerCardSpecificPurchaseResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgClientToGCPlayerCardSpecificPurchaseResponse_Result.ERROR_INTERNAL:
      return "ERROR_INTERNAL";
    case CMsgClientToGCPlayerCardSpecificPurchaseResponse_Result.ERROR_INSUFFICIENT_DUST:
      return "ERROR_INSUFFICIENT_DUST";
    case CMsgClientToGCPlayerCardSpecificPurchaseResponse_Result.ERROR_ITEM_NOT_DUST_ITEM:
      return "ERROR_ITEM_NOT_DUST_ITEM";
    case CMsgClientToGCPlayerCardSpecificPurchaseResponse_Result.ERROR_FAILED_CARD_PACK_CREATE:
      return "ERROR_FAILED_CARD_PACK_CREATE";
    case CMsgClientToGCPlayerCardSpecificPurchaseResponse_Result.ERROR_NOT_AVAILABLE:
      return "ERROR_NOT_AVAILABLE";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCPlayerCardSpecificPurchaseResponse_Result",
      );
  }
}

export interface CMsgClientToGCRequestContestVotes {
  contestId: number;
}

export interface CMsgClientToGCRequestContestVotesResponse {
  result: CMsgClientToGCRequestContestVotesResponse_EResponse;
  votes: CMsgClientToGCRequestContestVotesResponse_ItemVote[];
}

export enum CMsgClientToGCRequestContestVotesResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
}

export function cMsgClientToGCRequestContestVotesResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCRequestContestVotesResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCRequestContestVotesResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCRequestContestVotesResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgClientToGCRequestContestVotesResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgClientToGCRequestContestVotesResponse_EResponse.k_eDisabled;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCRequestContestVotesResponse_EResponse",
      );
  }
}

export function cMsgClientToGCRequestContestVotesResponse_EResponseToJSON(
  object: CMsgClientToGCRequestContestVotesResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCRequestContestVotesResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCRequestContestVotesResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCRequestContestVotesResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCRequestContestVotesResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCRequestContestVotesResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCRequestContestVotesResponse_ItemVote {
  contestItemId: string;
  vote: number;
}

export interface CMsgClientToGCRecordContestVote {
  contestId: number;
  contestItemId: string;
  vote: number;
}

export interface CMsgGCToClientRecordContestVoteResponse {
  eresult: CMsgGCToClientRecordContestVoteResponse_EResult;
}

export enum CMsgGCToClientRecordContestVoteResponse_EResult {
  SUCCESS = 0,
  FAILED_EVENT_NOT_OWNED = 1,
  FAILED_SQL_INSERT_FAILED = 2,
  FAILED_INVALID_CONTEST = 3,
  FAILED_CONTEST_NOT_ACTIVE = 4,
  FAILED_TIMEOUT = 5,
}

export function cMsgGCToClientRecordContestVoteResponse_EResultFromJSON(
  object: any,
): CMsgGCToClientRecordContestVoteResponse_EResult {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgGCToClientRecordContestVoteResponse_EResult.SUCCESS;
    case 1:
    case "FAILED_EVENT_NOT_OWNED":
      return CMsgGCToClientRecordContestVoteResponse_EResult.FAILED_EVENT_NOT_OWNED;
    case 2:
    case "FAILED_SQL_INSERT_FAILED":
      return CMsgGCToClientRecordContestVoteResponse_EResult.FAILED_SQL_INSERT_FAILED;
    case 3:
    case "FAILED_INVALID_CONTEST":
      return CMsgGCToClientRecordContestVoteResponse_EResult.FAILED_INVALID_CONTEST;
    case 4:
    case "FAILED_CONTEST_NOT_ACTIVE":
      return CMsgGCToClientRecordContestVoteResponse_EResult.FAILED_CONTEST_NOT_ACTIVE;
    case 5:
    case "FAILED_TIMEOUT":
      return CMsgGCToClientRecordContestVoteResponse_EResult.FAILED_TIMEOUT;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientRecordContestVoteResponse_EResult",
      );
  }
}

export function cMsgGCToClientRecordContestVoteResponse_EResultToJSON(
  object: CMsgGCToClientRecordContestVoteResponse_EResult,
): string {
  switch (object) {
    case CMsgGCToClientRecordContestVoteResponse_EResult.SUCCESS:
      return "SUCCESS";
    case CMsgGCToClientRecordContestVoteResponse_EResult.FAILED_EVENT_NOT_OWNED:
      return "FAILED_EVENT_NOT_OWNED";
    case CMsgGCToClientRecordContestVoteResponse_EResult.FAILED_SQL_INSERT_FAILED:
      return "FAILED_SQL_INSERT_FAILED";
    case CMsgGCToClientRecordContestVoteResponse_EResult.FAILED_INVALID_CONTEST:
      return "FAILED_INVALID_CONTEST";
    case CMsgGCToClientRecordContestVoteResponse_EResult.FAILED_CONTEST_NOT_ACTIVE:
      return "FAILED_CONTEST_NOT_ACTIVE";
    case CMsgGCToClientRecordContestVoteResponse_EResult.FAILED_TIMEOUT:
      return "FAILED_TIMEOUT";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientRecordContestVoteResponse_EResult",
      );
  }
}

export interface CMsgDevGrantEventPoints {
  eventId: EEvent;
  eventPoints: number;
  premiumPoints: number;
}

export interface CMsgDevGrantEventPointsResponse {
  result: EDevEventRequestResult;
}

export interface CMsgDevGrantEventAction {
  eventId: EEvent;
  actionId: number;
  actionScore: number;
}

export interface CMsgDevGrantEventActionResponse {
  result: EDevEventRequestResult;
}

export interface CMsgDevDeleteEventActions {
  eventId: EEvent;
  startActionId: number;
  endActionId: number;
  removeAudit: boolean;
}

export interface CMsgDevDeleteEventActionsResponse {
  result: EDevEventRequestResult;
}

export interface CMsgDevResetEventState {
  eventId: EEvent;
  removeAudit: boolean;
}

export interface CMsgDevResetEventStateResponse {
  result: EDevEventRequestResult;
}

export interface CMsgConsumeEventSupportGrantItem {
  itemId: string;
}

export interface CMsgConsumeEventSupportGrantItemResponse {
  result: ESupportEventRequestResult;
}

export interface CMsgClientToGCGetFilteredPlayers {
}

export interface CMsgGCToClientGetFilteredPlayersResponse {
  result: CMsgGCToClientGetFilteredPlayersResponse_Result;
  filteredPlayers: CMsgGCToClientGetFilteredPlayersResponse_CFilterEntry[];
  baseSlots: number;
  additionalSlots: number;
  nextSlotCost: number;
}

export enum CMsgGCToClientGetFilteredPlayersResponse_Result {
  SUCCESS = 0,
  FAILURE = 1,
}

export function cMsgGCToClientGetFilteredPlayersResponse_ResultFromJSON(
  object: any,
): CMsgGCToClientGetFilteredPlayersResponse_Result {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgGCToClientGetFilteredPlayersResponse_Result.SUCCESS;
    case 1:
    case "FAILURE":
      return CMsgGCToClientGetFilteredPlayersResponse_Result.FAILURE;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientGetFilteredPlayersResponse_Result",
      );
  }
}

export function cMsgGCToClientGetFilteredPlayersResponse_ResultToJSON(
  object: CMsgGCToClientGetFilteredPlayersResponse_Result,
): string {
  switch (object) {
    case CMsgGCToClientGetFilteredPlayersResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgGCToClientGetFilteredPlayersResponse_Result.FAILURE:
      return "FAILURE";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientGetFilteredPlayersResponse_Result",
      );
  }
}

export interface CMsgGCToClientGetFilteredPlayersResponse_CFilterEntry {
  accountId: number;
  timeAdded: number;
  timeExpires: number;
  note: string;
}

export interface CMsgClientToGCRemoveFilteredPlayer {
  accountIdToRemove: number;
}

export interface CMsgGCToClientRemoveFilteredPlayerResponse {
  result: CMsgGCToClientRemoveFilteredPlayerResponse_Result;
}

export enum CMsgGCToClientRemoveFilteredPlayerResponse_Result {
  SUCCESS = 0,
  FAILURE = 1,
}

export function cMsgGCToClientRemoveFilteredPlayerResponse_ResultFromJSON(
  object: any,
): CMsgGCToClientRemoveFilteredPlayerResponse_Result {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgGCToClientRemoveFilteredPlayerResponse_Result.SUCCESS;
    case 1:
    case "FAILURE":
      return CMsgGCToClientRemoveFilteredPlayerResponse_Result.FAILURE;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientRemoveFilteredPlayerResponse_Result",
      );
  }
}

export function cMsgGCToClientRemoveFilteredPlayerResponse_ResultToJSON(
  object: CMsgGCToClientRemoveFilteredPlayerResponse_Result,
): string {
  switch (object) {
    case CMsgGCToClientRemoveFilteredPlayerResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgGCToClientRemoveFilteredPlayerResponse_Result.FAILURE:
      return "FAILURE";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientRemoveFilteredPlayerResponse_Result",
      );
  }
}

export interface CMsgClientToGCPurchaseFilteredPlayerSlot {
  additionalSlotsCurrent: number;
}

export interface CMsgGCToClientPurchaseFilteredPlayerSlotResponse {
  result: CMsgGCToClientPurchaseFilteredPlayerSlotResponse_Result;
  additionalSlots: number;
  nextSlotCost: number;
}

export enum CMsgGCToClientPurchaseFilteredPlayerSlotResponse_Result {
  SUCCESS = 0,
  FAILURE = 1,
  CURRENT_SLOTCOUNT_DOESNT_MATCH = 2,
  CANT_AFFORD = 3,
}

export function cMsgGCToClientPurchaseFilteredPlayerSlotResponse_ResultFromJSON(
  object: any,
): CMsgGCToClientPurchaseFilteredPlayerSlotResponse_Result {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgGCToClientPurchaseFilteredPlayerSlotResponse_Result.SUCCESS;
    case 1:
    case "FAILURE":
      return CMsgGCToClientPurchaseFilteredPlayerSlotResponse_Result.FAILURE;
    case 2:
    case "CURRENT_SLOTCOUNT_DOESNT_MATCH":
      return CMsgGCToClientPurchaseFilteredPlayerSlotResponse_Result.CURRENT_SLOTCOUNT_DOESNT_MATCH;
    case 3:
    case "CANT_AFFORD":
      return CMsgGCToClientPurchaseFilteredPlayerSlotResponse_Result.CANT_AFFORD;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientPurchaseFilteredPlayerSlotResponse_Result",
      );
  }
}

export function cMsgGCToClientPurchaseFilteredPlayerSlotResponse_ResultToJSON(
  object: CMsgGCToClientPurchaseFilteredPlayerSlotResponse_Result,
): string {
  switch (object) {
    case CMsgGCToClientPurchaseFilteredPlayerSlotResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgGCToClientPurchaseFilteredPlayerSlotResponse_Result.FAILURE:
      return "FAILURE";
    case CMsgGCToClientPurchaseFilteredPlayerSlotResponse_Result.CURRENT_SLOTCOUNT_DOESNT_MATCH:
      return "CURRENT_SLOTCOUNT_DOESNT_MATCH";
    case CMsgGCToClientPurchaseFilteredPlayerSlotResponse_Result.CANT_AFFORD:
      return "CANT_AFFORD";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientPurchaseFilteredPlayerSlotResponse_Result",
      );
  }
}

export interface CMsgClientToGCUpdateFilteredPlayerNote {
  targetAccountId: number;
  newNote: string;
}

export interface CMsgGCToClientUpdateFilteredPlayerNoteResponse {
  result: CMsgGCToClientUpdateFilteredPlayerNoteResponse_Result;
}

export enum CMsgGCToClientUpdateFilteredPlayerNoteResponse_Result {
  SUCCESS = 0,
  FAILURE = 1,
  NOT_FOUND = 2,
}

export function cMsgGCToClientUpdateFilteredPlayerNoteResponse_ResultFromJSON(
  object: any,
): CMsgGCToClientUpdateFilteredPlayerNoteResponse_Result {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgGCToClientUpdateFilteredPlayerNoteResponse_Result.SUCCESS;
    case 1:
    case "FAILURE":
      return CMsgGCToClientUpdateFilteredPlayerNoteResponse_Result.FAILURE;
    case 2:
    case "NOT_FOUND":
      return CMsgGCToClientUpdateFilteredPlayerNoteResponse_Result.NOT_FOUND;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientUpdateFilteredPlayerNoteResponse_Result",
      );
  }
}

export function cMsgGCToClientUpdateFilteredPlayerNoteResponse_ResultToJSON(
  object: CMsgGCToClientUpdateFilteredPlayerNoteResponse_Result,
): string {
  switch (object) {
    case CMsgGCToClientUpdateFilteredPlayerNoteResponse_Result.SUCCESS:
      return "SUCCESS";
    case CMsgGCToClientUpdateFilteredPlayerNoteResponse_Result.FAILURE:
      return "FAILURE";
    case CMsgGCToClientUpdateFilteredPlayerNoteResponse_Result.NOT_FOUND:
      return "NOT_FOUND";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientUpdateFilteredPlayerNoteResponse_Result",
      );
  }
}

export interface CMsgPartySearchPlayer {
  accountId: number;
  matchId: string;
  creationTime: number;
}

export interface CMsgGCToClientPlayerBeaconState {
  numActiveBeacons: number[];
}

export interface CMsgGCToClientPartyBeaconUpdate {
  beaconAdded: boolean;
  beaconType: number;
  accountId: number;
}

export interface CMsgClientToGCUpdatePartyBeacon {
  action: CMsgClientToGCUpdatePartyBeacon_Action;
}

export enum CMsgClientToGCUpdatePartyBeacon_Action {
  ON = 0,
  OFF = 1,
}

export function cMsgClientToGCUpdatePartyBeacon_ActionFromJSON(object: any): CMsgClientToGCUpdatePartyBeacon_Action {
  switch (object) {
    case 0:
    case "ON":
      return CMsgClientToGCUpdatePartyBeacon_Action.ON;
    case 1:
    case "OFF":
      return CMsgClientToGCUpdatePartyBeacon_Action.OFF;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCUpdatePartyBeacon_Action",
      );
  }
}

export function cMsgClientToGCUpdatePartyBeacon_ActionToJSON(object: CMsgClientToGCUpdatePartyBeacon_Action): string {
  switch (object) {
    case CMsgClientToGCUpdatePartyBeacon_Action.ON:
      return "ON";
    case CMsgClientToGCUpdatePartyBeacon_Action.OFF:
      return "OFF";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCUpdatePartyBeacon_Action",
      );
  }
}

export interface CMsgClientToGCRequestActiveBeaconParties {
}

export interface CMsgGCToClientRequestActiveBeaconPartiesResponse {
  response: CMsgGCToClientRequestActiveBeaconPartiesResponse_EResponse;
  activeParties: CPartySearchClientParty[];
}

export enum CMsgGCToClientRequestActiveBeaconPartiesResponse_EResponse {
  SUCCESS = 0,
  FAILURE = 1,
  BUSY = 2,
}

export function cMsgGCToClientRequestActiveBeaconPartiesResponse_EResponseFromJSON(
  object: any,
): CMsgGCToClientRequestActiveBeaconPartiesResponse_EResponse {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgGCToClientRequestActiveBeaconPartiesResponse_EResponse.SUCCESS;
    case 1:
    case "FAILURE":
      return CMsgGCToClientRequestActiveBeaconPartiesResponse_EResponse.FAILURE;
    case 2:
    case "BUSY":
      return CMsgGCToClientRequestActiveBeaconPartiesResponse_EResponse.BUSY;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientRequestActiveBeaconPartiesResponse_EResponse",
      );
  }
}

export function cMsgGCToClientRequestActiveBeaconPartiesResponse_EResponseToJSON(
  object: CMsgGCToClientRequestActiveBeaconPartiesResponse_EResponse,
): string {
  switch (object) {
    case CMsgGCToClientRequestActiveBeaconPartiesResponse_EResponse.SUCCESS:
      return "SUCCESS";
    case CMsgGCToClientRequestActiveBeaconPartiesResponse_EResponse.FAILURE:
      return "FAILURE";
    case CMsgGCToClientRequestActiveBeaconPartiesResponse_EResponse.BUSY:
      return "BUSY";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientRequestActiveBeaconPartiesResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCJoinPartyFromBeacon {
  partyId: string;
  accountId: number;
  beaconType: number;
}

export interface CMsgGCToClientJoinPartyFromBeaconResponse {
  response: CMsgGCToClientJoinPartyFromBeaconResponse_EResponse;
}

export enum CMsgGCToClientJoinPartyFromBeaconResponse_EResponse {
  SUCCESS = 0,
  FAILURE = 1,
  BUSY = 2,
  NOT_LEADER = 3,
}

export function cMsgGCToClientJoinPartyFromBeaconResponse_EResponseFromJSON(
  object: any,
): CMsgGCToClientJoinPartyFromBeaconResponse_EResponse {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgGCToClientJoinPartyFromBeaconResponse_EResponse.SUCCESS;
    case 1:
    case "FAILURE":
      return CMsgGCToClientJoinPartyFromBeaconResponse_EResponse.FAILURE;
    case 2:
    case "BUSY":
      return CMsgGCToClientJoinPartyFromBeaconResponse_EResponse.BUSY;
    case 3:
    case "NOT_LEADER":
      return CMsgGCToClientJoinPartyFromBeaconResponse_EResponse.NOT_LEADER;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientJoinPartyFromBeaconResponse_EResponse",
      );
  }
}

export function cMsgGCToClientJoinPartyFromBeaconResponse_EResponseToJSON(
  object: CMsgGCToClientJoinPartyFromBeaconResponse_EResponse,
): string {
  switch (object) {
    case CMsgGCToClientJoinPartyFromBeaconResponse_EResponse.SUCCESS:
      return "SUCCESS";
    case CMsgGCToClientJoinPartyFromBeaconResponse_EResponse.FAILURE:
      return "FAILURE";
    case CMsgGCToClientJoinPartyFromBeaconResponse_EResponse.BUSY:
      return "BUSY";
    case CMsgGCToClientJoinPartyFromBeaconResponse_EResponse.NOT_LEADER:
      return "NOT_LEADER";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientJoinPartyFromBeaconResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCManageFavorites {
  action: CMsgClientToGCManageFavorites_Action;
  accountId: number;
  favoriteName: string;
  inviteResponse: boolean;
  fromFriendlist: boolean;
  lobbyId: string;
}

export enum CMsgClientToGCManageFavorites_Action {
  ADD = 0,
  REMOVE = 1,
}

export function cMsgClientToGCManageFavorites_ActionFromJSON(object: any): CMsgClientToGCManageFavorites_Action {
  switch (object) {
    case 0:
    case "ADD":
      return CMsgClientToGCManageFavorites_Action.ADD;
    case 1:
    case "REMOVE":
      return CMsgClientToGCManageFavorites_Action.REMOVE;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCManageFavorites_Action",
      );
  }
}

export function cMsgClientToGCManageFavorites_ActionToJSON(object: CMsgClientToGCManageFavorites_Action): string {
  switch (object) {
    case CMsgClientToGCManageFavorites_Action.ADD:
      return "ADD";
    case CMsgClientToGCManageFavorites_Action.REMOVE:
      return "REMOVE";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCManageFavorites_Action",
      );
  }
}

export interface CMsgGCToClientManageFavoritesResponse {
  response: CMsgGCToClientManageFavoritesResponse_EResponse;
  debugMessage: string;
  player: CMsgPartySearchPlayer | undefined;
}

export enum CMsgGCToClientManageFavoritesResponse_EResponse {
  SUCCESS = 0,
  FAILURE = 1,
  NO_INVITE_PRESENT = 2,
  INVITE_SENT = 3,
  EXPIRED = 4,
  BUSY = 5,
}

export function cMsgGCToClientManageFavoritesResponse_EResponseFromJSON(
  object: any,
): CMsgGCToClientManageFavoritesResponse_EResponse {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgGCToClientManageFavoritesResponse_EResponse.SUCCESS;
    case 1:
    case "FAILURE":
      return CMsgGCToClientManageFavoritesResponse_EResponse.FAILURE;
    case 2:
    case "NO_INVITE_PRESENT":
      return CMsgGCToClientManageFavoritesResponse_EResponse.NO_INVITE_PRESENT;
    case 3:
    case "INVITE_SENT":
      return CMsgGCToClientManageFavoritesResponse_EResponse.INVITE_SENT;
    case 4:
    case "EXPIRED":
      return CMsgGCToClientManageFavoritesResponse_EResponse.EXPIRED;
    case 5:
    case "BUSY":
      return CMsgGCToClientManageFavoritesResponse_EResponse.BUSY;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientManageFavoritesResponse_EResponse",
      );
  }
}

export function cMsgGCToClientManageFavoritesResponse_EResponseToJSON(
  object: CMsgGCToClientManageFavoritesResponse_EResponse,
): string {
  switch (object) {
    case CMsgGCToClientManageFavoritesResponse_EResponse.SUCCESS:
      return "SUCCESS";
    case CMsgGCToClientManageFavoritesResponse_EResponse.FAILURE:
      return "FAILURE";
    case CMsgGCToClientManageFavoritesResponse_EResponse.NO_INVITE_PRESENT:
      return "NO_INVITE_PRESENT";
    case CMsgGCToClientManageFavoritesResponse_EResponse.INVITE_SENT:
      return "INVITE_SENT";
    case CMsgGCToClientManageFavoritesResponse_EResponse.EXPIRED:
      return "EXPIRED";
    case CMsgGCToClientManageFavoritesResponse_EResponse.BUSY:
      return "BUSY";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientManageFavoritesResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCGetFavoritePlayers {
  paginationKey: string;
  paginationCount: number;
}

export interface CMsgGCToClientGetFavoritePlayersResponse {
  response: CMsgGCToClientGetFavoritePlayersResponse_EResponse;
  players: CMsgPartySearchPlayer[];
  nextPaginationKey: string;
}

export enum CMsgGCToClientGetFavoritePlayersResponse_EResponse {
  SUCCESS = 0,
  FAILURE = 1,
}

export function cMsgGCToClientGetFavoritePlayersResponse_EResponseFromJSON(
  object: any,
): CMsgGCToClientGetFavoritePlayersResponse_EResponse {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgGCToClientGetFavoritePlayersResponse_EResponse.SUCCESS;
    case 1:
    case "FAILURE":
      return CMsgGCToClientGetFavoritePlayersResponse_EResponse.FAILURE;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientGetFavoritePlayersResponse_EResponse",
      );
  }
}

export function cMsgGCToClientGetFavoritePlayersResponse_EResponseToJSON(
  object: CMsgGCToClientGetFavoritePlayersResponse_EResponse,
): string {
  switch (object) {
    case CMsgGCToClientGetFavoritePlayersResponse_EResponse.SUCCESS:
      return "SUCCESS";
    case CMsgGCToClientGetFavoritePlayersResponse_EResponse.FAILURE:
      return "FAILURE";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientGetFavoritePlayersResponse_EResponse",
      );
  }
}

export interface CMsgGCToClientPartySearchInvite {
  accountId: number;
}

export interface CMsgClientToGCVerifyFavoritePlayers {
  accountIds: number[];
}

export interface CMsgGCToClientVerifyFavoritePlayersResponse {
  results: CMsgGCToClientVerifyFavoritePlayersResponse_Result[];
}

export interface CMsgGCToClientVerifyFavoritePlayersResponse_Result {
  player: CMsgPartySearchPlayer | undefined;
  isFavorite: boolean;
}

export interface CMsgClientToGCRequestPlayerRecentAccomplishments {
  accountId: number;
}

export interface CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse {
  result: CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse_EResponse;
  playerAccomplishments: CMsgPlayerRecentAccomplishments | undefined;
}

export enum CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
}

export function cMsgClientToGCRequestPlayerRecentAccomplishmentsResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eDisabled;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object +
          " for enum CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse_EResponse",
      );
  }
}

export function cMsgClientToGCRequestPlayerRecentAccomplishmentsResponse_EResponseToJSON(
  object: CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object +
          " for enum CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCRequestPlayerHeroRecentAccomplishments {
  accountId: number;
  heroId: number;
}

export interface CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse {
  result: CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse_EResponse;
  heroAccomplishments: CMsgPlayerHeroRecentAccomplishments | undefined;
}

export enum CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
}

export function cMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse_EResponse.k_eDisabled;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object +
          " for enum CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse_EResponse",
      );
  }
}

export function cMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse_EResponseToJSON(
  object: CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object +
          " for enum CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCSubmitPlayerMatchSurvey {
  matchId: string;
  rating: number;
  flags: number;
}

export interface CMsgClientToGCSubmitPlayerMatchSurveyResponse {
  eresult: CMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponse;
  accountId: number;
}

export enum CMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
  k_eAlreadySubmitted = 4,
  k_ePlayerNotValid = 5,
}

export function cMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponse.k_eDisabled;
    case 4:
    case "k_eAlreadySubmitted":
      return CMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponse.k_eAlreadySubmitted;
    case 5:
    case "k_ePlayerNotValid":
      return CMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponse.k_ePlayerNotValid;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponse",
      );
  }
}

export function cMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponseToJSON(
  object: CMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    case CMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponse.k_eAlreadySubmitted:
      return "k_eAlreadySubmitted";
    case CMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponse.k_ePlayerNotValid:
      return "k_ePlayerNotValid";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponse",
      );
  }
}

export interface CMsgGCToClientVACReminder {
}

export interface CMsgClientToGCUnderDraftRequest {
  accountId: number;
  eventId: number;
}

export interface CMsgClientToGCUnderDraftResponse {
  result: EUnderDraftResponse;
  accountId: number;
  eventId: number;
  draftData: CMsgUnderDraftData | undefined;
}

export interface CMsgClientToGCUnderDraftReroll {
  eventId: number;
}

export interface CMsgClientToGCUnderDraftRerollResponse {
  result: EUnderDraftResponse;
  eventId: number;
  draftData: CMsgUnderDraftData | undefined;
}

export interface CMsgClientToGCUnderDraftBuy {
  eventId: number;
  slotId: number;
}

export interface CMsgGCToClientGuildUnderDraftGoldUpdated {
  eventId: number;
}

export interface CMsgClientToGCUnderDraftBuyResponse {
  result: EUnderDraftResponse;
  eventId: number;
  slotId: number;
  draftData: CMsgUnderDraftData | undefined;
}

export interface CMsgClientToGCUnderDraftRollBackBench {
  eventId: number;
}

export interface CMsgClientToGCUnderDraftRollBackBenchResponse {
  result: EUnderDraftResponse;
  eventId: number;
  draftData: CMsgUnderDraftData | undefined;
}

export interface CMsgClientToGCUnderDraftSell {
  eventId: number;
  slotId: number;
}

export interface CMsgClientToGCUnderDraftSellResponse {
  result: EUnderDraftResponse;
  eventId: number;
  slotId: number;
  draftData: CMsgUnderDraftData | undefined;
}

export interface CMsgClientToGCUnderDraftRedeemReward {
  eventId: number;
  actionId: number;
}

export interface CMsgClientToGCUnderDraftRedeemRewardResponse {
  result: EUnderDraftResponse;
}

export interface CMsgClientToGCSubmitDraftTriviaMatchAnswer {
  choseRadiantAsWinner: boolean;
  eventId: number;
  endTime: number;
}

export interface CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse {
  result: EDOTADraftTriviaAnswerResult;
}

export interface CMsgDraftTriviaVoteCount {
  totalVotes: number;
  radiantVotes: number;
  direVotes: number;
}

export interface CMsgClientToGCRecalibrateMMR {
}

export interface CMsgClientToGCRecalibrateMMRResponse {
  result: CMsgClientToGCRecalibrateMMRResponse_EResponse;
}

export enum CMsgClientToGCRecalibrateMMRResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTimeout = 2,
  k_eTooBusy = 3,
  k_eNotPermitted = 4,
  k_eNotToSoon = 5,
  k_eNotValid = 6,
}

export function cMsgClientToGCRecalibrateMMRResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCRecalibrateMMRResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCRecalibrateMMRResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCRecalibrateMMRResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTimeout":
      return CMsgClientToGCRecalibrateMMRResponse_EResponse.k_eTimeout;
    case 3:
    case "k_eTooBusy":
      return CMsgClientToGCRecalibrateMMRResponse_EResponse.k_eTooBusy;
    case 4:
    case "k_eNotPermitted":
      return CMsgClientToGCRecalibrateMMRResponse_EResponse.k_eNotPermitted;
    case 5:
    case "k_eNotToSoon":
      return CMsgClientToGCRecalibrateMMRResponse_EResponse.k_eNotToSoon;
    case 6:
    case "k_eNotValid":
      return CMsgClientToGCRecalibrateMMRResponse_EResponse.k_eNotValid;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCRecalibrateMMRResponse_EResponse",
      );
  }
}

export function cMsgClientToGCRecalibrateMMRResponse_EResponseToJSON(
  object: CMsgClientToGCRecalibrateMMRResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCRecalibrateMMRResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCRecalibrateMMRResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCRecalibrateMMRResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCRecalibrateMMRResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCRecalibrateMMRResponse_EResponse.k_eNotPermitted:
      return "k_eNotPermitted";
    case CMsgClientToGCRecalibrateMMRResponse_EResponse.k_eNotToSoon:
      return "k_eNotToSoon";
    case CMsgClientToGCRecalibrateMMRResponse_EResponse.k_eNotValid:
      return "k_eNotValid";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCRecalibrateMMRResponse_EResponse",
      );
  }
}

export interface CMsgDOTAPostGameItemAwardNotification {
  receiverAccountId: number;
  itemDefIndex: number[];
  actionId: number;
}

export interface CMsgClientToGCGetOWMatchDetails {
}

export interface CMsgClientToGCGetOWMatchDetailsResponse {
  result: CMsgClientToGCGetOWMatchDetailsResponse_EResponse;
  overwatchReplayId: string;
  decryptionKey: string;
  cluster: number;
  overwatchSalt: number;
  targetPlayerSlot: number;
  markers: CMsgClientToGCGetOWMatchDetailsResponse_Marker[];
  reportReason: EOverwatchReportReason;
  targetHeroId: number;
  rankTier: number;
  laneSelectionFlags: number;
}

export enum CMsgClientToGCGetOWMatchDetailsResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTimeout = 2,
  k_eTooBusy = 3,
  k_eNotPermitted = 4,
  k_eNoCaseAvailable = 5,
}

export function cMsgClientToGCGetOWMatchDetailsResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCGetOWMatchDetailsResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCGetOWMatchDetailsResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCGetOWMatchDetailsResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTimeout":
      return CMsgClientToGCGetOWMatchDetailsResponse_EResponse.k_eTimeout;
    case 3:
    case "k_eTooBusy":
      return CMsgClientToGCGetOWMatchDetailsResponse_EResponse.k_eTooBusy;
    case 4:
    case "k_eNotPermitted":
      return CMsgClientToGCGetOWMatchDetailsResponse_EResponse.k_eNotPermitted;
    case 5:
    case "k_eNoCaseAvailable":
      return CMsgClientToGCGetOWMatchDetailsResponse_EResponse.k_eNoCaseAvailable;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCGetOWMatchDetailsResponse_EResponse",
      );
  }
}

export function cMsgClientToGCGetOWMatchDetailsResponse_EResponseToJSON(
  object: CMsgClientToGCGetOWMatchDetailsResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCGetOWMatchDetailsResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCGetOWMatchDetailsResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCGetOWMatchDetailsResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCGetOWMatchDetailsResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCGetOWMatchDetailsResponse_EResponse.k_eNotPermitted:
      return "k_eNotPermitted";
    case CMsgClientToGCGetOWMatchDetailsResponse_EResponse.k_eNoCaseAvailable:
      return "k_eNoCaseAvailable";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCGetOWMatchDetailsResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCGetOWMatchDetailsResponse_Marker {
  startGameTimeS: number;
  endGameTimeS: number;
}

export interface CMsgClientToGCSubmitOWConviction {
  overwatchReplayId: string;
  targetPlayerSlot: number;
  cheatingConviction: EOverwatchConviction;
  griefingConviction: EOverwatchConviction;
}

export interface CMsgClientToGCSubmitOWConvictionResponse {
  result: CMsgClientToGCSubmitOWConvictionResponse_EResponse;
  overwatchReplayId: string;
}

export enum CMsgClientToGCSubmitOWConvictionResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTimeout = 2,
  k_eTooBusy = 3,
  k_eNotPermitted = 4,
  k_eInvalidReplayID = 5,
  k_eInvalidConviction = 6,
  k_eInvalidPlayerSlot = 7,
}

export function cMsgClientToGCSubmitOWConvictionResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCSubmitOWConvictionResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCSubmitOWConvictionResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCSubmitOWConvictionResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTimeout":
      return CMsgClientToGCSubmitOWConvictionResponse_EResponse.k_eTimeout;
    case 3:
    case "k_eTooBusy":
      return CMsgClientToGCSubmitOWConvictionResponse_EResponse.k_eTooBusy;
    case 4:
    case "k_eNotPermitted":
      return CMsgClientToGCSubmitOWConvictionResponse_EResponse.k_eNotPermitted;
    case 5:
    case "k_eInvalidReplayID":
      return CMsgClientToGCSubmitOWConvictionResponse_EResponse.k_eInvalidReplayID;
    case 6:
    case "k_eInvalidConviction":
      return CMsgClientToGCSubmitOWConvictionResponse_EResponse.k_eInvalidConviction;
    case 7:
    case "k_eInvalidPlayerSlot":
      return CMsgClientToGCSubmitOWConvictionResponse_EResponse.k_eInvalidPlayerSlot;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCSubmitOWConvictionResponse_EResponse",
      );
  }
}

export function cMsgClientToGCSubmitOWConvictionResponse_EResponseToJSON(
  object: CMsgClientToGCSubmitOWConvictionResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCSubmitOWConvictionResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCSubmitOWConvictionResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCSubmitOWConvictionResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCSubmitOWConvictionResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCSubmitOWConvictionResponse_EResponse.k_eNotPermitted:
      return "k_eNotPermitted";
    case CMsgClientToGCSubmitOWConvictionResponse_EResponse.k_eInvalidReplayID:
      return "k_eInvalidReplayID";
    case CMsgClientToGCSubmitOWConvictionResponse_EResponse.k_eInvalidConviction:
      return "k_eInvalidConviction";
    case CMsgClientToGCSubmitOWConvictionResponse_EResponse.k_eInvalidPlayerSlot:
      return "k_eInvalidPlayerSlot";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCSubmitOWConvictionResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCChinaSSAURLRequest {
}

export interface CMsgClientToGCChinaSSAURLResponse {
  agreementUrl: string;
}

export interface CMsgClientToGCChinaSSAAcceptedRequest {
}

export interface CMsgClientToGCChinaSSAAcceptedResponse {
  agreementAccepted: boolean;
}

export interface CMsgGCToClientOverwatchCasesAvailable {
  expireTime: number;
}

export interface CMsgClientToGCStartWatchingOverwatch {
  overwatchReplayId: string;
  targetPlayerSlot: number;
}

export interface CMsgClientToGCStopWatchingOverwatch {
  overwatchReplayId: string;
  targetPlayerSlot: number;
}

export interface CMsgClientToGCOverwatchReplayError {
  overwatchReplayId: string;
}

export interface CMsgClientToGCGetDPCFavorites {
}

export interface CMsgClientToGCGetDPCFavoritesResponse {
  result: CMsgClientToGCGetDPCFavoritesResponse_EResponse;
  favorites: CMsgClientToGCGetDPCFavoritesResponse_Favorite[];
}

export enum CMsgClientToGCGetDPCFavoritesResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
  k_eTimeout = 4,
  k_eInvalidRequest = 5,
}

export function cMsgClientToGCGetDPCFavoritesResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCGetDPCFavoritesResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCGetDPCFavoritesResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCGetDPCFavoritesResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgClientToGCGetDPCFavoritesResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgClientToGCGetDPCFavoritesResponse_EResponse.k_eDisabled;
    case 4:
    case "k_eTimeout":
      return CMsgClientToGCGetDPCFavoritesResponse_EResponse.k_eTimeout;
    case 5:
    case "k_eInvalidRequest":
      return CMsgClientToGCGetDPCFavoritesResponse_EResponse.k_eInvalidRequest;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCGetDPCFavoritesResponse_EResponse",
      );
  }
}

export function cMsgClientToGCGetDPCFavoritesResponse_EResponseToJSON(
  object: CMsgClientToGCGetDPCFavoritesResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCGetDPCFavoritesResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCGetDPCFavoritesResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCGetDPCFavoritesResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCGetDPCFavoritesResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    case CMsgClientToGCGetDPCFavoritesResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCGetDPCFavoritesResponse_EResponse.k_eInvalidRequest:
      return "k_eInvalidRequest";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCGetDPCFavoritesResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCGetDPCFavoritesResponse_Favorite {
  favoriteType: EDPCFavoriteType;
  favoriteId: number;
}

export interface CMsgClientToGCSetDPCFavoriteState {
  favoriteType: EDPCFavoriteType;
  favoriteId: number;
  enabled: boolean;
}

export interface CMsgClientToGCSetDPCFavoriteStateResponse {
  result: CMsgClientToGCSetDPCFavoriteStateResponse_EResponse;
}

export enum CMsgClientToGCSetDPCFavoriteStateResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eFavoriteTypeOutOfRange = 2,
  k_eLockFailed = 3,
  k_eAlreadyFavorited = 4,
  k_eAlreadyUnfavorited = 5,
  k_eInsertRecordFailed = 6,
  k_eRemoveRecordFailed = 7,
  k_eTimeout = 8,
}

export function cMsgClientToGCSetDPCFavoriteStateResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCSetDPCFavoriteStateResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCSetDPCFavoriteStateResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCSetDPCFavoriteStateResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eFavoriteTypeOutOfRange":
      return CMsgClientToGCSetDPCFavoriteStateResponse_EResponse.k_eFavoriteTypeOutOfRange;
    case 3:
    case "k_eLockFailed":
      return CMsgClientToGCSetDPCFavoriteStateResponse_EResponse.k_eLockFailed;
    case 4:
    case "k_eAlreadyFavorited":
      return CMsgClientToGCSetDPCFavoriteStateResponse_EResponse.k_eAlreadyFavorited;
    case 5:
    case "k_eAlreadyUnfavorited":
      return CMsgClientToGCSetDPCFavoriteStateResponse_EResponse.k_eAlreadyUnfavorited;
    case 6:
    case "k_eInsertRecordFailed":
      return CMsgClientToGCSetDPCFavoriteStateResponse_EResponse.k_eInsertRecordFailed;
    case 7:
    case "k_eRemoveRecordFailed":
      return CMsgClientToGCSetDPCFavoriteStateResponse_EResponse.k_eRemoveRecordFailed;
    case 8:
    case "k_eTimeout":
      return CMsgClientToGCSetDPCFavoriteStateResponse_EResponse.k_eTimeout;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCSetDPCFavoriteStateResponse_EResponse",
      );
  }
}

export function cMsgClientToGCSetDPCFavoriteStateResponse_EResponseToJSON(
  object: CMsgClientToGCSetDPCFavoriteStateResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCSetDPCFavoriteStateResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCSetDPCFavoriteStateResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCSetDPCFavoriteStateResponse_EResponse.k_eFavoriteTypeOutOfRange:
      return "k_eFavoriteTypeOutOfRange";
    case CMsgClientToGCSetDPCFavoriteStateResponse_EResponse.k_eLockFailed:
      return "k_eLockFailed";
    case CMsgClientToGCSetDPCFavoriteStateResponse_EResponse.k_eAlreadyFavorited:
      return "k_eAlreadyFavorited";
    case CMsgClientToGCSetDPCFavoriteStateResponse_EResponse.k_eAlreadyUnfavorited:
      return "k_eAlreadyUnfavorited";
    case CMsgClientToGCSetDPCFavoriteStateResponse_EResponse.k_eInsertRecordFailed:
      return "k_eInsertRecordFailed";
    case CMsgClientToGCSetDPCFavoriteStateResponse_EResponse.k_eRemoveRecordFailed:
      return "k_eRemoveRecordFailed";
    case CMsgClientToGCSetDPCFavoriteStateResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCSetDPCFavoriteStateResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCSetEventActiveSeasonID {
  eventId: number;
  activeSeasonId: number;
}

export interface CMsgClientToGCSetEventActiveSeasonIDResponse {
  result: CMsgClientToGCSetEventActiveSeasonIDResponse_EResponse;
}

export enum CMsgClientToGCSetEventActiveSeasonIDResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eDisabled = 2,
  k_eTooBusy = 3,
  k_eNotAllowed = 4,
  k_eTimeout = 5,
  k_eInternalSuccessNoChange = 6,
}

export function cMsgClientToGCSetEventActiveSeasonIDResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCSetEventActiveSeasonIDResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCSetEventActiveSeasonIDResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCSetEventActiveSeasonIDResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eDisabled":
      return CMsgClientToGCSetEventActiveSeasonIDResponse_EResponse.k_eDisabled;
    case 3:
    case "k_eTooBusy":
      return CMsgClientToGCSetEventActiveSeasonIDResponse_EResponse.k_eTooBusy;
    case 4:
    case "k_eNotAllowed":
      return CMsgClientToGCSetEventActiveSeasonIDResponse_EResponse.k_eNotAllowed;
    case 5:
    case "k_eTimeout":
      return CMsgClientToGCSetEventActiveSeasonIDResponse_EResponse.k_eTimeout;
    case 6:
    case "k_eInternalSuccessNoChange":
      return CMsgClientToGCSetEventActiveSeasonIDResponse_EResponse.k_eInternalSuccessNoChange;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCSetEventActiveSeasonIDResponse_EResponse",
      );
  }
}

export function cMsgClientToGCSetEventActiveSeasonIDResponse_EResponseToJSON(
  object: CMsgClientToGCSetEventActiveSeasonIDResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCSetEventActiveSeasonIDResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCSetEventActiveSeasonIDResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCSetEventActiveSeasonIDResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    case CMsgClientToGCSetEventActiveSeasonIDResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCSetEventActiveSeasonIDResponse_EResponse.k_eNotAllowed:
      return "k_eNotAllowed";
    case CMsgClientToGCSetEventActiveSeasonIDResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCSetEventActiveSeasonIDResponse_EResponse.k_eInternalSuccessNoChange:
      return "k_eInternalSuccessNoChange";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCSetEventActiveSeasonIDResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCPurchaseLabyrinthBlessings {
  eventId: EEvent;
  blessingIds: number[];
  debug: boolean;
  debugRemove: boolean;
}

export interface CMsgClientToGCPurchaseLabyrinthBlessingsResponse {
  result: CMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponse;
}

export enum CMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eNoSuchBlessing = 2,
  k_eNotEnoughShards = 3,
  k_eNoPath = 4,
  k_eTimeout = 5,
}

export function cMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eNoSuchBlessing":
      return CMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponse.k_eNoSuchBlessing;
    case 3:
    case "k_eNotEnoughShards":
      return CMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponse.k_eNotEnoughShards;
    case 4:
    case "k_eNoPath":
      return CMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponse.k_eNoPath;
    case 5:
    case "k_eTimeout":
      return CMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponse.k_eTimeout;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponse",
      );
  }
}

export function cMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponseToJSON(
  object: CMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponse.k_eNoSuchBlessing:
      return "k_eNoSuchBlessing";
    case CMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponse.k_eNotEnoughShards:
      return "k_eNotEnoughShards";
    case CMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponse.k_eNoPath:
      return "k_eNoPath";
    case CMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCGetStickerbookRequest {
  accountId: number;
}

export interface CMsgClientToGCGetStickerbookResponse {
  response: CMsgClientToGCGetStickerbookResponse_EResponse;
  stickerbook: CMsgStickerbook | undefined;
}

export enum CMsgClientToGCGetStickerbookResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTimeout = 2,
  k_eNotAllowed = 3,
  k_eTooBusy = 4,
}

export function cMsgClientToGCGetStickerbookResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCGetStickerbookResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCGetStickerbookResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCGetStickerbookResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTimeout":
      return CMsgClientToGCGetStickerbookResponse_EResponse.k_eTimeout;
    case 3:
    case "k_eNotAllowed":
      return CMsgClientToGCGetStickerbookResponse_EResponse.k_eNotAllowed;
    case 4:
    case "k_eTooBusy":
      return CMsgClientToGCGetStickerbookResponse_EResponse.k_eTooBusy;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCGetStickerbookResponse_EResponse",
      );
  }
}

export function cMsgClientToGCGetStickerbookResponse_EResponseToJSON(
  object: CMsgClientToGCGetStickerbookResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCGetStickerbookResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCGetStickerbookResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCGetStickerbookResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCGetStickerbookResponse_EResponse.k_eNotAllowed:
      return "k_eNotAllowed";
    case CMsgClientToGCGetStickerbookResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCGetStickerbookResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCCreateStickerbookPageRequest {
  teamId: number;
  eventId: EEvent;
  pageType: EStickerbookPageType;
}

export interface CMsgClientToGCCreateStickerbookPageResponse {
  response: CMsgClientToGCCreateStickerbookPageResponse_EResponse;
  pageNumber: number;
}

export enum CMsgClientToGCCreateStickerbookPageResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTimeout = 2,
  k_eTooManyPages = 3,
  k_eTooBusy = 4,
}

export function cMsgClientToGCCreateStickerbookPageResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCCreateStickerbookPageResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCCreateStickerbookPageResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCCreateStickerbookPageResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTimeout":
      return CMsgClientToGCCreateStickerbookPageResponse_EResponse.k_eTimeout;
    case 3:
    case "k_eTooManyPages":
      return CMsgClientToGCCreateStickerbookPageResponse_EResponse.k_eTooManyPages;
    case 4:
    case "k_eTooBusy":
      return CMsgClientToGCCreateStickerbookPageResponse_EResponse.k_eTooBusy;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCCreateStickerbookPageResponse_EResponse",
      );
  }
}

export function cMsgClientToGCCreateStickerbookPageResponse_EResponseToJSON(
  object: CMsgClientToGCCreateStickerbookPageResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCCreateStickerbookPageResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCCreateStickerbookPageResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCCreateStickerbookPageResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCCreateStickerbookPageResponse_EResponse.k_eTooManyPages:
      return "k_eTooManyPages";
    case CMsgClientToGCCreateStickerbookPageResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCCreateStickerbookPageResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCDeleteStickerbookPageRequest {
  pageNum: number;
  stickerCount: number;
  stickerMax: number;
}

export interface CMsgClientToGCDeleteStickerbookPageResponse {
  response: CMsgClientToGCDeleteStickerbookPageResponse_EResponse;
}

export enum CMsgClientToGCDeleteStickerbookPageResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTimeout = 2,
  k_eInvalidStickerCount = 3,
  k_eTooBusy = 4,
  k_eInvalidStickerMax = 5,
  k_eInvalidPage = 6,
}

export function cMsgClientToGCDeleteStickerbookPageResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCDeleteStickerbookPageResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCDeleteStickerbookPageResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCDeleteStickerbookPageResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTimeout":
      return CMsgClientToGCDeleteStickerbookPageResponse_EResponse.k_eTimeout;
    case 3:
    case "k_eInvalidStickerCount":
      return CMsgClientToGCDeleteStickerbookPageResponse_EResponse.k_eInvalidStickerCount;
    case 4:
    case "k_eTooBusy":
      return CMsgClientToGCDeleteStickerbookPageResponse_EResponse.k_eTooBusy;
    case 5:
    case "k_eInvalidStickerMax":
      return CMsgClientToGCDeleteStickerbookPageResponse_EResponse.k_eInvalidStickerMax;
    case 6:
    case "k_eInvalidPage":
      return CMsgClientToGCDeleteStickerbookPageResponse_EResponse.k_eInvalidPage;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCDeleteStickerbookPageResponse_EResponse",
      );
  }
}

export function cMsgClientToGCDeleteStickerbookPageResponse_EResponseToJSON(
  object: CMsgClientToGCDeleteStickerbookPageResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCDeleteStickerbookPageResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCDeleteStickerbookPageResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCDeleteStickerbookPageResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCDeleteStickerbookPageResponse_EResponse.k_eInvalidStickerCount:
      return "k_eInvalidStickerCount";
    case CMsgClientToGCDeleteStickerbookPageResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCDeleteStickerbookPageResponse_EResponse.k_eInvalidStickerMax:
      return "k_eInvalidStickerMax";
    case CMsgClientToGCDeleteStickerbookPageResponse_EResponse.k_eInvalidPage:
      return "k_eInvalidPage";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCDeleteStickerbookPageResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCPlaceStickersRequest {
  stickerItems: CMsgClientToGCPlaceStickersRequest_StickerItem[];
}

export interface CMsgClientToGCPlaceStickersRequest_StickerItem {
  pageNum: number;
  sticker: CMsgStickerbookSticker | undefined;
}

export interface CMsgClientToGCPlaceStickersResponse {
  response: CMsgClientToGCPlaceStickersResponse_EResponse;
}

export enum CMsgClientToGCPlaceStickersResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTimeout = 2,
  k_eMissingItem = 3,
  k_eTooBusy = 4,
  k_eDuplicateItem = 5,
  k_eInvalidPage = 6,
  k_ePageTypeMismatch = 7,
  k_eTooManyStickers = 8,
}

export function cMsgClientToGCPlaceStickersResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCPlaceStickersResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCPlaceStickersResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCPlaceStickersResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTimeout":
      return CMsgClientToGCPlaceStickersResponse_EResponse.k_eTimeout;
    case 3:
    case "k_eMissingItem":
      return CMsgClientToGCPlaceStickersResponse_EResponse.k_eMissingItem;
    case 4:
    case "k_eTooBusy":
      return CMsgClientToGCPlaceStickersResponse_EResponse.k_eTooBusy;
    case 5:
    case "k_eDuplicateItem":
      return CMsgClientToGCPlaceStickersResponse_EResponse.k_eDuplicateItem;
    case 6:
    case "k_eInvalidPage":
      return CMsgClientToGCPlaceStickersResponse_EResponse.k_eInvalidPage;
    case 7:
    case "k_ePageTypeMismatch":
      return CMsgClientToGCPlaceStickersResponse_EResponse.k_ePageTypeMismatch;
    case 8:
    case "k_eTooManyStickers":
      return CMsgClientToGCPlaceStickersResponse_EResponse.k_eTooManyStickers;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCPlaceStickersResponse_EResponse",
      );
  }
}

export function cMsgClientToGCPlaceStickersResponse_EResponseToJSON(
  object: CMsgClientToGCPlaceStickersResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCPlaceStickersResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCPlaceStickersResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCPlaceStickersResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCPlaceStickersResponse_EResponse.k_eMissingItem:
      return "k_eMissingItem";
    case CMsgClientToGCPlaceStickersResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCPlaceStickersResponse_EResponse.k_eDuplicateItem:
      return "k_eDuplicateItem";
    case CMsgClientToGCPlaceStickersResponse_EResponse.k_eInvalidPage:
      return "k_eInvalidPage";
    case CMsgClientToGCPlaceStickersResponse_EResponse.k_ePageTypeMismatch:
      return "k_ePageTypeMismatch";
    case CMsgClientToGCPlaceStickersResponse_EResponse.k_eTooManyStickers:
      return "k_eTooManyStickers";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCPlaceStickersResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCPlaceCollectionStickersRequest {
  slots: CMsgClientToGCPlaceCollectionStickersRequest_Slot[];
}

export interface CMsgClientToGCPlaceCollectionStickersRequest_Slot {
  pageNum: number;
  slot: number;
  newItemId: string;
  oldItemDefId: number;
  oldQuality: number;
}

export interface CMsgClientToGCPlaceCollectionStickersResponse {
  response: CMsgClientToGCPlaceCollectionStickersResponse_EResponse;
}

export enum CMsgClientToGCPlaceCollectionStickersResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTimeout = 2,
  k_eMissingItem = 3,
  k_eTooBusy = 4,
  k_eDuplicateItem = 5,
  k_eInvalidPage = 6,
  k_ePageTypeMismatch = 7,
  k_eOldItemMismatch = 8,
  k_eInvalidSlot = 9,
  k_eSlotTypeMismatch = 10,
}

export function cMsgClientToGCPlaceCollectionStickersResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCPlaceCollectionStickersResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTimeout":
      return CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_eTimeout;
    case 3:
    case "k_eMissingItem":
      return CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_eMissingItem;
    case 4:
    case "k_eTooBusy":
      return CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_eTooBusy;
    case 5:
    case "k_eDuplicateItem":
      return CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_eDuplicateItem;
    case 6:
    case "k_eInvalidPage":
      return CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_eInvalidPage;
    case 7:
    case "k_ePageTypeMismatch":
      return CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_ePageTypeMismatch;
    case 8:
    case "k_eOldItemMismatch":
      return CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_eOldItemMismatch;
    case 9:
    case "k_eInvalidSlot":
      return CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_eInvalidSlot;
    case 10:
    case "k_eSlotTypeMismatch":
      return CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_eSlotTypeMismatch;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCPlaceCollectionStickersResponse_EResponse",
      );
  }
}

export function cMsgClientToGCPlaceCollectionStickersResponse_EResponseToJSON(
  object: CMsgClientToGCPlaceCollectionStickersResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_eMissingItem:
      return "k_eMissingItem";
    case CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_eDuplicateItem:
      return "k_eDuplicateItem";
    case CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_eInvalidPage:
      return "k_eInvalidPage";
    case CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_ePageTypeMismatch:
      return "k_ePageTypeMismatch";
    case CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_eOldItemMismatch:
      return "k_eOldItemMismatch";
    case CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_eInvalidSlot:
      return "k_eInvalidSlot";
    case CMsgClientToGCPlaceCollectionStickersResponse_EResponse.k_eSlotTypeMismatch:
      return "k_eSlotTypeMismatch";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCPlaceCollectionStickersResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCOrderStickerbookTeamPageRequest {
  pageOrderSequence: CMsgStickerbookTeamPageOrderSequence | undefined;
}

export interface CMsgClientToGCOrderStickerbookTeamPageResponse {
  response: CMsgClientToGCOrderStickerbookTeamPageResponse_EResponse;
}

export enum CMsgClientToGCOrderStickerbookTeamPageResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTimeout = 2,
  k_eTooManyPages = 3,
  k_eTooBusy = 4,
  k_eInvalidPage = 5,
}

export function cMsgClientToGCOrderStickerbookTeamPageResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCOrderStickerbookTeamPageResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCOrderStickerbookTeamPageResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCOrderStickerbookTeamPageResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTimeout":
      return CMsgClientToGCOrderStickerbookTeamPageResponse_EResponse.k_eTimeout;
    case 3:
    case "k_eTooManyPages":
      return CMsgClientToGCOrderStickerbookTeamPageResponse_EResponse.k_eTooManyPages;
    case 4:
    case "k_eTooBusy":
      return CMsgClientToGCOrderStickerbookTeamPageResponse_EResponse.k_eTooBusy;
    case 5:
    case "k_eInvalidPage":
      return CMsgClientToGCOrderStickerbookTeamPageResponse_EResponse.k_eInvalidPage;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOrderStickerbookTeamPageResponse_EResponse",
      );
  }
}

export function cMsgClientToGCOrderStickerbookTeamPageResponse_EResponseToJSON(
  object: CMsgClientToGCOrderStickerbookTeamPageResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCOrderStickerbookTeamPageResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCOrderStickerbookTeamPageResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCOrderStickerbookTeamPageResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCOrderStickerbookTeamPageResponse_EResponse.k_eTooManyPages:
      return "k_eTooManyPages";
    case CMsgClientToGCOrderStickerbookTeamPageResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCOrderStickerbookTeamPageResponse_EResponse.k_eInvalidPage:
      return "k_eInvalidPage";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOrderStickerbookTeamPageResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCSetHeroSticker {
  heroId: number;
  newItemId: string;
  oldItemId: string;
}

export interface CMsgClientToGCSetHeroStickerResponse {
  response: CMsgClientToGCSetHeroStickerResponse_EResponse;
}

export enum CMsgClientToGCSetHeroStickerResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTimeout = 2,
  k_eMissingItem = 3,
  k_eTooBusy = 4,
  k_eOldItemMismatch = 5,
  k_eInvalidHero = 6,
}

export function cMsgClientToGCSetHeroStickerResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCSetHeroStickerResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCSetHeroStickerResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCSetHeroStickerResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTimeout":
      return CMsgClientToGCSetHeroStickerResponse_EResponse.k_eTimeout;
    case 3:
    case "k_eMissingItem":
      return CMsgClientToGCSetHeroStickerResponse_EResponse.k_eMissingItem;
    case 4:
    case "k_eTooBusy":
      return CMsgClientToGCSetHeroStickerResponse_EResponse.k_eTooBusy;
    case 5:
    case "k_eOldItemMismatch":
      return CMsgClientToGCSetHeroStickerResponse_EResponse.k_eOldItemMismatch;
    case 6:
    case "k_eInvalidHero":
      return CMsgClientToGCSetHeroStickerResponse_EResponse.k_eInvalidHero;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCSetHeroStickerResponse_EResponse",
      );
  }
}

export function cMsgClientToGCSetHeroStickerResponse_EResponseToJSON(
  object: CMsgClientToGCSetHeroStickerResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCSetHeroStickerResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCSetHeroStickerResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCSetHeroStickerResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCSetHeroStickerResponse_EResponse.k_eMissingItem:
      return "k_eMissingItem";
    case CMsgClientToGCSetHeroStickerResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCSetHeroStickerResponse_EResponse.k_eOldItemMismatch:
      return "k_eOldItemMismatch";
    case CMsgClientToGCSetHeroStickerResponse_EResponse.k_eInvalidHero:
      return "k_eInvalidHero";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCSetHeroStickerResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCGetHeroStickers {
}

export interface CMsgClientToGCGetHeroStickersResponse {
  response: CMsgClientToGCGetHeroStickersResponse_EResponse;
  stickerHeroes: CMsgStickerHeroes | undefined;
}

export enum CMsgClientToGCGetHeroStickersResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTimeout = 2,
  k_eTooBusy = 4,
}

export function cMsgClientToGCGetHeroStickersResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCGetHeroStickersResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCGetHeroStickersResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCGetHeroStickersResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTimeout":
      return CMsgClientToGCGetHeroStickersResponse_EResponse.k_eTimeout;
    case 4:
    case "k_eTooBusy":
      return CMsgClientToGCGetHeroStickersResponse_EResponse.k_eTooBusy;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCGetHeroStickersResponse_EResponse",
      );
  }
}

export function cMsgClientToGCGetHeroStickersResponse_EResponseToJSON(
  object: CMsgClientToGCGetHeroStickersResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCGetHeroStickersResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCGetHeroStickersResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCGetHeroStickersResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCGetHeroStickersResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCGetHeroStickersResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCSetFavoritePage {
  pageNum: number;
  clear: boolean;
}

export interface CMsgClientToGCSetFavoritePageResponse {
  response: CMsgClientToGCSetFavoritePageResponse_EResponse;
}

export enum CMsgClientToGCSetFavoritePageResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTimeout = 2,
  k_eTooBusy = 4,
  k_eInvalidPage = 5,
}

export function cMsgClientToGCSetFavoritePageResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCSetFavoritePageResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCSetFavoritePageResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCSetFavoritePageResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTimeout":
      return CMsgClientToGCSetFavoritePageResponse_EResponse.k_eTimeout;
    case 4:
    case "k_eTooBusy":
      return CMsgClientToGCSetFavoritePageResponse_EResponse.k_eTooBusy;
    case 5:
    case "k_eInvalidPage":
      return CMsgClientToGCSetFavoritePageResponse_EResponse.k_eInvalidPage;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCSetFavoritePageResponse_EResponse",
      );
  }
}

export function cMsgClientToGCSetFavoritePageResponse_EResponseToJSON(
  object: CMsgClientToGCSetFavoritePageResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCSetFavoritePageResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCSetFavoritePageResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCSetFavoritePageResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCSetFavoritePageResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCSetFavoritePageResponse_EResponse.k_eInvalidPage:
      return "k_eInvalidPage";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCSetFavoritePageResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCClaimSwag {
  eventId: EEvent;
  actionId: number;
  data: number;
}

export interface CMsgClientToGCClaimSwagResponse {
  response: CMsgClientToGCClaimSwagResponse_EResponse;
}

export enum CMsgClientToGCClaimSwagResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTimeout = 2,
  k_eTooBusy = 4,
  k_eAlreadyClaimed = 5,
  k_eDisabled = 6,
  k_eInvalidRequest = 7,
  k_eUserNotEligible = 8,
  k_eStorageError = 9,
  k_eRewardDisabled = 10,
}

export function cMsgClientToGCClaimSwagResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCClaimSwagResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCClaimSwagResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCClaimSwagResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTimeout":
      return CMsgClientToGCClaimSwagResponse_EResponse.k_eTimeout;
    case 4:
    case "k_eTooBusy":
      return CMsgClientToGCClaimSwagResponse_EResponse.k_eTooBusy;
    case 5:
    case "k_eAlreadyClaimed":
      return CMsgClientToGCClaimSwagResponse_EResponse.k_eAlreadyClaimed;
    case 6:
    case "k_eDisabled":
      return CMsgClientToGCClaimSwagResponse_EResponse.k_eDisabled;
    case 7:
    case "k_eInvalidRequest":
      return CMsgClientToGCClaimSwagResponse_EResponse.k_eInvalidRequest;
    case 8:
    case "k_eUserNotEligible":
      return CMsgClientToGCClaimSwagResponse_EResponse.k_eUserNotEligible;
    case 9:
    case "k_eStorageError":
      return CMsgClientToGCClaimSwagResponse_EResponse.k_eStorageError;
    case 10:
    case "k_eRewardDisabled":
      return CMsgClientToGCClaimSwagResponse_EResponse.k_eRewardDisabled;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCClaimSwagResponse_EResponse",
      );
  }
}

export function cMsgClientToGCClaimSwagResponse_EResponseToJSON(
  object: CMsgClientToGCClaimSwagResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCClaimSwagResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCClaimSwagResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCClaimSwagResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCClaimSwagResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCClaimSwagResponse_EResponse.k_eAlreadyClaimed:
      return "k_eAlreadyClaimed";
    case CMsgClientToGCClaimSwagResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    case CMsgClientToGCClaimSwagResponse_EResponse.k_eInvalidRequest:
      return "k_eInvalidRequest";
    case CMsgClientToGCClaimSwagResponse_EResponse.k_eUserNotEligible:
      return "k_eUserNotEligible";
    case CMsgClientToGCClaimSwagResponse_EResponse.k_eStorageError:
      return "k_eStorageError";
    case CMsgClientToGCClaimSwagResponse_EResponse.k_eRewardDisabled:
      return "k_eRewardDisabled";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCClaimSwagResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCCollectorsCacheAvailableDataRequest {
  contestId: number;
}

export interface CMsgGCToClientCollectorsCacheAvailableDataResponse {
  votes: CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote[];
}

export interface CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote {
  itemDef: number;
  voteType: CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote_EVoteType;
}

export enum CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote_EVoteType {
  k_eUp = 0,
  k_eDown = 1,
}

export function cMsgGCToClientCollectorsCacheAvailableDataResponse_Vote_EVoteTypeFromJSON(
  object: any,
): CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote_EVoteType {
  switch (object) {
    case 0:
    case "k_eUp":
      return CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote_EVoteType.k_eUp;
    case 1:
    case "k_eDown":
      return CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote_EVoteType.k_eDown;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object +
          " for enum CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote_EVoteType",
      );
  }
}

export function cMsgGCToClientCollectorsCacheAvailableDataResponse_Vote_EVoteTypeToJSON(
  object: CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote_EVoteType,
): string {
  switch (object) {
    case CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote_EVoteType.k_eUp:
      return "k_eUp";
    case CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote_EVoteType.k_eDown:
      return "k_eDown";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object +
          " for enum CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote_EVoteType",
      );
  }
}

export interface CMsgClientToGCUploadMatchClip {
  matchClip: CMatchClip | undefined;
}

export interface CMsgGCToClientUploadMatchClipResponse {
  response: CMsgGCToClientUploadMatchClipResponse_EResponse;
}

export enum CMsgGCToClientUploadMatchClipResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTimeout = 2,
  k_eTooBusy = 4,
}

export function cMsgGCToClientUploadMatchClipResponse_EResponseFromJSON(
  object: any,
): CMsgGCToClientUploadMatchClipResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgGCToClientUploadMatchClipResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgGCToClientUploadMatchClipResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTimeout":
      return CMsgGCToClientUploadMatchClipResponse_EResponse.k_eTimeout;
    case 4:
    case "k_eTooBusy":
      return CMsgGCToClientUploadMatchClipResponse_EResponse.k_eTooBusy;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientUploadMatchClipResponse_EResponse",
      );
  }
}

export function cMsgGCToClientUploadMatchClipResponse_EResponseToJSON(
  object: CMsgGCToClientUploadMatchClipResponse_EResponse,
): string {
  switch (object) {
    case CMsgGCToClientUploadMatchClipResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgGCToClientUploadMatchClipResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgGCToClientUploadMatchClipResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgGCToClientUploadMatchClipResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientUploadMatchClipResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCMapStatsRequest {
}

export interface CMsgGCToClientMapStatsResponse {
  response: CMsgGCToClientMapStatsResponse_EResponse;
  personalStats: CMsgMapStatsSnapshot | undefined;
  globalStats: CMsgGlobalMapStats | undefined;
}

export enum CMsgGCToClientMapStatsResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
}

export function cMsgGCToClientMapStatsResponse_EResponseFromJSON(
  object: any,
): CMsgGCToClientMapStatsResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgGCToClientMapStatsResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgGCToClientMapStatsResponse_EResponse.k_eSuccess;
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientMapStatsResponse_EResponse",
      );
  }
}

export function cMsgGCToClientMapStatsResponse_EResponseToJSON(
  object: CMsgGCToClientMapStatsResponse_EResponse,
): string {
  switch (object) {
    case CMsgGCToClientMapStatsResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgGCToClientMapStatsResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    default:
      throw new tsProtoGlobalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCToClientMapStatsResponse_EResponse",
      );
  }
}

function createBaseCMsgClientSuspended(): CMsgClientSuspended {
  return { timeEnd: 0 };
}

export const CMsgClientSuspended = {
  encode(message: CMsgClientSuspended, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timeEnd !== 0) {
      writer.uint32(8).uint32(message.timeEnd);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientSuspended {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientSuspended();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.timeEnd = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientSuspended {
    return { timeEnd: isSet(object.timeEnd) ? Number(object.timeEnd) : 0 };
  },

  toJSON(message: CMsgClientSuspended): unknown {
    const obj: any = {};
    message.timeEnd !== undefined && (obj.timeEnd = Math.round(message.timeEnd));
    return obj;
  },
};

function createBaseCMsgBalancedShuffleLobby(): CMsgBalancedShuffleLobby {
  return {};
}

export const CMsgBalancedShuffleLobby = {
  encode(_: CMsgBalancedShuffleLobby, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgBalancedShuffleLobby {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgBalancedShuffleLobby();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgBalancedShuffleLobby {
    return {};
  },

  toJSON(_: CMsgBalancedShuffleLobby): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgInitialQuestionnaireResponse(): CMsgInitialQuestionnaireResponse {
  return { initialSkill: 0 };
}

export const CMsgInitialQuestionnaireResponse = {
  encode(message: CMsgInitialQuestionnaireResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.initialSkill !== 0) {
      writer.uint32(8).uint32(message.initialSkill);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgInitialQuestionnaireResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgInitialQuestionnaireResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.initialSkill = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgInitialQuestionnaireResponse {
    return { initialSkill: isSet(object.initialSkill) ? Number(object.initialSkill) : 0 };
  },

  toJSON(message: CMsgInitialQuestionnaireResponse): unknown {
    const obj: any = {};
    message.initialSkill !== undefined && (obj.initialSkill = Math.round(message.initialSkill));
    return obj;
  },
};

function createBaseCMsgDOTARequestMatchesResponse(): CMsgDOTARequestMatchesResponse {
  return { matches: [], series: [], requestId: 0, totalResults: 0, resultsRemaining: 0 };
}

export const CMsgDOTARequestMatchesResponse = {
  encode(message: CMsgDOTARequestMatchesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.matches) {
      CMsgDOTAMatch.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.series) {
      CMsgDOTARequestMatchesResponse_Series.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.requestId !== 0) {
      writer.uint32(24).uint32(message.requestId);
    }
    if (message.totalResults !== 0) {
      writer.uint32(32).uint32(message.totalResults);
    }
    if (message.resultsRemaining !== 0) {
      writer.uint32(40).uint32(message.resultsRemaining);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARequestMatchesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARequestMatchesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.matches.push(CMsgDOTAMatch.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.series.push(CMsgDOTARequestMatchesResponse_Series.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.requestId = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.totalResults = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.resultsRemaining = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARequestMatchesResponse {
    return {
      matches: Array.isArray(object?.matches) ? object.matches.map((e: any) => CMsgDOTAMatch.fromJSON(e)) : [],
      series: Array.isArray(object?.series)
        ? object.series.map((e: any) => CMsgDOTARequestMatchesResponse_Series.fromJSON(e))
        : [],
      requestId: isSet(object.requestId) ? Number(object.requestId) : 0,
      totalResults: isSet(object.totalResults) ? Number(object.totalResults) : 0,
      resultsRemaining: isSet(object.resultsRemaining) ? Number(object.resultsRemaining) : 0,
    };
  },

  toJSON(message: CMsgDOTARequestMatchesResponse): unknown {
    const obj: any = {};
    if (message.matches) {
      obj.matches = message.matches.map((e) => e ? CMsgDOTAMatch.toJSON(e) : undefined);
    } else {
      obj.matches = [];
    }
    if (message.series) {
      obj.series = message.series.map((e) => e ? CMsgDOTARequestMatchesResponse_Series.toJSON(e) : undefined);
    } else {
      obj.series = [];
    }
    message.requestId !== undefined && (obj.requestId = Math.round(message.requestId));
    message.totalResults !== undefined && (obj.totalResults = Math.round(message.totalResults));
    message.resultsRemaining !== undefined && (obj.resultsRemaining = Math.round(message.resultsRemaining));
    return obj;
  },
};

function createBaseCMsgDOTARequestMatchesResponse_Series(): CMsgDOTARequestMatchesResponse_Series {
  return { matches: [], seriesId: 0, seriesType: 0 };
}

export const CMsgDOTARequestMatchesResponse_Series = {
  encode(message: CMsgDOTARequestMatchesResponse_Series, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.matches) {
      CMsgDOTAMatch.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.seriesId !== 0) {
      writer.uint32(16).uint32(message.seriesId);
    }
    if (message.seriesType !== 0) {
      writer.uint32(24).uint32(message.seriesType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARequestMatchesResponse_Series {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARequestMatchesResponse_Series();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.matches.push(CMsgDOTAMatch.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.seriesId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.seriesType = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARequestMatchesResponse_Series {
    return {
      matches: Array.isArray(object?.matches) ? object.matches.map((e: any) => CMsgDOTAMatch.fromJSON(e)) : [],
      seriesId: isSet(object.seriesId) ? Number(object.seriesId) : 0,
      seriesType: isSet(object.seriesType) ? Number(object.seriesType) : 0,
    };
  },

  toJSON(message: CMsgDOTARequestMatchesResponse_Series): unknown {
    const obj: any = {};
    if (message.matches) {
      obj.matches = message.matches.map((e) => e ? CMsgDOTAMatch.toJSON(e) : undefined);
    } else {
      obj.matches = [];
    }
    message.seriesId !== undefined && (obj.seriesId = Math.round(message.seriesId));
    message.seriesType !== undefined && (obj.seriesType = Math.round(message.seriesType));
    return obj;
  },
};

function createBaseCMsgDOTAPopup(): CMsgDOTAPopup {
  return {
    id: 0,
    customText: "",
    intData: 0,
    popupData: Buffer.alloc(0),
    locTokenHeader: "",
    locTokenMsg: "",
    varNames: [],
    varValues: [],
    debugText: "",
  };
}

export const CMsgDOTAPopup = {
  encode(message: CMsgDOTAPopup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.customText !== "") {
      writer.uint32(18).string(message.customText);
    }
    if (message.intData !== 0) {
      writer.uint32(24).sint32(message.intData);
    }
    if (message.popupData.length !== 0) {
      writer.uint32(34).bytes(message.popupData);
    }
    if (message.locTokenHeader !== "") {
      writer.uint32(42).string(message.locTokenHeader);
    }
    if (message.locTokenMsg !== "") {
      writer.uint32(50).string(message.locTokenMsg);
    }
    for (const v of message.varNames) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.varValues) {
      writer.uint32(66).string(v!);
    }
    if (message.debugText !== "") {
      writer.uint32(74).string(message.debugText);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAPopup {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAPopup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.id = reader.int32() as any;
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.customText = reader.string();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.intData = reader.sint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.popupData = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag != 42) {
            break;
          }

          message.locTokenHeader = reader.string();
          continue;
        case 6:
          if (tag != 50) {
            break;
          }

          message.locTokenMsg = reader.string();
          continue;
        case 7:
          if (tag != 58) {
            break;
          }

          message.varNames.push(reader.string());
          continue;
        case 8:
          if (tag != 66) {
            break;
          }

          message.varValues.push(reader.string());
          continue;
        case 9:
          if (tag != 74) {
            break;
          }

          message.debugText = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAPopup {
    return {
      id: isSet(object.id) ? cMsgDOTAPopup_PopupIDFromJSON(object.id) : 0,
      customText: isSet(object.customText) ? String(object.customText) : "",
      intData: isSet(object.intData) ? Number(object.intData) : 0,
      popupData: isSet(object.popupData) ? Buffer.from(bytesFromBase64(object.popupData)) : Buffer.alloc(0),
      locTokenHeader: isSet(object.locTokenHeader) ? String(object.locTokenHeader) : "",
      locTokenMsg: isSet(object.locTokenMsg) ? String(object.locTokenMsg) : "",
      varNames: Array.isArray(object?.varNames) ? object.varNames.map((e: any) => String(e)) : [],
      varValues: Array.isArray(object?.varValues) ? object.varValues.map((e: any) => String(e)) : [],
      debugText: isSet(object.debugText) ? String(object.debugText) : "",
    };
  },

  toJSON(message: CMsgDOTAPopup): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = cMsgDOTAPopup_PopupIDToJSON(message.id));
    message.customText !== undefined && (obj.customText = message.customText);
    message.intData !== undefined && (obj.intData = Math.round(message.intData));
    message.popupData !== undefined &&
      (obj.popupData = base64FromBytes(message.popupData !== undefined ? message.popupData : Buffer.alloc(0)));
    message.locTokenHeader !== undefined && (obj.locTokenHeader = message.locTokenHeader);
    message.locTokenMsg !== undefined && (obj.locTokenMsg = message.locTokenMsg);
    if (message.varNames) {
      obj.varNames = message.varNames.map((e) => e);
    } else {
      obj.varNames = [];
    }
    if (message.varValues) {
      obj.varValues = message.varValues.map((e) => e);
    } else {
      obj.varValues = [];
    }
    message.debugText !== undefined && (obj.debugText = message.debugText);
    return obj;
  },
};

function createBaseCMsgDOTAReportsRemainingRequest(): CMsgDOTAReportsRemainingRequest {
  return {};
}

export const CMsgDOTAReportsRemainingRequest = {
  encode(_: CMsgDOTAReportsRemainingRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAReportsRemainingRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAReportsRemainingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgDOTAReportsRemainingRequest {
    return {};
  },

  toJSON(_: CMsgDOTAReportsRemainingRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgDOTAReportsRemainingResponse(): CMsgDOTAReportsRemainingResponse {
  return {
    numPositiveReportsRemaining: 0,
    numNegativeReportsRemaining: 0,
    numPositiveReportsTotal: 0,
    numNegativeReportsTotal: 0,
    numCommsReportsRemaining: 0,
    numCommsReportsTotal: 0,
  };
}

export const CMsgDOTAReportsRemainingResponse = {
  encode(message: CMsgDOTAReportsRemainingResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.numPositiveReportsRemaining !== 0) {
      writer.uint32(8).uint32(message.numPositiveReportsRemaining);
    }
    if (message.numNegativeReportsRemaining !== 0) {
      writer.uint32(16).uint32(message.numNegativeReportsRemaining);
    }
    if (message.numPositiveReportsTotal !== 0) {
      writer.uint32(24).uint32(message.numPositiveReportsTotal);
    }
    if (message.numNegativeReportsTotal !== 0) {
      writer.uint32(32).uint32(message.numNegativeReportsTotal);
    }
    if (message.numCommsReportsRemaining !== 0) {
      writer.uint32(40).uint32(message.numCommsReportsRemaining);
    }
    if (message.numCommsReportsTotal !== 0) {
      writer.uint32(48).uint32(message.numCommsReportsTotal);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAReportsRemainingResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAReportsRemainingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.numPositiveReportsRemaining = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.numNegativeReportsRemaining = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.numPositiveReportsTotal = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.numNegativeReportsTotal = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.numCommsReportsRemaining = reader.uint32();
          continue;
        case 6:
          if (tag != 48) {
            break;
          }

          message.numCommsReportsTotal = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAReportsRemainingResponse {
    return {
      numPositiveReportsRemaining: isSet(object.numPositiveReportsRemaining)
        ? Number(object.numPositiveReportsRemaining)
        : 0,
      numNegativeReportsRemaining: isSet(object.numNegativeReportsRemaining)
        ? Number(object.numNegativeReportsRemaining)
        : 0,
      numPositiveReportsTotal: isSet(object.numPositiveReportsTotal) ? Number(object.numPositiveReportsTotal) : 0,
      numNegativeReportsTotal: isSet(object.numNegativeReportsTotal) ? Number(object.numNegativeReportsTotal) : 0,
      numCommsReportsRemaining: isSet(object.numCommsReportsRemaining) ? Number(object.numCommsReportsRemaining) : 0,
      numCommsReportsTotal: isSet(object.numCommsReportsTotal) ? Number(object.numCommsReportsTotal) : 0,
    };
  },

  toJSON(message: CMsgDOTAReportsRemainingResponse): unknown {
    const obj: any = {};
    message.numPositiveReportsRemaining !== undefined &&
      (obj.numPositiveReportsRemaining = Math.round(message.numPositiveReportsRemaining));
    message.numNegativeReportsRemaining !== undefined &&
      (obj.numNegativeReportsRemaining = Math.round(message.numNegativeReportsRemaining));
    message.numPositiveReportsTotal !== undefined &&
      (obj.numPositiveReportsTotal = Math.round(message.numPositiveReportsTotal));
    message.numNegativeReportsTotal !== undefined &&
      (obj.numNegativeReportsTotal = Math.round(message.numNegativeReportsTotal));
    message.numCommsReportsRemaining !== undefined &&
      (obj.numCommsReportsRemaining = Math.round(message.numCommsReportsRemaining));
    message.numCommsReportsTotal !== undefined && (obj.numCommsReportsTotal = Math.round(message.numCommsReportsTotal));
    return obj;
  },
};

function createBaseCMsgDOTASubmitPlayerReport(): CMsgDOTASubmitPlayerReport {
  return { targetAccountId: 0, reportFlags: 0, lobbyId: "0", comment: "" };
}

export const CMsgDOTASubmitPlayerReport = {
  encode(message: CMsgDOTASubmitPlayerReport, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetAccountId !== 0) {
      writer.uint32(8).uint32(message.targetAccountId);
    }
    if (message.reportFlags !== 0) {
      writer.uint32(16).uint32(message.reportFlags);
    }
    if (message.lobbyId !== "0") {
      writer.uint32(32).uint64(message.lobbyId);
    }
    if (message.comment !== "") {
      writer.uint32(42).string(message.comment);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASubmitPlayerReport {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASubmitPlayerReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.targetAccountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.reportFlags = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.lobbyId = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag != 42) {
            break;
          }

          message.comment = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASubmitPlayerReport {
    return {
      targetAccountId: isSet(object.targetAccountId) ? Number(object.targetAccountId) : 0,
      reportFlags: isSet(object.reportFlags) ? Number(object.reportFlags) : 0,
      lobbyId: isSet(object.lobbyId) ? String(object.lobbyId) : "0",
      comment: isSet(object.comment) ? String(object.comment) : "",
    };
  },

  toJSON(message: CMsgDOTASubmitPlayerReport): unknown {
    const obj: any = {};
    message.targetAccountId !== undefined && (obj.targetAccountId = Math.round(message.targetAccountId));
    message.reportFlags !== undefined && (obj.reportFlags = Math.round(message.reportFlags));
    message.lobbyId !== undefined && (obj.lobbyId = message.lobbyId);
    message.comment !== undefined && (obj.comment = message.comment);
    return obj;
  },
};

function createBaseCMsgDOTASubmitPlayerReportResponse(): CMsgDOTASubmitPlayerReportResponse {
  return { targetAccountId: 0, reportFlags: 0, debugMessage: "", enumResult: 0 };
}

export const CMsgDOTASubmitPlayerReportResponse = {
  encode(message: CMsgDOTASubmitPlayerReportResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetAccountId !== 0) {
      writer.uint32(8).uint32(message.targetAccountId);
    }
    if (message.reportFlags !== 0) {
      writer.uint32(16).uint32(message.reportFlags);
    }
    if (message.debugMessage !== "") {
      writer.uint32(34).string(message.debugMessage);
    }
    if (message.enumResult !== 0) {
      writer.uint32(40).int32(message.enumResult);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASubmitPlayerReportResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASubmitPlayerReportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.targetAccountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.reportFlags = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.debugMessage = reader.string();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.enumResult = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASubmitPlayerReportResponse {
    return {
      targetAccountId: isSet(object.targetAccountId) ? Number(object.targetAccountId) : 0,
      reportFlags: isSet(object.reportFlags) ? Number(object.reportFlags) : 0,
      debugMessage: isSet(object.debugMessage) ? String(object.debugMessage) : "",
      enumResult: isSet(object.enumResult) ? cMsgDOTASubmitPlayerReportResponse_EResultFromJSON(object.enumResult) : 0,
    };
  },

  toJSON(message: CMsgDOTASubmitPlayerReportResponse): unknown {
    const obj: any = {};
    message.targetAccountId !== undefined && (obj.targetAccountId = Math.round(message.targetAccountId));
    message.reportFlags !== undefined && (obj.reportFlags = Math.round(message.reportFlags));
    message.debugMessage !== undefined && (obj.debugMessage = message.debugMessage);
    message.enumResult !== undefined &&
      (obj.enumResult = cMsgDOTASubmitPlayerReportResponse_EResultToJSON(message.enumResult));
    return obj;
  },
};

function createBaseCMsgDOTASubmitPlayerAvoidRequest(): CMsgDOTASubmitPlayerAvoidRequest {
  return { targetAccountId: 0, lobbyId: "0", userNote: "" };
}

export const CMsgDOTASubmitPlayerAvoidRequest = {
  encode(message: CMsgDOTASubmitPlayerAvoidRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetAccountId !== 0) {
      writer.uint32(8).uint32(message.targetAccountId);
    }
    if (message.lobbyId !== "0") {
      writer.uint32(32).uint64(message.lobbyId);
    }
    if (message.userNote !== "") {
      writer.uint32(42).string(message.userNote);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASubmitPlayerAvoidRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASubmitPlayerAvoidRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.targetAccountId = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.lobbyId = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag != 42) {
            break;
          }

          message.userNote = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASubmitPlayerAvoidRequest {
    return {
      targetAccountId: isSet(object.targetAccountId) ? Number(object.targetAccountId) : 0,
      lobbyId: isSet(object.lobbyId) ? String(object.lobbyId) : "0",
      userNote: isSet(object.userNote) ? String(object.userNote) : "",
    };
  },

  toJSON(message: CMsgDOTASubmitPlayerAvoidRequest): unknown {
    const obj: any = {};
    message.targetAccountId !== undefined && (obj.targetAccountId = Math.round(message.targetAccountId));
    message.lobbyId !== undefined && (obj.lobbyId = message.lobbyId);
    message.userNote !== undefined && (obj.userNote = message.userNote);
    return obj;
  },
};

function createBaseCMsgDOTASubmitPlayerAvoidRequestResponse(): CMsgDOTASubmitPlayerAvoidRequestResponse {
  return { targetAccountId: 0, result: 0, debugMessage: "" };
}

export const CMsgDOTASubmitPlayerAvoidRequestResponse = {
  encode(message: CMsgDOTASubmitPlayerAvoidRequestResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetAccountId !== 0) {
      writer.uint32(8).uint32(message.targetAccountId);
    }
    if (message.result !== 0) {
      writer.uint32(16).uint32(message.result);
    }
    if (message.debugMessage !== "") {
      writer.uint32(26).string(message.debugMessage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASubmitPlayerAvoidRequestResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASubmitPlayerAvoidRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.targetAccountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.result = reader.uint32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.debugMessage = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASubmitPlayerAvoidRequestResponse {
    return {
      targetAccountId: isSet(object.targetAccountId) ? Number(object.targetAccountId) : 0,
      result: isSet(object.result) ? Number(object.result) : 0,
      debugMessage: isSet(object.debugMessage) ? String(object.debugMessage) : "",
    };
  },

  toJSON(message: CMsgDOTASubmitPlayerAvoidRequestResponse): unknown {
    const obj: any = {};
    message.targetAccountId !== undefined && (obj.targetAccountId = Math.round(message.targetAccountId));
    message.result !== undefined && (obj.result = Math.round(message.result));
    message.debugMessage !== undefined && (obj.debugMessage = message.debugMessage);
    return obj;
  },
};

function createBaseCMsgDOTASubmitLobbyMVPVote(): CMsgDOTASubmitLobbyMVPVote {
  return { targetAccountId: 0 };
}

export const CMsgDOTASubmitLobbyMVPVote = {
  encode(message: CMsgDOTASubmitLobbyMVPVote, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetAccountId !== 0) {
      writer.uint32(8).uint32(message.targetAccountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASubmitLobbyMVPVote {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASubmitLobbyMVPVote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.targetAccountId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASubmitLobbyMVPVote {
    return { targetAccountId: isSet(object.targetAccountId) ? Number(object.targetAccountId) : 0 };
  },

  toJSON(message: CMsgDOTASubmitLobbyMVPVote): unknown {
    const obj: any = {};
    message.targetAccountId !== undefined && (obj.targetAccountId = Math.round(message.targetAccountId));
    return obj;
  },
};

function createBaseCMsgDOTASubmitLobbyMVPVoteResponse(): CMsgDOTASubmitLobbyMVPVoteResponse {
  return { targetAccountId: 0, eresult: 0 };
}

export const CMsgDOTASubmitLobbyMVPVoteResponse = {
  encode(message: CMsgDOTASubmitLobbyMVPVoteResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetAccountId !== 0) {
      writer.uint32(8).uint32(message.targetAccountId);
    }
    if (message.eresult !== 0) {
      writer.uint32(16).uint32(message.eresult);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASubmitLobbyMVPVoteResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASubmitLobbyMVPVoteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.targetAccountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.eresult = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASubmitLobbyMVPVoteResponse {
    return {
      targetAccountId: isSet(object.targetAccountId) ? Number(object.targetAccountId) : 0,
      eresult: isSet(object.eresult) ? Number(object.eresult) : 0,
    };
  },

  toJSON(message: CMsgDOTASubmitLobbyMVPVoteResponse): unknown {
    const obj: any = {};
    message.targetAccountId !== undefined && (obj.targetAccountId = Math.round(message.targetAccountId));
    message.eresult !== undefined && (obj.eresult = Math.round(message.eresult));
    return obj;
  },
};

function createBaseCMsgDOTALobbyMVPAwarded(): CMsgDOTALobbyMVPAwarded {
  return { matchId: "0", mvpAccountId: [] };
}

export const CMsgDOTALobbyMVPAwarded = {
  encode(message: CMsgDOTALobbyMVPAwarded, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    writer.uint32(18).fork();
    for (const v of message.mvpAccountId) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALobbyMVPAwarded {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALobbyMVPAwarded();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag == 16) {
            message.mvpAccountId.push(reader.uint32());
            continue;
          }

          if (tag == 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.mvpAccountId.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALobbyMVPAwarded {
    return {
      matchId: isSet(object.matchId) ? String(object.matchId) : "0",
      mvpAccountId: Array.isArray(object?.mvpAccountId) ? object.mvpAccountId.map((e: any) => Number(e)) : [],
    };
  },

  toJSON(message: CMsgDOTALobbyMVPAwarded): unknown {
    const obj: any = {};
    message.matchId !== undefined && (obj.matchId = message.matchId);
    if (message.mvpAccountId) {
      obj.mvpAccountId = message.mvpAccountId.map((e) => Math.round(e));
    } else {
      obj.mvpAccountId = [];
    }
    return obj;
  },
};

function createBaseCMsgDOTAKickedFromMatchmakingQueue(): CMsgDOTAKickedFromMatchmakingQueue {
  return { matchType: 0 };
}

export const CMsgDOTAKickedFromMatchmakingQueue = {
  encode(message: CMsgDOTAKickedFromMatchmakingQueue, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchType !== 0) {
      writer.uint32(8).int32(message.matchType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAKickedFromMatchmakingQueue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAKickedFromMatchmakingQueue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.matchType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAKickedFromMatchmakingQueue {
    return { matchType: isSet(object.matchType) ? matchTypeFromJSON(object.matchType) : 0 };
  },

  toJSON(message: CMsgDOTAKickedFromMatchmakingQueue): unknown {
    const obj: any = {};
    message.matchType !== undefined && (obj.matchType = matchTypeToJSON(message.matchType));
    return obj;
  },
};

function createBaseCMsgGCMatchDetailsRequest(): CMsgGCMatchDetailsRequest {
  return { matchId: "0" };
}

export const CMsgGCMatchDetailsRequest = {
  encode(message: CMsgGCMatchDetailsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCMatchDetailsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCMatchDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCMatchDetailsRequest {
    return { matchId: isSet(object.matchId) ? String(object.matchId) : "0" };
  },

  toJSON(message: CMsgGCMatchDetailsRequest): unknown {
    const obj: any = {};
    message.matchId !== undefined && (obj.matchId = message.matchId);
    return obj;
  },
};

function createBaseCMsgGCMatchDetailsResponse(): CMsgGCMatchDetailsResponse {
  return { result: 0, match: undefined, vote: 0 };
}

export const CMsgGCMatchDetailsResponse = {
  encode(message: CMsgGCMatchDetailsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.match !== undefined) {
      CMsgDOTAMatch.encode(message.match, writer.uint32(18).fork()).ldelim();
    }
    if (message.vote !== 0) {
      writer.uint32(24).int32(message.vote);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCMatchDetailsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCMatchDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.match = CMsgDOTAMatch.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.vote = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCMatchDetailsResponse {
    return {
      result: isSet(object.result) ? Number(object.result) : 0,
      match: isSet(object.match) ? CMsgDOTAMatch.fromJSON(object.match) : undefined,
      vote: isSet(object.vote) ? dOTAMatchVoteFromJSON(object.vote) : 0,
    };
  },

  toJSON(message: CMsgGCMatchDetailsResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = Math.round(message.result));
    message.match !== undefined && (obj.match = message.match ? CMsgDOTAMatch.toJSON(message.match) : undefined);
    message.vote !== undefined && (obj.vote = dOTAMatchVoteToJSON(message.vote));
    return obj;
  },
};

function createBaseCMsgDOTAProfileTickets(): CMsgDOTAProfileTickets {
  return { result: 0, accountId: 0, leaguePasses: [] };
}

export const CMsgDOTAProfileTickets = {
  encode(message: CMsgDOTAProfileTickets, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.accountId !== 0) {
      writer.uint32(16).uint32(message.accountId);
    }
    for (const v of message.leaguePasses) {
      CMsgDOTAProfileTickets_LeaguePass.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAProfileTickets {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAProfileTickets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.leaguePasses.push(CMsgDOTAProfileTickets_LeaguePass.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAProfileTickets {
    return {
      result: isSet(object.result) ? Number(object.result) : 0,
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      leaguePasses: Array.isArray(object?.leaguePasses)
        ? object.leaguePasses.map((e: any) => CMsgDOTAProfileTickets_LeaguePass.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTAProfileTickets): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = Math.round(message.result));
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    if (message.leaguePasses) {
      obj.leaguePasses = message.leaguePasses.map((e) => e ? CMsgDOTAProfileTickets_LeaguePass.toJSON(e) : undefined);
    } else {
      obj.leaguePasses = [];
    }
    return obj;
  },
};

function createBaseCMsgDOTAProfileTickets_LeaguePass(): CMsgDOTAProfileTickets_LeaguePass {
  return { leagueId: 0, itemDef: 0 };
}

export const CMsgDOTAProfileTickets_LeaguePass = {
  encode(message: CMsgDOTAProfileTickets_LeaguePass, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.leagueId !== 0) {
      writer.uint32(8).uint32(message.leagueId);
    }
    if (message.itemDef !== 0) {
      writer.uint32(16).uint32(message.itemDef);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAProfileTickets_LeaguePass {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAProfileTickets_LeaguePass();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.itemDef = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAProfileTickets_LeaguePass {
    return {
      leagueId: isSet(object.leagueId) ? Number(object.leagueId) : 0,
      itemDef: isSet(object.itemDef) ? Number(object.itemDef) : 0,
    };
  },

  toJSON(message: CMsgDOTAProfileTickets_LeaguePass): unknown {
    const obj: any = {};
    message.leagueId !== undefined && (obj.leagueId = Math.round(message.leagueId));
    message.itemDef !== undefined && (obj.itemDef = Math.round(message.itemDef));
    return obj;
  },
};

function createBaseCMsgClientToGCGetProfileTickets(): CMsgClientToGCGetProfileTickets {
  return { accountId: 0 };
}

export const CMsgClientToGCGetProfileTickets = {
  encode(message: CMsgClientToGCGetProfileTickets, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetProfileTickets {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetProfileTickets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetProfileTickets {
    return { accountId: isSet(object.accountId) ? Number(object.accountId) : 0 };
  },

  toJSON(message: CMsgClientToGCGetProfileTickets): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    return obj;
  },
};

function createBaseCMsgGCToClientPartySearchInvites(): CMsgGCToClientPartySearchInvites {
  return { invites: [] };
}

export const CMsgGCToClientPartySearchInvites = {
  encode(message: CMsgGCToClientPartySearchInvites, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.invites) {
      CMsgGCToClientPartySearchInvite.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientPartySearchInvites {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientPartySearchInvites();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.invites.push(CMsgGCToClientPartySearchInvite.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientPartySearchInvites {
    return {
      invites: Array.isArray(object?.invites)
        ? object.invites.map((e: any) => CMsgGCToClientPartySearchInvite.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCToClientPartySearchInvites): unknown {
    const obj: any = {};
    if (message.invites) {
      obj.invites = message.invites.map((e) => e ? CMsgGCToClientPartySearchInvite.toJSON(e) : undefined);
    } else {
      obj.invites = [];
    }
    return obj;
  },
};

function createBaseCMsgDOTAWelcome(): CMsgDOTAWelcome {
  return {
    storeItemHash: 0,
    timeplayedconsecutively: 0,
    allow3rdPartyMatchHistory: false,
    lastIpAddress: 0,
    profilePrivate: false,
    currency: 0,
    shouldRequestPlayerOrigin: false,
    gcSocacheFileVersion: 0,
    isPerfectWorldTestAccount: false,
    extraMessages: [],
    minimumRecentItemId: "0",
    activeEvent: 0,
    additionalUserMessage: 0,
    customGameWhitelistVersion: 0,
    partySearchFriendInvites: undefined,
    remainingPlaytime: 0,
    disableGuildPersonaInfo: false,
    extraMessageBlocks: [],
  };
}

export const CMsgDOTAWelcome = {
  encode(message: CMsgDOTAWelcome, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.storeItemHash !== 0) {
      writer.uint32(40).uint32(message.storeItemHash);
    }
    if (message.timeplayedconsecutively !== 0) {
      writer.uint32(48).uint32(message.timeplayedconsecutively);
    }
    if (message.allow3rdPartyMatchHistory === true) {
      writer.uint32(56).bool(message.allow3rdPartyMatchHistory);
    }
    if (message.lastIpAddress !== 0) {
      writer.uint32(104).uint32(message.lastIpAddress);
    }
    if (message.profilePrivate === true) {
      writer.uint32(136).bool(message.profilePrivate);
    }
    if (message.currency !== 0) {
      writer.uint32(144).uint32(message.currency);
    }
    if (message.shouldRequestPlayerOrigin === true) {
      writer.uint32(160).bool(message.shouldRequestPlayerOrigin);
    }
    if (message.gcSocacheFileVersion !== 0) {
      writer.uint32(176).uint32(message.gcSocacheFileVersion);
    }
    if (message.isPerfectWorldTestAccount === true) {
      writer.uint32(192).bool(message.isPerfectWorldTestAccount);
    }
    for (const v of message.extraMessages) {
      CMsgDOTAWelcome_CExtraMsg.encode(v!, writer.uint32(210).fork()).ldelim();
    }
    if (message.minimumRecentItemId !== "0") {
      writer.uint32(216).uint64(message.minimumRecentItemId);
    }
    if (message.activeEvent !== 0) {
      writer.uint32(224).int32(message.activeEvent);
    }
    if (message.additionalUserMessage !== 0) {
      writer.uint32(232).uint32(message.additionalUserMessage);
    }
    if (message.customGameWhitelistVersion !== 0) {
      writer.uint32(240).uint32(message.customGameWhitelistVersion);
    }
    if (message.partySearchFriendInvites !== undefined) {
      CMsgGCToClientPartySearchInvites.encode(message.partySearchFriendInvites, writer.uint32(250).fork()).ldelim();
    }
    if (message.remainingPlaytime !== 0) {
      writer.uint32(256).int32(message.remainingPlaytime);
    }
    if (message.disableGuildPersonaInfo === true) {
      writer.uint32(264).bool(message.disableGuildPersonaInfo);
    }
    for (const v of message.extraMessageBlocks) {
      CExtraMsgBlock.encode(v!, writer.uint32(274).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAWelcome {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAWelcome();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag != 40) {
            break;
          }

          message.storeItemHash = reader.uint32();
          continue;
        case 6:
          if (tag != 48) {
            break;
          }

          message.timeplayedconsecutively = reader.uint32();
          continue;
        case 7:
          if (tag != 56) {
            break;
          }

          message.allow3rdPartyMatchHistory = reader.bool();
          continue;
        case 13:
          if (tag != 104) {
            break;
          }

          message.lastIpAddress = reader.uint32();
          continue;
        case 17:
          if (tag != 136) {
            break;
          }

          message.profilePrivate = reader.bool();
          continue;
        case 18:
          if (tag != 144) {
            break;
          }

          message.currency = reader.uint32();
          continue;
        case 20:
          if (tag != 160) {
            break;
          }

          message.shouldRequestPlayerOrigin = reader.bool();
          continue;
        case 22:
          if (tag != 176) {
            break;
          }

          message.gcSocacheFileVersion = reader.uint32();
          continue;
        case 24:
          if (tag != 192) {
            break;
          }

          message.isPerfectWorldTestAccount = reader.bool();
          continue;
        case 26:
          if (tag != 210) {
            break;
          }

          message.extraMessages.push(CMsgDOTAWelcome_CExtraMsg.decode(reader, reader.uint32()));
          continue;
        case 27:
          if (tag != 216) {
            break;
          }

          message.minimumRecentItemId = longToString(reader.uint64() as Long);
          continue;
        case 28:
          if (tag != 224) {
            break;
          }

          message.activeEvent = reader.int32() as any;
          continue;
        case 29:
          if (tag != 232) {
            break;
          }

          message.additionalUserMessage = reader.uint32();
          continue;
        case 30:
          if (tag != 240) {
            break;
          }

          message.customGameWhitelistVersion = reader.uint32();
          continue;
        case 31:
          if (tag != 250) {
            break;
          }

          message.partySearchFriendInvites = CMsgGCToClientPartySearchInvites.decode(reader, reader.uint32());
          continue;
        case 32:
          if (tag != 256) {
            break;
          }

          message.remainingPlaytime = reader.int32();
          continue;
        case 33:
          if (tag != 264) {
            break;
          }

          message.disableGuildPersonaInfo = reader.bool();
          continue;
        case 34:
          if (tag != 274) {
            break;
          }

          message.extraMessageBlocks.push(CExtraMsgBlock.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAWelcome {
    return {
      storeItemHash: isSet(object.storeItemHash) ? Number(object.storeItemHash) : 0,
      timeplayedconsecutively: isSet(object.timeplayedconsecutively) ? Number(object.timeplayedconsecutively) : 0,
      allow3rdPartyMatchHistory: isSet(object.allow3rdPartyMatchHistory)
        ? Boolean(object.allow3rdPartyMatchHistory)
        : false,
      lastIpAddress: isSet(object.lastIpAddress) ? Number(object.lastIpAddress) : 0,
      profilePrivate: isSet(object.profilePrivate) ? Boolean(object.profilePrivate) : false,
      currency: isSet(object.currency) ? Number(object.currency) : 0,
      shouldRequestPlayerOrigin: isSet(object.shouldRequestPlayerOrigin)
        ? Boolean(object.shouldRequestPlayerOrigin)
        : false,
      gcSocacheFileVersion: isSet(object.gcSocacheFileVersion) ? Number(object.gcSocacheFileVersion) : 0,
      isPerfectWorldTestAccount: isSet(object.isPerfectWorldTestAccount)
        ? Boolean(object.isPerfectWorldTestAccount)
        : false,
      extraMessages: Array.isArray(object?.extraMessages)
        ? object.extraMessages.map((e: any) => CMsgDOTAWelcome_CExtraMsg.fromJSON(e))
        : [],
      minimumRecentItemId: isSet(object.minimumRecentItemId) ? String(object.minimumRecentItemId) : "0",
      activeEvent: isSet(object.activeEvent) ? eEventFromJSON(object.activeEvent) : 0,
      additionalUserMessage: isSet(object.additionalUserMessage) ? Number(object.additionalUserMessage) : 0,
      customGameWhitelistVersion: isSet(object.customGameWhitelistVersion)
        ? Number(object.customGameWhitelistVersion)
        : 0,
      partySearchFriendInvites: isSet(object.partySearchFriendInvites)
        ? CMsgGCToClientPartySearchInvites.fromJSON(object.partySearchFriendInvites)
        : undefined,
      remainingPlaytime: isSet(object.remainingPlaytime) ? Number(object.remainingPlaytime) : 0,
      disableGuildPersonaInfo: isSet(object.disableGuildPersonaInfo) ? Boolean(object.disableGuildPersonaInfo) : false,
      extraMessageBlocks: Array.isArray(object?.extraMessageBlocks)
        ? object.extraMessageBlocks.map((e: any) => CExtraMsgBlock.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTAWelcome): unknown {
    const obj: any = {};
    message.storeItemHash !== undefined && (obj.storeItemHash = Math.round(message.storeItemHash));
    message.timeplayedconsecutively !== undefined &&
      (obj.timeplayedconsecutively = Math.round(message.timeplayedconsecutively));
    message.allow3rdPartyMatchHistory !== undefined &&
      (obj.allow3rdPartyMatchHistory = message.allow3rdPartyMatchHistory);
    message.lastIpAddress !== undefined && (obj.lastIpAddress = Math.round(message.lastIpAddress));
    message.profilePrivate !== undefined && (obj.profilePrivate = message.profilePrivate);
    message.currency !== undefined && (obj.currency = Math.round(message.currency));
    message.shouldRequestPlayerOrigin !== undefined &&
      (obj.shouldRequestPlayerOrigin = message.shouldRequestPlayerOrigin);
    message.gcSocacheFileVersion !== undefined && (obj.gcSocacheFileVersion = Math.round(message.gcSocacheFileVersion));
    message.isPerfectWorldTestAccount !== undefined &&
      (obj.isPerfectWorldTestAccount = message.isPerfectWorldTestAccount);
    if (message.extraMessages) {
      obj.extraMessages = message.extraMessages.map((e) => e ? CMsgDOTAWelcome_CExtraMsg.toJSON(e) : undefined);
    } else {
      obj.extraMessages = [];
    }
    message.minimumRecentItemId !== undefined && (obj.minimumRecentItemId = message.minimumRecentItemId);
    message.activeEvent !== undefined && (obj.activeEvent = eEventToJSON(message.activeEvent));
    message.additionalUserMessage !== undefined &&
      (obj.additionalUserMessage = Math.round(message.additionalUserMessage));
    message.customGameWhitelistVersion !== undefined &&
      (obj.customGameWhitelistVersion = Math.round(message.customGameWhitelistVersion));
    message.partySearchFriendInvites !== undefined && (obj.partySearchFriendInvites = message.partySearchFriendInvites
      ? CMsgGCToClientPartySearchInvites.toJSON(message.partySearchFriendInvites)
      : undefined);
    message.remainingPlaytime !== undefined && (obj.remainingPlaytime = Math.round(message.remainingPlaytime));
    message.disableGuildPersonaInfo !== undefined && (obj.disableGuildPersonaInfo = message.disableGuildPersonaInfo);
    if (message.extraMessageBlocks) {
      obj.extraMessageBlocks = message.extraMessageBlocks.map((e) => e ? CExtraMsgBlock.toJSON(e) : undefined);
    } else {
      obj.extraMessageBlocks = [];
    }
    return obj;
  },
};

function createBaseCMsgDOTAWelcome_CExtraMsg(): CMsgDOTAWelcome_CExtraMsg {
  return { id: 0, contents: Buffer.alloc(0) };
}

export const CMsgDOTAWelcome_CExtraMsg = {
  encode(message: CMsgDOTAWelcome_CExtraMsg, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.contents.length !== 0) {
      writer.uint32(18).bytes(message.contents);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAWelcome_CExtraMsg {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAWelcome_CExtraMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.contents = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAWelcome_CExtraMsg {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      contents: isSet(object.contents) ? Buffer.from(bytesFromBase64(object.contents)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CMsgDOTAWelcome_CExtraMsg): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.contents !== undefined &&
      (obj.contents = base64FromBytes(message.contents !== undefined ? message.contents : Buffer.alloc(0)));
    return obj;
  },
};

function createBaseCSODOTAGameHeroFavorites(): CSODOTAGameHeroFavorites {
  return { accountId: 0, heroId: 0 };
}

export const CSODOTAGameHeroFavorites = {
  encode(message: CSODOTAGameHeroFavorites, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.heroId !== 0) {
      writer.uint32(16).uint32(message.heroId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSODOTAGameHeroFavorites {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSODOTAGameHeroFavorites();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSODOTAGameHeroFavorites {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      heroId: isSet(object.heroId) ? Number(object.heroId) : 0,
    };
  },

  toJSON(message: CSODOTAGameHeroFavorites): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.heroId !== undefined && (obj.heroId = Math.round(message.heroId));
    return obj;
  },
};

function createBaseCMsgDOTAMatchVotes(): CMsgDOTAMatchVotes {
  return { matchId: "0", votes: [] };
}

export const CMsgDOTAMatchVotes = {
  encode(message: CMsgDOTAMatchVotes, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    for (const v of message.votes) {
      CMsgDOTAMatchVotes_PlayerVote.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAMatchVotes {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatchVotes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.votes.push(CMsgDOTAMatchVotes_PlayerVote.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatchVotes {
    return {
      matchId: isSet(object.matchId) ? String(object.matchId) : "0",
      votes: Array.isArray(object?.votes)
        ? object.votes.map((e: any) => CMsgDOTAMatchVotes_PlayerVote.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTAMatchVotes): unknown {
    const obj: any = {};
    message.matchId !== undefined && (obj.matchId = message.matchId);
    if (message.votes) {
      obj.votes = message.votes.map((e) => e ? CMsgDOTAMatchVotes_PlayerVote.toJSON(e) : undefined);
    } else {
      obj.votes = [];
    }
    return obj;
  },
};

function createBaseCMsgDOTAMatchVotes_PlayerVote(): CMsgDOTAMatchVotes_PlayerVote {
  return { accountId: 0, vote: 0 };
}

export const CMsgDOTAMatchVotes_PlayerVote = {
  encode(message: CMsgDOTAMatchVotes_PlayerVote, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.vote !== 0) {
      writer.uint32(16).uint32(message.vote);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAMatchVotes_PlayerVote {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatchVotes_PlayerVote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.vote = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatchVotes_PlayerVote {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      vote: isSet(object.vote) ? Number(object.vote) : 0,
    };
  },

  toJSON(message: CMsgDOTAMatchVotes_PlayerVote): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.vote !== undefined && (obj.vote = Math.round(message.vote));
    return obj;
  },
};

function createBaseCMsgMatchmakingMatchGroupInfo(): CMsgMatchmakingMatchGroupInfo {
  return { playersSearching: 0, autoRegionSelectPingPenalty: 0, autoRegionSelectPingPenaltyCustom: 0, status: 0 };
}

export const CMsgMatchmakingMatchGroupInfo = {
  encode(message: CMsgMatchmakingMatchGroupInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playersSearching !== 0) {
      writer.uint32(8).uint32(message.playersSearching);
    }
    if (message.autoRegionSelectPingPenalty !== 0) {
      writer.uint32(16).sint32(message.autoRegionSelectPingPenalty);
    }
    if (message.autoRegionSelectPingPenaltyCustom !== 0) {
      writer.uint32(32).sint32(message.autoRegionSelectPingPenaltyCustom);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgMatchmakingMatchGroupInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgMatchmakingMatchGroupInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.playersSearching = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.autoRegionSelectPingPenalty = reader.sint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.autoRegionSelectPingPenaltyCustom = reader.sint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgMatchmakingMatchGroupInfo {
    return {
      playersSearching: isSet(object.playersSearching) ? Number(object.playersSearching) : 0,
      autoRegionSelectPingPenalty: isSet(object.autoRegionSelectPingPenalty)
        ? Number(object.autoRegionSelectPingPenalty)
        : 0,
      autoRegionSelectPingPenaltyCustom: isSet(object.autoRegionSelectPingPenaltyCustom)
        ? Number(object.autoRegionSelectPingPenaltyCustom)
        : 0,
      status: isSet(object.status) ? eMatchGroupServerStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: CMsgMatchmakingMatchGroupInfo): unknown {
    const obj: any = {};
    message.playersSearching !== undefined && (obj.playersSearching = Math.round(message.playersSearching));
    message.autoRegionSelectPingPenalty !== undefined &&
      (obj.autoRegionSelectPingPenalty = Math.round(message.autoRegionSelectPingPenalty));
    message.autoRegionSelectPingPenaltyCustom !== undefined &&
      (obj.autoRegionSelectPingPenaltyCustom = Math.round(message.autoRegionSelectPingPenaltyCustom));
    message.status !== undefined && (obj.status = eMatchGroupServerStatusToJSON(message.status));
    return obj;
  },
};

function createBaseCMsgDOTAMatchmakingStatsRequest(): CMsgDOTAMatchmakingStatsRequest {
  return {};
}

export const CMsgDOTAMatchmakingStatsRequest = {
  encode(_: CMsgDOTAMatchmakingStatsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAMatchmakingStatsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatchmakingStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgDOTAMatchmakingStatsRequest {
    return {};
  },

  toJSON(_: CMsgDOTAMatchmakingStatsRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgDOTAMatchmakingStatsResponse(): CMsgDOTAMatchmakingStatsResponse {
  return { matchgroupsVersion: 0, legacySearchingPlayersByGroupSource2: [], matchGroups: [] };
}

export const CMsgDOTAMatchmakingStatsResponse = {
  encode(message: CMsgDOTAMatchmakingStatsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchgroupsVersion !== 0) {
      writer.uint32(8).uint32(message.matchgroupsVersion);
    }
    writer.uint32(58).fork();
    for (const v of message.legacySearchingPlayersByGroupSource2) {
      writer.uint32(v);
    }
    writer.ldelim();
    for (const v of message.matchGroups) {
      CMsgMatchmakingMatchGroupInfo.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAMatchmakingStatsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatchmakingStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.matchgroupsVersion = reader.uint32();
          continue;
        case 7:
          if (tag == 56) {
            message.legacySearchingPlayersByGroupSource2.push(reader.uint32());
            continue;
          }

          if (tag == 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.legacySearchingPlayersByGroupSource2.push(reader.uint32());
            }

            continue;
          }

          break;
        case 8:
          if (tag != 66) {
            break;
          }

          message.matchGroups.push(CMsgMatchmakingMatchGroupInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatchmakingStatsResponse {
    return {
      matchgroupsVersion: isSet(object.matchgroupsVersion) ? Number(object.matchgroupsVersion) : 0,
      legacySearchingPlayersByGroupSource2: Array.isArray(object?.legacySearchingPlayersByGroupSource2)
        ? object.legacySearchingPlayersByGroupSource2.map((e: any) => Number(e))
        : [],
      matchGroups: Array.isArray(object?.matchGroups)
        ? object.matchGroups.map((e: any) => CMsgMatchmakingMatchGroupInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTAMatchmakingStatsResponse): unknown {
    const obj: any = {};
    message.matchgroupsVersion !== undefined && (obj.matchgroupsVersion = Math.round(message.matchgroupsVersion));
    if (message.legacySearchingPlayersByGroupSource2) {
      obj.legacySearchingPlayersByGroupSource2 = message.legacySearchingPlayersByGroupSource2.map((e) => Math.round(e));
    } else {
      obj.legacySearchingPlayersByGroupSource2 = [];
    }
    if (message.matchGroups) {
      obj.matchGroups = message.matchGroups.map((e) => e ? CMsgMatchmakingMatchGroupInfo.toJSON(e) : undefined);
    } else {
      obj.matchGroups = [];
    }
    return obj;
  },
};

function createBaseCMsgDOTAUpdateMatchmakingStats(): CMsgDOTAUpdateMatchmakingStats {
  return { stats: undefined };
}

export const CMsgDOTAUpdateMatchmakingStats = {
  encode(message: CMsgDOTAUpdateMatchmakingStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stats !== undefined) {
      CMsgDOTAMatchmakingStatsResponse.encode(message.stats, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAUpdateMatchmakingStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAUpdateMatchmakingStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.stats = CMsgDOTAMatchmakingStatsResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAUpdateMatchmakingStats {
    return { stats: isSet(object.stats) ? CMsgDOTAMatchmakingStatsResponse.fromJSON(object.stats) : undefined };
  },

  toJSON(message: CMsgDOTAUpdateMatchmakingStats): unknown {
    const obj: any = {};
    message.stats !== undefined &&
      (obj.stats = message.stats ? CMsgDOTAMatchmakingStatsResponse.toJSON(message.stats) : undefined);
    return obj;
  },
};

function createBaseCMsgDOTAUpdateMatchManagementStats(): CMsgDOTAUpdateMatchManagementStats {
  return { stats: undefined };
}

export const CMsgDOTAUpdateMatchManagementStats = {
  encode(message: CMsgDOTAUpdateMatchManagementStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stats !== undefined) {
      CMsgDOTAMatchmakingStatsResponse.encode(message.stats, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAUpdateMatchManagementStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAUpdateMatchManagementStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.stats = CMsgDOTAMatchmakingStatsResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAUpdateMatchManagementStats {
    return { stats: isSet(object.stats) ? CMsgDOTAMatchmakingStatsResponse.fromJSON(object.stats) : undefined };
  },

  toJSON(message: CMsgDOTAUpdateMatchManagementStats): unknown {
    const obj: any = {};
    message.stats !== undefined &&
      (obj.stats = message.stats ? CMsgDOTAMatchmakingStatsResponse.toJSON(message.stats) : undefined);
    return obj;
  },
};

function createBaseCMsgDOTASetMatchHistoryAccess(): CMsgDOTASetMatchHistoryAccess {
  return { allow3rdPartyMatchHistory: false };
}

export const CMsgDOTASetMatchHistoryAccess = {
  encode(message: CMsgDOTASetMatchHistoryAccess, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.allow3rdPartyMatchHistory === true) {
      writer.uint32(8).bool(message.allow3rdPartyMatchHistory);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASetMatchHistoryAccess {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASetMatchHistoryAccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.allow3rdPartyMatchHistory = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASetMatchHistoryAccess {
    return {
      allow3rdPartyMatchHistory: isSet(object.allow3rdPartyMatchHistory)
        ? Boolean(object.allow3rdPartyMatchHistory)
        : false,
    };
  },

  toJSON(message: CMsgDOTASetMatchHistoryAccess): unknown {
    const obj: any = {};
    message.allow3rdPartyMatchHistory !== undefined &&
      (obj.allow3rdPartyMatchHistory = message.allow3rdPartyMatchHistory);
    return obj;
  },
};

function createBaseCMsgDOTASetMatchHistoryAccessResponse(): CMsgDOTASetMatchHistoryAccessResponse {
  return { eresult: 0 };
}

export const CMsgDOTASetMatchHistoryAccessResponse = {
  encode(message: CMsgDOTASetMatchHistoryAccessResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== 0) {
      writer.uint32(8).uint32(message.eresult);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASetMatchHistoryAccessResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASetMatchHistoryAccessResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eresult = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASetMatchHistoryAccessResponse {
    return { eresult: isSet(object.eresult) ? Number(object.eresult) : 0 };
  },

  toJSON(message: CMsgDOTASetMatchHistoryAccessResponse): unknown {
    const obj: any = {};
    message.eresult !== undefined && (obj.eresult = Math.round(message.eresult));
    return obj;
  },
};

function createBaseCMsgDOTANotifyAccountFlagsChange(): CMsgDOTANotifyAccountFlagsChange {
  return { accountid: 0, accountFlags: 0 };
}

export const CMsgDOTANotifyAccountFlagsChange = {
  encode(message: CMsgDOTANotifyAccountFlagsChange, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountid !== 0) {
      writer.uint32(8).uint32(message.accountid);
    }
    if (message.accountFlags !== 0) {
      writer.uint32(16).uint32(message.accountFlags);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTANotifyAccountFlagsChange {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTANotifyAccountFlagsChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountid = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.accountFlags = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTANotifyAccountFlagsChange {
    return {
      accountid: isSet(object.accountid) ? Number(object.accountid) : 0,
      accountFlags: isSet(object.accountFlags) ? Number(object.accountFlags) : 0,
    };
  },

  toJSON(message: CMsgDOTANotifyAccountFlagsChange): unknown {
    const obj: any = {};
    message.accountid !== undefined && (obj.accountid = Math.round(message.accountid));
    message.accountFlags !== undefined && (obj.accountFlags = Math.round(message.accountFlags));
    return obj;
  },
};

function createBaseCMsgDOTASetProfilePrivacy(): CMsgDOTASetProfilePrivacy {
  return { profilePrivate: false };
}

export const CMsgDOTASetProfilePrivacy = {
  encode(message: CMsgDOTASetProfilePrivacy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.profilePrivate === true) {
      writer.uint32(8).bool(message.profilePrivate);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASetProfilePrivacy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASetProfilePrivacy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.profilePrivate = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASetProfilePrivacy {
    return { profilePrivate: isSet(object.profilePrivate) ? Boolean(object.profilePrivate) : false };
  },

  toJSON(message: CMsgDOTASetProfilePrivacy): unknown {
    const obj: any = {};
    message.profilePrivate !== undefined && (obj.profilePrivate = message.profilePrivate);
    return obj;
  },
};

function createBaseCMsgDOTASetProfilePrivacyResponse(): CMsgDOTASetProfilePrivacyResponse {
  return { eresult: 0 };
}

export const CMsgDOTASetProfilePrivacyResponse = {
  encode(message: CMsgDOTASetProfilePrivacyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== 0) {
      writer.uint32(8).uint32(message.eresult);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASetProfilePrivacyResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASetProfilePrivacyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eresult = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASetProfilePrivacyResponse {
    return { eresult: isSet(object.eresult) ? Number(object.eresult) : 0 };
  },

  toJSON(message: CMsgDOTASetProfilePrivacyResponse): unknown {
    const obj: any = {};
    message.eresult !== undefined && (obj.eresult = Math.round(message.eresult));
    return obj;
  },
};

function createBaseCMsgUpgradeLeagueItem(): CMsgUpgradeLeagueItem {
  return { matchId: "0", leagueId: 0 };
}

export const CMsgUpgradeLeagueItem = {
  encode(message: CMsgUpgradeLeagueItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.leagueId !== 0) {
      writer.uint32(16).uint32(message.leagueId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgUpgradeLeagueItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgUpgradeLeagueItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgUpgradeLeagueItem {
    return {
      matchId: isSet(object.matchId) ? String(object.matchId) : "0",
      leagueId: isSet(object.leagueId) ? Number(object.leagueId) : 0,
    };
  },

  toJSON(message: CMsgUpgradeLeagueItem): unknown {
    const obj: any = {};
    message.matchId !== undefined && (obj.matchId = message.matchId);
    message.leagueId !== undefined && (obj.leagueId = Math.round(message.leagueId));
    return obj;
  },
};

function createBaseCMsgUpgradeLeagueItemResponse(): CMsgUpgradeLeagueItemResponse {
  return {};
}

export const CMsgUpgradeLeagueItemResponse = {
  encode(_: CMsgUpgradeLeagueItemResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgUpgradeLeagueItemResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgUpgradeLeagueItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgUpgradeLeagueItemResponse {
    return {};
  },

  toJSON(_: CMsgUpgradeLeagueItemResponse): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgGCWatchDownloadedReplay(): CMsgGCWatchDownloadedReplay {
  return { matchId: "0", watchType: 0 };
}

export const CMsgGCWatchDownloadedReplay = {
  encode(message: CMsgGCWatchDownloadedReplay, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.watchType !== 0) {
      writer.uint32(16).int32(message.watchType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCWatchDownloadedReplay {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCWatchDownloadedReplay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.watchType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCWatchDownloadedReplay {
    return {
      matchId: isSet(object.matchId) ? String(object.matchId) : "0",
      watchType: isSet(object.watchType) ? dOTAWatchReplayTypeFromJSON(object.watchType) : 0,
    };
  },

  toJSON(message: CMsgGCWatchDownloadedReplay): unknown {
    const obj: any = {};
    message.matchId !== undefined && (obj.matchId = message.matchId);
    message.watchType !== undefined && (obj.watchType = dOTAWatchReplayTypeToJSON(message.watchType));
    return obj;
  },
};

function createBaseCMsgClientsRejoinChatChannels(): CMsgClientsRejoinChatChannels {
  return {};
}

export const CMsgClientsRejoinChatChannels = {
  encode(_: CMsgClientsRejoinChatChannels, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientsRejoinChatChannels {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientsRejoinChatChannels();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientsRejoinChatChannels {
    return {};
  },

  toJSON(_: CMsgClientsRejoinChatChannels): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgGCGetHeroStandings(): CMsgGCGetHeroStandings {
  return {};
}

export const CMsgGCGetHeroStandings = {
  encode(_: CMsgGCGetHeroStandings, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGetHeroStandings {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetHeroStandings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgGCGetHeroStandings {
    return {};
  },

  toJSON(_: CMsgGCGetHeroStandings): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgGCGetHeroStandingsResponse(): CMsgGCGetHeroStandingsResponse {
  return { standings: [] };
}

export const CMsgGCGetHeroStandingsResponse = {
  encode(message: CMsgGCGetHeroStandingsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.standings) {
      CMsgGCGetHeroStandingsResponse_Hero.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGetHeroStandingsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetHeroStandingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.standings.push(CMsgGCGetHeroStandingsResponse_Hero.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetHeroStandingsResponse {
    return {
      standings: Array.isArray(object?.standings)
        ? object.standings.map((e: any) => CMsgGCGetHeroStandingsResponse_Hero.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCGetHeroStandingsResponse): unknown {
    const obj: any = {};
    if (message.standings) {
      obj.standings = message.standings.map((e) => e ? CMsgGCGetHeroStandingsResponse_Hero.toJSON(e) : undefined);
    } else {
      obj.standings = [];
    }
    return obj;
  },
};

function createBaseCMsgGCGetHeroStandingsResponse_Hero(): CMsgGCGetHeroStandingsResponse_Hero {
  return {
    heroId: 0,
    wins: 0,
    losses: 0,
    winStreak: 0,
    bestWinStreak: 0,
    avgKills: 0,
    avgDeaths: 0,
    avgAssists: 0,
    avgGpm: 0,
    avgXpm: 0,
    bestKills: 0,
    bestAssists: 0,
    bestGpm: 0,
    bestXpm: 0,
    performance: 0,
    winsWithAlly: 0,
    lossesWithAlly: 0,
    winsAgainstEnemy: 0,
    lossesAgainstEnemy: 0,
    networthPeak: 0,
    lasthitPeak: 0,
    denyPeak: 0,
    damagePeak: 0,
    longestGamePeak: 0,
    healingPeak: 0,
    avgLasthits: 0,
    avgDenies: 0,
  };
}

export const CMsgGCGetHeroStandingsResponse_Hero = {
  encode(message: CMsgGCGetHeroStandingsResponse_Hero, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroId !== 0) {
      writer.uint32(8).uint32(message.heroId);
    }
    if (message.wins !== 0) {
      writer.uint32(16).uint32(message.wins);
    }
    if (message.losses !== 0) {
      writer.uint32(24).uint32(message.losses);
    }
    if (message.winStreak !== 0) {
      writer.uint32(32).uint32(message.winStreak);
    }
    if (message.bestWinStreak !== 0) {
      writer.uint32(40).uint32(message.bestWinStreak);
    }
    if (message.avgKills !== 0) {
      writer.uint32(53).float(message.avgKills);
    }
    if (message.avgDeaths !== 0) {
      writer.uint32(61).float(message.avgDeaths);
    }
    if (message.avgAssists !== 0) {
      writer.uint32(69).float(message.avgAssists);
    }
    if (message.avgGpm !== 0) {
      writer.uint32(77).float(message.avgGpm);
    }
    if (message.avgXpm !== 0) {
      writer.uint32(85).float(message.avgXpm);
    }
    if (message.bestKills !== 0) {
      writer.uint32(88).uint32(message.bestKills);
    }
    if (message.bestAssists !== 0) {
      writer.uint32(96).uint32(message.bestAssists);
    }
    if (message.bestGpm !== 0) {
      writer.uint32(104).uint32(message.bestGpm);
    }
    if (message.bestXpm !== 0) {
      writer.uint32(112).uint32(message.bestXpm);
    }
    if (message.performance !== 0) {
      writer.uint32(125).float(message.performance);
    }
    if (message.winsWithAlly !== 0) {
      writer.uint32(128).uint32(message.winsWithAlly);
    }
    if (message.lossesWithAlly !== 0) {
      writer.uint32(136).uint32(message.lossesWithAlly);
    }
    if (message.winsAgainstEnemy !== 0) {
      writer.uint32(144).uint32(message.winsAgainstEnemy);
    }
    if (message.lossesAgainstEnemy !== 0) {
      writer.uint32(152).uint32(message.lossesAgainstEnemy);
    }
    if (message.networthPeak !== 0) {
      writer.uint32(160).uint32(message.networthPeak);
    }
    if (message.lasthitPeak !== 0) {
      writer.uint32(168).uint32(message.lasthitPeak);
    }
    if (message.denyPeak !== 0) {
      writer.uint32(176).uint32(message.denyPeak);
    }
    if (message.damagePeak !== 0) {
      writer.uint32(184).uint32(message.damagePeak);
    }
    if (message.longestGamePeak !== 0) {
      writer.uint32(192).uint32(message.longestGamePeak);
    }
    if (message.healingPeak !== 0) {
      writer.uint32(200).uint32(message.healingPeak);
    }
    if (message.avgLasthits !== 0) {
      writer.uint32(213).float(message.avgLasthits);
    }
    if (message.avgDenies !== 0) {
      writer.uint32(221).float(message.avgDenies);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGetHeroStandingsResponse_Hero {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetHeroStandingsResponse_Hero();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.wins = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.losses = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.winStreak = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.bestWinStreak = reader.uint32();
          continue;
        case 6:
          if (tag != 53) {
            break;
          }

          message.avgKills = reader.float();
          continue;
        case 7:
          if (tag != 61) {
            break;
          }

          message.avgDeaths = reader.float();
          continue;
        case 8:
          if (tag != 69) {
            break;
          }

          message.avgAssists = reader.float();
          continue;
        case 9:
          if (tag != 77) {
            break;
          }

          message.avgGpm = reader.float();
          continue;
        case 10:
          if (tag != 85) {
            break;
          }

          message.avgXpm = reader.float();
          continue;
        case 11:
          if (tag != 88) {
            break;
          }

          message.bestKills = reader.uint32();
          continue;
        case 12:
          if (tag != 96) {
            break;
          }

          message.bestAssists = reader.uint32();
          continue;
        case 13:
          if (tag != 104) {
            break;
          }

          message.bestGpm = reader.uint32();
          continue;
        case 14:
          if (tag != 112) {
            break;
          }

          message.bestXpm = reader.uint32();
          continue;
        case 15:
          if (tag != 125) {
            break;
          }

          message.performance = reader.float();
          continue;
        case 16:
          if (tag != 128) {
            break;
          }

          message.winsWithAlly = reader.uint32();
          continue;
        case 17:
          if (tag != 136) {
            break;
          }

          message.lossesWithAlly = reader.uint32();
          continue;
        case 18:
          if (tag != 144) {
            break;
          }

          message.winsAgainstEnemy = reader.uint32();
          continue;
        case 19:
          if (tag != 152) {
            break;
          }

          message.lossesAgainstEnemy = reader.uint32();
          continue;
        case 20:
          if (tag != 160) {
            break;
          }

          message.networthPeak = reader.uint32();
          continue;
        case 21:
          if (tag != 168) {
            break;
          }

          message.lasthitPeak = reader.uint32();
          continue;
        case 22:
          if (tag != 176) {
            break;
          }

          message.denyPeak = reader.uint32();
          continue;
        case 23:
          if (tag != 184) {
            break;
          }

          message.damagePeak = reader.uint32();
          continue;
        case 24:
          if (tag != 192) {
            break;
          }

          message.longestGamePeak = reader.uint32();
          continue;
        case 25:
          if (tag != 200) {
            break;
          }

          message.healingPeak = reader.uint32();
          continue;
        case 26:
          if (tag != 213) {
            break;
          }

          message.avgLasthits = reader.float();
          continue;
        case 27:
          if (tag != 221) {
            break;
          }

          message.avgDenies = reader.float();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetHeroStandingsResponse_Hero {
    return {
      heroId: isSet(object.heroId) ? Number(object.heroId) : 0,
      wins: isSet(object.wins) ? Number(object.wins) : 0,
      losses: isSet(object.losses) ? Number(object.losses) : 0,
      winStreak: isSet(object.winStreak) ? Number(object.winStreak) : 0,
      bestWinStreak: isSet(object.bestWinStreak) ? Number(object.bestWinStreak) : 0,
      avgKills: isSet(object.avgKills) ? Number(object.avgKills) : 0,
      avgDeaths: isSet(object.avgDeaths) ? Number(object.avgDeaths) : 0,
      avgAssists: isSet(object.avgAssists) ? Number(object.avgAssists) : 0,
      avgGpm: isSet(object.avgGpm) ? Number(object.avgGpm) : 0,
      avgXpm: isSet(object.avgXpm) ? Number(object.avgXpm) : 0,
      bestKills: isSet(object.bestKills) ? Number(object.bestKills) : 0,
      bestAssists: isSet(object.bestAssists) ? Number(object.bestAssists) : 0,
      bestGpm: isSet(object.bestGpm) ? Number(object.bestGpm) : 0,
      bestXpm: isSet(object.bestXpm) ? Number(object.bestXpm) : 0,
      performance: isSet(object.performance) ? Number(object.performance) : 0,
      winsWithAlly: isSet(object.winsWithAlly) ? Number(object.winsWithAlly) : 0,
      lossesWithAlly: isSet(object.lossesWithAlly) ? Number(object.lossesWithAlly) : 0,
      winsAgainstEnemy: isSet(object.winsAgainstEnemy) ? Number(object.winsAgainstEnemy) : 0,
      lossesAgainstEnemy: isSet(object.lossesAgainstEnemy) ? Number(object.lossesAgainstEnemy) : 0,
      networthPeak: isSet(object.networthPeak) ? Number(object.networthPeak) : 0,
      lasthitPeak: isSet(object.lasthitPeak) ? Number(object.lasthitPeak) : 0,
      denyPeak: isSet(object.denyPeak) ? Number(object.denyPeak) : 0,
      damagePeak: isSet(object.damagePeak) ? Number(object.damagePeak) : 0,
      longestGamePeak: isSet(object.longestGamePeak) ? Number(object.longestGamePeak) : 0,
      healingPeak: isSet(object.healingPeak) ? Number(object.healingPeak) : 0,
      avgLasthits: isSet(object.avgLasthits) ? Number(object.avgLasthits) : 0,
      avgDenies: isSet(object.avgDenies) ? Number(object.avgDenies) : 0,
    };
  },

  toJSON(message: CMsgGCGetHeroStandingsResponse_Hero): unknown {
    const obj: any = {};
    message.heroId !== undefined && (obj.heroId = Math.round(message.heroId));
    message.wins !== undefined && (obj.wins = Math.round(message.wins));
    message.losses !== undefined && (obj.losses = Math.round(message.losses));
    message.winStreak !== undefined && (obj.winStreak = Math.round(message.winStreak));
    message.bestWinStreak !== undefined && (obj.bestWinStreak = Math.round(message.bestWinStreak));
    message.avgKills !== undefined && (obj.avgKills = message.avgKills);
    message.avgDeaths !== undefined && (obj.avgDeaths = message.avgDeaths);
    message.avgAssists !== undefined && (obj.avgAssists = message.avgAssists);
    message.avgGpm !== undefined && (obj.avgGpm = message.avgGpm);
    message.avgXpm !== undefined && (obj.avgXpm = message.avgXpm);
    message.bestKills !== undefined && (obj.bestKills = Math.round(message.bestKills));
    message.bestAssists !== undefined && (obj.bestAssists = Math.round(message.bestAssists));
    message.bestGpm !== undefined && (obj.bestGpm = Math.round(message.bestGpm));
    message.bestXpm !== undefined && (obj.bestXpm = Math.round(message.bestXpm));
    message.performance !== undefined && (obj.performance = message.performance);
    message.winsWithAlly !== undefined && (obj.winsWithAlly = Math.round(message.winsWithAlly));
    message.lossesWithAlly !== undefined && (obj.lossesWithAlly = Math.round(message.lossesWithAlly));
    message.winsAgainstEnemy !== undefined && (obj.winsAgainstEnemy = Math.round(message.winsAgainstEnemy));
    message.lossesAgainstEnemy !== undefined && (obj.lossesAgainstEnemy = Math.round(message.lossesAgainstEnemy));
    message.networthPeak !== undefined && (obj.networthPeak = Math.round(message.networthPeak));
    message.lasthitPeak !== undefined && (obj.lasthitPeak = Math.round(message.lasthitPeak));
    message.denyPeak !== undefined && (obj.denyPeak = Math.round(message.denyPeak));
    message.damagePeak !== undefined && (obj.damagePeak = Math.round(message.damagePeak));
    message.longestGamePeak !== undefined && (obj.longestGamePeak = Math.round(message.longestGamePeak));
    message.healingPeak !== undefined && (obj.healingPeak = Math.round(message.healingPeak));
    message.avgLasthits !== undefined && (obj.avgLasthits = message.avgLasthits);
    message.avgDenies !== undefined && (obj.avgDenies = message.avgDenies);
    return obj;
  },
};

function createBaseCMatchPlayerTimedStatAverages(): CMatchPlayerTimedStatAverages {
  return {
    kills: 0,
    deaths: 0,
    assists: 0,
    netWorth: 0,
    lastHits: 0,
    denies: 0,
    itemValue: 0,
    supportGoldSpent: 0,
    campsStacked: 0,
    wardsPlaced: 0,
    dewards: 0,
    tripleKills: 0,
    rampages: 0,
  };
}

export const CMatchPlayerTimedStatAverages = {
  encode(message: CMatchPlayerTimedStatAverages, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.kills !== 0) {
      writer.uint32(21).float(message.kills);
    }
    if (message.deaths !== 0) {
      writer.uint32(29).float(message.deaths);
    }
    if (message.assists !== 0) {
      writer.uint32(37).float(message.assists);
    }
    if (message.netWorth !== 0) {
      writer.uint32(45).float(message.netWorth);
    }
    if (message.lastHits !== 0) {
      writer.uint32(53).float(message.lastHits);
    }
    if (message.denies !== 0) {
      writer.uint32(61).float(message.denies);
    }
    if (message.itemValue !== 0) {
      writer.uint32(69).float(message.itemValue);
    }
    if (message.supportGoldSpent !== 0) {
      writer.uint32(77).float(message.supportGoldSpent);
    }
    if (message.campsStacked !== 0) {
      writer.uint32(85).float(message.campsStacked);
    }
    if (message.wardsPlaced !== 0) {
      writer.uint32(93).float(message.wardsPlaced);
    }
    if (message.dewards !== 0) {
      writer.uint32(101).float(message.dewards);
    }
    if (message.tripleKills !== 0) {
      writer.uint32(109).float(message.tripleKills);
    }
    if (message.rampages !== 0) {
      writer.uint32(117).float(message.rampages);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMatchPlayerTimedStatAverages {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMatchPlayerTimedStatAverages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag != 21) {
            break;
          }

          message.kills = reader.float();
          continue;
        case 3:
          if (tag != 29) {
            break;
          }

          message.deaths = reader.float();
          continue;
        case 4:
          if (tag != 37) {
            break;
          }

          message.assists = reader.float();
          continue;
        case 5:
          if (tag != 45) {
            break;
          }

          message.netWorth = reader.float();
          continue;
        case 6:
          if (tag != 53) {
            break;
          }

          message.lastHits = reader.float();
          continue;
        case 7:
          if (tag != 61) {
            break;
          }

          message.denies = reader.float();
          continue;
        case 8:
          if (tag != 69) {
            break;
          }

          message.itemValue = reader.float();
          continue;
        case 9:
          if (tag != 77) {
            break;
          }

          message.supportGoldSpent = reader.float();
          continue;
        case 10:
          if (tag != 85) {
            break;
          }

          message.campsStacked = reader.float();
          continue;
        case 11:
          if (tag != 93) {
            break;
          }

          message.wardsPlaced = reader.float();
          continue;
        case 12:
          if (tag != 101) {
            break;
          }

          message.dewards = reader.float();
          continue;
        case 13:
          if (tag != 109) {
            break;
          }

          message.tripleKills = reader.float();
          continue;
        case 14:
          if (tag != 117) {
            break;
          }

          message.rampages = reader.float();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMatchPlayerTimedStatAverages {
    return {
      kills: isSet(object.kills) ? Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? Number(object.deaths) : 0,
      assists: isSet(object.assists) ? Number(object.assists) : 0,
      netWorth: isSet(object.netWorth) ? Number(object.netWorth) : 0,
      lastHits: isSet(object.lastHits) ? Number(object.lastHits) : 0,
      denies: isSet(object.denies) ? Number(object.denies) : 0,
      itemValue: isSet(object.itemValue) ? Number(object.itemValue) : 0,
      supportGoldSpent: isSet(object.supportGoldSpent) ? Number(object.supportGoldSpent) : 0,
      campsStacked: isSet(object.campsStacked) ? Number(object.campsStacked) : 0,
      wardsPlaced: isSet(object.wardsPlaced) ? Number(object.wardsPlaced) : 0,
      dewards: isSet(object.dewards) ? Number(object.dewards) : 0,
      tripleKills: isSet(object.tripleKills) ? Number(object.tripleKills) : 0,
      rampages: isSet(object.rampages) ? Number(object.rampages) : 0,
    };
  },

  toJSON(message: CMatchPlayerTimedStatAverages): unknown {
    const obj: any = {};
    message.kills !== undefined && (obj.kills = message.kills);
    message.deaths !== undefined && (obj.deaths = message.deaths);
    message.assists !== undefined && (obj.assists = message.assists);
    message.netWorth !== undefined && (obj.netWorth = message.netWorth);
    message.lastHits !== undefined && (obj.lastHits = message.lastHits);
    message.denies !== undefined && (obj.denies = message.denies);
    message.itemValue !== undefined && (obj.itemValue = message.itemValue);
    message.supportGoldSpent !== undefined && (obj.supportGoldSpent = message.supportGoldSpent);
    message.campsStacked !== undefined && (obj.campsStacked = message.campsStacked);
    message.wardsPlaced !== undefined && (obj.wardsPlaced = message.wardsPlaced);
    message.dewards !== undefined && (obj.dewards = message.dewards);
    message.tripleKills !== undefined && (obj.tripleKills = message.tripleKills);
    message.rampages !== undefined && (obj.rampages = message.rampages);
    return obj;
  },
};

function createBaseCMatchPlayerTimedStatStdDeviations(): CMatchPlayerTimedStatStdDeviations {
  return {
    kills: 0,
    deaths: 0,
    assists: 0,
    netWorth: 0,
    lastHits: 0,
    denies: 0,
    itemValue: 0,
    supportGoldSpent: 0,
    campsStacked: 0,
    wardsPlaced: 0,
    dewards: 0,
    tripleKills: 0,
    rampages: 0,
  };
}

export const CMatchPlayerTimedStatStdDeviations = {
  encode(message: CMatchPlayerTimedStatStdDeviations, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.kills !== 0) {
      writer.uint32(21).float(message.kills);
    }
    if (message.deaths !== 0) {
      writer.uint32(29).float(message.deaths);
    }
    if (message.assists !== 0) {
      writer.uint32(37).float(message.assists);
    }
    if (message.netWorth !== 0) {
      writer.uint32(45).float(message.netWorth);
    }
    if (message.lastHits !== 0) {
      writer.uint32(53).float(message.lastHits);
    }
    if (message.denies !== 0) {
      writer.uint32(61).float(message.denies);
    }
    if (message.itemValue !== 0) {
      writer.uint32(69).float(message.itemValue);
    }
    if (message.supportGoldSpent !== 0) {
      writer.uint32(77).float(message.supportGoldSpent);
    }
    if (message.campsStacked !== 0) {
      writer.uint32(85).float(message.campsStacked);
    }
    if (message.wardsPlaced !== 0) {
      writer.uint32(93).float(message.wardsPlaced);
    }
    if (message.dewards !== 0) {
      writer.uint32(101).float(message.dewards);
    }
    if (message.tripleKills !== 0) {
      writer.uint32(109).float(message.tripleKills);
    }
    if (message.rampages !== 0) {
      writer.uint32(117).float(message.rampages);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMatchPlayerTimedStatStdDeviations {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMatchPlayerTimedStatStdDeviations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag != 21) {
            break;
          }

          message.kills = reader.float();
          continue;
        case 3:
          if (tag != 29) {
            break;
          }

          message.deaths = reader.float();
          continue;
        case 4:
          if (tag != 37) {
            break;
          }

          message.assists = reader.float();
          continue;
        case 5:
          if (tag != 45) {
            break;
          }

          message.netWorth = reader.float();
          continue;
        case 6:
          if (tag != 53) {
            break;
          }

          message.lastHits = reader.float();
          continue;
        case 7:
          if (tag != 61) {
            break;
          }

          message.denies = reader.float();
          continue;
        case 8:
          if (tag != 69) {
            break;
          }

          message.itemValue = reader.float();
          continue;
        case 9:
          if (tag != 77) {
            break;
          }

          message.supportGoldSpent = reader.float();
          continue;
        case 10:
          if (tag != 85) {
            break;
          }

          message.campsStacked = reader.float();
          continue;
        case 11:
          if (tag != 93) {
            break;
          }

          message.wardsPlaced = reader.float();
          continue;
        case 12:
          if (tag != 101) {
            break;
          }

          message.dewards = reader.float();
          continue;
        case 13:
          if (tag != 109) {
            break;
          }

          message.tripleKills = reader.float();
          continue;
        case 14:
          if (tag != 117) {
            break;
          }

          message.rampages = reader.float();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMatchPlayerTimedStatStdDeviations {
    return {
      kills: isSet(object.kills) ? Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? Number(object.deaths) : 0,
      assists: isSet(object.assists) ? Number(object.assists) : 0,
      netWorth: isSet(object.netWorth) ? Number(object.netWorth) : 0,
      lastHits: isSet(object.lastHits) ? Number(object.lastHits) : 0,
      denies: isSet(object.denies) ? Number(object.denies) : 0,
      itemValue: isSet(object.itemValue) ? Number(object.itemValue) : 0,
      supportGoldSpent: isSet(object.supportGoldSpent) ? Number(object.supportGoldSpent) : 0,
      campsStacked: isSet(object.campsStacked) ? Number(object.campsStacked) : 0,
      wardsPlaced: isSet(object.wardsPlaced) ? Number(object.wardsPlaced) : 0,
      dewards: isSet(object.dewards) ? Number(object.dewards) : 0,
      tripleKills: isSet(object.tripleKills) ? Number(object.tripleKills) : 0,
      rampages: isSet(object.rampages) ? Number(object.rampages) : 0,
    };
  },

  toJSON(message: CMatchPlayerTimedStatStdDeviations): unknown {
    const obj: any = {};
    message.kills !== undefined && (obj.kills = message.kills);
    message.deaths !== undefined && (obj.deaths = message.deaths);
    message.assists !== undefined && (obj.assists = message.assists);
    message.netWorth !== undefined && (obj.netWorth = message.netWorth);
    message.lastHits !== undefined && (obj.lastHits = message.lastHits);
    message.denies !== undefined && (obj.denies = message.denies);
    message.itemValue !== undefined && (obj.itemValue = message.itemValue);
    message.supportGoldSpent !== undefined && (obj.supportGoldSpent = message.supportGoldSpent);
    message.campsStacked !== undefined && (obj.campsStacked = message.campsStacked);
    message.wardsPlaced !== undefined && (obj.wardsPlaced = message.wardsPlaced);
    message.dewards !== undefined && (obj.dewards = message.dewards);
    message.tripleKills !== undefined && (obj.tripleKills = message.tripleKills);
    message.rampages !== undefined && (obj.rampages = message.rampages);
    return obj;
  },
};

function createBaseCMsgGCGetHeroTimedStatsResponse(): CMsgGCGetHeroTimedStatsResponse {
  return { heroId: 0, rankChunkedStats: [] };
}

export const CMsgGCGetHeroTimedStatsResponse = {
  encode(message: CMsgGCGetHeroTimedStatsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroId !== 0) {
      writer.uint32(8).uint32(message.heroId);
    }
    for (const v of message.rankChunkedStats) {
      CMsgGCGetHeroTimedStatsResponse_RankChunkedStats.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGetHeroTimedStatsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetHeroTimedStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.rankChunkedStats.push(
            CMsgGCGetHeroTimedStatsResponse_RankChunkedStats.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetHeroTimedStatsResponse {
    return {
      heroId: isSet(object.heroId) ? Number(object.heroId) : 0,
      rankChunkedStats: Array.isArray(object?.rankChunkedStats)
        ? object.rankChunkedStats.map((e: any) => CMsgGCGetHeroTimedStatsResponse_RankChunkedStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCGetHeroTimedStatsResponse): unknown {
    const obj: any = {};
    message.heroId !== undefined && (obj.heroId = Math.round(message.heroId));
    if (message.rankChunkedStats) {
      obj.rankChunkedStats = message.rankChunkedStats.map((e) =>
        e ? CMsgGCGetHeroTimedStatsResponse_RankChunkedStats.toJSON(e) : undefined
      );
    } else {
      obj.rankChunkedStats = [];
    }
    return obj;
  },
};

function createBaseCMsgGCGetHeroTimedStatsResponse_TimedStatsContainer(): CMsgGCGetHeroTimedStatsResponse_TimedStatsContainer {
  return {
    time: 0,
    allStats: undefined,
    winningStats: undefined,
    losingStats: undefined,
    winningStddevs: undefined,
    losingStddevs: undefined,
  };
}

export const CMsgGCGetHeroTimedStatsResponse_TimedStatsContainer = {
  encode(
    message: CMsgGCGetHeroTimedStatsResponse_TimedStatsContainer,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.time !== 0) {
      writer.uint32(8).uint32(message.time);
    }
    if (message.allStats !== undefined) {
      CMatchPlayerTimedStatAverages.encode(message.allStats, writer.uint32(18).fork()).ldelim();
    }
    if (message.winningStats !== undefined) {
      CMatchPlayerTimedStatAverages.encode(message.winningStats, writer.uint32(26).fork()).ldelim();
    }
    if (message.losingStats !== undefined) {
      CMatchPlayerTimedStatAverages.encode(message.losingStats, writer.uint32(34).fork()).ldelim();
    }
    if (message.winningStddevs !== undefined) {
      CMatchPlayerTimedStatStdDeviations.encode(message.winningStddevs, writer.uint32(42).fork()).ldelim();
    }
    if (message.losingStddevs !== undefined) {
      CMatchPlayerTimedStatStdDeviations.encode(message.losingStddevs, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGetHeroTimedStatsResponse_TimedStatsContainer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetHeroTimedStatsResponse_TimedStatsContainer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.time = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.allStats = CMatchPlayerTimedStatAverages.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.winningStats = CMatchPlayerTimedStatAverages.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.losingStats = CMatchPlayerTimedStatAverages.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag != 42) {
            break;
          }

          message.winningStddevs = CMatchPlayerTimedStatStdDeviations.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }

          message.losingStddevs = CMatchPlayerTimedStatStdDeviations.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetHeroTimedStatsResponse_TimedStatsContainer {
    return {
      time: isSet(object.time) ? Number(object.time) : 0,
      allStats: isSet(object.allStats) ? CMatchPlayerTimedStatAverages.fromJSON(object.allStats) : undefined,
      winningStats: isSet(object.winningStats)
        ? CMatchPlayerTimedStatAverages.fromJSON(object.winningStats)
        : undefined,
      losingStats: isSet(object.losingStats) ? CMatchPlayerTimedStatAverages.fromJSON(object.losingStats) : undefined,
      winningStddevs: isSet(object.winningStddevs)
        ? CMatchPlayerTimedStatStdDeviations.fromJSON(object.winningStddevs)
        : undefined,
      losingStddevs: isSet(object.losingStddevs)
        ? CMatchPlayerTimedStatStdDeviations.fromJSON(object.losingStddevs)
        : undefined,
    };
  },

  toJSON(message: CMsgGCGetHeroTimedStatsResponse_TimedStatsContainer): unknown {
    const obj: any = {};
    message.time !== undefined && (obj.time = Math.round(message.time));
    message.allStats !== undefined &&
      (obj.allStats = message.allStats ? CMatchPlayerTimedStatAverages.toJSON(message.allStats) : undefined);
    message.winningStats !== undefined &&
      (obj.winningStats = message.winningStats
        ? CMatchPlayerTimedStatAverages.toJSON(message.winningStats)
        : undefined);
    message.losingStats !== undefined &&
      (obj.losingStats = message.losingStats ? CMatchPlayerTimedStatAverages.toJSON(message.losingStats) : undefined);
    message.winningStddevs !== undefined && (obj.winningStddevs = message.winningStddevs
      ? CMatchPlayerTimedStatStdDeviations.toJSON(message.winningStddevs)
      : undefined);
    message.losingStddevs !== undefined && (obj.losingStddevs = message.losingStddevs
      ? CMatchPlayerTimedStatStdDeviations.toJSON(message.losingStddevs)
      : undefined);
    return obj;
  },
};

function createBaseCMsgGCGetHeroTimedStatsResponse_RankChunkedStats(): CMsgGCGetHeroTimedStatsResponse_RankChunkedStats {
  return { rankChunk: 0, timedStats: [] };
}

export const CMsgGCGetHeroTimedStatsResponse_RankChunkedStats = {
  encode(
    message: CMsgGCGetHeroTimedStatsResponse_RankChunkedStats,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.rankChunk !== 0) {
      writer.uint32(8).uint32(message.rankChunk);
    }
    for (const v of message.timedStats) {
      CMsgGCGetHeroTimedStatsResponse_TimedStatsContainer.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGetHeroTimedStatsResponse_RankChunkedStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetHeroTimedStatsResponse_RankChunkedStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.rankChunk = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.timedStats.push(CMsgGCGetHeroTimedStatsResponse_TimedStatsContainer.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetHeroTimedStatsResponse_RankChunkedStats {
    return {
      rankChunk: isSet(object.rankChunk) ? Number(object.rankChunk) : 0,
      timedStats: Array.isArray(object?.timedStats)
        ? object.timedStats.map((e: any) => CMsgGCGetHeroTimedStatsResponse_TimedStatsContainer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCGetHeroTimedStatsResponse_RankChunkedStats): unknown {
    const obj: any = {};
    message.rankChunk !== undefined && (obj.rankChunk = Math.round(message.rankChunk));
    if (message.timedStats) {
      obj.timedStats = message.timedStats.map((e) =>
        e ? CMsgGCGetHeroTimedStatsResponse_TimedStatsContainer.toJSON(e) : undefined
      );
    } else {
      obj.timedStats = [];
    }
    return obj;
  },
};

function createBaseCMsgGCItemEditorReservationsRequest(): CMsgGCItemEditorReservationsRequest {
  return {};
}

export const CMsgGCItemEditorReservationsRequest = {
  encode(_: CMsgGCItemEditorReservationsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCItemEditorReservationsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCItemEditorReservationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgGCItemEditorReservationsRequest {
    return {};
  },

  toJSON(_: CMsgGCItemEditorReservationsRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgGCItemEditorReservation(): CMsgGCItemEditorReservation {
  return { defIndex: 0, name: "" };
}

export const CMsgGCItemEditorReservation = {
  encode(message: CMsgGCItemEditorReservation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.defIndex !== 0) {
      writer.uint32(8).uint32(message.defIndex);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCItemEditorReservation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCItemEditorReservation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.defIndex = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCItemEditorReservation {
    return {
      defIndex: isSet(object.defIndex) ? Number(object.defIndex) : 0,
      name: isSet(object.name) ? String(object.name) : "",
    };
  },

  toJSON(message: CMsgGCItemEditorReservation): unknown {
    const obj: any = {};
    message.defIndex !== undefined && (obj.defIndex = Math.round(message.defIndex));
    message.name !== undefined && (obj.name = message.name);
    return obj;
  },
};

function createBaseCMsgGCItemEditorReservationsResponse(): CMsgGCItemEditorReservationsResponse {
  return { reservations: [] };
}

export const CMsgGCItemEditorReservationsResponse = {
  encode(message: CMsgGCItemEditorReservationsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.reservations) {
      CMsgGCItemEditorReservation.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCItemEditorReservationsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCItemEditorReservationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.reservations.push(CMsgGCItemEditorReservation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCItemEditorReservationsResponse {
    return {
      reservations: Array.isArray(object?.reservations)
        ? object.reservations.map((e: any) => CMsgGCItemEditorReservation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCItemEditorReservationsResponse): unknown {
    const obj: any = {};
    if (message.reservations) {
      obj.reservations = message.reservations.map((e) => e ? CMsgGCItemEditorReservation.toJSON(e) : undefined);
    } else {
      obj.reservations = [];
    }
    return obj;
  },
};

function createBaseCMsgGCItemEditorReserveItemDef(): CMsgGCItemEditorReserveItemDef {
  return { defIndex: 0, username: "" };
}

export const CMsgGCItemEditorReserveItemDef = {
  encode(message: CMsgGCItemEditorReserveItemDef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.defIndex !== 0) {
      writer.uint32(8).uint32(message.defIndex);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCItemEditorReserveItemDef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCItemEditorReserveItemDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.defIndex = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.username = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCItemEditorReserveItemDef {
    return {
      defIndex: isSet(object.defIndex) ? Number(object.defIndex) : 0,
      username: isSet(object.username) ? String(object.username) : "",
    };
  },

  toJSON(message: CMsgGCItemEditorReserveItemDef): unknown {
    const obj: any = {};
    message.defIndex !== undefined && (obj.defIndex = Math.round(message.defIndex));
    message.username !== undefined && (obj.username = message.username);
    return obj;
  },
};

function createBaseCMsgGCItemEditorReserveItemDefResponse(): CMsgGCItemEditorReserveItemDefResponse {
  return { defIndex: 0, username: "", result: 0 };
}

export const CMsgGCItemEditorReserveItemDefResponse = {
  encode(message: CMsgGCItemEditorReserveItemDefResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.defIndex !== 0) {
      writer.uint32(8).uint32(message.defIndex);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.result !== 0) {
      writer.uint32(24).uint32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCItemEditorReserveItemDefResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCItemEditorReserveItemDefResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.defIndex = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.username = reader.string();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.result = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCItemEditorReserveItemDefResponse {
    return {
      defIndex: isSet(object.defIndex) ? Number(object.defIndex) : 0,
      username: isSet(object.username) ? String(object.username) : "",
      result: isSet(object.result) ? Number(object.result) : 0,
    };
  },

  toJSON(message: CMsgGCItemEditorReserveItemDefResponse): unknown {
    const obj: any = {};
    message.defIndex !== undefined && (obj.defIndex = Math.round(message.defIndex));
    message.username !== undefined && (obj.username = message.username);
    message.result !== undefined && (obj.result = Math.round(message.result));
    return obj;
  },
};

function createBaseCMsgGCItemEditorReleaseReservation(): CMsgGCItemEditorReleaseReservation {
  return { defIndex: 0, username: "" };
}

export const CMsgGCItemEditorReleaseReservation = {
  encode(message: CMsgGCItemEditorReleaseReservation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.defIndex !== 0) {
      writer.uint32(8).uint32(message.defIndex);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCItemEditorReleaseReservation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCItemEditorReleaseReservation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.defIndex = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.username = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCItemEditorReleaseReservation {
    return {
      defIndex: isSet(object.defIndex) ? Number(object.defIndex) : 0,
      username: isSet(object.username) ? String(object.username) : "",
    };
  },

  toJSON(message: CMsgGCItemEditorReleaseReservation): unknown {
    const obj: any = {};
    message.defIndex !== undefined && (obj.defIndex = Math.round(message.defIndex));
    message.username !== undefined && (obj.username = message.username);
    return obj;
  },
};

function createBaseCMsgGCItemEditorReleaseReservationResponse(): CMsgGCItemEditorReleaseReservationResponse {
  return { defIndex: 0, released: false };
}

export const CMsgGCItemEditorReleaseReservationResponse = {
  encode(message: CMsgGCItemEditorReleaseReservationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.defIndex !== 0) {
      writer.uint32(8).uint32(message.defIndex);
    }
    if (message.released === true) {
      writer.uint32(16).bool(message.released);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCItemEditorReleaseReservationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCItemEditorReleaseReservationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.defIndex = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.released = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCItemEditorReleaseReservationResponse {
    return {
      defIndex: isSet(object.defIndex) ? Number(object.defIndex) : 0,
      released: isSet(object.released) ? Boolean(object.released) : false,
    };
  },

  toJSON(message: CMsgGCItemEditorReleaseReservationResponse): unknown {
    const obj: any = {};
    message.defIndex !== undefined && (obj.defIndex = Math.round(message.defIndex));
    message.released !== undefined && (obj.released = message.released);
    return obj;
  },
};

function createBaseCMsgDOTARewardTutorialPrizes(): CMsgDOTARewardTutorialPrizes {
  return { locationId: 0, trackingOnly: false };
}

export const CMsgDOTARewardTutorialPrizes = {
  encode(message: CMsgDOTARewardTutorialPrizes, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.locationId !== 0) {
      writer.uint32(8).uint32(message.locationId);
    }
    if (message.trackingOnly === true) {
      writer.uint32(16).bool(message.trackingOnly);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARewardTutorialPrizes {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARewardTutorialPrizes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.locationId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.trackingOnly = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARewardTutorialPrizes {
    return {
      locationId: isSet(object.locationId) ? Number(object.locationId) : 0,
      trackingOnly: isSet(object.trackingOnly) ? Boolean(object.trackingOnly) : false,
    };
  },

  toJSON(message: CMsgDOTARewardTutorialPrizes): unknown {
    const obj: any = {};
    message.locationId !== undefined && (obj.locationId = Math.round(message.locationId));
    message.trackingOnly !== undefined && (obj.trackingOnly = message.trackingOnly);
    return obj;
  },
};

function createBaseCMsgFlipLobbyTeams(): CMsgFlipLobbyTeams {
  return {};
}

export const CMsgFlipLobbyTeams = {
  encode(_: CMsgFlipLobbyTeams, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgFlipLobbyTeams {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgFlipLobbyTeams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgFlipLobbyTeams {
    return {};
  },

  toJSON(_: CMsgFlipLobbyTeams): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgGCLobbyUpdateBroadcastChannelInfo(): CMsgGCLobbyUpdateBroadcastChannelInfo {
  return { channelId: 0, countryCode: "", description: "", languageCode: "" };
}

export const CMsgGCLobbyUpdateBroadcastChannelInfo = {
  encode(message: CMsgGCLobbyUpdateBroadcastChannelInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channelId !== 0) {
      writer.uint32(8).uint32(message.channelId);
    }
    if (message.countryCode !== "") {
      writer.uint32(18).string(message.countryCode);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.languageCode !== "") {
      writer.uint32(34).string(message.languageCode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCLobbyUpdateBroadcastChannelInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCLobbyUpdateBroadcastChannelInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.channelId = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCLobbyUpdateBroadcastChannelInfo {
    return {
      channelId: isSet(object.channelId) ? Number(object.channelId) : 0,
      countryCode: isSet(object.countryCode) ? String(object.countryCode) : "",
      description: isSet(object.description) ? String(object.description) : "",
      languageCode: isSet(object.languageCode) ? String(object.languageCode) : "",
    };
  },

  toJSON(message: CMsgGCLobbyUpdateBroadcastChannelInfo): unknown {
    const obj: any = {};
    message.channelId !== undefined && (obj.channelId = Math.round(message.channelId));
    message.countryCode !== undefined && (obj.countryCode = message.countryCode);
    message.description !== undefined && (obj.description = message.description);
    message.languageCode !== undefined && (obj.languageCode = message.languageCode);
    return obj;
  },
};

function createBaseCMsgDOTAClaimEventActionData(): CMsgDOTAClaimEventActionData {
  return { grantItemGiftData: undefined };
}

export const CMsgDOTAClaimEventActionData = {
  encode(message: CMsgDOTAClaimEventActionData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.grantItemGiftData !== undefined) {
      CMsgDOTAClaimEventActionData_GrantItemGiftData.encode(message.grantItemGiftData, writer.uint32(34).fork())
        .ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAClaimEventActionData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAClaimEventActionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag != 34) {
            break;
          }

          message.grantItemGiftData = CMsgDOTAClaimEventActionData_GrantItemGiftData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAClaimEventActionData {
    return {
      grantItemGiftData: isSet(object.grantItemGiftData)
        ? CMsgDOTAClaimEventActionData_GrantItemGiftData.fromJSON(object.grantItemGiftData)
        : undefined,
    };
  },

  toJSON(message: CMsgDOTAClaimEventActionData): unknown {
    const obj: any = {};
    message.grantItemGiftData !== undefined && (obj.grantItemGiftData = message.grantItemGiftData
      ? CMsgDOTAClaimEventActionData_GrantItemGiftData.toJSON(message.grantItemGiftData)
      : undefined);
    return obj;
  },
};

function createBaseCMsgDOTAClaimEventActionData_GrantItemGiftData(): CMsgDOTAClaimEventActionData_GrantItemGiftData {
  return { giveToAccountId: 0, giftMessage: "" };
}

export const CMsgDOTAClaimEventActionData_GrantItemGiftData = {
  encode(
    message: CMsgDOTAClaimEventActionData_GrantItemGiftData,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.giveToAccountId !== 0) {
      writer.uint32(8).uint32(message.giveToAccountId);
    }
    if (message.giftMessage !== "") {
      writer.uint32(18).string(message.giftMessage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAClaimEventActionData_GrantItemGiftData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAClaimEventActionData_GrantItemGiftData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.giveToAccountId = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.giftMessage = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAClaimEventActionData_GrantItemGiftData {
    return {
      giveToAccountId: isSet(object.giveToAccountId) ? Number(object.giveToAccountId) : 0,
      giftMessage: isSet(object.giftMessage) ? String(object.giftMessage) : "",
    };
  },

  toJSON(message: CMsgDOTAClaimEventActionData_GrantItemGiftData): unknown {
    const obj: any = {};
    message.giveToAccountId !== undefined && (obj.giveToAccountId = Math.round(message.giveToAccountId));
    message.giftMessage !== undefined && (obj.giftMessage = message.giftMessage);
    return obj;
  },
};

function createBaseCMsgDOTAClaimEventAction(): CMsgDOTAClaimEventAction {
  return { eventId: 0, actionId: 0, quantity: 0, data: undefined };
}

export const CMsgDOTAClaimEventAction = {
  encode(message: CMsgDOTAClaimEventAction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    if (message.actionId !== 0) {
      writer.uint32(16).uint32(message.actionId);
    }
    if (message.quantity !== 0) {
      writer.uint32(24).uint32(message.quantity);
    }
    if (message.data !== undefined) {
      CMsgDOTAClaimEventActionData.encode(message.data, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAClaimEventAction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAClaimEventAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.actionId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.quantity = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.data = CMsgDOTAClaimEventActionData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAClaimEventAction {
    return {
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      actionId: isSet(object.actionId) ? Number(object.actionId) : 0,
      quantity: isSet(object.quantity) ? Number(object.quantity) : 0,
      data: isSet(object.data) ? CMsgDOTAClaimEventActionData.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: CMsgDOTAClaimEventAction): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.actionId !== undefined && (obj.actionId = Math.round(message.actionId));
    message.quantity !== undefined && (obj.quantity = Math.round(message.quantity));
    message.data !== undefined &&
      (obj.data = message.data ? CMsgDOTAClaimEventActionData.toJSON(message.data) : undefined);
    return obj;
  },
};

function createBaseCMsgDOTAClaimEventActionResponse(): CMsgDOTAClaimEventActionResponse {
  return { result: 0, rewardResults: [] };
}

export const CMsgDOTAClaimEventActionResponse = {
  encode(message: CMsgDOTAClaimEventActionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    for (const v of message.rewardResults) {
      CMsgDOTAClaimEventActionResponse_GrantedRewardData.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAClaimEventActionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAClaimEventActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.rewardResults.push(
            CMsgDOTAClaimEventActionResponse_GrantedRewardData.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAClaimEventActionResponse {
    return {
      result: isSet(object.result) ? cMsgDOTAClaimEventActionResponse_ResultCodeFromJSON(object.result) : 0,
      rewardResults: Array.isArray(object?.rewardResults)
        ? object.rewardResults.map((e: any) => CMsgDOTAClaimEventActionResponse_GrantedRewardData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTAClaimEventActionResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = cMsgDOTAClaimEventActionResponse_ResultCodeToJSON(message.result));
    if (message.rewardResults) {
      obj.rewardResults = message.rewardResults.map((e) =>
        e ? CMsgDOTAClaimEventActionResponse_GrantedRewardData.toJSON(e) : undefined
      );
    } else {
      obj.rewardResults = [];
    }
    return obj;
  },
};

function createBaseCMsgDOTAClaimEventActionResponse_MysteryItemRewardData(): CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {
  return { itemDef: 0, itemCategory: 0 };
}

export const CMsgDOTAClaimEventActionResponse_MysteryItemRewardData = {
  encode(
    message: CMsgDOTAClaimEventActionResponse_MysteryItemRewardData,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.itemDef !== 0) {
      writer.uint32(8).uint32(message.itemDef);
    }
    if (message.itemCategory !== 0) {
      writer.uint32(16).uint32(message.itemCategory);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAClaimEventActionResponse_MysteryItemRewardData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.itemDef = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.itemCategory = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {
    return {
      itemDef: isSet(object.itemDef) ? Number(object.itemDef) : 0,
      itemCategory: isSet(object.itemCategory) ? Number(object.itemCategory) : 0,
    };
  },

  toJSON(message: CMsgDOTAClaimEventActionResponse_MysteryItemRewardData): unknown {
    const obj: any = {};
    message.itemDef !== undefined && (obj.itemDef = Math.round(message.itemDef));
    message.itemCategory !== undefined && (obj.itemCategory = Math.round(message.itemCategory));
    return obj;
  },
};

function createBaseCMsgDOTAClaimEventActionResponse_LootListRewardData(): CMsgDOTAClaimEventActionResponse_LootListRewardData {
  return { itemDef: [] };
}

export const CMsgDOTAClaimEventActionResponse_LootListRewardData = {
  encode(
    message: CMsgDOTAClaimEventActionResponse_LootListRewardData,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.itemDef) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAClaimEventActionResponse_LootListRewardData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAClaimEventActionResponse_LootListRewardData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag == 8) {
            message.itemDef.push(reader.uint32());
            continue;
          }

          if (tag == 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.itemDef.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAClaimEventActionResponse_LootListRewardData {
    return { itemDef: Array.isArray(object?.itemDef) ? object.itemDef.map((e: any) => Number(e)) : [] };
  },

  toJSON(message: CMsgDOTAClaimEventActionResponse_LootListRewardData): unknown {
    const obj: any = {};
    if (message.itemDef) {
      obj.itemDef = message.itemDef.map((e) => Math.round(e));
    } else {
      obj.itemDef = [];
    }
    return obj;
  },
};

function createBaseCMsgDOTAClaimEventActionResponse_ActionListRewardData(): CMsgDOTAClaimEventActionResponse_ActionListRewardData {
  return { actionId: 0, resultRewardData: Buffer.alloc(0) };
}

export const CMsgDOTAClaimEventActionResponse_ActionListRewardData = {
  encode(
    message: CMsgDOTAClaimEventActionResponse_ActionListRewardData,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.actionId !== 0) {
      writer.uint32(8).uint32(message.actionId);
    }
    if (message.resultRewardData.length !== 0) {
      writer.uint32(18).bytes(message.resultRewardData);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAClaimEventActionResponse_ActionListRewardData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAClaimEventActionResponse_ActionListRewardData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.actionId = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.resultRewardData = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAClaimEventActionResponse_ActionListRewardData {
    return {
      actionId: isSet(object.actionId) ? Number(object.actionId) : 0,
      resultRewardData: isSet(object.resultRewardData)
        ? Buffer.from(bytesFromBase64(object.resultRewardData))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: CMsgDOTAClaimEventActionResponse_ActionListRewardData): unknown {
    const obj: any = {};
    message.actionId !== undefined && (obj.actionId = Math.round(message.actionId));
    message.resultRewardData !== undefined &&
      (obj.resultRewardData = base64FromBytes(
        message.resultRewardData !== undefined ? message.resultRewardData : Buffer.alloc(0),
      ));
    return obj;
  },
};

function createBaseCMsgDOTAClaimEventActionResponse_GrantedRewardData(): CMsgDOTAClaimEventActionResponse_GrantedRewardData {
  return { grantIndex: 0, scoreIndex: 0, rewardIndex: 0, rewardData: Buffer.alloc(0) };
}

export const CMsgDOTAClaimEventActionResponse_GrantedRewardData = {
  encode(
    message: CMsgDOTAClaimEventActionResponse_GrantedRewardData,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.grantIndex !== 0) {
      writer.uint32(8).uint32(message.grantIndex);
    }
    if (message.scoreIndex !== 0) {
      writer.uint32(16).uint32(message.scoreIndex);
    }
    if (message.rewardIndex !== 0) {
      writer.uint32(24).uint32(message.rewardIndex);
    }
    if (message.rewardData.length !== 0) {
      writer.uint32(34).bytes(message.rewardData);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAClaimEventActionResponse_GrantedRewardData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAClaimEventActionResponse_GrantedRewardData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.grantIndex = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.scoreIndex = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.rewardIndex = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.rewardData = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAClaimEventActionResponse_GrantedRewardData {
    return {
      grantIndex: isSet(object.grantIndex) ? Number(object.grantIndex) : 0,
      scoreIndex: isSet(object.scoreIndex) ? Number(object.scoreIndex) : 0,
      rewardIndex: isSet(object.rewardIndex) ? Number(object.rewardIndex) : 0,
      rewardData: isSet(object.rewardData) ? Buffer.from(bytesFromBase64(object.rewardData)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CMsgDOTAClaimEventActionResponse_GrantedRewardData): unknown {
    const obj: any = {};
    message.grantIndex !== undefined && (obj.grantIndex = Math.round(message.grantIndex));
    message.scoreIndex !== undefined && (obj.scoreIndex = Math.round(message.scoreIndex));
    message.rewardIndex !== undefined && (obj.rewardIndex = Math.round(message.rewardIndex));
    message.rewardData !== undefined &&
      (obj.rewardData = base64FromBytes(message.rewardData !== undefined ? message.rewardData : Buffer.alloc(0)));
    return obj;
  },
};

function createBaseCMsgClientToGCClaimEventActionUsingItem(): CMsgClientToGCClaimEventActionUsingItem {
  return { eventId: 0, actionId: 0, itemId: "0", quantity: 0 };
}

export const CMsgClientToGCClaimEventActionUsingItem = {
  encode(message: CMsgClientToGCClaimEventActionUsingItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    if (message.actionId !== 0) {
      writer.uint32(16).uint32(message.actionId);
    }
    if (message.itemId !== "0") {
      writer.uint32(24).uint64(message.itemId);
    }
    if (message.quantity !== 0) {
      writer.uint32(32).uint32(message.quantity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCClaimEventActionUsingItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCClaimEventActionUsingItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.actionId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.itemId = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.quantity = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCClaimEventActionUsingItem {
    return {
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      actionId: isSet(object.actionId) ? Number(object.actionId) : 0,
      itemId: isSet(object.itemId) ? String(object.itemId) : "0",
      quantity: isSet(object.quantity) ? Number(object.quantity) : 0,
    };
  },

  toJSON(message: CMsgClientToGCClaimEventActionUsingItem): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.actionId !== undefined && (obj.actionId = Math.round(message.actionId));
    message.itemId !== undefined && (obj.itemId = message.itemId);
    message.quantity !== undefined && (obj.quantity = Math.round(message.quantity));
    return obj;
  },
};

function createBaseCMsgClientToGCClaimEventActionUsingItemResponse(): CMsgClientToGCClaimEventActionUsingItemResponse {
  return { actionResults: undefined };
}

export const CMsgClientToGCClaimEventActionUsingItemResponse = {
  encode(
    message: CMsgClientToGCClaimEventActionUsingItemResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.actionResults !== undefined) {
      CMsgDOTAClaimEventActionResponse.encode(message.actionResults, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCClaimEventActionUsingItemResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCClaimEventActionUsingItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.actionResults = CMsgDOTAClaimEventActionResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCClaimEventActionUsingItemResponse {
    return {
      actionResults: isSet(object.actionResults)
        ? CMsgDOTAClaimEventActionResponse.fromJSON(object.actionResults)
        : undefined,
    };
  },

  toJSON(message: CMsgClientToGCClaimEventActionUsingItemResponse): unknown {
    const obj: any = {};
    message.actionResults !== undefined && (obj.actionResults = message.actionResults
      ? CMsgDOTAClaimEventActionResponse.toJSON(message.actionResults)
      : undefined);
    return obj;
  },
};

function createBaseCMsgGCToClientClaimEventActionUsingItemCompleted(): CMsgGCToClientClaimEventActionUsingItemCompleted {
  return { itemId: "0", actionResults: undefined };
}

export const CMsgGCToClientClaimEventActionUsingItemCompleted = {
  encode(
    message: CMsgGCToClientClaimEventActionUsingItemCompleted,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.itemId !== "0") {
      writer.uint32(8).uint64(message.itemId);
    }
    if (message.actionResults !== undefined) {
      CMsgDOTAClaimEventActionResponse.encode(message.actionResults, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientClaimEventActionUsingItemCompleted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientClaimEventActionUsingItemCompleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.itemId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.actionResults = CMsgDOTAClaimEventActionResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientClaimEventActionUsingItemCompleted {
    return {
      itemId: isSet(object.itemId) ? String(object.itemId) : "0",
      actionResults: isSet(object.actionResults)
        ? CMsgDOTAClaimEventActionResponse.fromJSON(object.actionResults)
        : undefined,
    };
  },

  toJSON(message: CMsgGCToClientClaimEventActionUsingItemCompleted): unknown {
    const obj: any = {};
    message.itemId !== undefined && (obj.itemId = message.itemId);
    message.actionResults !== undefined && (obj.actionResults = message.actionResults
      ? CMsgDOTAClaimEventActionResponse.toJSON(message.actionResults)
      : undefined);
    return obj;
  },
};

function createBaseCMsgDOTAGetEventPoints(): CMsgDOTAGetEventPoints {
  return { eventId: 0, accountId: 0 };
}

export const CMsgDOTAGetEventPoints = {
  encode(message: CMsgDOTAGetEventPoints, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    if (message.accountId !== 0) {
      writer.uint32(16).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAGetEventPoints {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAGetEventPoints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAGetEventPoints {
    return {
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
    };
  },

  toJSON(message: CMsgDOTAGetEventPoints): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    return obj;
  },
};

function createBaseCMsgDOTAGetEventPointsResponse(): CMsgDOTAGetEventPointsResponse {
  return {
    totalPoints: 0,
    totalPremiumPoints: 0,
    eventId: 0,
    points: 0,
    premiumPoints: 0,
    completedActions: [],
    accountId: 0,
    owned: false,
    auditAction: 0,
    activeSeasonId: 0,
  };
}

export const CMsgDOTAGetEventPointsResponse = {
  encode(message: CMsgDOTAGetEventPointsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.totalPoints !== 0) {
      writer.uint32(8).uint32(message.totalPoints);
    }
    if (message.totalPremiumPoints !== 0) {
      writer.uint32(16).uint32(message.totalPremiumPoints);
    }
    if (message.eventId !== 0) {
      writer.uint32(24).uint32(message.eventId);
    }
    if (message.points !== 0) {
      writer.uint32(32).uint32(message.points);
    }
    if (message.premiumPoints !== 0) {
      writer.uint32(40).uint32(message.premiumPoints);
    }
    for (const v of message.completedActions) {
      CMsgDOTAGetEventPointsResponse_Action.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.accountId !== 0) {
      writer.uint32(56).uint32(message.accountId);
    }
    if (message.owned === true) {
      writer.uint32(64).bool(message.owned);
    }
    if (message.auditAction !== 0) {
      writer.uint32(72).uint32(message.auditAction);
    }
    if (message.activeSeasonId !== 0) {
      writer.uint32(80).uint32(message.activeSeasonId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAGetEventPointsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAGetEventPointsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.totalPoints = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.totalPremiumPoints = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.points = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.premiumPoints = reader.uint32();
          continue;
        case 6:
          if (tag != 50) {
            break;
          }

          message.completedActions.push(CMsgDOTAGetEventPointsResponse_Action.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag != 56) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 8:
          if (tag != 64) {
            break;
          }

          message.owned = reader.bool();
          continue;
        case 9:
          if (tag != 72) {
            break;
          }

          message.auditAction = reader.uint32();
          continue;
        case 10:
          if (tag != 80) {
            break;
          }

          message.activeSeasonId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAGetEventPointsResponse {
    return {
      totalPoints: isSet(object.totalPoints) ? Number(object.totalPoints) : 0,
      totalPremiumPoints: isSet(object.totalPremiumPoints) ? Number(object.totalPremiumPoints) : 0,
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      points: isSet(object.points) ? Number(object.points) : 0,
      premiumPoints: isSet(object.premiumPoints) ? Number(object.premiumPoints) : 0,
      completedActions: Array.isArray(object?.completedActions)
        ? object.completedActions.map((e: any) => CMsgDOTAGetEventPointsResponse_Action.fromJSON(e))
        : [],
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      owned: isSet(object.owned) ? Boolean(object.owned) : false,
      auditAction: isSet(object.auditAction) ? Number(object.auditAction) : 0,
      activeSeasonId: isSet(object.activeSeasonId) ? Number(object.activeSeasonId) : 0,
    };
  },

  toJSON(message: CMsgDOTAGetEventPointsResponse): unknown {
    const obj: any = {};
    message.totalPoints !== undefined && (obj.totalPoints = Math.round(message.totalPoints));
    message.totalPremiumPoints !== undefined && (obj.totalPremiumPoints = Math.round(message.totalPremiumPoints));
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.points !== undefined && (obj.points = Math.round(message.points));
    message.premiumPoints !== undefined && (obj.premiumPoints = Math.round(message.premiumPoints));
    if (message.completedActions) {
      obj.completedActions = message.completedActions.map((e) =>
        e ? CMsgDOTAGetEventPointsResponse_Action.toJSON(e) : undefined
      );
    } else {
      obj.completedActions = [];
    }
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.owned !== undefined && (obj.owned = message.owned);
    message.auditAction !== undefined && (obj.auditAction = Math.round(message.auditAction));
    message.activeSeasonId !== undefined && (obj.activeSeasonId = Math.round(message.activeSeasonId));
    return obj;
  },
};

function createBaseCMsgDOTAGetEventPointsResponse_Action(): CMsgDOTAGetEventPointsResponse_Action {
  return { actionId: 0, timesCompleted: 0 };
}

export const CMsgDOTAGetEventPointsResponse_Action = {
  encode(message: CMsgDOTAGetEventPointsResponse_Action, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.actionId !== 0) {
      writer.uint32(8).uint32(message.actionId);
    }
    if (message.timesCompleted !== 0) {
      writer.uint32(16).uint32(message.timesCompleted);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAGetEventPointsResponse_Action {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAGetEventPointsResponse_Action();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.actionId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.timesCompleted = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAGetEventPointsResponse_Action {
    return {
      actionId: isSet(object.actionId) ? Number(object.actionId) : 0,
      timesCompleted: isSet(object.timesCompleted) ? Number(object.timesCompleted) : 0,
    };
  },

  toJSON(message: CMsgDOTAGetEventPointsResponse_Action): unknown {
    const obj: any = {};
    message.actionId !== undefined && (obj.actionId = Math.round(message.actionId));
    message.timesCompleted !== undefined && (obj.timesCompleted = Math.round(message.timesCompleted));
    return obj;
  },
};

function createBaseCMsgDOTAGetPeriodicResource(): CMsgDOTAGetPeriodicResource {
  return { accountId: 0, periodicResourceId: 0, timestamp: 0 };
}

export const CMsgDOTAGetPeriodicResource = {
  encode(message: CMsgDOTAGetPeriodicResource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.periodicResourceId !== 0) {
      writer.uint32(16).uint32(message.periodicResourceId);
    }
    if (message.timestamp !== 0) {
      writer.uint32(24).uint32(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAGetPeriodicResource {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAGetPeriodicResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.periodicResourceId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAGetPeriodicResource {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      periodicResourceId: isSet(object.periodicResourceId) ? Number(object.periodicResourceId) : 0,
      timestamp: isSet(object.timestamp) ? Number(object.timestamp) : 0,
    };
  },

  toJSON(message: CMsgDOTAGetPeriodicResource): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.periodicResourceId !== undefined && (obj.periodicResourceId = Math.round(message.periodicResourceId));
    message.timestamp !== undefined && (obj.timestamp = Math.round(message.timestamp));
    return obj;
  },
};

function createBaseCMsgDOTAGetPeriodicResourceResponse(): CMsgDOTAGetPeriodicResourceResponse {
  return { periodicResourceMax: 0, periodicResourceUsed: 0 };
}

export const CMsgDOTAGetPeriodicResourceResponse = {
  encode(message: CMsgDOTAGetPeriodicResourceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.periodicResourceMax !== 0) {
      writer.uint32(8).uint32(message.periodicResourceMax);
    }
    if (message.periodicResourceUsed !== 0) {
      writer.uint32(16).uint32(message.periodicResourceUsed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAGetPeriodicResourceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAGetPeriodicResourceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.periodicResourceMax = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.periodicResourceUsed = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAGetPeriodicResourceResponse {
    return {
      periodicResourceMax: isSet(object.periodicResourceMax) ? Number(object.periodicResourceMax) : 0,
      periodicResourceUsed: isSet(object.periodicResourceUsed) ? Number(object.periodicResourceUsed) : 0,
    };
  },

  toJSON(message: CMsgDOTAGetPeriodicResourceResponse): unknown {
    const obj: any = {};
    message.periodicResourceMax !== undefined && (obj.periodicResourceMax = Math.round(message.periodicResourceMax));
    message.periodicResourceUsed !== undefined && (obj.periodicResourceUsed = Math.round(message.periodicResourceUsed));
    return obj;
  },
};

function createBaseCMsgDOTAPeriodicResourceUpdated(): CMsgDOTAPeriodicResourceUpdated {
  return { periodicResourceKey: undefined, periodicResourceValue: undefined };
}

export const CMsgDOTAPeriodicResourceUpdated = {
  encode(message: CMsgDOTAPeriodicResourceUpdated, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.periodicResourceKey !== undefined) {
      CMsgDOTAGetPeriodicResource.encode(message.periodicResourceKey, writer.uint32(10).fork()).ldelim();
    }
    if (message.periodicResourceValue !== undefined) {
      CMsgDOTAGetPeriodicResourceResponse.encode(message.periodicResourceValue, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAPeriodicResourceUpdated {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAPeriodicResourceUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.periodicResourceKey = CMsgDOTAGetPeriodicResource.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.periodicResourceValue = CMsgDOTAGetPeriodicResourceResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAPeriodicResourceUpdated {
    return {
      periodicResourceKey: isSet(object.periodicResourceKey)
        ? CMsgDOTAGetPeriodicResource.fromJSON(object.periodicResourceKey)
        : undefined,
      periodicResourceValue: isSet(object.periodicResourceValue)
        ? CMsgDOTAGetPeriodicResourceResponse.fromJSON(object.periodicResourceValue)
        : undefined,
    };
  },

  toJSON(message: CMsgDOTAPeriodicResourceUpdated): unknown {
    const obj: any = {};
    message.periodicResourceKey !== undefined && (obj.periodicResourceKey = message.periodicResourceKey
      ? CMsgDOTAGetPeriodicResource.toJSON(message.periodicResourceKey)
      : undefined);
    message.periodicResourceValue !== undefined && (obj.periodicResourceValue = message.periodicResourceValue
      ? CMsgDOTAGetPeriodicResourceResponse.toJSON(message.periodicResourceValue)
      : undefined);
    return obj;
  },
};

function createBaseCMsgDOTACompendiumSelection(): CMsgDOTACompendiumSelection {
  return { selectionIndex: 0, selection: 0, leagueid: 0 };
}

export const CMsgDOTACompendiumSelection = {
  encode(message: CMsgDOTACompendiumSelection, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.selectionIndex !== 0) {
      writer.uint32(8).uint32(message.selectionIndex);
    }
    if (message.selection !== 0) {
      writer.uint32(16).uint32(message.selection);
    }
    if (message.leagueid !== 0) {
      writer.uint32(24).uint32(message.leagueid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTACompendiumSelection {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTACompendiumSelection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.selectionIndex = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.selection = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.leagueid = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTACompendiumSelection {
    return {
      selectionIndex: isSet(object.selectionIndex) ? Number(object.selectionIndex) : 0,
      selection: isSet(object.selection) ? Number(object.selection) : 0,
      leagueid: isSet(object.leagueid) ? Number(object.leagueid) : 0,
    };
  },

  toJSON(message: CMsgDOTACompendiumSelection): unknown {
    const obj: any = {};
    message.selectionIndex !== undefined && (obj.selectionIndex = Math.round(message.selectionIndex));
    message.selection !== undefined && (obj.selection = Math.round(message.selection));
    message.leagueid !== undefined && (obj.leagueid = Math.round(message.leagueid));
    return obj;
  },
};

function createBaseCMsgDOTACompendiumSelectionResponse(): CMsgDOTACompendiumSelectionResponse {
  return { eresult: 0 };
}

export const CMsgDOTACompendiumSelectionResponse = {
  encode(message: CMsgDOTACompendiumSelectionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== 0) {
      writer.uint32(8).uint32(message.eresult);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTACompendiumSelectionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTACompendiumSelectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eresult = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTACompendiumSelectionResponse {
    return { eresult: isSet(object.eresult) ? Number(object.eresult) : 0 };
  },

  toJSON(message: CMsgDOTACompendiumSelectionResponse): unknown {
    const obj: any = {};
    message.eresult !== undefined && (obj.eresult = Math.round(message.eresult));
    return obj;
  },
};

function createBaseCMsgDOTACompendiumData(): CMsgDOTACompendiumData {
  return { selections: [] };
}

export const CMsgDOTACompendiumData = {
  encode(message: CMsgDOTACompendiumData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.selections) {
      CMsgDOTACompendiumSelection.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTACompendiumData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTACompendiumData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.selections.push(CMsgDOTACompendiumSelection.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTACompendiumData {
    return {
      selections: Array.isArray(object?.selections)
        ? object.selections.map((e: any) => CMsgDOTACompendiumSelection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTACompendiumData): unknown {
    const obj: any = {};
    if (message.selections) {
      obj.selections = message.selections.map((e) => e ? CMsgDOTACompendiumSelection.toJSON(e) : undefined);
    } else {
      obj.selections = [];
    }
    return obj;
  },
};

function createBaseCMsgDOTACompendiumDataRequest(): CMsgDOTACompendiumDataRequest {
  return { accountId: 0, leagueid: 0 };
}

export const CMsgDOTACompendiumDataRequest = {
  encode(message: CMsgDOTACompendiumDataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.leagueid !== 0) {
      writer.uint32(16).uint32(message.leagueid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTACompendiumDataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTACompendiumDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.leagueid = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTACompendiumDataRequest {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      leagueid: isSet(object.leagueid) ? Number(object.leagueid) : 0,
    };
  },

  toJSON(message: CMsgDOTACompendiumDataRequest): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.leagueid !== undefined && (obj.leagueid = Math.round(message.leagueid));
    return obj;
  },
};

function createBaseCMsgDOTACompendiumDataResponse(): CMsgDOTACompendiumDataResponse {
  return { accountId: 0, leagueid: 0, result: 0, compendiumData: undefined };
}

export const CMsgDOTACompendiumDataResponse = {
  encode(message: CMsgDOTACompendiumDataResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.leagueid !== 0) {
      writer.uint32(16).uint32(message.leagueid);
    }
    if (message.result !== 0) {
      writer.uint32(24).uint32(message.result);
    }
    if (message.compendiumData !== undefined) {
      CMsgDOTACompendiumData.encode(message.compendiumData, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTACompendiumDataResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTACompendiumDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.leagueid = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.result = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.compendiumData = CMsgDOTACompendiumData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTACompendiumDataResponse {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      leagueid: isSet(object.leagueid) ? Number(object.leagueid) : 0,
      result: isSet(object.result) ? Number(object.result) : 0,
      compendiumData: isSet(object.compendiumData) ? CMsgDOTACompendiumData.fromJSON(object.compendiumData) : undefined,
    };
  },

  toJSON(message: CMsgDOTACompendiumDataResponse): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.leagueid !== undefined && (obj.leagueid = Math.round(message.leagueid));
    message.result !== undefined && (obj.result = Math.round(message.result));
    message.compendiumData !== undefined &&
      (obj.compendiumData = message.compendiumData ? CMsgDOTACompendiumData.toJSON(message.compendiumData) : undefined);
    return obj;
  },
};

function createBaseCMsgDOTAGetPlayerMatchHistory(): CMsgDOTAGetPlayerMatchHistory {
  return {
    accountId: 0,
    startAtMatchId: "0",
    matchesRequested: 0,
    heroId: 0,
    requestId: 0,
    includePracticeMatches: false,
    includeCustomGames: false,
    includeEventGames: false,
  };
}

export const CMsgDOTAGetPlayerMatchHistory = {
  encode(message: CMsgDOTAGetPlayerMatchHistory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.startAtMatchId !== "0") {
      writer.uint32(16).uint64(message.startAtMatchId);
    }
    if (message.matchesRequested !== 0) {
      writer.uint32(24).uint32(message.matchesRequested);
    }
    if (message.heroId !== 0) {
      writer.uint32(32).uint32(message.heroId);
    }
    if (message.requestId !== 0) {
      writer.uint32(40).uint32(message.requestId);
    }
    if (message.includePracticeMatches === true) {
      writer.uint32(56).bool(message.includePracticeMatches);
    }
    if (message.includeCustomGames === true) {
      writer.uint32(64).bool(message.includeCustomGames);
    }
    if (message.includeEventGames === true) {
      writer.uint32(72).bool(message.includeEventGames);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAGetPlayerMatchHistory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAGetPlayerMatchHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.startAtMatchId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.matchesRequested = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.requestId = reader.uint32();
          continue;
        case 7:
          if (tag != 56) {
            break;
          }

          message.includePracticeMatches = reader.bool();
          continue;
        case 8:
          if (tag != 64) {
            break;
          }

          message.includeCustomGames = reader.bool();
          continue;
        case 9:
          if (tag != 72) {
            break;
          }

          message.includeEventGames = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAGetPlayerMatchHistory {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      startAtMatchId: isSet(object.startAtMatchId) ? String(object.startAtMatchId) : "0",
      matchesRequested: isSet(object.matchesRequested) ? Number(object.matchesRequested) : 0,
      heroId: isSet(object.heroId) ? Number(object.heroId) : 0,
      requestId: isSet(object.requestId) ? Number(object.requestId) : 0,
      includePracticeMatches: isSet(object.includePracticeMatches) ? Boolean(object.includePracticeMatches) : false,
      includeCustomGames: isSet(object.includeCustomGames) ? Boolean(object.includeCustomGames) : false,
      includeEventGames: isSet(object.includeEventGames) ? Boolean(object.includeEventGames) : false,
    };
  },

  toJSON(message: CMsgDOTAGetPlayerMatchHistory): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.startAtMatchId !== undefined && (obj.startAtMatchId = message.startAtMatchId);
    message.matchesRequested !== undefined && (obj.matchesRequested = Math.round(message.matchesRequested));
    message.heroId !== undefined && (obj.heroId = Math.round(message.heroId));
    message.requestId !== undefined && (obj.requestId = Math.round(message.requestId));
    message.includePracticeMatches !== undefined && (obj.includePracticeMatches = message.includePracticeMatches);
    message.includeCustomGames !== undefined && (obj.includeCustomGames = message.includeCustomGames);
    message.includeEventGames !== undefined && (obj.includeEventGames = message.includeEventGames);
    return obj;
  },
};

function createBaseCMsgDOTAGetPlayerMatchHistoryResponse(): CMsgDOTAGetPlayerMatchHistoryResponse {
  return { matches: [], requestId: 0 };
}

export const CMsgDOTAGetPlayerMatchHistoryResponse = {
  encode(message: CMsgDOTAGetPlayerMatchHistoryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.matches) {
      CMsgDOTAGetPlayerMatchHistoryResponse_Match.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.requestId !== 0) {
      writer.uint32(16).uint32(message.requestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAGetPlayerMatchHistoryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAGetPlayerMatchHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.matches.push(CMsgDOTAGetPlayerMatchHistoryResponse_Match.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.requestId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAGetPlayerMatchHistoryResponse {
    return {
      matches: Array.isArray(object?.matches)
        ? object.matches.map((e: any) => CMsgDOTAGetPlayerMatchHistoryResponse_Match.fromJSON(e))
        : [],
      requestId: isSet(object.requestId) ? Number(object.requestId) : 0,
    };
  },

  toJSON(message: CMsgDOTAGetPlayerMatchHistoryResponse): unknown {
    const obj: any = {};
    if (message.matches) {
      obj.matches = message.matches.map((e) => e ? CMsgDOTAGetPlayerMatchHistoryResponse_Match.toJSON(e) : undefined);
    } else {
      obj.matches = [];
    }
    message.requestId !== undefined && (obj.requestId = Math.round(message.requestId));
    return obj;
  },
};

function createBaseCMsgDOTAGetPlayerMatchHistoryResponse_Match(): CMsgDOTAGetPlayerMatchHistoryResponse_Match {
  return {
    matchId: "0",
    startTime: 0,
    heroId: 0,
    winner: false,
    gameMode: 0,
    rankChange: 0,
    previousRank: 0,
    lobbyType: 0,
    soloRank: false,
    abandon: false,
    duration: 0,
    engine: 0,
    activePlusSubscription: false,
    seasonalRank: false,
    tourneyId: 0,
    tourneyRound: 0,
    tourneyTier: 0,
    tourneyDivision: 0,
    teamId: 0,
    teamName: "",
    ugcTeamUiLogo: "0",
  };
}

export const CMsgDOTAGetPlayerMatchHistoryResponse_Match = {
  encode(message: CMsgDOTAGetPlayerMatchHistoryResponse_Match, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.startTime !== 0) {
      writer.uint32(16).uint32(message.startTime);
    }
    if (message.heroId !== 0) {
      writer.uint32(24).uint32(message.heroId);
    }
    if (message.winner === true) {
      writer.uint32(32).bool(message.winner);
    }
    if (message.gameMode !== 0) {
      writer.uint32(40).uint32(message.gameMode);
    }
    if (message.rankChange !== 0) {
      writer.uint32(48).int32(message.rankChange);
    }
    if (message.previousRank !== 0) {
      writer.uint32(56).uint32(message.previousRank);
    }
    if (message.lobbyType !== 0) {
      writer.uint32(64).uint32(message.lobbyType);
    }
    if (message.soloRank === true) {
      writer.uint32(72).bool(message.soloRank);
    }
    if (message.abandon === true) {
      writer.uint32(80).bool(message.abandon);
    }
    if (message.duration !== 0) {
      writer.uint32(88).uint32(message.duration);
    }
    if (message.engine !== 0) {
      writer.uint32(96).uint32(message.engine);
    }
    if (message.activePlusSubscription === true) {
      writer.uint32(104).bool(message.activePlusSubscription);
    }
    if (message.seasonalRank === true) {
      writer.uint32(112).bool(message.seasonalRank);
    }
    if (message.tourneyId !== 0) {
      writer.uint32(120).uint32(message.tourneyId);
    }
    if (message.tourneyRound !== 0) {
      writer.uint32(128).uint32(message.tourneyRound);
    }
    if (message.tourneyTier !== 0) {
      writer.uint32(136).uint32(message.tourneyTier);
    }
    if (message.tourneyDivision !== 0) {
      writer.uint32(144).uint32(message.tourneyDivision);
    }
    if (message.teamId !== 0) {
      writer.uint32(152).uint32(message.teamId);
    }
    if (message.teamName !== "") {
      writer.uint32(162).string(message.teamName);
    }
    if (message.ugcTeamUiLogo !== "0") {
      writer.uint32(168).uint64(message.ugcTeamUiLogo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAGetPlayerMatchHistoryResponse_Match {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAGetPlayerMatchHistoryResponse_Match();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.startTime = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.winner = reader.bool();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.gameMode = reader.uint32();
          continue;
        case 6:
          if (tag != 48) {
            break;
          }

          message.rankChange = reader.int32();
          continue;
        case 7:
          if (tag != 56) {
            break;
          }

          message.previousRank = reader.uint32();
          continue;
        case 8:
          if (tag != 64) {
            break;
          }

          message.lobbyType = reader.uint32();
          continue;
        case 9:
          if (tag != 72) {
            break;
          }

          message.soloRank = reader.bool();
          continue;
        case 10:
          if (tag != 80) {
            break;
          }

          message.abandon = reader.bool();
          continue;
        case 11:
          if (tag != 88) {
            break;
          }

          message.duration = reader.uint32();
          continue;
        case 12:
          if (tag != 96) {
            break;
          }

          message.engine = reader.uint32();
          continue;
        case 13:
          if (tag != 104) {
            break;
          }

          message.activePlusSubscription = reader.bool();
          continue;
        case 14:
          if (tag != 112) {
            break;
          }

          message.seasonalRank = reader.bool();
          continue;
        case 15:
          if (tag != 120) {
            break;
          }

          message.tourneyId = reader.uint32();
          continue;
        case 16:
          if (tag != 128) {
            break;
          }

          message.tourneyRound = reader.uint32();
          continue;
        case 17:
          if (tag != 136) {
            break;
          }

          message.tourneyTier = reader.uint32();
          continue;
        case 18:
          if (tag != 144) {
            break;
          }

          message.tourneyDivision = reader.uint32();
          continue;
        case 19:
          if (tag != 152) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 20:
          if (tag != 162) {
            break;
          }

          message.teamName = reader.string();
          continue;
        case 21:
          if (tag != 168) {
            break;
          }

          message.ugcTeamUiLogo = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAGetPlayerMatchHistoryResponse_Match {
    return {
      matchId: isSet(object.matchId) ? String(object.matchId) : "0",
      startTime: isSet(object.startTime) ? Number(object.startTime) : 0,
      heroId: isSet(object.heroId) ? Number(object.heroId) : 0,
      winner: isSet(object.winner) ? Boolean(object.winner) : false,
      gameMode: isSet(object.gameMode) ? Number(object.gameMode) : 0,
      rankChange: isSet(object.rankChange) ? Number(object.rankChange) : 0,
      previousRank: isSet(object.previousRank) ? Number(object.previousRank) : 0,
      lobbyType: isSet(object.lobbyType) ? Number(object.lobbyType) : 0,
      soloRank: isSet(object.soloRank) ? Boolean(object.soloRank) : false,
      abandon: isSet(object.abandon) ? Boolean(object.abandon) : false,
      duration: isSet(object.duration) ? Number(object.duration) : 0,
      engine: isSet(object.engine) ? Number(object.engine) : 0,
      activePlusSubscription: isSet(object.activePlusSubscription) ? Boolean(object.activePlusSubscription) : false,
      seasonalRank: isSet(object.seasonalRank) ? Boolean(object.seasonalRank) : false,
      tourneyId: isSet(object.tourneyId) ? Number(object.tourneyId) : 0,
      tourneyRound: isSet(object.tourneyRound) ? Number(object.tourneyRound) : 0,
      tourneyTier: isSet(object.tourneyTier) ? Number(object.tourneyTier) : 0,
      tourneyDivision: isSet(object.tourneyDivision) ? Number(object.tourneyDivision) : 0,
      teamId: isSet(object.teamId) ? Number(object.teamId) : 0,
      teamName: isSet(object.teamName) ? String(object.teamName) : "",
      ugcTeamUiLogo: isSet(object.ugcTeamUiLogo) ? String(object.ugcTeamUiLogo) : "0",
    };
  },

  toJSON(message: CMsgDOTAGetPlayerMatchHistoryResponse_Match): unknown {
    const obj: any = {};
    message.matchId !== undefined && (obj.matchId = message.matchId);
    message.startTime !== undefined && (obj.startTime = Math.round(message.startTime));
    message.heroId !== undefined && (obj.heroId = Math.round(message.heroId));
    message.winner !== undefined && (obj.winner = message.winner);
    message.gameMode !== undefined && (obj.gameMode = Math.round(message.gameMode));
    message.rankChange !== undefined && (obj.rankChange = Math.round(message.rankChange));
    message.previousRank !== undefined && (obj.previousRank = Math.round(message.previousRank));
    message.lobbyType !== undefined && (obj.lobbyType = Math.round(message.lobbyType));
    message.soloRank !== undefined && (obj.soloRank = message.soloRank);
    message.abandon !== undefined && (obj.abandon = message.abandon);
    message.duration !== undefined && (obj.duration = Math.round(message.duration));
    message.engine !== undefined && (obj.engine = Math.round(message.engine));
    message.activePlusSubscription !== undefined && (obj.activePlusSubscription = message.activePlusSubscription);
    message.seasonalRank !== undefined && (obj.seasonalRank = message.seasonalRank);
    message.tourneyId !== undefined && (obj.tourneyId = Math.round(message.tourneyId));
    message.tourneyRound !== undefined && (obj.tourneyRound = Math.round(message.tourneyRound));
    message.tourneyTier !== undefined && (obj.tourneyTier = Math.round(message.tourneyTier));
    message.tourneyDivision !== undefined && (obj.tourneyDivision = Math.round(message.tourneyDivision));
    message.teamId !== undefined && (obj.teamId = Math.round(message.teamId));
    message.teamName !== undefined && (obj.teamName = message.teamName);
    message.ugcTeamUiLogo !== undefined && (obj.ugcTeamUiLogo = message.ugcTeamUiLogo);
    return obj;
  },
};

function createBaseCMsgGCNotificationsRequest(): CMsgGCNotificationsRequest {
  return {};
}

export const CMsgGCNotificationsRequest = {
  encode(_: CMsgGCNotificationsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCNotificationsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCNotificationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgGCNotificationsRequest {
    return {};
  },

  toJSON(_: CMsgGCNotificationsRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgGCNotificationsNotification(): CMsgGCNotificationsNotification {
  return { id: "0", type: 0, timestamp: 0, referenceA: 0, referenceB: 0, referenceC: 0, message: "", unread: false };
}

export const CMsgGCNotificationsNotification = {
  encode(message: CMsgGCNotificationsNotification, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "0") {
      writer.uint32(8).uint64(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(16).uint32(message.type);
    }
    if (message.timestamp !== 0) {
      writer.uint32(24).uint32(message.timestamp);
    }
    if (message.referenceA !== 0) {
      writer.uint32(32).uint32(message.referenceA);
    }
    if (message.referenceB !== 0) {
      writer.uint32(40).uint32(message.referenceB);
    }
    if (message.referenceC !== 0) {
      writer.uint32(48).uint32(message.referenceC);
    }
    if (message.message !== "") {
      writer.uint32(58).string(message.message);
    }
    if (message.unread === true) {
      writer.uint32(64).bool(message.unread);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCNotificationsNotification {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCNotificationsNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.id = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.type = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.referenceA = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.referenceB = reader.uint32();
          continue;
        case 6:
          if (tag != 48) {
            break;
          }

          message.referenceC = reader.uint32();
          continue;
        case 7:
          if (tag != 58) {
            break;
          }

          message.message = reader.string();
          continue;
        case 8:
          if (tag != 64) {
            break;
          }

          message.unread = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCNotificationsNotification {
    return {
      id: isSet(object.id) ? String(object.id) : "0",
      type: isSet(object.type) ? Number(object.type) : 0,
      timestamp: isSet(object.timestamp) ? Number(object.timestamp) : 0,
      referenceA: isSet(object.referenceA) ? Number(object.referenceA) : 0,
      referenceB: isSet(object.referenceB) ? Number(object.referenceB) : 0,
      referenceC: isSet(object.referenceC) ? Number(object.referenceC) : 0,
      message: isSet(object.message) ? String(object.message) : "",
      unread: isSet(object.unread) ? Boolean(object.unread) : false,
    };
  },

  toJSON(message: CMsgGCNotificationsNotification): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    message.type !== undefined && (obj.type = Math.round(message.type));
    message.timestamp !== undefined && (obj.timestamp = Math.round(message.timestamp));
    message.referenceA !== undefined && (obj.referenceA = Math.round(message.referenceA));
    message.referenceB !== undefined && (obj.referenceB = Math.round(message.referenceB));
    message.referenceC !== undefined && (obj.referenceC = Math.round(message.referenceC));
    message.message !== undefined && (obj.message = message.message);
    message.unread !== undefined && (obj.unread = message.unread);
    return obj;
  },
};

function createBaseCMsgGCNotificationsUpdate(): CMsgGCNotificationsUpdate {
  return { result: 0, notifications: [] };
}

export const CMsgGCNotificationsUpdate = {
  encode(message: CMsgGCNotificationsUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    for (const v of message.notifications) {
      CMsgGCNotificationsNotification.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCNotificationsUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCNotificationsUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.notifications.push(CMsgGCNotificationsNotification.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCNotificationsUpdate {
    return {
      result: isSet(object.result) ? cMsgGCNotificationsUpdate_EResultFromJSON(object.result) : 0,
      notifications: Array.isArray(object?.notifications)
        ? object.notifications.map((e: any) => CMsgGCNotificationsNotification.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCNotificationsUpdate): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = cMsgGCNotificationsUpdate_EResultToJSON(message.result));
    if (message.notifications) {
      obj.notifications = message.notifications.map((e) => e ? CMsgGCNotificationsNotification.toJSON(e) : undefined);
    } else {
      obj.notifications = [];
    }
    return obj;
  },
};

function createBaseCMsgGCNotificationsResponse(): CMsgGCNotificationsResponse {
  return { update: undefined };
}

export const CMsgGCNotificationsResponse = {
  encode(message: CMsgGCNotificationsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.update !== undefined) {
      CMsgGCNotificationsUpdate.encode(message.update, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCNotificationsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCNotificationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.update = CMsgGCNotificationsUpdate.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCNotificationsResponse {
    return { update: isSet(object.update) ? CMsgGCNotificationsUpdate.fromJSON(object.update) : undefined };
  },

  toJSON(message: CMsgGCNotificationsResponse): unknown {
    const obj: any = {};
    message.update !== undefined &&
      (obj.update = message.update ? CMsgGCNotificationsUpdate.toJSON(message.update) : undefined);
    return obj;
  },
};

function createBaseCMsgGCNotificationsMarkReadRequest(): CMsgGCNotificationsMarkReadRequest {
  return {};
}

export const CMsgGCNotificationsMarkReadRequest = {
  encode(_: CMsgGCNotificationsMarkReadRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCNotificationsMarkReadRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCNotificationsMarkReadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgGCNotificationsMarkReadRequest {
    return {};
  },

  toJSON(_: CMsgGCNotificationsMarkReadRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgGCPlayerInfoSubmit(): CMsgGCPlayerInfoSubmit {
  return { name: "", countryCode: "", fantasyRole: 0, teamId: 0, sponsor: "" };
}

export const CMsgGCPlayerInfoSubmit = {
  encode(message: CMsgGCPlayerInfoSubmit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.countryCode !== "") {
      writer.uint32(18).string(message.countryCode);
    }
    if (message.fantasyRole !== 0) {
      writer.uint32(24).uint32(message.fantasyRole);
    }
    if (message.teamId !== 0) {
      writer.uint32(32).uint32(message.teamId);
    }
    if (message.sponsor !== "") {
      writer.uint32(42).string(message.sponsor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCPlayerInfoSubmit {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCPlayerInfoSubmit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.fantasyRole = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 5:
          if (tag != 42) {
            break;
          }

          message.sponsor = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCPlayerInfoSubmit {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      countryCode: isSet(object.countryCode) ? String(object.countryCode) : "",
      fantasyRole: isSet(object.fantasyRole) ? Number(object.fantasyRole) : 0,
      teamId: isSet(object.teamId) ? Number(object.teamId) : 0,
      sponsor: isSet(object.sponsor) ? String(object.sponsor) : "",
    };
  },

  toJSON(message: CMsgGCPlayerInfoSubmit): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.countryCode !== undefined && (obj.countryCode = message.countryCode);
    message.fantasyRole !== undefined && (obj.fantasyRole = Math.round(message.fantasyRole));
    message.teamId !== undefined && (obj.teamId = Math.round(message.teamId));
    message.sponsor !== undefined && (obj.sponsor = message.sponsor);
    return obj;
  },
};

function createBaseCMsgGCPlayerInfoSubmitResponse(): CMsgGCPlayerInfoSubmitResponse {
  return { result: 0 };
}

export const CMsgGCPlayerInfoSubmitResponse = {
  encode(message: CMsgGCPlayerInfoSubmitResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCPlayerInfoSubmitResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCPlayerInfoSubmitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCPlayerInfoSubmitResponse {
    return { result: isSet(object.result) ? cMsgGCPlayerInfoSubmitResponse_EResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgGCPlayerInfoSubmitResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = cMsgGCPlayerInfoSubmitResponse_EResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgDOTAEmoticonAccessSDO(): CMsgDOTAEmoticonAccessSDO {
  return { accountId: 0, unlockedEmoticons: Buffer.alloc(0) };
}

export const CMsgDOTAEmoticonAccessSDO = {
  encode(message: CMsgDOTAEmoticonAccessSDO, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.unlockedEmoticons.length !== 0) {
      writer.uint32(18).bytes(message.unlockedEmoticons);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAEmoticonAccessSDO {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAEmoticonAccessSDO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.unlockedEmoticons = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAEmoticonAccessSDO {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      unlockedEmoticons: isSet(object.unlockedEmoticons)
        ? Buffer.from(bytesFromBase64(object.unlockedEmoticons))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: CMsgDOTAEmoticonAccessSDO): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.unlockedEmoticons !== undefined &&
      (obj.unlockedEmoticons = base64FromBytes(
        message.unlockedEmoticons !== undefined ? message.unlockedEmoticons : Buffer.alloc(0),
      ));
    return obj;
  },
};

function createBaseCMsgClientToGCEmoticonDataRequest(): CMsgClientToGCEmoticonDataRequest {
  return {};
}

export const CMsgClientToGCEmoticonDataRequest = {
  encode(_: CMsgClientToGCEmoticonDataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCEmoticonDataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCEmoticonDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientToGCEmoticonDataRequest {
    return {};
  },

  toJSON(_: CMsgClientToGCEmoticonDataRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgGCToClientEmoticonData(): CMsgGCToClientEmoticonData {
  return { emoticonAccess: undefined };
}

export const CMsgGCToClientEmoticonData = {
  encode(message: CMsgGCToClientEmoticonData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.emoticonAccess !== undefined) {
      CMsgDOTAEmoticonAccessSDO.encode(message.emoticonAccess, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientEmoticonData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientEmoticonData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.emoticonAccess = CMsgDOTAEmoticonAccessSDO.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientEmoticonData {
    return {
      emoticonAccess: isSet(object.emoticonAccess)
        ? CMsgDOTAEmoticonAccessSDO.fromJSON(object.emoticonAccess)
        : undefined,
    };
  },

  toJSON(message: CMsgGCToClientEmoticonData): unknown {
    const obj: any = {};
    message.emoticonAccess !== undefined && (obj.emoticonAccess = message.emoticonAccess
      ? CMsgDOTAEmoticonAccessSDO.toJSON(message.emoticonAccess)
      : undefined);
    return obj;
  },
};

function createBaseCMsgGCToClientTournamentItemDrop(): CMsgGCToClientTournamentItemDrop {
  return { itemDef: 0, eventType: 0 };
}

export const CMsgGCToClientTournamentItemDrop = {
  encode(message: CMsgGCToClientTournamentItemDrop, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemDef !== 0) {
      writer.uint32(8).uint32(message.itemDef);
    }
    if (message.eventType !== 0) {
      writer.uint32(16).uint32(message.eventType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientTournamentItemDrop {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientTournamentItemDrop();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.itemDef = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.eventType = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientTournamentItemDrop {
    return {
      itemDef: isSet(object.itemDef) ? Number(object.itemDef) : 0,
      eventType: isSet(object.eventType) ? Number(object.eventType) : 0,
    };
  },

  toJSON(message: CMsgGCToClientTournamentItemDrop): unknown {
    const obj: any = {};
    message.itemDef !== undefined && (obj.itemDef = Math.round(message.itemDef));
    message.eventType !== undefined && (obj.eventType = Math.round(message.eventType));
    return obj;
  },
};

function createBaseCMsgClientToGCGetAllHeroOrder(): CMsgClientToGCGetAllHeroOrder {
  return {};
}

export const CMsgClientToGCGetAllHeroOrder = {
  encode(_: CMsgClientToGCGetAllHeroOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetAllHeroOrder {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetAllHeroOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientToGCGetAllHeroOrder {
    return {};
  },

  toJSON(_: CMsgClientToGCGetAllHeroOrder): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgClientToGCGetAllHeroOrderResponse(): CMsgClientToGCGetAllHeroOrderResponse {
  return { heroIds: [] };
}

export const CMsgClientToGCGetAllHeroOrderResponse = {
  encode(message: CMsgClientToGCGetAllHeroOrderResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.heroIds) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetAllHeroOrderResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetAllHeroOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag == 8) {
            message.heroIds.push(reader.uint32());
            continue;
          }

          if (tag == 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.heroIds.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetAllHeroOrderResponse {
    return { heroIds: Array.isArray(object?.heroIds) ? object.heroIds.map((e: any) => Number(e)) : [] };
  },

  toJSON(message: CMsgClientToGCGetAllHeroOrderResponse): unknown {
    const obj: any = {};
    if (message.heroIds) {
      obj.heroIds = message.heroIds.map((e) => Math.round(e));
    } else {
      obj.heroIds = [];
    }
    return obj;
  },
};

function createBaseCMsgClientToGCGetAllHeroProgress(): CMsgClientToGCGetAllHeroProgress {
  return { accountId: 0 };
}

export const CMsgClientToGCGetAllHeroProgress = {
  encode(message: CMsgClientToGCGetAllHeroProgress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetAllHeroProgress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetAllHeroProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetAllHeroProgress {
    return { accountId: isSet(object.accountId) ? Number(object.accountId) : 0 };
  },

  toJSON(message: CMsgClientToGCGetAllHeroProgress): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    return obj;
  },
};

function createBaseCMsgClientToGCGetAllHeroProgressResponse(): CMsgClientToGCGetAllHeroProgressResponse {
  return {
    accountId: 0,
    currHeroId: 0,
    lapsCompleted: 0,
    currHeroGames: 0,
    currLapTimeStarted: 0,
    currLapGames: 0,
    bestLapGames: 0,
    bestLapTime: 0,
    lapHeroesCompleted: 0,
    lapHeroesRemaining: 0,
    nextHeroId: 0,
    prevHeroId: 0,
    prevHeroGames: 0,
    prevAvgTries: 0,
    currAvgTries: 0,
    nextAvgTries: 0,
    fullLapAvgTries: 0,
    currLapAvgTries: 0,
    profileName: "",
    startHeroId: 0,
  };
}

export const CMsgClientToGCGetAllHeroProgressResponse = {
  encode(message: CMsgClientToGCGetAllHeroProgressResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.currHeroId !== 0) {
      writer.uint32(16).uint32(message.currHeroId);
    }
    if (message.lapsCompleted !== 0) {
      writer.uint32(24).uint32(message.lapsCompleted);
    }
    if (message.currHeroGames !== 0) {
      writer.uint32(32).uint32(message.currHeroGames);
    }
    if (message.currLapTimeStarted !== 0) {
      writer.uint32(40).uint32(message.currLapTimeStarted);
    }
    if (message.currLapGames !== 0) {
      writer.uint32(48).uint32(message.currLapGames);
    }
    if (message.bestLapGames !== 0) {
      writer.uint32(56).uint32(message.bestLapGames);
    }
    if (message.bestLapTime !== 0) {
      writer.uint32(64).uint32(message.bestLapTime);
    }
    if (message.lapHeroesCompleted !== 0) {
      writer.uint32(72).uint32(message.lapHeroesCompleted);
    }
    if (message.lapHeroesRemaining !== 0) {
      writer.uint32(80).uint32(message.lapHeroesRemaining);
    }
    if (message.nextHeroId !== 0) {
      writer.uint32(88).uint32(message.nextHeroId);
    }
    if (message.prevHeroId !== 0) {
      writer.uint32(96).uint32(message.prevHeroId);
    }
    if (message.prevHeroGames !== 0) {
      writer.uint32(104).uint32(message.prevHeroGames);
    }
    if (message.prevAvgTries !== 0) {
      writer.uint32(117).float(message.prevAvgTries);
    }
    if (message.currAvgTries !== 0) {
      writer.uint32(125).float(message.currAvgTries);
    }
    if (message.nextAvgTries !== 0) {
      writer.uint32(133).float(message.nextAvgTries);
    }
    if (message.fullLapAvgTries !== 0) {
      writer.uint32(141).float(message.fullLapAvgTries);
    }
    if (message.currLapAvgTries !== 0) {
      writer.uint32(149).float(message.currLapAvgTries);
    }
    if (message.profileName !== "") {
      writer.uint32(154).string(message.profileName);
    }
    if (message.startHeroId !== 0) {
      writer.uint32(160).uint32(message.startHeroId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetAllHeroProgressResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetAllHeroProgressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.currHeroId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.lapsCompleted = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.currHeroGames = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.currLapTimeStarted = reader.uint32();
          continue;
        case 6:
          if (tag != 48) {
            break;
          }

          message.currLapGames = reader.uint32();
          continue;
        case 7:
          if (tag != 56) {
            break;
          }

          message.bestLapGames = reader.uint32();
          continue;
        case 8:
          if (tag != 64) {
            break;
          }

          message.bestLapTime = reader.uint32();
          continue;
        case 9:
          if (tag != 72) {
            break;
          }

          message.lapHeroesCompleted = reader.uint32();
          continue;
        case 10:
          if (tag != 80) {
            break;
          }

          message.lapHeroesRemaining = reader.uint32();
          continue;
        case 11:
          if (tag != 88) {
            break;
          }

          message.nextHeroId = reader.uint32();
          continue;
        case 12:
          if (tag != 96) {
            break;
          }

          message.prevHeroId = reader.uint32();
          continue;
        case 13:
          if (tag != 104) {
            break;
          }

          message.prevHeroGames = reader.uint32();
          continue;
        case 14:
          if (tag != 117) {
            break;
          }

          message.prevAvgTries = reader.float();
          continue;
        case 15:
          if (tag != 125) {
            break;
          }

          message.currAvgTries = reader.float();
          continue;
        case 16:
          if (tag != 133) {
            break;
          }

          message.nextAvgTries = reader.float();
          continue;
        case 17:
          if (tag != 141) {
            break;
          }

          message.fullLapAvgTries = reader.float();
          continue;
        case 18:
          if (tag != 149) {
            break;
          }

          message.currLapAvgTries = reader.float();
          continue;
        case 19:
          if (tag != 154) {
            break;
          }

          message.profileName = reader.string();
          continue;
        case 20:
          if (tag != 160) {
            break;
          }

          message.startHeroId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetAllHeroProgressResponse {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      currHeroId: isSet(object.currHeroId) ? Number(object.currHeroId) : 0,
      lapsCompleted: isSet(object.lapsCompleted) ? Number(object.lapsCompleted) : 0,
      currHeroGames: isSet(object.currHeroGames) ? Number(object.currHeroGames) : 0,
      currLapTimeStarted: isSet(object.currLapTimeStarted) ? Number(object.currLapTimeStarted) : 0,
      currLapGames: isSet(object.currLapGames) ? Number(object.currLapGames) : 0,
      bestLapGames: isSet(object.bestLapGames) ? Number(object.bestLapGames) : 0,
      bestLapTime: isSet(object.bestLapTime) ? Number(object.bestLapTime) : 0,
      lapHeroesCompleted: isSet(object.lapHeroesCompleted) ? Number(object.lapHeroesCompleted) : 0,
      lapHeroesRemaining: isSet(object.lapHeroesRemaining) ? Number(object.lapHeroesRemaining) : 0,
      nextHeroId: isSet(object.nextHeroId) ? Number(object.nextHeroId) : 0,
      prevHeroId: isSet(object.prevHeroId) ? Number(object.prevHeroId) : 0,
      prevHeroGames: isSet(object.prevHeroGames) ? Number(object.prevHeroGames) : 0,
      prevAvgTries: isSet(object.prevAvgTries) ? Number(object.prevAvgTries) : 0,
      currAvgTries: isSet(object.currAvgTries) ? Number(object.currAvgTries) : 0,
      nextAvgTries: isSet(object.nextAvgTries) ? Number(object.nextAvgTries) : 0,
      fullLapAvgTries: isSet(object.fullLapAvgTries) ? Number(object.fullLapAvgTries) : 0,
      currLapAvgTries: isSet(object.currLapAvgTries) ? Number(object.currLapAvgTries) : 0,
      profileName: isSet(object.profileName) ? String(object.profileName) : "",
      startHeroId: isSet(object.startHeroId) ? Number(object.startHeroId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCGetAllHeroProgressResponse): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.currHeroId !== undefined && (obj.currHeroId = Math.round(message.currHeroId));
    message.lapsCompleted !== undefined && (obj.lapsCompleted = Math.round(message.lapsCompleted));
    message.currHeroGames !== undefined && (obj.currHeroGames = Math.round(message.currHeroGames));
    message.currLapTimeStarted !== undefined && (obj.currLapTimeStarted = Math.round(message.currLapTimeStarted));
    message.currLapGames !== undefined && (obj.currLapGames = Math.round(message.currLapGames));
    message.bestLapGames !== undefined && (obj.bestLapGames = Math.round(message.bestLapGames));
    message.bestLapTime !== undefined && (obj.bestLapTime = Math.round(message.bestLapTime));
    message.lapHeroesCompleted !== undefined && (obj.lapHeroesCompleted = Math.round(message.lapHeroesCompleted));
    message.lapHeroesRemaining !== undefined && (obj.lapHeroesRemaining = Math.round(message.lapHeroesRemaining));
    message.nextHeroId !== undefined && (obj.nextHeroId = Math.round(message.nextHeroId));
    message.prevHeroId !== undefined && (obj.prevHeroId = Math.round(message.prevHeroId));
    message.prevHeroGames !== undefined && (obj.prevHeroGames = Math.round(message.prevHeroGames));
    message.prevAvgTries !== undefined && (obj.prevAvgTries = message.prevAvgTries);
    message.currAvgTries !== undefined && (obj.currAvgTries = message.currAvgTries);
    message.nextAvgTries !== undefined && (obj.nextAvgTries = message.nextAvgTries);
    message.fullLapAvgTries !== undefined && (obj.fullLapAvgTries = message.fullLapAvgTries);
    message.currLapAvgTries !== undefined && (obj.currLapAvgTries = message.currLapAvgTries);
    message.profileName !== undefined && (obj.profileName = message.profileName);
    message.startHeroId !== undefined && (obj.startHeroId = Math.round(message.startHeroId));
    return obj;
  },
};

function createBaseCMsgClientToGCGetTrophyList(): CMsgClientToGCGetTrophyList {
  return { accountId: 0 };
}

export const CMsgClientToGCGetTrophyList = {
  encode(message: CMsgClientToGCGetTrophyList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetTrophyList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetTrophyList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetTrophyList {
    return { accountId: isSet(object.accountId) ? Number(object.accountId) : 0 };
  },

  toJSON(message: CMsgClientToGCGetTrophyList): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    return obj;
  },
};

function createBaseCMsgClientToGCGetTrophyListResponse(): CMsgClientToGCGetTrophyListResponse {
  return { trophies: [] };
}

export const CMsgClientToGCGetTrophyListResponse = {
  encode(message: CMsgClientToGCGetTrophyListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.trophies) {
      CMsgClientToGCGetTrophyListResponse_Trophy.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetTrophyListResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetTrophyListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag != 18) {
            break;
          }

          message.trophies.push(CMsgClientToGCGetTrophyListResponse_Trophy.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetTrophyListResponse {
    return {
      trophies: Array.isArray(object?.trophies)
        ? object.trophies.map((e: any) => CMsgClientToGCGetTrophyListResponse_Trophy.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientToGCGetTrophyListResponse): unknown {
    const obj: any = {};
    if (message.trophies) {
      obj.trophies = message.trophies.map((e) => e ? CMsgClientToGCGetTrophyListResponse_Trophy.toJSON(e) : undefined);
    } else {
      obj.trophies = [];
    }
    return obj;
  },
};

function createBaseCMsgClientToGCGetTrophyListResponse_Trophy(): CMsgClientToGCGetTrophyListResponse_Trophy {
  return { trophyId: 0, trophyScore: 0, lastUpdated: 0 };
}

export const CMsgClientToGCGetTrophyListResponse_Trophy = {
  encode(message: CMsgClientToGCGetTrophyListResponse_Trophy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.trophyId !== 0) {
      writer.uint32(8).uint32(message.trophyId);
    }
    if (message.trophyScore !== 0) {
      writer.uint32(16).uint32(message.trophyScore);
    }
    if (message.lastUpdated !== 0) {
      writer.uint32(24).uint32(message.lastUpdated);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetTrophyListResponse_Trophy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetTrophyListResponse_Trophy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.trophyId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.trophyScore = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.lastUpdated = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetTrophyListResponse_Trophy {
    return {
      trophyId: isSet(object.trophyId) ? Number(object.trophyId) : 0,
      trophyScore: isSet(object.trophyScore) ? Number(object.trophyScore) : 0,
      lastUpdated: isSet(object.lastUpdated) ? Number(object.lastUpdated) : 0,
    };
  },

  toJSON(message: CMsgClientToGCGetTrophyListResponse_Trophy): unknown {
    const obj: any = {};
    message.trophyId !== undefined && (obj.trophyId = Math.round(message.trophyId));
    message.trophyScore !== undefined && (obj.trophyScore = Math.round(message.trophyScore));
    message.lastUpdated !== undefined && (obj.lastUpdated = Math.round(message.lastUpdated));
    return obj;
  },
};

function createBaseCMsgGCToClientTrophyAwarded(): CMsgGCToClientTrophyAwarded {
  return { trophyId: 0, trophyScore: 0, trophyOldScore: 0, lastUpdated: 0 };
}

export const CMsgGCToClientTrophyAwarded = {
  encode(message: CMsgGCToClientTrophyAwarded, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.trophyId !== 0) {
      writer.uint32(8).uint32(message.trophyId);
    }
    if (message.trophyScore !== 0) {
      writer.uint32(16).uint32(message.trophyScore);
    }
    if (message.trophyOldScore !== 0) {
      writer.uint32(24).uint32(message.trophyOldScore);
    }
    if (message.lastUpdated !== 0) {
      writer.uint32(32).uint32(message.lastUpdated);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientTrophyAwarded {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientTrophyAwarded();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.trophyId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.trophyScore = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.trophyOldScore = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.lastUpdated = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientTrophyAwarded {
    return {
      trophyId: isSet(object.trophyId) ? Number(object.trophyId) : 0,
      trophyScore: isSet(object.trophyScore) ? Number(object.trophyScore) : 0,
      trophyOldScore: isSet(object.trophyOldScore) ? Number(object.trophyOldScore) : 0,
      lastUpdated: isSet(object.lastUpdated) ? Number(object.lastUpdated) : 0,
    };
  },

  toJSON(message: CMsgGCToClientTrophyAwarded): unknown {
    const obj: any = {};
    message.trophyId !== undefined && (obj.trophyId = Math.round(message.trophyId));
    message.trophyScore !== undefined && (obj.trophyScore = Math.round(message.trophyScore));
    message.trophyOldScore !== undefined && (obj.trophyOldScore = Math.round(message.trophyOldScore));
    message.lastUpdated !== undefined && (obj.lastUpdated = Math.round(message.lastUpdated));
    return obj;
  },
};

function createBaseCMsgClientToGCRankRequest(): CMsgClientToGCRankRequest {
  return { rankType: 0 };
}

export const CMsgClientToGCRankRequest = {
  encode(message: CMsgClientToGCRankRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rankType !== 0) {
      writer.uint32(8).int32(message.rankType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRankRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRankRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.rankType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRankRequest {
    return { rankType: isSet(object.rankType) ? eRankTypeFromJSON(object.rankType) : 0 };
  },

  toJSON(message: CMsgClientToGCRankRequest): unknown {
    const obj: any = {};
    message.rankType !== undefined && (obj.rankType = eRankTypeToJSON(message.rankType));
    return obj;
  },
};

function createBaseCMsgGCToClientRankResponse(): CMsgGCToClientRankResponse {
  return { result: 0, rankValue: 0, rankData1: 0, rankData2: 0, rankData3: 0 };
}

export const CMsgGCToClientRankResponse = {
  encode(message: CMsgGCToClientRankResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.rankValue !== 0) {
      writer.uint32(16).uint32(message.rankValue);
    }
    if (message.rankData1 !== 0) {
      writer.uint32(24).uint32(message.rankData1);
    }
    if (message.rankData2 !== 0) {
      writer.uint32(32).uint32(message.rankData2);
    }
    if (message.rankData3 !== 0) {
      writer.uint32(40).uint32(message.rankData3);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientRankResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientRankResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.rankValue = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.rankData1 = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.rankData2 = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.rankData3 = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientRankResponse {
    return {
      result: isSet(object.result) ? cMsgGCToClientRankResponse_EResultCodeFromJSON(object.result) : 0,
      rankValue: isSet(object.rankValue) ? Number(object.rankValue) : 0,
      rankData1: isSet(object.rankData1) ? Number(object.rankData1) : 0,
      rankData2: isSet(object.rankData2) ? Number(object.rankData2) : 0,
      rankData3: isSet(object.rankData3) ? Number(object.rankData3) : 0,
    };
  },

  toJSON(message: CMsgGCToClientRankResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = cMsgGCToClientRankResponse_EResultCodeToJSON(message.result));
    message.rankValue !== undefined && (obj.rankValue = Math.round(message.rankValue));
    message.rankData1 !== undefined && (obj.rankData1 = Math.round(message.rankData1));
    message.rankData2 !== undefined && (obj.rankData2 = Math.round(message.rankData2));
    message.rankData3 !== undefined && (obj.rankData3 = Math.round(message.rankData3));
    return obj;
  },
};

function createBaseCMsgGCToClientRankUpdate(): CMsgGCToClientRankUpdate {
  return { rankType: 0, rankInfo: undefined };
}

export const CMsgGCToClientRankUpdate = {
  encode(message: CMsgGCToClientRankUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rankType !== 0) {
      writer.uint32(8).int32(message.rankType);
    }
    if (message.rankInfo !== undefined) {
      CMsgGCToClientRankResponse.encode(message.rankInfo, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientRankUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientRankUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.rankType = reader.int32() as any;
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.rankInfo = CMsgGCToClientRankResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientRankUpdate {
    return {
      rankType: isSet(object.rankType) ? eRankTypeFromJSON(object.rankType) : 0,
      rankInfo: isSet(object.rankInfo) ? CMsgGCToClientRankResponse.fromJSON(object.rankInfo) : undefined,
    };
  },

  toJSON(message: CMsgGCToClientRankUpdate): unknown {
    const obj: any = {};
    message.rankType !== undefined && (obj.rankType = eRankTypeToJSON(message.rankType));
    message.rankInfo !== undefined &&
      (obj.rankInfo = message.rankInfo ? CMsgGCToClientRankResponse.toJSON(message.rankInfo) : undefined);
    return obj;
  },
};

function createBaseCMsgClientToGCGetProfileCard(): CMsgClientToGCGetProfileCard {
  return { accountId: 0 };
}

export const CMsgClientToGCGetProfileCard = {
  encode(message: CMsgClientToGCGetProfileCard, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetProfileCard {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetProfileCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetProfileCard {
    return { accountId: isSet(object.accountId) ? Number(object.accountId) : 0 };
  },

  toJSON(message: CMsgClientToGCGetProfileCard): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    return obj;
  },
};

function createBaseCMsgClientToGCSetProfileCardSlots(): CMsgClientToGCSetProfileCardSlots {
  return { slots: [] };
}

export const CMsgClientToGCSetProfileCardSlots = {
  encode(message: CMsgClientToGCSetProfileCardSlots, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.slots) {
      CMsgClientToGCSetProfileCardSlots_CardSlot.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSetProfileCardSlots {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSetProfileCardSlots();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.slots.push(CMsgClientToGCSetProfileCardSlots_CardSlot.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSetProfileCardSlots {
    return {
      slots: Array.isArray(object?.slots)
        ? object.slots.map((e: any) => CMsgClientToGCSetProfileCardSlots_CardSlot.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientToGCSetProfileCardSlots): unknown {
    const obj: any = {};
    if (message.slots) {
      obj.slots = message.slots.map((e) => e ? CMsgClientToGCSetProfileCardSlots_CardSlot.toJSON(e) : undefined);
    } else {
      obj.slots = [];
    }
    return obj;
  },
};

function createBaseCMsgClientToGCSetProfileCardSlots_CardSlot(): CMsgClientToGCSetProfileCardSlots_CardSlot {
  return { slotId: 0, slotType: 0, slotValue: "0" };
}

export const CMsgClientToGCSetProfileCardSlots_CardSlot = {
  encode(message: CMsgClientToGCSetProfileCardSlots_CardSlot, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.slotId !== 0) {
      writer.uint32(8).uint32(message.slotId);
    }
    if (message.slotType !== 0) {
      writer.uint32(16).int32(message.slotType);
    }
    if (message.slotValue !== "0") {
      writer.uint32(24).uint64(message.slotValue);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSetProfileCardSlots_CardSlot {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSetProfileCardSlots_CardSlot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.slotId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.slotType = reader.int32() as any;
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.slotValue = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSetProfileCardSlots_CardSlot {
    return {
      slotId: isSet(object.slotId) ? Number(object.slotId) : 0,
      slotType: isSet(object.slotType) ? eProfileCardSlotTypeFromJSON(object.slotType) : 0,
      slotValue: isSet(object.slotValue) ? String(object.slotValue) : "0",
    };
  },

  toJSON(message: CMsgClientToGCSetProfileCardSlots_CardSlot): unknown {
    const obj: any = {};
    message.slotId !== undefined && (obj.slotId = Math.round(message.slotId));
    message.slotType !== undefined && (obj.slotType = eProfileCardSlotTypeToJSON(message.slotType));
    message.slotValue !== undefined && (obj.slotValue = message.slotValue);
    return obj;
  },
};

function createBaseCMsgClientToGCGetProfileCardStats(): CMsgClientToGCGetProfileCardStats {
  return {};
}

export const CMsgClientToGCGetProfileCardStats = {
  encode(_: CMsgClientToGCGetProfileCardStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetProfileCardStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetProfileCardStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientToGCGetProfileCardStats {
    return {};
  },

  toJSON(_: CMsgClientToGCGetProfileCardStats): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgClientToGCCreateHeroStatue(): CMsgClientToGCCreateHeroStatue {
  return {
    sourceItemId: "0",
    heroId: 0,
    sequenceName: "",
    cycle: 0,
    wearables: [],
    inscription: "",
    styles: [],
    reforgerItemId: "0",
    tournamentDrop: false,
  };
}

export const CMsgClientToGCCreateHeroStatue = {
  encode(message: CMsgClientToGCCreateHeroStatue, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sourceItemId !== "0") {
      writer.uint32(8).uint64(message.sourceItemId);
    }
    if (message.heroId !== 0) {
      writer.uint32(24).uint32(message.heroId);
    }
    if (message.sequenceName !== "") {
      writer.uint32(34).string(message.sequenceName);
    }
    if (message.cycle !== 0) {
      writer.uint32(45).float(message.cycle);
    }
    writer.uint32(50).fork();
    for (const v of message.wearables) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.inscription !== "") {
      writer.uint32(58).string(message.inscription);
    }
    writer.uint32(66).fork();
    for (const v of message.styles) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.reforgerItemId !== "0") {
      writer.uint32(72).uint64(message.reforgerItemId);
    }
    if (message.tournamentDrop === true) {
      writer.uint32(80).bool(message.tournamentDrop);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCCreateHeroStatue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCreateHeroStatue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.sourceItemId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.sequenceName = reader.string();
          continue;
        case 5:
          if (tag != 45) {
            break;
          }

          message.cycle = reader.float();
          continue;
        case 6:
          if (tag == 48) {
            message.wearables.push(reader.uint32());
            continue;
          }

          if (tag == 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.wearables.push(reader.uint32());
            }

            continue;
          }

          break;
        case 7:
          if (tag != 58) {
            break;
          }

          message.inscription = reader.string();
          continue;
        case 8:
          if (tag == 64) {
            message.styles.push(reader.uint32());
            continue;
          }

          if (tag == 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.styles.push(reader.uint32());
            }

            continue;
          }

          break;
        case 9:
          if (tag != 72) {
            break;
          }

          message.reforgerItemId = longToString(reader.uint64() as Long);
          continue;
        case 10:
          if (tag != 80) {
            break;
          }

          message.tournamentDrop = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCreateHeroStatue {
    return {
      sourceItemId: isSet(object.sourceItemId) ? String(object.sourceItemId) : "0",
      heroId: isSet(object.heroId) ? Number(object.heroId) : 0,
      sequenceName: isSet(object.sequenceName) ? String(object.sequenceName) : "",
      cycle: isSet(object.cycle) ? Number(object.cycle) : 0,
      wearables: Array.isArray(object?.wearables) ? object.wearables.map((e: any) => Number(e)) : [],
      inscription: isSet(object.inscription) ? String(object.inscription) : "",
      styles: Array.isArray(object?.styles) ? object.styles.map((e: any) => Number(e)) : [],
      reforgerItemId: isSet(object.reforgerItemId) ? String(object.reforgerItemId) : "0",
      tournamentDrop: isSet(object.tournamentDrop) ? Boolean(object.tournamentDrop) : false,
    };
  },

  toJSON(message: CMsgClientToGCCreateHeroStatue): unknown {
    const obj: any = {};
    message.sourceItemId !== undefined && (obj.sourceItemId = message.sourceItemId);
    message.heroId !== undefined && (obj.heroId = Math.round(message.heroId));
    message.sequenceName !== undefined && (obj.sequenceName = message.sequenceName);
    message.cycle !== undefined && (obj.cycle = message.cycle);
    if (message.wearables) {
      obj.wearables = message.wearables.map((e) => Math.round(e));
    } else {
      obj.wearables = [];
    }
    message.inscription !== undefined && (obj.inscription = message.inscription);
    if (message.styles) {
      obj.styles = message.styles.map((e) => Math.round(e));
    } else {
      obj.styles = [];
    }
    message.reforgerItemId !== undefined && (obj.reforgerItemId = message.reforgerItemId);
    message.tournamentDrop !== undefined && (obj.tournamentDrop = message.tournamentDrop);
    return obj;
  },
};

function createBaseCMsgGCToClientHeroStatueCreateResult(): CMsgGCToClientHeroStatueCreateResult {
  return { resultingItemId: "0" };
}

export const CMsgGCToClientHeroStatueCreateResult = {
  encode(message: CMsgGCToClientHeroStatueCreateResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.resultingItemId !== "0") {
      writer.uint32(8).uint64(message.resultingItemId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientHeroStatueCreateResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientHeroStatueCreateResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.resultingItemId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientHeroStatueCreateResult {
    return { resultingItemId: isSet(object.resultingItemId) ? String(object.resultingItemId) : "0" };
  },

  toJSON(message: CMsgGCToClientHeroStatueCreateResult): unknown {
    const obj: any = {};
    message.resultingItemId !== undefined && (obj.resultingItemId = message.resultingItemId);
    return obj;
  },
};

function createBaseCMsgClientToGCPlayerStatsRequest(): CMsgClientToGCPlayerStatsRequest {
  return { accountId: 0 };
}

export const CMsgClientToGCPlayerStatsRequest = {
  encode(message: CMsgClientToGCPlayerStatsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCPlayerStatsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCPlayerStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCPlayerStatsRequest {
    return { accountId: isSet(object.accountId) ? Number(object.accountId) : 0 };
  },

  toJSON(message: CMsgClientToGCPlayerStatsRequest): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    return obj;
  },
};

function createBaseCMsgGCToClientPlayerStatsResponse(): CMsgGCToClientPlayerStatsResponse {
  return {
    accountId: 0,
    playerStats: [],
    matchCount: 0,
    meanGpm: 0,
    meanXppm: 0,
    meanLasthits: 0,
    rampages: 0,
    tripleKills: 0,
    firstBloodClaimed: 0,
    firstBloodGiven: 0,
    couriersKilled: 0,
    aegisesSnatched: 0,
    cheesesEaten: 0,
    creepsStacked: 0,
    fightScore: 0,
    farmScore: 0,
    supportScore: 0,
    pushScore: 0,
    versatilityScore: 0,
    meanNetworth: 0,
    meanDamage: 0,
    meanHeals: 0,
    rapiersPurchased: 0,
  };
}

export const CMsgGCToClientPlayerStatsResponse = {
  encode(message: CMsgGCToClientPlayerStatsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    writer.uint32(18).fork();
    for (const v of message.playerStats) {
      writer.float(v);
    }
    writer.ldelim();
    if (message.matchCount !== 0) {
      writer.uint32(24).uint32(message.matchCount);
    }
    if (message.meanGpm !== 0) {
      writer.uint32(37).float(message.meanGpm);
    }
    if (message.meanXppm !== 0) {
      writer.uint32(45).float(message.meanXppm);
    }
    if (message.meanLasthits !== 0) {
      writer.uint32(53).float(message.meanLasthits);
    }
    if (message.rampages !== 0) {
      writer.uint32(56).uint32(message.rampages);
    }
    if (message.tripleKills !== 0) {
      writer.uint32(64).uint32(message.tripleKills);
    }
    if (message.firstBloodClaimed !== 0) {
      writer.uint32(72).uint32(message.firstBloodClaimed);
    }
    if (message.firstBloodGiven !== 0) {
      writer.uint32(80).uint32(message.firstBloodGiven);
    }
    if (message.couriersKilled !== 0) {
      writer.uint32(88).uint32(message.couriersKilled);
    }
    if (message.aegisesSnatched !== 0) {
      writer.uint32(96).uint32(message.aegisesSnatched);
    }
    if (message.cheesesEaten !== 0) {
      writer.uint32(104).uint32(message.cheesesEaten);
    }
    if (message.creepsStacked !== 0) {
      writer.uint32(112).uint32(message.creepsStacked);
    }
    if (message.fightScore !== 0) {
      writer.uint32(125).float(message.fightScore);
    }
    if (message.farmScore !== 0) {
      writer.uint32(133).float(message.farmScore);
    }
    if (message.supportScore !== 0) {
      writer.uint32(141).float(message.supportScore);
    }
    if (message.pushScore !== 0) {
      writer.uint32(149).float(message.pushScore);
    }
    if (message.versatilityScore !== 0) {
      writer.uint32(157).float(message.versatilityScore);
    }
    if (message.meanNetworth !== 0) {
      writer.uint32(165).float(message.meanNetworth);
    }
    if (message.meanDamage !== 0) {
      writer.uint32(173).float(message.meanDamage);
    }
    if (message.meanHeals !== 0) {
      writer.uint32(181).float(message.meanHeals);
    }
    if (message.rapiersPurchased !== 0) {
      writer.uint32(184).uint32(message.rapiersPurchased);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientPlayerStatsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientPlayerStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag == 21) {
            message.playerStats.push(reader.float());
            continue;
          }

          if (tag == 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.playerStats.push(reader.float());
            }

            continue;
          }

          break;
        case 3:
          if (tag != 24) {
            break;
          }

          message.matchCount = reader.uint32();
          continue;
        case 4:
          if (tag != 37) {
            break;
          }

          message.meanGpm = reader.float();
          continue;
        case 5:
          if (tag != 45) {
            break;
          }

          message.meanXppm = reader.float();
          continue;
        case 6:
          if (tag != 53) {
            break;
          }

          message.meanLasthits = reader.float();
          continue;
        case 7:
          if (tag != 56) {
            break;
          }

          message.rampages = reader.uint32();
          continue;
        case 8:
          if (tag != 64) {
            break;
          }

          message.tripleKills = reader.uint32();
          continue;
        case 9:
          if (tag != 72) {
            break;
          }

          message.firstBloodClaimed = reader.uint32();
          continue;
        case 10:
          if (tag != 80) {
            break;
          }

          message.firstBloodGiven = reader.uint32();
          continue;
        case 11:
          if (tag != 88) {
            break;
          }

          message.couriersKilled = reader.uint32();
          continue;
        case 12:
          if (tag != 96) {
            break;
          }

          message.aegisesSnatched = reader.uint32();
          continue;
        case 13:
          if (tag != 104) {
            break;
          }

          message.cheesesEaten = reader.uint32();
          continue;
        case 14:
          if (tag != 112) {
            break;
          }

          message.creepsStacked = reader.uint32();
          continue;
        case 15:
          if (tag != 125) {
            break;
          }

          message.fightScore = reader.float();
          continue;
        case 16:
          if (tag != 133) {
            break;
          }

          message.farmScore = reader.float();
          continue;
        case 17:
          if (tag != 141) {
            break;
          }

          message.supportScore = reader.float();
          continue;
        case 18:
          if (tag != 149) {
            break;
          }

          message.pushScore = reader.float();
          continue;
        case 19:
          if (tag != 157) {
            break;
          }

          message.versatilityScore = reader.float();
          continue;
        case 20:
          if (tag != 165) {
            break;
          }

          message.meanNetworth = reader.float();
          continue;
        case 21:
          if (tag != 173) {
            break;
          }

          message.meanDamage = reader.float();
          continue;
        case 22:
          if (tag != 181) {
            break;
          }

          message.meanHeals = reader.float();
          continue;
        case 23:
          if (tag != 184) {
            break;
          }

          message.rapiersPurchased = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientPlayerStatsResponse {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      playerStats: Array.isArray(object?.playerStats) ? object.playerStats.map((e: any) => Number(e)) : [],
      matchCount: isSet(object.matchCount) ? Number(object.matchCount) : 0,
      meanGpm: isSet(object.meanGpm) ? Number(object.meanGpm) : 0,
      meanXppm: isSet(object.meanXppm) ? Number(object.meanXppm) : 0,
      meanLasthits: isSet(object.meanLasthits) ? Number(object.meanLasthits) : 0,
      rampages: isSet(object.rampages) ? Number(object.rampages) : 0,
      tripleKills: isSet(object.tripleKills) ? Number(object.tripleKills) : 0,
      firstBloodClaimed: isSet(object.firstBloodClaimed) ? Number(object.firstBloodClaimed) : 0,
      firstBloodGiven: isSet(object.firstBloodGiven) ? Number(object.firstBloodGiven) : 0,
      couriersKilled: isSet(object.couriersKilled) ? Number(object.couriersKilled) : 0,
      aegisesSnatched: isSet(object.aegisesSnatched) ? Number(object.aegisesSnatched) : 0,
      cheesesEaten: isSet(object.cheesesEaten) ? Number(object.cheesesEaten) : 0,
      creepsStacked: isSet(object.creepsStacked) ? Number(object.creepsStacked) : 0,
      fightScore: isSet(object.fightScore) ? Number(object.fightScore) : 0,
      farmScore: isSet(object.farmScore) ? Number(object.farmScore) : 0,
      supportScore: isSet(object.supportScore) ? Number(object.supportScore) : 0,
      pushScore: isSet(object.pushScore) ? Number(object.pushScore) : 0,
      versatilityScore: isSet(object.versatilityScore) ? Number(object.versatilityScore) : 0,
      meanNetworth: isSet(object.meanNetworth) ? Number(object.meanNetworth) : 0,
      meanDamage: isSet(object.meanDamage) ? Number(object.meanDamage) : 0,
      meanHeals: isSet(object.meanHeals) ? Number(object.meanHeals) : 0,
      rapiersPurchased: isSet(object.rapiersPurchased) ? Number(object.rapiersPurchased) : 0,
    };
  },

  toJSON(message: CMsgGCToClientPlayerStatsResponse): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    if (message.playerStats) {
      obj.playerStats = message.playerStats.map((e) => e);
    } else {
      obj.playerStats = [];
    }
    message.matchCount !== undefined && (obj.matchCount = Math.round(message.matchCount));
    message.meanGpm !== undefined && (obj.meanGpm = message.meanGpm);
    message.meanXppm !== undefined && (obj.meanXppm = message.meanXppm);
    message.meanLasthits !== undefined && (obj.meanLasthits = message.meanLasthits);
    message.rampages !== undefined && (obj.rampages = Math.round(message.rampages));
    message.tripleKills !== undefined && (obj.tripleKills = Math.round(message.tripleKills));
    message.firstBloodClaimed !== undefined && (obj.firstBloodClaimed = Math.round(message.firstBloodClaimed));
    message.firstBloodGiven !== undefined && (obj.firstBloodGiven = Math.round(message.firstBloodGiven));
    message.couriersKilled !== undefined && (obj.couriersKilled = Math.round(message.couriersKilled));
    message.aegisesSnatched !== undefined && (obj.aegisesSnatched = Math.round(message.aegisesSnatched));
    message.cheesesEaten !== undefined && (obj.cheesesEaten = Math.round(message.cheesesEaten));
    message.creepsStacked !== undefined && (obj.creepsStacked = Math.round(message.creepsStacked));
    message.fightScore !== undefined && (obj.fightScore = message.fightScore);
    message.farmScore !== undefined && (obj.farmScore = message.farmScore);
    message.supportScore !== undefined && (obj.supportScore = message.supportScore);
    message.pushScore !== undefined && (obj.pushScore = message.pushScore);
    message.versatilityScore !== undefined && (obj.versatilityScore = message.versatilityScore);
    message.meanNetworth !== undefined && (obj.meanNetworth = message.meanNetworth);
    message.meanDamage !== undefined && (obj.meanDamage = message.meanDamage);
    message.meanHeals !== undefined && (obj.meanHeals = message.meanHeals);
    message.rapiersPurchased !== undefined && (obj.rapiersPurchased = Math.round(message.rapiersPurchased));
    return obj;
  },
};

function createBaseCMsgClientToGCCustomGamesFriendsPlayedRequest(): CMsgClientToGCCustomGamesFriendsPlayedRequest {
  return {};
}

export const CMsgClientToGCCustomGamesFriendsPlayedRequest = {
  encode(_: CMsgClientToGCCustomGamesFriendsPlayedRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCCustomGamesFriendsPlayedRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCustomGamesFriendsPlayedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientToGCCustomGamesFriendsPlayedRequest {
    return {};
  },

  toJSON(_: CMsgClientToGCCustomGamesFriendsPlayedRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgGCToClientCustomGamesFriendsPlayedResponse(): CMsgGCToClientCustomGamesFriendsPlayedResponse {
  return { accountId: 0, games: [] };
}

export const CMsgGCToClientCustomGamesFriendsPlayedResponse = {
  encode(
    message: CMsgGCToClientCustomGamesFriendsPlayedResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    for (const v of message.games) {
      CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientCustomGamesFriendsPlayedResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientCustomGamesFriendsPlayedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.games.push(CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientCustomGamesFriendsPlayedResponse {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      games: Array.isArray(object?.games)
        ? object.games.map((e: any) => CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCToClientCustomGamesFriendsPlayedResponse): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    if (message.games) {
      obj.games = message.games.map((e) =>
        e ? CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame.toJSON(e) : undefined
      );
    } else {
      obj.games = [];
    }
    return obj;
  },
};

function createBaseCMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame(): CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame {
  return { customGameId: "0", accountIds: [] };
}

export const CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame = {
  encode(
    message: CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.customGameId !== "0") {
      writer.uint32(8).uint64(message.customGameId);
    }
    writer.uint32(18).fork();
    for (const v of message.accountIds) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.customGameId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag == 16) {
            message.accountIds.push(reader.uint32());
            continue;
          }

          if (tag == 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.accountIds.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame {
    return {
      customGameId: isSet(object.customGameId) ? String(object.customGameId) : "0",
      accountIds: Array.isArray(object?.accountIds) ? object.accountIds.map((e: any) => Number(e)) : [],
    };
  },

  toJSON(message: CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame): unknown {
    const obj: any = {};
    message.customGameId !== undefined && (obj.customGameId = message.customGameId);
    if (message.accountIds) {
      obj.accountIds = message.accountIds.map((e) => Math.round(e));
    } else {
      obj.accountIds = [];
    }
    return obj;
  },
};

function createBaseCMsgClientToGCSocialFeedPostCommentRequest(): CMsgClientToGCSocialFeedPostCommentRequest {
  return { eventId: "0", comment: "" };
}

export const CMsgClientToGCSocialFeedPostCommentRequest = {
  encode(message: CMsgClientToGCSocialFeedPostCommentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "0") {
      writer.uint32(8).uint64(message.eventId);
    }
    if (message.comment !== "") {
      writer.uint32(18).string(message.comment);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSocialFeedPostCommentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSocialFeedPostCommentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.comment = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSocialFeedPostCommentRequest {
    return {
      eventId: isSet(object.eventId) ? String(object.eventId) : "0",
      comment: isSet(object.comment) ? String(object.comment) : "",
    };
  },

  toJSON(message: CMsgClientToGCSocialFeedPostCommentRequest): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = message.eventId);
    message.comment !== undefined && (obj.comment = message.comment);
    return obj;
  },
};

function createBaseCMsgGCToClientSocialFeedPostCommentResponse(): CMsgGCToClientSocialFeedPostCommentResponse {
  return { success: false };
}

export const CMsgGCToClientSocialFeedPostCommentResponse = {
  encode(message: CMsgGCToClientSocialFeedPostCommentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success === true) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientSocialFeedPostCommentResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientSocialFeedPostCommentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientSocialFeedPostCommentResponse {
    return { success: isSet(object.success) ? Boolean(object.success) : false };
  },

  toJSON(message: CMsgGCToClientSocialFeedPostCommentResponse): unknown {
    const obj: any = {};
    message.success !== undefined && (obj.success = message.success);
    return obj;
  },
};

function createBaseCMsgClientToGCSocialFeedPostMessageRequest(): CMsgClientToGCSocialFeedPostMessageRequest {
  return { message: "", matchId: "0", matchTimestamp: 0 };
}

export const CMsgClientToGCSocialFeedPostMessageRequest = {
  encode(message: CMsgClientToGCSocialFeedPostMessageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.matchId !== "0") {
      writer.uint32(16).uint64(message.matchId);
    }
    if (message.matchTimestamp !== 0) {
      writer.uint32(24).uint32(message.matchTimestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSocialFeedPostMessageRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSocialFeedPostMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.message = reader.string();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.matchTimestamp = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSocialFeedPostMessageRequest {
    return {
      message: isSet(object.message) ? String(object.message) : "",
      matchId: isSet(object.matchId) ? String(object.matchId) : "0",
      matchTimestamp: isSet(object.matchTimestamp) ? Number(object.matchTimestamp) : 0,
    };
  },

  toJSON(message: CMsgClientToGCSocialFeedPostMessageRequest): unknown {
    const obj: any = {};
    message.message !== undefined && (obj.message = message.message);
    message.matchId !== undefined && (obj.matchId = message.matchId);
    message.matchTimestamp !== undefined && (obj.matchTimestamp = Math.round(message.matchTimestamp));
    return obj;
  },
};

function createBaseCMsgGCToClientSocialFeedPostMessageResponse(): CMsgGCToClientSocialFeedPostMessageResponse {
  return { success: false };
}

export const CMsgGCToClientSocialFeedPostMessageResponse = {
  encode(message: CMsgGCToClientSocialFeedPostMessageResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success === true) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientSocialFeedPostMessageResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientSocialFeedPostMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientSocialFeedPostMessageResponse {
    return { success: isSet(object.success) ? Boolean(object.success) : false };
  },

  toJSON(message: CMsgGCToClientSocialFeedPostMessageResponse): unknown {
    const obj: any = {};
    message.success !== undefined && (obj.success = message.success);
    return obj;
  },
};

function createBaseCMsgClientToGCFriendsPlayedCustomGameRequest(): CMsgClientToGCFriendsPlayedCustomGameRequest {
  return { customGameId: "0" };
}

export const CMsgClientToGCFriendsPlayedCustomGameRequest = {
  encode(message: CMsgClientToGCFriendsPlayedCustomGameRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.customGameId !== "0") {
      writer.uint32(8).uint64(message.customGameId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCFriendsPlayedCustomGameRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCFriendsPlayedCustomGameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.customGameId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCFriendsPlayedCustomGameRequest {
    return { customGameId: isSet(object.customGameId) ? String(object.customGameId) : "0" };
  },

  toJSON(message: CMsgClientToGCFriendsPlayedCustomGameRequest): unknown {
    const obj: any = {};
    message.customGameId !== undefined && (obj.customGameId = message.customGameId);
    return obj;
  },
};

function createBaseCMsgGCToClientFriendsPlayedCustomGameResponse(): CMsgGCToClientFriendsPlayedCustomGameResponse {
  return { customGameId: "0", accountIds: [] };
}

export const CMsgGCToClientFriendsPlayedCustomGameResponse = {
  encode(message: CMsgGCToClientFriendsPlayedCustomGameResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.customGameId !== "0") {
      writer.uint32(8).uint64(message.customGameId);
    }
    writer.uint32(18).fork();
    for (const v of message.accountIds) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientFriendsPlayedCustomGameResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientFriendsPlayedCustomGameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.customGameId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag == 16) {
            message.accountIds.push(reader.uint32());
            continue;
          }

          if (tag == 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.accountIds.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientFriendsPlayedCustomGameResponse {
    return {
      customGameId: isSet(object.customGameId) ? String(object.customGameId) : "0",
      accountIds: Array.isArray(object?.accountIds) ? object.accountIds.map((e: any) => Number(e)) : [],
    };
  },

  toJSON(message: CMsgGCToClientFriendsPlayedCustomGameResponse): unknown {
    const obj: any = {};
    message.customGameId !== undefined && (obj.customGameId = message.customGameId);
    if (message.accountIds) {
      obj.accountIds = message.accountIds.map((e) => Math.round(e));
    } else {
      obj.accountIds = [];
    }
    return obj;
  },
};

function createBaseCMsgDOTAPartyRichPresence(): CMsgDOTAPartyRichPresence {
  return {
    partyId: "0",
    partyState: 0,
    open: false,
    lowPriority: false,
    teamId: 0,
    teamName: "",
    ugcTeamUiLogo: "0",
    members: [],
    weekendTourney: undefined,
  };
}

export const CMsgDOTAPartyRichPresence = {
  encode(message: CMsgDOTAPartyRichPresence, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.partyId !== "0") {
      writer.uint32(9).fixed64(message.partyId);
    }
    if (message.partyState !== 0) {
      writer.uint32(16).int32(message.partyState);
    }
    if (message.open === true) {
      writer.uint32(24).bool(message.open);
    }
    if (message.lowPriority === true) {
      writer.uint32(40).bool(message.lowPriority);
    }
    if (message.teamId !== 0) {
      writer.uint32(56).uint32(message.teamId);
    }
    if (message.teamName !== "") {
      writer.uint32(66).string(message.teamName);
    }
    if (message.ugcTeamUiLogo !== "0") {
      writer.uint32(72).uint64(message.ugcTeamUiLogo);
    }
    for (const v of message.members) {
      CMsgDOTAPartyRichPresence_Member.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.weekendTourney !== undefined) {
      CMsgDOTAPartyRichPresence_WeekendTourney.encode(message.weekendTourney, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAPartyRichPresence {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAPartyRichPresence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 9) {
            break;
          }

          message.partyId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.partyState = reader.int32() as any;
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.open = reader.bool();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.lowPriority = reader.bool();
          continue;
        case 7:
          if (tag != 56) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 8:
          if (tag != 66) {
            break;
          }

          message.teamName = reader.string();
          continue;
        case 9:
          if (tag != 72) {
            break;
          }

          message.ugcTeamUiLogo = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.members.push(CMsgDOTAPartyRichPresence_Member.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag != 50) {
            break;
          }

          message.weekendTourney = CMsgDOTAPartyRichPresence_WeekendTourney.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAPartyRichPresence {
    return {
      partyId: isSet(object.partyId) ? String(object.partyId) : "0",
      partyState: isSet(object.partyState) ? cSODOTAParty_StateFromJSON(object.partyState) : 0,
      open: isSet(object.open) ? Boolean(object.open) : false,
      lowPriority: isSet(object.lowPriority) ? Boolean(object.lowPriority) : false,
      teamId: isSet(object.teamId) ? Number(object.teamId) : 0,
      teamName: isSet(object.teamName) ? String(object.teamName) : "",
      ugcTeamUiLogo: isSet(object.ugcTeamUiLogo) ? String(object.ugcTeamUiLogo) : "0",
      members: Array.isArray(object?.members)
        ? object.members.map((e: any) => CMsgDOTAPartyRichPresence_Member.fromJSON(e))
        : [],
      weekendTourney: isSet(object.weekendTourney)
        ? CMsgDOTAPartyRichPresence_WeekendTourney.fromJSON(object.weekendTourney)
        : undefined,
    };
  },

  toJSON(message: CMsgDOTAPartyRichPresence): unknown {
    const obj: any = {};
    message.partyId !== undefined && (obj.partyId = message.partyId);
    message.partyState !== undefined && (obj.partyState = cSODOTAParty_StateToJSON(message.partyState));
    message.open !== undefined && (obj.open = message.open);
    message.lowPriority !== undefined && (obj.lowPriority = message.lowPriority);
    message.teamId !== undefined && (obj.teamId = Math.round(message.teamId));
    message.teamName !== undefined && (obj.teamName = message.teamName);
    message.ugcTeamUiLogo !== undefined && (obj.ugcTeamUiLogo = message.ugcTeamUiLogo);
    if (message.members) {
      obj.members = message.members.map((e) => e ? CMsgDOTAPartyRichPresence_Member.toJSON(e) : undefined);
    } else {
      obj.members = [];
    }
    message.weekendTourney !== undefined && (obj.weekendTourney = message.weekendTourney
      ? CMsgDOTAPartyRichPresence_WeekendTourney.toJSON(message.weekendTourney)
      : undefined);
    return obj;
  },
};

function createBaseCMsgDOTAPartyRichPresence_Member(): CMsgDOTAPartyRichPresence_Member {
  return { steamId: "0", coach: false };
}

export const CMsgDOTAPartyRichPresence_Member = {
  encode(message: CMsgDOTAPartyRichPresence_Member, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamId !== "0") {
      writer.uint32(9).fixed64(message.steamId);
    }
    if (message.coach === true) {
      writer.uint32(16).bool(message.coach);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAPartyRichPresence_Member {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAPartyRichPresence_Member();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 9) {
            break;
          }

          message.steamId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.coach = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAPartyRichPresence_Member {
    return {
      steamId: isSet(object.steamId) ? String(object.steamId) : "0",
      coach: isSet(object.coach) ? Boolean(object.coach) : false,
    };
  },

  toJSON(message: CMsgDOTAPartyRichPresence_Member): unknown {
    const obj: any = {};
    message.steamId !== undefined && (obj.steamId = message.steamId);
    message.coach !== undefined && (obj.coach = message.coach);
    return obj;
  },
};

function createBaseCMsgDOTAPartyRichPresence_WeekendTourney(): CMsgDOTAPartyRichPresence_WeekendTourney {
  return { division: 0, skillLevel: 0, round: 0, tournamentId: 0, stateSeqNum: 0, event: 0, eventRound: 0 };
}

export const CMsgDOTAPartyRichPresence_WeekendTourney = {
  encode(message: CMsgDOTAPartyRichPresence_WeekendTourney, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.division !== 0) {
      writer.uint32(8).uint32(message.division);
    }
    if (message.skillLevel !== 0) {
      writer.uint32(16).uint32(message.skillLevel);
    }
    if (message.round !== 0) {
      writer.uint32(24).uint32(message.round);
    }
    if (message.tournamentId !== 0) {
      writer.uint32(32).uint32(message.tournamentId);
    }
    if (message.stateSeqNum !== 0) {
      writer.uint32(40).uint32(message.stateSeqNum);
    }
    if (message.event !== 0) {
      writer.uint32(48).int32(message.event);
    }
    if (message.eventRound !== 0) {
      writer.uint32(56).uint32(message.eventRound);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAPartyRichPresence_WeekendTourney {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAPartyRichPresence_WeekendTourney();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.division = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.skillLevel = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.round = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.tournamentId = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.stateSeqNum = reader.uint32();
          continue;
        case 6:
          if (tag != 48) {
            break;
          }

          message.event = reader.int32() as any;
          continue;
        case 7:
          if (tag != 56) {
            break;
          }

          message.eventRound = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAPartyRichPresence_WeekendTourney {
    return {
      division: isSet(object.division) ? Number(object.division) : 0,
      skillLevel: isSet(object.skillLevel) ? Number(object.skillLevel) : 0,
      round: isSet(object.round) ? Number(object.round) : 0,
      tournamentId: isSet(object.tournamentId) ? Number(object.tournamentId) : 0,
      stateSeqNum: isSet(object.stateSeqNum) ? Number(object.stateSeqNum) : 0,
      event: isSet(object.event) ? eWeekendTourneyRichPresenceEventFromJSON(object.event) : 0,
      eventRound: isSet(object.eventRound) ? Number(object.eventRound) : 0,
    };
  },

  toJSON(message: CMsgDOTAPartyRichPresence_WeekendTourney): unknown {
    const obj: any = {};
    message.division !== undefined && (obj.division = Math.round(message.division));
    message.skillLevel !== undefined && (obj.skillLevel = Math.round(message.skillLevel));
    message.round !== undefined && (obj.round = Math.round(message.round));
    message.tournamentId !== undefined && (obj.tournamentId = Math.round(message.tournamentId));
    message.stateSeqNum !== undefined && (obj.stateSeqNum = Math.round(message.stateSeqNum));
    message.event !== undefined && (obj.event = eWeekendTourneyRichPresenceEventToJSON(message.event));
    message.eventRound !== undefined && (obj.eventRound = Math.round(message.eventRound));
    return obj;
  },
};

function createBaseCMsgDOTALobbyRichPresence(): CMsgDOTALobbyRichPresence {
  return {
    lobbyId: "0",
    lobbyState: 0,
    password: false,
    gameMode: 0,
    memberCount: 0,
    maxMemberCount: 0,
    customGameId: "0",
    name: "",
    lobbyType: 0,
  };
}

export const CMsgDOTALobbyRichPresence = {
  encode(message: CMsgDOTALobbyRichPresence, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lobbyId !== "0") {
      writer.uint32(9).fixed64(message.lobbyId);
    }
    if (message.lobbyState !== 0) {
      writer.uint32(16).int32(message.lobbyState);
    }
    if (message.password === true) {
      writer.uint32(24).bool(message.password);
    }
    if (message.gameMode !== 0) {
      writer.uint32(32).int32(message.gameMode);
    }
    if (message.memberCount !== 0) {
      writer.uint32(40).uint32(message.memberCount);
    }
    if (message.maxMemberCount !== 0) {
      writer.uint32(48).uint32(message.maxMemberCount);
    }
    if (message.customGameId !== "0") {
      writer.uint32(57).fixed64(message.customGameId);
    }
    if (message.name !== "") {
      writer.uint32(66).string(message.name);
    }
    if (message.lobbyType !== 0) {
      writer.uint32(72).uint32(message.lobbyType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALobbyRichPresence {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALobbyRichPresence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 9) {
            break;
          }

          message.lobbyId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.lobbyState = reader.int32() as any;
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.password = reader.bool();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.gameMode = reader.int32() as any;
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.memberCount = reader.uint32();
          continue;
        case 6:
          if (tag != 48) {
            break;
          }

          message.maxMemberCount = reader.uint32();
          continue;
        case 7:
          if (tag != 57) {
            break;
          }

          message.customGameId = longToString(reader.fixed64() as Long);
          continue;
        case 8:
          if (tag != 66) {
            break;
          }

          message.name = reader.string();
          continue;
        case 9:
          if (tag != 72) {
            break;
          }

          message.lobbyType = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALobbyRichPresence {
    return {
      lobbyId: isSet(object.lobbyId) ? String(object.lobbyId) : "0",
      lobbyState: isSet(object.lobbyState) ? cSODOTALobby_StateFromJSON(object.lobbyState) : 0,
      password: isSet(object.password) ? Boolean(object.password) : false,
      gameMode: isSet(object.gameMode) ? dOTAGameModeFromJSON(object.gameMode) : 0,
      memberCount: isSet(object.memberCount) ? Number(object.memberCount) : 0,
      maxMemberCount: isSet(object.maxMemberCount) ? Number(object.maxMemberCount) : 0,
      customGameId: isSet(object.customGameId) ? String(object.customGameId) : "0",
      name: isSet(object.name) ? String(object.name) : "",
      lobbyType: isSet(object.lobbyType) ? Number(object.lobbyType) : 0,
    };
  },

  toJSON(message: CMsgDOTALobbyRichPresence): unknown {
    const obj: any = {};
    message.lobbyId !== undefined && (obj.lobbyId = message.lobbyId);
    message.lobbyState !== undefined && (obj.lobbyState = cSODOTALobby_StateToJSON(message.lobbyState));
    message.password !== undefined && (obj.password = message.password);
    message.gameMode !== undefined && (obj.gameMode = dOTAGameModeToJSON(message.gameMode));
    message.memberCount !== undefined && (obj.memberCount = Math.round(message.memberCount));
    message.maxMemberCount !== undefined && (obj.maxMemberCount = Math.round(message.maxMemberCount));
    message.customGameId !== undefined && (obj.customGameId = message.customGameId);
    message.name !== undefined && (obj.name = message.name);
    message.lobbyType !== undefined && (obj.lobbyType = Math.round(message.lobbyType));
    return obj;
  },
};

function createBaseCMsgDOTACustomGameListenServerStartedLoading(): CMsgDOTACustomGameListenServerStartedLoading {
  return { lobbyId: "0", customGameId: "0", lobbyMembers: [], startTime: 0 };
}

export const CMsgDOTACustomGameListenServerStartedLoading = {
  encode(message: CMsgDOTACustomGameListenServerStartedLoading, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lobbyId !== "0") {
      writer.uint32(9).fixed64(message.lobbyId);
    }
    if (message.customGameId !== "0") {
      writer.uint32(16).uint64(message.customGameId);
    }
    writer.uint32(26).fork();
    for (const v of message.lobbyMembers) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.startTime !== 0) {
      writer.uint32(32).uint32(message.startTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTACustomGameListenServerStartedLoading {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTACustomGameListenServerStartedLoading();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 9) {
            break;
          }

          message.lobbyId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.customGameId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag == 24) {
            message.lobbyMembers.push(reader.uint32());
            continue;
          }

          if (tag == 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.lobbyMembers.push(reader.uint32());
            }

            continue;
          }

          break;
        case 4:
          if (tag != 32) {
            break;
          }

          message.startTime = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTACustomGameListenServerStartedLoading {
    return {
      lobbyId: isSet(object.lobbyId) ? String(object.lobbyId) : "0",
      customGameId: isSet(object.customGameId) ? String(object.customGameId) : "0",
      lobbyMembers: Array.isArray(object?.lobbyMembers) ? object.lobbyMembers.map((e: any) => Number(e)) : [],
      startTime: isSet(object.startTime) ? Number(object.startTime) : 0,
    };
  },

  toJSON(message: CMsgDOTACustomGameListenServerStartedLoading): unknown {
    const obj: any = {};
    message.lobbyId !== undefined && (obj.lobbyId = message.lobbyId);
    message.customGameId !== undefined && (obj.customGameId = message.customGameId);
    if (message.lobbyMembers) {
      obj.lobbyMembers = message.lobbyMembers.map((e) => Math.round(e));
    } else {
      obj.lobbyMembers = [];
    }
    message.startTime !== undefined && (obj.startTime = Math.round(message.startTime));
    return obj;
  },
};

function createBaseCMsgDOTACustomGameClientFinishedLoading(): CMsgDOTACustomGameClientFinishedLoading {
  return { lobbyId: "0", loadingDuration: 0, resultCode: 0, resultString: "", signonStates: 0, comment: "" };
}

export const CMsgDOTACustomGameClientFinishedLoading = {
  encode(message: CMsgDOTACustomGameClientFinishedLoading, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lobbyId !== "0") {
      writer.uint32(9).fixed64(message.lobbyId);
    }
    if (message.loadingDuration !== 0) {
      writer.uint32(16).uint32(message.loadingDuration);
    }
    if (message.resultCode !== 0) {
      writer.uint32(24).sint32(message.resultCode);
    }
    if (message.resultString !== "") {
      writer.uint32(34).string(message.resultString);
    }
    if (message.signonStates !== 0) {
      writer.uint32(40).uint32(message.signonStates);
    }
    if (message.comment !== "") {
      writer.uint32(50).string(message.comment);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTACustomGameClientFinishedLoading {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTACustomGameClientFinishedLoading();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 9) {
            break;
          }

          message.lobbyId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.loadingDuration = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.resultCode = reader.sint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.resultString = reader.string();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.signonStates = reader.uint32();
          continue;
        case 6:
          if (tag != 50) {
            break;
          }

          message.comment = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTACustomGameClientFinishedLoading {
    return {
      lobbyId: isSet(object.lobbyId) ? String(object.lobbyId) : "0",
      loadingDuration: isSet(object.loadingDuration) ? Number(object.loadingDuration) : 0,
      resultCode: isSet(object.resultCode) ? Number(object.resultCode) : 0,
      resultString: isSet(object.resultString) ? String(object.resultString) : "",
      signonStates: isSet(object.signonStates) ? Number(object.signonStates) : 0,
      comment: isSet(object.comment) ? String(object.comment) : "",
    };
  },

  toJSON(message: CMsgDOTACustomGameClientFinishedLoading): unknown {
    const obj: any = {};
    message.lobbyId !== undefined && (obj.lobbyId = message.lobbyId);
    message.loadingDuration !== undefined && (obj.loadingDuration = Math.round(message.loadingDuration));
    message.resultCode !== undefined && (obj.resultCode = Math.round(message.resultCode));
    message.resultString !== undefined && (obj.resultString = message.resultString);
    message.signonStates !== undefined && (obj.signonStates = Math.round(message.signonStates));
    message.comment !== undefined && (obj.comment = message.comment);
    return obj;
  },
};

function createBaseCMsgClientToGCApplyGemCombiner(): CMsgClientToGCApplyGemCombiner {
  return { itemId1: "0", itemId2: "0" };
}

export const CMsgClientToGCApplyGemCombiner = {
  encode(message: CMsgClientToGCApplyGemCombiner, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemId1 !== "0") {
      writer.uint32(8).uint64(message.itemId1);
    }
    if (message.itemId2 !== "0") {
      writer.uint32(16).uint64(message.itemId2);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCApplyGemCombiner {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCApplyGemCombiner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.itemId1 = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.itemId2 = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCApplyGemCombiner {
    return {
      itemId1: isSet(object.itemId1) ? String(object.itemId1) : "0",
      itemId2: isSet(object.itemId2) ? String(object.itemId2) : "0",
    };
  },

  toJSON(message: CMsgClientToGCApplyGemCombiner): unknown {
    const obj: any = {};
    message.itemId1 !== undefined && (obj.itemId1 = message.itemId1);
    message.itemId2 !== undefined && (obj.itemId2 = message.itemId2);
    return obj;
  },
};

function createBaseCMsgClientToGCH264Unsupported(): CMsgClientToGCH264Unsupported {
  return {};
}

export const CMsgClientToGCH264Unsupported = {
  encode(_: CMsgClientToGCH264Unsupported, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCH264Unsupported {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCH264Unsupported();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientToGCH264Unsupported {
    return {};
  },

  toJSON(_: CMsgClientToGCH264Unsupported): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgClientToGCGetQuestProgress(): CMsgClientToGCGetQuestProgress {
  return { questIds: [] };
}

export const CMsgClientToGCGetQuestProgress = {
  encode(message: CMsgClientToGCGetQuestProgress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.questIds) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetQuestProgress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetQuestProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag == 8) {
            message.questIds.push(reader.uint32());
            continue;
          }

          if (tag == 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.questIds.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetQuestProgress {
    return { questIds: Array.isArray(object?.questIds) ? object.questIds.map((e: any) => Number(e)) : [] };
  },

  toJSON(message: CMsgClientToGCGetQuestProgress): unknown {
    const obj: any = {};
    if (message.questIds) {
      obj.questIds = message.questIds.map((e) => Math.round(e));
    } else {
      obj.questIds = [];
    }
    return obj;
  },
};

function createBaseCMsgClientToGCGetQuestProgressResponse(): CMsgClientToGCGetQuestProgressResponse {
  return { success: false, quests: [] };
}

export const CMsgClientToGCGetQuestProgressResponse = {
  encode(message: CMsgClientToGCGetQuestProgressResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success === true) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.quests) {
      CMsgClientToGCGetQuestProgressResponse_Quest.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetQuestProgressResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetQuestProgressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.quests.push(CMsgClientToGCGetQuestProgressResponse_Quest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetQuestProgressResponse {
    return {
      success: isSet(object.success) ? Boolean(object.success) : false,
      quests: Array.isArray(object?.quests)
        ? object.quests.map((e: any) => CMsgClientToGCGetQuestProgressResponse_Quest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientToGCGetQuestProgressResponse): unknown {
    const obj: any = {};
    message.success !== undefined && (obj.success = message.success);
    if (message.quests) {
      obj.quests = message.quests.map((e) => e ? CMsgClientToGCGetQuestProgressResponse_Quest.toJSON(e) : undefined);
    } else {
      obj.quests = [];
    }
    return obj;
  },
};

function createBaseCMsgClientToGCGetQuestProgressResponse_Challenge(): CMsgClientToGCGetQuestProgressResponse_Challenge {
  return { challengeId: 0, timeCompleted: 0, attempts: 0, heroId: 0, templateId: 0, questRank: 0 };
}

export const CMsgClientToGCGetQuestProgressResponse_Challenge = {
  encode(
    message: CMsgClientToGCGetQuestProgressResponse_Challenge,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.challengeId !== 0) {
      writer.uint32(8).uint32(message.challengeId);
    }
    if (message.timeCompleted !== 0) {
      writer.uint32(16).uint32(message.timeCompleted);
    }
    if (message.attempts !== 0) {
      writer.uint32(24).uint32(message.attempts);
    }
    if (message.heroId !== 0) {
      writer.uint32(32).uint32(message.heroId);
    }
    if (message.templateId !== 0) {
      writer.uint32(40).uint32(message.templateId);
    }
    if (message.questRank !== 0) {
      writer.uint32(48).uint32(message.questRank);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetQuestProgressResponse_Challenge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetQuestProgressResponse_Challenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.challengeId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.timeCompleted = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.attempts = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.templateId = reader.uint32();
          continue;
        case 6:
          if (tag != 48) {
            break;
          }

          message.questRank = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetQuestProgressResponse_Challenge {
    return {
      challengeId: isSet(object.challengeId) ? Number(object.challengeId) : 0,
      timeCompleted: isSet(object.timeCompleted) ? Number(object.timeCompleted) : 0,
      attempts: isSet(object.attempts) ? Number(object.attempts) : 0,
      heroId: isSet(object.heroId) ? Number(object.heroId) : 0,
      templateId: isSet(object.templateId) ? Number(object.templateId) : 0,
      questRank: isSet(object.questRank) ? Number(object.questRank) : 0,
    };
  },

  toJSON(message: CMsgClientToGCGetQuestProgressResponse_Challenge): unknown {
    const obj: any = {};
    message.challengeId !== undefined && (obj.challengeId = Math.round(message.challengeId));
    message.timeCompleted !== undefined && (obj.timeCompleted = Math.round(message.timeCompleted));
    message.attempts !== undefined && (obj.attempts = Math.round(message.attempts));
    message.heroId !== undefined && (obj.heroId = Math.round(message.heroId));
    message.templateId !== undefined && (obj.templateId = Math.round(message.templateId));
    message.questRank !== undefined && (obj.questRank = Math.round(message.questRank));
    return obj;
  },
};

function createBaseCMsgClientToGCGetQuestProgressResponse_Quest(): CMsgClientToGCGetQuestProgressResponse_Quest {
  return { questId: 0, completedChallenges: [] };
}

export const CMsgClientToGCGetQuestProgressResponse_Quest = {
  encode(message: CMsgClientToGCGetQuestProgressResponse_Quest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.questId !== 0) {
      writer.uint32(8).uint32(message.questId);
    }
    for (const v of message.completedChallenges) {
      CMsgClientToGCGetQuestProgressResponse_Challenge.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetQuestProgressResponse_Quest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetQuestProgressResponse_Quest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.questId = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.completedChallenges.push(
            CMsgClientToGCGetQuestProgressResponse_Challenge.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetQuestProgressResponse_Quest {
    return {
      questId: isSet(object.questId) ? Number(object.questId) : 0,
      completedChallenges: Array.isArray(object?.completedChallenges)
        ? object.completedChallenges.map((e: any) => CMsgClientToGCGetQuestProgressResponse_Challenge.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientToGCGetQuestProgressResponse_Quest): unknown {
    const obj: any = {};
    message.questId !== undefined && (obj.questId = Math.round(message.questId));
    if (message.completedChallenges) {
      obj.completedChallenges = message.completedChallenges.map((e) =>
        e ? CMsgClientToGCGetQuestProgressResponse_Challenge.toJSON(e) : undefined
      );
    } else {
      obj.completedChallenges = [];
    }
    return obj;
  },
};

function createBaseCMsgGCToClientMatchSignedOut(): CMsgGCToClientMatchSignedOut {
  return { matchId: "0" };
}

export const CMsgGCToClientMatchSignedOut = {
  encode(message: CMsgGCToClientMatchSignedOut, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientMatchSignedOut {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientMatchSignedOut();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientMatchSignedOut {
    return { matchId: isSet(object.matchId) ? String(object.matchId) : "0" };
  },

  toJSON(message: CMsgGCToClientMatchSignedOut): unknown {
    const obj: any = {};
    message.matchId !== undefined && (obj.matchId = message.matchId);
    return obj;
  },
};

function createBaseCMsgGCGetHeroStatsHistory(): CMsgGCGetHeroStatsHistory {
  return { heroId: 0 };
}

export const CMsgGCGetHeroStatsHistory = {
  encode(message: CMsgGCGetHeroStatsHistory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroId !== 0) {
      writer.uint32(8).uint32(message.heroId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGetHeroStatsHistory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetHeroStatsHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetHeroStatsHistory {
    return { heroId: isSet(object.heroId) ? Number(object.heroId) : 0 };
  },

  toJSON(message: CMsgGCGetHeroStatsHistory): unknown {
    const obj: any = {};
    message.heroId !== undefined && (obj.heroId = Math.round(message.heroId));
    return obj;
  },
};

function createBaseCMsgGCGetHeroStatsHistoryResponse(): CMsgGCGetHeroStatsHistoryResponse {
  return { heroId: 0, records: [] };
}

export const CMsgGCGetHeroStatsHistoryResponse = {
  encode(message: CMsgGCGetHeroStatsHistoryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroId !== 0) {
      writer.uint32(8).uint32(message.heroId);
    }
    for (const v of message.records) {
      CMsgDOTASDOHeroStatsHistory.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGetHeroStatsHistoryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetHeroStatsHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.records.push(CMsgDOTASDOHeroStatsHistory.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetHeroStatsHistoryResponse {
    return {
      heroId: isSet(object.heroId) ? Number(object.heroId) : 0,
      records: Array.isArray(object?.records)
        ? object.records.map((e: any) => CMsgDOTASDOHeroStatsHistory.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCGetHeroStatsHistoryResponse): unknown {
    const obj: any = {};
    message.heroId !== undefined && (obj.heroId = Math.round(message.heroId));
    if (message.records) {
      obj.records = message.records.map((e) => e ? CMsgDOTASDOHeroStatsHistory.toJSON(e) : undefined);
    } else {
      obj.records = [];
    }
    return obj;
  },
};

function createBaseCMsgPlayerConductScorecardRequest(): CMsgPlayerConductScorecardRequest {
  return {};
}

export const CMsgPlayerConductScorecardRequest = {
  encode(_: CMsgPlayerConductScorecardRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPlayerConductScorecardRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerConductScorecardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgPlayerConductScorecardRequest {
    return {};
  },

  toJSON(_: CMsgPlayerConductScorecardRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgPlayerConductScorecard(): CMsgPlayerConductScorecard {
  return {
    accountId: 0,
    matchId: "0",
    seqNum: 0,
    reasons: 0,
    matchesInReport: 0,
    matchesClean: 0,
    matchesReported: 0,
    matchesAbandoned: 0,
    reportsCount: 0,
    reportsParties: 0,
    commendCount: 0,
    date: 0,
    rawBehaviorScore: 0,
    oldRawBehaviorScore: 0,
    commsReports: 0,
    commsParties: 0,
    behaviorRating: 0,
  };
}

export const CMsgPlayerConductScorecard = {
  encode(message: CMsgPlayerConductScorecard, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.matchId !== "0") {
      writer.uint32(16).uint64(message.matchId);
    }
    if (message.seqNum !== 0) {
      writer.uint32(24).uint32(message.seqNum);
    }
    if (message.reasons !== 0) {
      writer.uint32(32).uint32(message.reasons);
    }
    if (message.matchesInReport !== 0) {
      writer.uint32(40).uint32(message.matchesInReport);
    }
    if (message.matchesClean !== 0) {
      writer.uint32(48).uint32(message.matchesClean);
    }
    if (message.matchesReported !== 0) {
      writer.uint32(56).uint32(message.matchesReported);
    }
    if (message.matchesAbandoned !== 0) {
      writer.uint32(64).uint32(message.matchesAbandoned);
    }
    if (message.reportsCount !== 0) {
      writer.uint32(72).uint32(message.reportsCount);
    }
    if (message.reportsParties !== 0) {
      writer.uint32(80).uint32(message.reportsParties);
    }
    if (message.commendCount !== 0) {
      writer.uint32(88).uint32(message.commendCount);
    }
    if (message.date !== 0) {
      writer.uint32(112).uint32(message.date);
    }
    if (message.rawBehaviorScore !== 0) {
      writer.uint32(136).uint32(message.rawBehaviorScore);
    }
    if (message.oldRawBehaviorScore !== 0) {
      writer.uint32(144).uint32(message.oldRawBehaviorScore);
    }
    if (message.commsReports !== 0) {
      writer.uint32(152).uint32(message.commsReports);
    }
    if (message.commsParties !== 0) {
      writer.uint32(160).uint32(message.commsParties);
    }
    if (message.behaviorRating !== 0) {
      writer.uint32(168).int32(message.behaviorRating);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPlayerConductScorecard {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerConductScorecard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.seqNum = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.reasons = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.matchesInReport = reader.uint32();
          continue;
        case 6:
          if (tag != 48) {
            break;
          }

          message.matchesClean = reader.uint32();
          continue;
        case 7:
          if (tag != 56) {
            break;
          }

          message.matchesReported = reader.uint32();
          continue;
        case 8:
          if (tag != 64) {
            break;
          }

          message.matchesAbandoned = reader.uint32();
          continue;
        case 9:
          if (tag != 72) {
            break;
          }

          message.reportsCount = reader.uint32();
          continue;
        case 10:
          if (tag != 80) {
            break;
          }

          message.reportsParties = reader.uint32();
          continue;
        case 11:
          if (tag != 88) {
            break;
          }

          message.commendCount = reader.uint32();
          continue;
        case 14:
          if (tag != 112) {
            break;
          }

          message.date = reader.uint32();
          continue;
        case 17:
          if (tag != 136) {
            break;
          }

          message.rawBehaviorScore = reader.uint32();
          continue;
        case 18:
          if (tag != 144) {
            break;
          }

          message.oldRawBehaviorScore = reader.uint32();
          continue;
        case 19:
          if (tag != 152) {
            break;
          }

          message.commsReports = reader.uint32();
          continue;
        case 20:
          if (tag != 160) {
            break;
          }

          message.commsParties = reader.uint32();
          continue;
        case 21:
          if (tag != 168) {
            break;
          }

          message.behaviorRating = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPlayerConductScorecard {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      matchId: isSet(object.matchId) ? String(object.matchId) : "0",
      seqNum: isSet(object.seqNum) ? Number(object.seqNum) : 0,
      reasons: isSet(object.reasons) ? Number(object.reasons) : 0,
      matchesInReport: isSet(object.matchesInReport) ? Number(object.matchesInReport) : 0,
      matchesClean: isSet(object.matchesClean) ? Number(object.matchesClean) : 0,
      matchesReported: isSet(object.matchesReported) ? Number(object.matchesReported) : 0,
      matchesAbandoned: isSet(object.matchesAbandoned) ? Number(object.matchesAbandoned) : 0,
      reportsCount: isSet(object.reportsCount) ? Number(object.reportsCount) : 0,
      reportsParties: isSet(object.reportsParties) ? Number(object.reportsParties) : 0,
      commendCount: isSet(object.commendCount) ? Number(object.commendCount) : 0,
      date: isSet(object.date) ? Number(object.date) : 0,
      rawBehaviorScore: isSet(object.rawBehaviorScore) ? Number(object.rawBehaviorScore) : 0,
      oldRawBehaviorScore: isSet(object.oldRawBehaviorScore) ? Number(object.oldRawBehaviorScore) : 0,
      commsReports: isSet(object.commsReports) ? Number(object.commsReports) : 0,
      commsParties: isSet(object.commsParties) ? Number(object.commsParties) : 0,
      behaviorRating: isSet(object.behaviorRating)
        ? cMsgPlayerConductScorecard_EBehaviorRatingFromJSON(object.behaviorRating)
        : 0,
    };
  },

  toJSON(message: CMsgPlayerConductScorecard): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.matchId !== undefined && (obj.matchId = message.matchId);
    message.seqNum !== undefined && (obj.seqNum = Math.round(message.seqNum));
    message.reasons !== undefined && (obj.reasons = Math.round(message.reasons));
    message.matchesInReport !== undefined && (obj.matchesInReport = Math.round(message.matchesInReport));
    message.matchesClean !== undefined && (obj.matchesClean = Math.round(message.matchesClean));
    message.matchesReported !== undefined && (obj.matchesReported = Math.round(message.matchesReported));
    message.matchesAbandoned !== undefined && (obj.matchesAbandoned = Math.round(message.matchesAbandoned));
    message.reportsCount !== undefined && (obj.reportsCount = Math.round(message.reportsCount));
    message.reportsParties !== undefined && (obj.reportsParties = Math.round(message.reportsParties));
    message.commendCount !== undefined && (obj.commendCount = Math.round(message.commendCount));
    message.date !== undefined && (obj.date = Math.round(message.date));
    message.rawBehaviorScore !== undefined && (obj.rawBehaviorScore = Math.round(message.rawBehaviorScore));
    message.oldRawBehaviorScore !== undefined && (obj.oldRawBehaviorScore = Math.round(message.oldRawBehaviorScore));
    message.commsReports !== undefined && (obj.commsReports = Math.round(message.commsReports));
    message.commsParties !== undefined && (obj.commsParties = Math.round(message.commsParties));
    message.behaviorRating !== undefined &&
      (obj.behaviorRating = cMsgPlayerConductScorecard_EBehaviorRatingToJSON(message.behaviorRating));
    return obj;
  },
};

function createBaseCMsgClientToGCWageringRequest(): CMsgClientToGCWageringRequest {
  return { eventId: 0 };
}

export const CMsgClientToGCWageringRequest = {
  encode(message: CMsgClientToGCWageringRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCWageringRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCWageringRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCWageringRequest {
    return { eventId: isSet(object.eventId) ? Number(object.eventId) : 0 };
  },

  toJSON(message: CMsgClientToGCWageringRequest): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    return obj;
  },
};

function createBaseCMsgGCToClientWageringResponse(): CMsgGCToClientWageringResponse {
  return {
    coinsRemaining: 0,
    totalPointsWon: 0,
    totalPointsWagered: 0,
    totalPointsTipped: 0,
    successRate: 0,
    totalGamesWagered: 0,
    coinsMax: 0,
    rankWagersRemaining: 0,
    rankWagersMax: 0,
    predictionTokensRemaining: 0,
    predictionTokensMax: 0,
    bountiesRemaining: 0,
    bountiesMax: 0,
  };
}

export const CMsgGCToClientWageringResponse = {
  encode(message: CMsgGCToClientWageringResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.coinsRemaining !== 0) {
      writer.uint32(8).uint32(message.coinsRemaining);
    }
    if (message.totalPointsWon !== 0) {
      writer.uint32(16).uint32(message.totalPointsWon);
    }
    if (message.totalPointsWagered !== 0) {
      writer.uint32(24).uint32(message.totalPointsWagered);
    }
    if (message.totalPointsTipped !== 0) {
      writer.uint32(32).uint32(message.totalPointsTipped);
    }
    if (message.successRate !== 0) {
      writer.uint32(40).uint32(message.successRate);
    }
    if (message.totalGamesWagered !== 0) {
      writer.uint32(48).uint32(message.totalGamesWagered);
    }
    if (message.coinsMax !== 0) {
      writer.uint32(56).uint32(message.coinsMax);
    }
    if (message.rankWagersRemaining !== 0) {
      writer.uint32(64).uint32(message.rankWagersRemaining);
    }
    if (message.rankWagersMax !== 0) {
      writer.uint32(72).uint32(message.rankWagersMax);
    }
    if (message.predictionTokensRemaining !== 0) {
      writer.uint32(80).uint32(message.predictionTokensRemaining);
    }
    if (message.predictionTokensMax !== 0) {
      writer.uint32(88).uint32(message.predictionTokensMax);
    }
    if (message.bountiesRemaining !== 0) {
      writer.uint32(96).uint32(message.bountiesRemaining);
    }
    if (message.bountiesMax !== 0) {
      writer.uint32(104).uint32(message.bountiesMax);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientWageringResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientWageringResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.coinsRemaining = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.totalPointsWon = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.totalPointsWagered = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.totalPointsTipped = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.successRate = reader.uint32();
          continue;
        case 6:
          if (tag != 48) {
            break;
          }

          message.totalGamesWagered = reader.uint32();
          continue;
        case 7:
          if (tag != 56) {
            break;
          }

          message.coinsMax = reader.uint32();
          continue;
        case 8:
          if (tag != 64) {
            break;
          }

          message.rankWagersRemaining = reader.uint32();
          continue;
        case 9:
          if (tag != 72) {
            break;
          }

          message.rankWagersMax = reader.uint32();
          continue;
        case 10:
          if (tag != 80) {
            break;
          }

          message.predictionTokensRemaining = reader.uint32();
          continue;
        case 11:
          if (tag != 88) {
            break;
          }

          message.predictionTokensMax = reader.uint32();
          continue;
        case 12:
          if (tag != 96) {
            break;
          }

          message.bountiesRemaining = reader.uint32();
          continue;
        case 13:
          if (tag != 104) {
            break;
          }

          message.bountiesMax = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientWageringResponse {
    return {
      coinsRemaining: isSet(object.coinsRemaining) ? Number(object.coinsRemaining) : 0,
      totalPointsWon: isSet(object.totalPointsWon) ? Number(object.totalPointsWon) : 0,
      totalPointsWagered: isSet(object.totalPointsWagered) ? Number(object.totalPointsWagered) : 0,
      totalPointsTipped: isSet(object.totalPointsTipped) ? Number(object.totalPointsTipped) : 0,
      successRate: isSet(object.successRate) ? Number(object.successRate) : 0,
      totalGamesWagered: isSet(object.totalGamesWagered) ? Number(object.totalGamesWagered) : 0,
      coinsMax: isSet(object.coinsMax) ? Number(object.coinsMax) : 0,
      rankWagersRemaining: isSet(object.rankWagersRemaining) ? Number(object.rankWagersRemaining) : 0,
      rankWagersMax: isSet(object.rankWagersMax) ? Number(object.rankWagersMax) : 0,
      predictionTokensRemaining: isSet(object.predictionTokensRemaining) ? Number(object.predictionTokensRemaining) : 0,
      predictionTokensMax: isSet(object.predictionTokensMax) ? Number(object.predictionTokensMax) : 0,
      bountiesRemaining: isSet(object.bountiesRemaining) ? Number(object.bountiesRemaining) : 0,
      bountiesMax: isSet(object.bountiesMax) ? Number(object.bountiesMax) : 0,
    };
  },

  toJSON(message: CMsgGCToClientWageringResponse): unknown {
    const obj: any = {};
    message.coinsRemaining !== undefined && (obj.coinsRemaining = Math.round(message.coinsRemaining));
    message.totalPointsWon !== undefined && (obj.totalPointsWon = Math.round(message.totalPointsWon));
    message.totalPointsWagered !== undefined && (obj.totalPointsWagered = Math.round(message.totalPointsWagered));
    message.totalPointsTipped !== undefined && (obj.totalPointsTipped = Math.round(message.totalPointsTipped));
    message.successRate !== undefined && (obj.successRate = Math.round(message.successRate));
    message.totalGamesWagered !== undefined && (obj.totalGamesWagered = Math.round(message.totalGamesWagered));
    message.coinsMax !== undefined && (obj.coinsMax = Math.round(message.coinsMax));
    message.rankWagersRemaining !== undefined && (obj.rankWagersRemaining = Math.round(message.rankWagersRemaining));
    message.rankWagersMax !== undefined && (obj.rankWagersMax = Math.round(message.rankWagersMax));
    message.predictionTokensRemaining !== undefined &&
      (obj.predictionTokensRemaining = Math.round(message.predictionTokensRemaining));
    message.predictionTokensMax !== undefined && (obj.predictionTokensMax = Math.round(message.predictionTokensMax));
    message.bountiesRemaining !== undefined && (obj.bountiesRemaining = Math.round(message.bountiesRemaining));
    message.bountiesMax !== undefined && (obj.bountiesMax = Math.round(message.bountiesMax));
    return obj;
  },
};

function createBaseCMsgGCToClientWageringUpdate(): CMsgGCToClientWageringUpdate {
  return { eventId: 0, wageringInfo: undefined };
}

export const CMsgGCToClientWageringUpdate = {
  encode(message: CMsgGCToClientWageringUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    if (message.wageringInfo !== undefined) {
      CMsgGCToClientWageringResponse.encode(message.wageringInfo, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientWageringUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientWageringUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.wageringInfo = CMsgGCToClientWageringResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientWageringUpdate {
    return {
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      wageringInfo: isSet(object.wageringInfo)
        ? CMsgGCToClientWageringResponse.fromJSON(object.wageringInfo)
        : undefined,
    };
  },

  toJSON(message: CMsgGCToClientWageringUpdate): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.wageringInfo !== undefined &&
      (obj.wageringInfo = message.wageringInfo
        ? CMsgGCToClientWageringResponse.toJSON(message.wageringInfo)
        : undefined);
    return obj;
  },
};

function createBaseCMsgGCToClientArcanaVotesUpdate(): CMsgGCToClientArcanaVotesUpdate {
  return { eventId: 0, arcanaVotes: undefined };
}

export const CMsgGCToClientArcanaVotesUpdate = {
  encode(message: CMsgGCToClientArcanaVotesUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    if (message.arcanaVotes !== undefined) {
      CMsgClientToGCRequestArcanaVotesRemainingResponse.encode(message.arcanaVotes, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientArcanaVotesUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientArcanaVotesUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.arcanaVotes = CMsgClientToGCRequestArcanaVotesRemainingResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientArcanaVotesUpdate {
    return {
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      arcanaVotes: isSet(object.arcanaVotes)
        ? CMsgClientToGCRequestArcanaVotesRemainingResponse.fromJSON(object.arcanaVotes)
        : undefined,
    };
  },

  toJSON(message: CMsgGCToClientArcanaVotesUpdate): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.arcanaVotes !== undefined && (obj.arcanaVotes = message.arcanaVotes
      ? CMsgClientToGCRequestArcanaVotesRemainingResponse.toJSON(message.arcanaVotes)
      : undefined);
    return obj;
  },
};

function createBaseCMsgClientToGCGetEventGoals(): CMsgClientToGCGetEventGoals {
  return { eventIds: [] };
}

export const CMsgClientToGCGetEventGoals = {
  encode(message: CMsgClientToGCGetEventGoals, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.eventIds) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetEventGoals {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetEventGoals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag == 8) {
            message.eventIds.push(reader.int32() as any);
            continue;
          }

          if (tag == 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.eventIds.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetEventGoals {
    return { eventIds: Array.isArray(object?.eventIds) ? object.eventIds.map((e: any) => eEventFromJSON(e)) : [] };
  },

  toJSON(message: CMsgClientToGCGetEventGoals): unknown {
    const obj: any = {};
    if (message.eventIds) {
      obj.eventIds = message.eventIds.map((e) => eEventToJSON(e));
    } else {
      obj.eventIds = [];
    }
    return obj;
  },
};

function createBaseCMsgEventGoals(): CMsgEventGoals {
  return { eventGoals: [] };
}

export const CMsgEventGoals = {
  encode(message: CMsgEventGoals, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.eventGoals) {
      CMsgEventGoals_EventGoal.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgEventGoals {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgEventGoals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.eventGoals.push(CMsgEventGoals_EventGoal.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgEventGoals {
    return {
      eventGoals: Array.isArray(object?.eventGoals)
        ? object.eventGoals.map((e: any) => CMsgEventGoals_EventGoal.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgEventGoals): unknown {
    const obj: any = {};
    if (message.eventGoals) {
      obj.eventGoals = message.eventGoals.map((e) => e ? CMsgEventGoals_EventGoal.toJSON(e) : undefined);
    } else {
      obj.eventGoals = [];
    }
    return obj;
  },
};

function createBaseCMsgEventGoals_EventGoal(): CMsgEventGoals_EventGoal {
  return { eventId: 0, goalId: 0, value: "0" };
}

export const CMsgEventGoals_EventGoal = {
  encode(message: CMsgEventGoals_EventGoal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).int32(message.eventId);
    }
    if (message.goalId !== 0) {
      writer.uint32(16).uint32(message.goalId);
    }
    if (message.value !== "0") {
      writer.uint32(24).uint64(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgEventGoals_EventGoal {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgEventGoals_EventGoal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.goalId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.value = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgEventGoals_EventGoal {
    return {
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      goalId: isSet(object.goalId) ? Number(object.goalId) : 0,
      value: isSet(object.value) ? String(object.value) : "0",
    };
  },

  toJSON(message: CMsgEventGoals_EventGoal): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = eEventToJSON(message.eventId));
    message.goalId !== undefined && (obj.goalId = Math.round(message.goalId));
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },
};

function createBaseCMsgGCToGCLeaguePredictions(): CMsgGCToGCLeaguePredictions {
  return { leagueId: 0 };
}

export const CMsgGCToGCLeaguePredictions = {
  encode(message: CMsgGCToGCLeaguePredictions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.leagueId !== 0) {
      writer.uint32(8).uint32(message.leagueId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToGCLeaguePredictions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCLeaguePredictions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCLeaguePredictions {
    return { leagueId: isSet(object.leagueId) ? Number(object.leagueId) : 0 };
  },

  toJSON(message: CMsgGCToGCLeaguePredictions): unknown {
    const obj: any = {};
    message.leagueId !== undefined && (obj.leagueId = Math.round(message.leagueId));
    return obj;
  },
};

function createBaseCMsgPredictionRankings(): CMsgPredictionRankings {
  return { predictions: [] };
}

export const CMsgPredictionRankings = {
  encode(message: CMsgPredictionRankings, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.predictions) {
      CMsgPredictionRankings_Prediction.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPredictionRankings {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPredictionRankings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.predictions.push(CMsgPredictionRankings_Prediction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPredictionRankings {
    return {
      predictions: Array.isArray(object?.predictions)
        ? object.predictions.map((e: any) => CMsgPredictionRankings_Prediction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgPredictionRankings): unknown {
    const obj: any = {};
    if (message.predictions) {
      obj.predictions = message.predictions.map((e) => e ? CMsgPredictionRankings_Prediction.toJSON(e) : undefined);
    } else {
      obj.predictions = [];
    }
    return obj;
  },
};

function createBaseCMsgPredictionRankings_PredictionLine(): CMsgPredictionRankings_PredictionLine {
  return { answerId: 0, answerName: "", answerLogo: "0", answerValue: 0 };
}

export const CMsgPredictionRankings_PredictionLine = {
  encode(message: CMsgPredictionRankings_PredictionLine, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.answerId !== 0) {
      writer.uint32(8).uint32(message.answerId);
    }
    if (message.answerName !== "") {
      writer.uint32(18).string(message.answerName);
    }
    if (message.answerLogo !== "0") {
      writer.uint32(24).uint64(message.answerLogo);
    }
    if (message.answerValue !== 0) {
      writer.uint32(37).float(message.answerValue);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPredictionRankings_PredictionLine {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPredictionRankings_PredictionLine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.answerId = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.answerName = reader.string();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.answerLogo = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag != 37) {
            break;
          }

          message.answerValue = reader.float();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPredictionRankings_PredictionLine {
    return {
      answerId: isSet(object.answerId) ? Number(object.answerId) : 0,
      answerName: isSet(object.answerName) ? String(object.answerName) : "",
      answerLogo: isSet(object.answerLogo) ? String(object.answerLogo) : "0",
      answerValue: isSet(object.answerValue) ? Number(object.answerValue) : 0,
    };
  },

  toJSON(message: CMsgPredictionRankings_PredictionLine): unknown {
    const obj: any = {};
    message.answerId !== undefined && (obj.answerId = Math.round(message.answerId));
    message.answerName !== undefined && (obj.answerName = message.answerName);
    message.answerLogo !== undefined && (obj.answerLogo = message.answerLogo);
    message.answerValue !== undefined && (obj.answerValue = message.answerValue);
    return obj;
  },
};

function createBaseCMsgPredictionRankings_Prediction(): CMsgPredictionRankings_Prediction {
  return { selectionId: 0, predictionLines: [] };
}

export const CMsgPredictionRankings_Prediction = {
  encode(message: CMsgPredictionRankings_Prediction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.selectionId !== 0) {
      writer.uint32(8).uint32(message.selectionId);
    }
    for (const v of message.predictionLines) {
      CMsgPredictionRankings_PredictionLine.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPredictionRankings_Prediction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPredictionRankings_Prediction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.selectionId = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.predictionLines.push(CMsgPredictionRankings_PredictionLine.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPredictionRankings_Prediction {
    return {
      selectionId: isSet(object.selectionId) ? Number(object.selectionId) : 0,
      predictionLines: Array.isArray(object?.predictionLines)
        ? object.predictionLines.map((e: any) => CMsgPredictionRankings_PredictionLine.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgPredictionRankings_Prediction): unknown {
    const obj: any = {};
    message.selectionId !== undefined && (obj.selectionId = Math.round(message.selectionId));
    if (message.predictionLines) {
      obj.predictionLines = message.predictionLines.map((e) =>
        e ? CMsgPredictionRankings_PredictionLine.toJSON(e) : undefined
      );
    } else {
      obj.predictionLines = [];
    }
    return obj;
  },
};

function createBaseCMsgPredictionResults(): CMsgPredictionResults {
  return { results: [] };
}

export const CMsgPredictionResults = {
  encode(message: CMsgPredictionResults, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      CMsgPredictionResults_Result.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPredictionResults {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPredictionResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.results.push(CMsgPredictionResults_Result.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPredictionResults {
    return {
      results: Array.isArray(object?.results)
        ? object.results.map((e: any) => CMsgPredictionResults_Result.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgPredictionResults): unknown {
    const obj: any = {};
    if (message.results) {
      obj.results = message.results.map((e) => e ? CMsgPredictionResults_Result.toJSON(e) : undefined);
    } else {
      obj.results = [];
    }
    return obj;
  },
};

function createBaseCMsgPredictionResults_ResultBreakdown(): CMsgPredictionResults_ResultBreakdown {
  return { answerSelection: 0, answerValue: 0 };
}

export const CMsgPredictionResults_ResultBreakdown = {
  encode(message: CMsgPredictionResults_ResultBreakdown, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.answerSelection !== 0) {
      writer.uint32(16).uint32(message.answerSelection);
    }
    if (message.answerValue !== 0) {
      writer.uint32(29).float(message.answerValue);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPredictionResults_ResultBreakdown {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPredictionResults_ResultBreakdown();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag != 16) {
            break;
          }

          message.answerSelection = reader.uint32();
          continue;
        case 3:
          if (tag != 29) {
            break;
          }

          message.answerValue = reader.float();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPredictionResults_ResultBreakdown {
    return {
      answerSelection: isSet(object.answerSelection) ? Number(object.answerSelection) : 0,
      answerValue: isSet(object.answerValue) ? Number(object.answerValue) : 0,
    };
  },

  toJSON(message: CMsgPredictionResults_ResultBreakdown): unknown {
    const obj: any = {};
    message.answerSelection !== undefined && (obj.answerSelection = Math.round(message.answerSelection));
    message.answerValue !== undefined && (obj.answerValue = message.answerValue);
    return obj;
  },
};

function createBaseCMsgPredictionResults_Result(): CMsgPredictionResults_Result {
  return { selectionId: 0, resultBreakdown: [] };
}

export const CMsgPredictionResults_Result = {
  encode(message: CMsgPredictionResults_Result, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.selectionId !== 0) {
      writer.uint32(8).uint32(message.selectionId);
    }
    for (const v of message.resultBreakdown) {
      CMsgPredictionResults_ResultBreakdown.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPredictionResults_Result {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPredictionResults_Result();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.selectionId = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.resultBreakdown.push(CMsgPredictionResults_ResultBreakdown.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPredictionResults_Result {
    return {
      selectionId: isSet(object.selectionId) ? Number(object.selectionId) : 0,
      resultBreakdown: Array.isArray(object?.resultBreakdown)
        ? object.resultBreakdown.map((e: any) => CMsgPredictionResults_ResultBreakdown.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgPredictionResults_Result): unknown {
    const obj: any = {};
    message.selectionId !== undefined && (obj.selectionId = Math.round(message.selectionId));
    if (message.resultBreakdown) {
      obj.resultBreakdown = message.resultBreakdown.map((e) =>
        e ? CMsgPredictionResults_ResultBreakdown.toJSON(e) : undefined
      );
    } else {
      obj.resultBreakdown = [];
    }
    return obj;
  },
};

function createBaseCMsgClientToGCHasPlayerVotedForMVP(): CMsgClientToGCHasPlayerVotedForMVP {
  return { matchId: "0" };
}

export const CMsgClientToGCHasPlayerVotedForMVP = {
  encode(message: CMsgClientToGCHasPlayerVotedForMVP, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCHasPlayerVotedForMVP {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCHasPlayerVotedForMVP();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCHasPlayerVotedForMVP {
    return { matchId: isSet(object.matchId) ? String(object.matchId) : "0" };
  },

  toJSON(message: CMsgClientToGCHasPlayerVotedForMVP): unknown {
    const obj: any = {};
    message.matchId !== undefined && (obj.matchId = message.matchId);
    return obj;
  },
};

function createBaseCMsgClientToGCHasPlayerVotedForMVPResponse(): CMsgClientToGCHasPlayerVotedForMVPResponse {
  return { result: false };
}

export const CMsgClientToGCHasPlayerVotedForMVPResponse = {
  encode(message: CMsgClientToGCHasPlayerVotedForMVPResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result === true) {
      writer.uint32(8).bool(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCHasPlayerVotedForMVPResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCHasPlayerVotedForMVPResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCHasPlayerVotedForMVPResponse {
    return { result: isSet(object.result) ? Boolean(object.result) : false };
  },

  toJSON(message: CMsgClientToGCHasPlayerVotedForMVPResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = message.result);
    return obj;
  },
};

function createBaseCMsgClientToGCVoteForMVP(): CMsgClientToGCVoteForMVP {
  return { matchId: "0", accountId: 0 };
}

export const CMsgClientToGCVoteForMVP = {
  encode(message: CMsgClientToGCVoteForMVP, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.accountId !== 0) {
      writer.uint32(24).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCVoteForMVP {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCVoteForMVP();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCVoteForMVP {
    return {
      matchId: isSet(object.matchId) ? String(object.matchId) : "0",
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCVoteForMVP): unknown {
    const obj: any = {};
    message.matchId !== undefined && (obj.matchId = message.matchId);
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    return obj;
  },
};

function createBaseCMsgClientToGCVoteForMVPResponse(): CMsgClientToGCVoteForMVPResponse {
  return { result: false };
}

export const CMsgClientToGCVoteForMVPResponse = {
  encode(message: CMsgClientToGCVoteForMVPResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result === true) {
      writer.uint32(8).bool(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCVoteForMVPResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCVoteForMVPResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCVoteForMVPResponse {
    return { result: isSet(object.result) ? Boolean(object.result) : false };
  },

  toJSON(message: CMsgClientToGCVoteForMVPResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = message.result);
    return obj;
  },
};

function createBaseCMsgClientToGCMVPVoteTimeout(): CMsgClientToGCMVPVoteTimeout {
  return { matchId: "0" };
}

export const CMsgClientToGCMVPVoteTimeout = {
  encode(message: CMsgClientToGCMVPVoteTimeout, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCMVPVoteTimeout {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCMVPVoteTimeout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCMVPVoteTimeout {
    return { matchId: isSet(object.matchId) ? String(object.matchId) : "0" };
  },

  toJSON(message: CMsgClientToGCMVPVoteTimeout): unknown {
    const obj: any = {};
    message.matchId !== undefined && (obj.matchId = message.matchId);
    return obj;
  },
};

function createBaseCMsgClientToGCMVPVoteTimeoutResponse(): CMsgClientToGCMVPVoteTimeoutResponse {
  return { result: false };
}

export const CMsgClientToGCMVPVoteTimeoutResponse = {
  encode(message: CMsgClientToGCMVPVoteTimeoutResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result === true) {
      writer.uint32(8).bool(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCMVPVoteTimeoutResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCMVPVoteTimeoutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCMVPVoteTimeoutResponse {
    return { result: isSet(object.result) ? Boolean(object.result) : false };
  },

  toJSON(message: CMsgClientToGCMVPVoteTimeoutResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = message.result);
    return obj;
  },
};

function createBaseCMsgClientToGCTeammateStatsRequest(): CMsgClientToGCTeammateStatsRequest {
  return {};
}

export const CMsgClientToGCTeammateStatsRequest = {
  encode(_: CMsgClientToGCTeammateStatsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCTeammateStatsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCTeammateStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientToGCTeammateStatsRequest {
    return {};
  },

  toJSON(_: CMsgClientToGCTeammateStatsRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgClientToGCTeammateStatsResponse(): CMsgClientToGCTeammateStatsResponse {
  return { success: false, teammateStats: [] };
}

export const CMsgClientToGCTeammateStatsResponse = {
  encode(message: CMsgClientToGCTeammateStatsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success === true) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.teammateStats) {
      CMsgClientToGCTeammateStatsResponse_TeammateStat.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCTeammateStatsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCTeammateStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.teammateStats.push(CMsgClientToGCTeammateStatsResponse_TeammateStat.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCTeammateStatsResponse {
    return {
      success: isSet(object.success) ? Boolean(object.success) : false,
      teammateStats: Array.isArray(object?.teammateStats)
        ? object.teammateStats.map((e: any) => CMsgClientToGCTeammateStatsResponse_TeammateStat.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientToGCTeammateStatsResponse): unknown {
    const obj: any = {};
    message.success !== undefined && (obj.success = message.success);
    if (message.teammateStats) {
      obj.teammateStats = message.teammateStats.map((e) =>
        e ? CMsgClientToGCTeammateStatsResponse_TeammateStat.toJSON(e) : undefined
      );
    } else {
      obj.teammateStats = [];
    }
    return obj;
  },
};

function createBaseCMsgClientToGCTeammateStatsResponse_TeammateStat(): CMsgClientToGCTeammateStatsResponse_TeammateStat {
  return { accountId: 0, games: 0, wins: 0, mostRecentGameTimestamp: 0, mostRecentGameMatchId: "0", performance: 0 };
}

export const CMsgClientToGCTeammateStatsResponse_TeammateStat = {
  encode(
    message: CMsgClientToGCTeammateStatsResponse_TeammateStat,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.games !== 0) {
      writer.uint32(16).uint32(message.games);
    }
    if (message.wins !== 0) {
      writer.uint32(24).uint32(message.wins);
    }
    if (message.mostRecentGameTimestamp !== 0) {
      writer.uint32(32).uint32(message.mostRecentGameTimestamp);
    }
    if (message.mostRecentGameMatchId !== "0") {
      writer.uint32(40).uint64(message.mostRecentGameMatchId);
    }
    if (message.performance !== 0) {
      writer.uint32(805).float(message.performance);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCTeammateStatsResponse_TeammateStat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCTeammateStatsResponse_TeammateStat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.games = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.wins = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.mostRecentGameTimestamp = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.mostRecentGameMatchId = longToString(reader.uint64() as Long);
          continue;
        case 100:
          if (tag != 805) {
            break;
          }

          message.performance = reader.float();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCTeammateStatsResponse_TeammateStat {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      games: isSet(object.games) ? Number(object.games) : 0,
      wins: isSet(object.wins) ? Number(object.wins) : 0,
      mostRecentGameTimestamp: isSet(object.mostRecentGameTimestamp) ? Number(object.mostRecentGameTimestamp) : 0,
      mostRecentGameMatchId: isSet(object.mostRecentGameMatchId) ? String(object.mostRecentGameMatchId) : "0",
      performance: isSet(object.performance) ? Number(object.performance) : 0,
    };
  },

  toJSON(message: CMsgClientToGCTeammateStatsResponse_TeammateStat): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.games !== undefined && (obj.games = Math.round(message.games));
    message.wins !== undefined && (obj.wins = Math.round(message.wins));
    message.mostRecentGameTimestamp !== undefined &&
      (obj.mostRecentGameTimestamp = Math.round(message.mostRecentGameTimestamp));
    message.mostRecentGameMatchId !== undefined && (obj.mostRecentGameMatchId = message.mostRecentGameMatchId);
    message.performance !== undefined && (obj.performance = message.performance);
    return obj;
  },
};

function createBaseCMsgClientToGCVoteForArcana(): CMsgClientToGCVoteForArcana {
  return { matches: [] };
}

export const CMsgClientToGCVoteForArcana = {
  encode(message: CMsgClientToGCVoteForArcana, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.matches) {
      CMsgArcanaVoteMatchVotes.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCVoteForArcana {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCVoteForArcana();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.matches.push(CMsgArcanaVoteMatchVotes.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCVoteForArcana {
    return {
      matches: Array.isArray(object?.matches)
        ? object.matches.map((e: any) => CMsgArcanaVoteMatchVotes.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientToGCVoteForArcana): unknown {
    const obj: any = {};
    if (message.matches) {
      obj.matches = message.matches.map((e) => e ? CMsgArcanaVoteMatchVotes.toJSON(e) : undefined);
    } else {
      obj.matches = [];
    }
    return obj;
  },
};

function createBaseCMsgClientToGCVoteForArcanaResponse(): CMsgClientToGCVoteForArcanaResponse {
  return { result: 0 };
}

export const CMsgClientToGCVoteForArcanaResponse = {
  encode(message: CMsgClientToGCVoteForArcanaResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCVoteForArcanaResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCVoteForArcanaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCVoteForArcanaResponse {
    return { result: isSet(object.result) ? cMsgClientToGCVoteForArcanaResponse_ResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgClientToGCVoteForArcanaResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = cMsgClientToGCVoteForArcanaResponse_ResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgClientToGCRequestArcanaVotesRemaining(): CMsgClientToGCRequestArcanaVotesRemaining {
  return {};
}

export const CMsgClientToGCRequestArcanaVotesRemaining = {
  encode(_: CMsgClientToGCRequestArcanaVotesRemaining, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRequestArcanaVotesRemaining {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRequestArcanaVotesRemaining();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientToGCRequestArcanaVotesRemaining {
    return {};
  },

  toJSON(_: CMsgClientToGCRequestArcanaVotesRemaining): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgClientToGCRequestArcanaVotesRemainingResponse(): CMsgClientToGCRequestArcanaVotesRemainingResponse {
  return { result: false, votesRemaining: 0, votesTotal: 0, matchesPreviouslyVotedFor: [] };
}

export const CMsgClientToGCRequestArcanaVotesRemainingResponse = {
  encode(
    message: CMsgClientToGCRequestArcanaVotesRemainingResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.result === true) {
      writer.uint32(8).bool(message.result);
    }
    if (message.votesRemaining !== 0) {
      writer.uint32(16).uint32(message.votesRemaining);
    }
    if (message.votesTotal !== 0) {
      writer.uint32(24).uint32(message.votesTotal);
    }
    for (const v of message.matchesPreviouslyVotedFor) {
      CMsgArcanaVoteMatchVotes.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRequestArcanaVotesRemainingResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRequestArcanaVotesRemainingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.bool();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.votesRemaining = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.votesTotal = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.matchesPreviouslyVotedFor.push(CMsgArcanaVoteMatchVotes.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRequestArcanaVotesRemainingResponse {
    return {
      result: isSet(object.result) ? Boolean(object.result) : false,
      votesRemaining: isSet(object.votesRemaining) ? Number(object.votesRemaining) : 0,
      votesTotal: isSet(object.votesTotal) ? Number(object.votesTotal) : 0,
      matchesPreviouslyVotedFor: Array.isArray(object?.matchesPreviouslyVotedFor)
        ? object.matchesPreviouslyVotedFor.map((e: any) => CMsgArcanaVoteMatchVotes.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientToGCRequestArcanaVotesRemainingResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = message.result);
    message.votesRemaining !== undefined && (obj.votesRemaining = Math.round(message.votesRemaining));
    message.votesTotal !== undefined && (obj.votesTotal = Math.round(message.votesTotal));
    if (message.matchesPreviouslyVotedFor) {
      obj.matchesPreviouslyVotedFor = message.matchesPreviouslyVotedFor.map((e) =>
        e ? CMsgArcanaVoteMatchVotes.toJSON(e) : undefined
      );
    } else {
      obj.matchesPreviouslyVotedFor = [];
    }
    return obj;
  },
};

function createBaseCMsgClientToGCRequestEventPointLogV2(): CMsgClientToGCRequestEventPointLogV2 {
  return { eventId: 0 };
}

export const CMsgClientToGCRequestEventPointLogV2 = {
  encode(message: CMsgClientToGCRequestEventPointLogV2, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRequestEventPointLogV2 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRequestEventPointLogV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRequestEventPointLogV2 {
    return { eventId: isSet(object.eventId) ? Number(object.eventId) : 0 };
  },

  toJSON(message: CMsgClientToGCRequestEventPointLogV2): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    return obj;
  },
};

function createBaseCMsgClientToGCRequestEventPointLogResponseV2(): CMsgClientToGCRequestEventPointLogResponseV2 {
  return { result: false, eventId: 0, logEntries: [] };
}

export const CMsgClientToGCRequestEventPointLogResponseV2 = {
  encode(message: CMsgClientToGCRequestEventPointLogResponseV2, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result === true) {
      writer.uint32(8).bool(message.result);
    }
    if (message.eventId !== 0) {
      writer.uint32(16).int32(message.eventId);
    }
    for (const v of message.logEntries) {
      CMsgClientToGCRequestEventPointLogResponseV2_LogEntry.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRequestEventPointLogResponseV2 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRequestEventPointLogResponseV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.bool();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.logEntries.push(
            CMsgClientToGCRequestEventPointLogResponseV2_LogEntry.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRequestEventPointLogResponseV2 {
    return {
      result: isSet(object.result) ? Boolean(object.result) : false,
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      logEntries: Array.isArray(object?.logEntries)
        ? object.logEntries.map((e: any) => CMsgClientToGCRequestEventPointLogResponseV2_LogEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientToGCRequestEventPointLogResponseV2): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = message.result);
    message.eventId !== undefined && (obj.eventId = eEventToJSON(message.eventId));
    if (message.logEntries) {
      obj.logEntries = message.logEntries.map((e) =>
        e ? CMsgClientToGCRequestEventPointLogResponseV2_LogEntry.toJSON(e) : undefined
      );
    } else {
      obj.logEntries = [];
    }
    return obj;
  },
};

function createBaseCMsgClientToGCRequestEventPointLogResponseV2_LogEntry(): CMsgClientToGCRequestEventPointLogResponseV2_LogEntry {
  return { timestamp: 0, auditAction: 0, eventPoints: 0, auditData: "0" };
}

export const CMsgClientToGCRequestEventPointLogResponseV2_LogEntry = {
  encode(
    message: CMsgClientToGCRequestEventPointLogResponseV2_LogEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.timestamp !== 0) {
      writer.uint32(8).uint32(message.timestamp);
    }
    if (message.auditAction !== 0) {
      writer.uint32(16).uint32(message.auditAction);
    }
    if (message.eventPoints !== 0) {
      writer.uint32(24).int32(message.eventPoints);
    }
    if (message.auditData !== "0") {
      writer.uint32(32).uint64(message.auditData);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRequestEventPointLogResponseV2_LogEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRequestEventPointLogResponseV2_LogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.auditAction = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.eventPoints = reader.int32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.auditData = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRequestEventPointLogResponseV2_LogEntry {
    return {
      timestamp: isSet(object.timestamp) ? Number(object.timestamp) : 0,
      auditAction: isSet(object.auditAction) ? Number(object.auditAction) : 0,
      eventPoints: isSet(object.eventPoints) ? Number(object.eventPoints) : 0,
      auditData: isSet(object.auditData) ? String(object.auditData) : "0",
    };
  },

  toJSON(message: CMsgClientToGCRequestEventPointLogResponseV2_LogEntry): unknown {
    const obj: any = {};
    message.timestamp !== undefined && (obj.timestamp = Math.round(message.timestamp));
    message.auditAction !== undefined && (obj.auditAction = Math.round(message.auditAction));
    message.eventPoints !== undefined && (obj.eventPoints = Math.round(message.eventPoints));
    message.auditData !== undefined && (obj.auditData = message.auditData);
    return obj;
  },
};

function createBaseCMsgClientToGCPublishUserStat(): CMsgClientToGCPublishUserStat {
  return { userStatsEvent: 0, referenceData: "0" };
}

export const CMsgClientToGCPublishUserStat = {
  encode(message: CMsgClientToGCPublishUserStat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userStatsEvent !== 0) {
      writer.uint32(8).uint32(message.userStatsEvent);
    }
    if (message.referenceData !== "0") {
      writer.uint32(16).uint64(message.referenceData);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCPublishUserStat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCPublishUserStat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.userStatsEvent = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.referenceData = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCPublishUserStat {
    return {
      userStatsEvent: isSet(object.userStatsEvent) ? Number(object.userStatsEvent) : 0,
      referenceData: isSet(object.referenceData) ? String(object.referenceData) : "0",
    };
  },

  toJSON(message: CMsgClientToGCPublishUserStat): unknown {
    const obj: any = {};
    message.userStatsEvent !== undefined && (obj.userStatsEvent = Math.round(message.userStatsEvent));
    message.referenceData !== undefined && (obj.referenceData = message.referenceData);
    return obj;
  },
};

function createBaseCMsgClientToGCRequestSlarkGameResult(): CMsgClientToGCRequestSlarkGameResult {
  return { eventId: 0, slotChosen: 0, week: 0 };
}

export const CMsgClientToGCRequestSlarkGameResult = {
  encode(message: CMsgClientToGCRequestSlarkGameResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).int32(message.eventId);
    }
    if (message.slotChosen !== 0) {
      writer.uint32(16).uint32(message.slotChosen);
    }
    if (message.week !== 0) {
      writer.uint32(24).uint32(message.week);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRequestSlarkGameResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRequestSlarkGameResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.slotChosen = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.week = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRequestSlarkGameResult {
    return {
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      slotChosen: isSet(object.slotChosen) ? Number(object.slotChosen) : 0,
      week: isSet(object.week) ? Number(object.week) : 0,
    };
  },

  toJSON(message: CMsgClientToGCRequestSlarkGameResult): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = eEventToJSON(message.eventId));
    message.slotChosen !== undefined && (obj.slotChosen = Math.round(message.slotChosen));
    message.week !== undefined && (obj.week = Math.round(message.week));
    return obj;
  },
};

function createBaseCMsgClientToGCRequestSlarkGameResultResponse(): CMsgClientToGCRequestSlarkGameResultResponse {
  return { pointsWon: 0, auraWon: false };
}

export const CMsgClientToGCRequestSlarkGameResultResponse = {
  encode(message: CMsgClientToGCRequestSlarkGameResultResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pointsWon !== 0) {
      writer.uint32(8).uint32(message.pointsWon);
    }
    if (message.auraWon === true) {
      writer.uint32(16).bool(message.auraWon);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRequestSlarkGameResultResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRequestSlarkGameResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.pointsWon = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.auraWon = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRequestSlarkGameResultResponse {
    return {
      pointsWon: isSet(object.pointsWon) ? Number(object.pointsWon) : 0,
      auraWon: isSet(object.auraWon) ? Boolean(object.auraWon) : false,
    };
  },

  toJSON(message: CMsgClientToGCRequestSlarkGameResultResponse): unknown {
    const obj: any = {};
    message.pointsWon !== undefined && (obj.pointsWon = Math.round(message.pointsWon));
    message.auraWon !== undefined && (obj.auraWon = message.auraWon);
    return obj;
  },
};

function createBaseCMsgGCToClientQuestProgressUpdated(): CMsgGCToClientQuestProgressUpdated {
  return { questId: 0, completedChallenges: [] };
}

export const CMsgGCToClientQuestProgressUpdated = {
  encode(message: CMsgGCToClientQuestProgressUpdated, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.questId !== 0) {
      writer.uint32(8).uint32(message.questId);
    }
    for (const v of message.completedChallenges) {
      CMsgGCToClientQuestProgressUpdated_Challenge.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientQuestProgressUpdated {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientQuestProgressUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.questId = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.completedChallenges.push(
            CMsgGCToClientQuestProgressUpdated_Challenge.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientQuestProgressUpdated {
    return {
      questId: isSet(object.questId) ? Number(object.questId) : 0,
      completedChallenges: Array.isArray(object?.completedChallenges)
        ? object.completedChallenges.map((e: any) => CMsgGCToClientQuestProgressUpdated_Challenge.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCToClientQuestProgressUpdated): unknown {
    const obj: any = {};
    message.questId !== undefined && (obj.questId = Math.round(message.questId));
    if (message.completedChallenges) {
      obj.completedChallenges = message.completedChallenges.map((e) =>
        e ? CMsgGCToClientQuestProgressUpdated_Challenge.toJSON(e) : undefined
      );
    } else {
      obj.completedChallenges = [];
    }
    return obj;
  },
};

function createBaseCMsgGCToClientQuestProgressUpdated_Challenge(): CMsgGCToClientQuestProgressUpdated_Challenge {
  return { challengeId: 0, timeCompleted: 0, attempts: 0, heroId: 0, templateId: 0, questRank: 0, maxQuestRank: 0 };
}

export const CMsgGCToClientQuestProgressUpdated_Challenge = {
  encode(message: CMsgGCToClientQuestProgressUpdated_Challenge, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.challengeId !== 0) {
      writer.uint32(8).uint32(message.challengeId);
    }
    if (message.timeCompleted !== 0) {
      writer.uint32(16).uint32(message.timeCompleted);
    }
    if (message.attempts !== 0) {
      writer.uint32(24).uint32(message.attempts);
    }
    if (message.heroId !== 0) {
      writer.uint32(32).uint32(message.heroId);
    }
    if (message.templateId !== 0) {
      writer.uint32(40).uint32(message.templateId);
    }
    if (message.questRank !== 0) {
      writer.uint32(48).uint32(message.questRank);
    }
    if (message.maxQuestRank !== 0) {
      writer.uint32(56).uint32(message.maxQuestRank);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientQuestProgressUpdated_Challenge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientQuestProgressUpdated_Challenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.challengeId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.timeCompleted = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.attempts = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.templateId = reader.uint32();
          continue;
        case 6:
          if (tag != 48) {
            break;
          }

          message.questRank = reader.uint32();
          continue;
        case 7:
          if (tag != 56) {
            break;
          }

          message.maxQuestRank = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientQuestProgressUpdated_Challenge {
    return {
      challengeId: isSet(object.challengeId) ? Number(object.challengeId) : 0,
      timeCompleted: isSet(object.timeCompleted) ? Number(object.timeCompleted) : 0,
      attempts: isSet(object.attempts) ? Number(object.attempts) : 0,
      heroId: isSet(object.heroId) ? Number(object.heroId) : 0,
      templateId: isSet(object.templateId) ? Number(object.templateId) : 0,
      questRank: isSet(object.questRank) ? Number(object.questRank) : 0,
      maxQuestRank: isSet(object.maxQuestRank) ? Number(object.maxQuestRank) : 0,
    };
  },

  toJSON(message: CMsgGCToClientQuestProgressUpdated_Challenge): unknown {
    const obj: any = {};
    message.challengeId !== undefined && (obj.challengeId = Math.round(message.challengeId));
    message.timeCompleted !== undefined && (obj.timeCompleted = Math.round(message.timeCompleted));
    message.attempts !== undefined && (obj.attempts = Math.round(message.attempts));
    message.heroId !== undefined && (obj.heroId = Math.round(message.heroId));
    message.templateId !== undefined && (obj.templateId = Math.round(message.templateId));
    message.questRank !== undefined && (obj.questRank = Math.round(message.questRank));
    message.maxQuestRank !== undefined && (obj.maxQuestRank = Math.round(message.maxQuestRank));
    return obj;
  },
};

function createBaseCMsgDOTARedeemItem(): CMsgDOTARedeemItem {
  return { currencyId: "0", purchaseDef: 0 };
}

export const CMsgDOTARedeemItem = {
  encode(message: CMsgDOTARedeemItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.currencyId !== "0") {
      writer.uint32(8).uint64(message.currencyId);
    }
    if (message.purchaseDef !== 0) {
      writer.uint32(16).uint32(message.purchaseDef);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARedeemItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARedeemItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.currencyId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.purchaseDef = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARedeemItem {
    return {
      currencyId: isSet(object.currencyId) ? String(object.currencyId) : "0",
      purchaseDef: isSet(object.purchaseDef) ? Number(object.purchaseDef) : 0,
    };
  },

  toJSON(message: CMsgDOTARedeemItem): unknown {
    const obj: any = {};
    message.currencyId !== undefined && (obj.currencyId = message.currencyId);
    message.purchaseDef !== undefined && (obj.purchaseDef = Math.round(message.purchaseDef));
    return obj;
  },
};

function createBaseCMsgDOTARedeemItemResponse(): CMsgDOTARedeemItemResponse {
  return { response: 0 };
}

export const CMsgDOTARedeemItemResponse = {
  encode(message: CMsgDOTARedeemItemResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARedeemItemResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARedeemItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARedeemItemResponse {
    return { response: isSet(object.response) ? cMsgDOTARedeemItemResponse_EResultCodeFromJSON(object.response) : 0 };
  },

  toJSON(message: CMsgDOTARedeemItemResponse): unknown {
    const obj: any = {};
    message.response !== undefined && (obj.response = cMsgDOTARedeemItemResponse_EResultCodeToJSON(message.response));
    return obj;
  },
};

function createBaseCMsgClientToGCSelectCompendiumInGamePrediction(): CMsgClientToGCSelectCompendiumInGamePrediction {
  return { matchId: "0", predictions: [], leagueId: 0 };
}

export const CMsgClientToGCSelectCompendiumInGamePrediction = {
  encode(
    message: CMsgClientToGCSelectCompendiumInGamePrediction,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    for (const v of message.predictions) {
      CMsgClientToGCSelectCompendiumInGamePrediction_Prediction.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.leagueId !== 0) {
      writer.uint32(24).uint32(message.leagueId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSelectCompendiumInGamePrediction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSelectCompendiumInGamePrediction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.predictions.push(
            CMsgClientToGCSelectCompendiumInGamePrediction_Prediction.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSelectCompendiumInGamePrediction {
    return {
      matchId: isSet(object.matchId) ? String(object.matchId) : "0",
      predictions: Array.isArray(object?.predictions)
        ? object.predictions.map((e: any) => CMsgClientToGCSelectCompendiumInGamePrediction_Prediction.fromJSON(e))
        : [],
      leagueId: isSet(object.leagueId) ? Number(object.leagueId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCSelectCompendiumInGamePrediction): unknown {
    const obj: any = {};
    message.matchId !== undefined && (obj.matchId = message.matchId);
    if (message.predictions) {
      obj.predictions = message.predictions.map((e) =>
        e ? CMsgClientToGCSelectCompendiumInGamePrediction_Prediction.toJSON(e) : undefined
      );
    } else {
      obj.predictions = [];
    }
    message.leagueId !== undefined && (obj.leagueId = Math.round(message.leagueId));
    return obj;
  },
};

function createBaseCMsgClientToGCSelectCompendiumInGamePrediction_Prediction(): CMsgClientToGCSelectCompendiumInGamePrediction_Prediction {
  return { predictionId: 0, predictionValue: 0 };
}

export const CMsgClientToGCSelectCompendiumInGamePrediction_Prediction = {
  encode(
    message: CMsgClientToGCSelectCompendiumInGamePrediction_Prediction,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.predictionId !== 0) {
      writer.uint32(8).uint32(message.predictionId);
    }
    if (message.predictionValue !== 0) {
      writer.uint32(16).uint32(message.predictionValue);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSelectCompendiumInGamePrediction_Prediction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSelectCompendiumInGamePrediction_Prediction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.predictionId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.predictionValue = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSelectCompendiumInGamePrediction_Prediction {
    return {
      predictionId: isSet(object.predictionId) ? Number(object.predictionId) : 0,
      predictionValue: isSet(object.predictionValue) ? Number(object.predictionValue) : 0,
    };
  },

  toJSON(message: CMsgClientToGCSelectCompendiumInGamePrediction_Prediction): unknown {
    const obj: any = {};
    message.predictionId !== undefined && (obj.predictionId = Math.round(message.predictionId));
    message.predictionValue !== undefined && (obj.predictionValue = Math.round(message.predictionValue));
    return obj;
  },
};

function createBaseCMsgClientToGCSelectCompendiumInGamePredictionResponse(): CMsgClientToGCSelectCompendiumInGamePredictionResponse {
  return { result: 0 };
}

export const CMsgClientToGCSelectCompendiumInGamePredictionResponse = {
  encode(
    message: CMsgClientToGCSelectCompendiumInGamePredictionResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSelectCompendiumInGamePredictionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSelectCompendiumInGamePredictionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSelectCompendiumInGamePredictionResponse {
    return {
      result: isSet(object.result)
        ? cMsgClientToGCSelectCompendiumInGamePredictionResponse_EResultFromJSON(object.result)
        : 0,
    };
  },

  toJSON(message: CMsgClientToGCSelectCompendiumInGamePredictionResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgClientToGCSelectCompendiumInGamePredictionResponse_EResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgClientToGCOpenPlayerCardPack(): CMsgClientToGCOpenPlayerCardPack {
  return { playerCardPackItemId: "0", teamId: 0, deprecatedLeagueId: 0, region: 0 };
}

export const CMsgClientToGCOpenPlayerCardPack = {
  encode(message: CMsgClientToGCOpenPlayerCardPack, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerCardPackItemId !== "0") {
      writer.uint32(8).uint64(message.playerCardPackItemId);
    }
    if (message.teamId !== 0) {
      writer.uint32(16).uint32(message.teamId);
    }
    if (message.deprecatedLeagueId !== 0) {
      writer.uint32(24).uint32(message.deprecatedLeagueId);
    }
    if (message.region !== 0) {
      writer.uint32(32).int32(message.region);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCOpenPlayerCardPack {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOpenPlayerCardPack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.playerCardPackItemId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.deprecatedLeagueId = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.region = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOpenPlayerCardPack {
    return {
      playerCardPackItemId: isSet(object.playerCardPackItemId) ? String(object.playerCardPackItemId) : "0",
      teamId: isSet(object.teamId) ? Number(object.teamId) : 0,
      deprecatedLeagueId: isSet(object.deprecatedLeagueId) ? Number(object.deprecatedLeagueId) : 0,
      region: isSet(object.region) ? eLeagueRegionFromJSON(object.region) : 0,
    };
  },

  toJSON(message: CMsgClientToGCOpenPlayerCardPack): unknown {
    const obj: any = {};
    message.playerCardPackItemId !== undefined && (obj.playerCardPackItemId = message.playerCardPackItemId);
    message.teamId !== undefined && (obj.teamId = Math.round(message.teamId));
    message.deprecatedLeagueId !== undefined && (obj.deprecatedLeagueId = Math.round(message.deprecatedLeagueId));
    message.region !== undefined && (obj.region = eLeagueRegionToJSON(message.region));
    return obj;
  },
};

function createBaseCMsgClientToGCOpenPlayerCardPackResponse(): CMsgClientToGCOpenPlayerCardPackResponse {
  return { result: 1, playerCardItemIds: [] };
}

export const CMsgClientToGCOpenPlayerCardPackResponse = {
  encode(message: CMsgClientToGCOpenPlayerCardPackResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 1) {
      writer.uint32(8).int32(message.result);
    }
    writer.uint32(18).fork();
    for (const v of message.playerCardItemIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCOpenPlayerCardPackResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOpenPlayerCardPackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag == 16) {
            message.playerCardItemIds.push(longToString(reader.uint64() as Long));
            continue;
          }

          if (tag == 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.playerCardItemIds.push(longToString(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOpenPlayerCardPackResponse {
    return {
      result: isSet(object.result) ? cMsgClientToGCOpenPlayerCardPackResponse_ResultFromJSON(object.result) : 1,
      playerCardItemIds: Array.isArray(object?.playerCardItemIds)
        ? object.playerCardItemIds.map((e: any) => String(e))
        : [],
    };
  },

  toJSON(message: CMsgClientToGCOpenPlayerCardPackResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgClientToGCOpenPlayerCardPackResponse_ResultToJSON(message.result));
    if (message.playerCardItemIds) {
      obj.playerCardItemIds = message.playerCardItemIds.map((e) => e);
    } else {
      obj.playerCardItemIds = [];
    }
    return obj;
  },
};

function createBaseCMsgClientToGCRecyclePlayerCard(): CMsgClientToGCRecyclePlayerCard {
  return { playerCardItemIds: [], eventId: 0 };
}

export const CMsgClientToGCRecyclePlayerCard = {
  encode(message: CMsgClientToGCRecyclePlayerCard, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(26).fork();
    for (const v of message.playerCardItemIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.eventId !== 0) {
      writer.uint32(16).uint32(message.eventId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRecyclePlayerCard {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRecyclePlayerCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag == 24) {
            message.playerCardItemIds.push(longToString(reader.uint64() as Long));
            continue;
          }

          if (tag == 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.playerCardItemIds.push(longToString(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag != 16) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRecyclePlayerCard {
    return {
      playerCardItemIds: Array.isArray(object?.playerCardItemIds)
        ? object.playerCardItemIds.map((e: any) => String(e))
        : [],
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCRecyclePlayerCard): unknown {
    const obj: any = {};
    if (message.playerCardItemIds) {
      obj.playerCardItemIds = message.playerCardItemIds.map((e) => e);
    } else {
      obj.playerCardItemIds = [];
    }
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    return obj;
  },
};

function createBaseCMsgClientToGCRecyclePlayerCardResponse(): CMsgClientToGCRecyclePlayerCardResponse {
  return { result: 1, dustAmount: 0 };
}

export const CMsgClientToGCRecyclePlayerCardResponse = {
  encode(message: CMsgClientToGCRecyclePlayerCardResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 1) {
      writer.uint32(8).int32(message.result);
    }
    if (message.dustAmount !== 0) {
      writer.uint32(16).uint32(message.dustAmount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRecyclePlayerCardResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRecyclePlayerCardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.dustAmount = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRecyclePlayerCardResponse {
    return {
      result: isSet(object.result) ? cMsgClientToGCRecyclePlayerCardResponse_ResultFromJSON(object.result) : 1,
      dustAmount: isSet(object.dustAmount) ? Number(object.dustAmount) : 0,
    };
  },

  toJSON(message: CMsgClientToGCRecyclePlayerCardResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = cMsgClientToGCRecyclePlayerCardResponse_ResultToJSON(message.result));
    message.dustAmount !== undefined && (obj.dustAmount = Math.round(message.dustAmount));
    return obj;
  },
};

function createBaseCMsgClientToGCCreatePlayerCardPack(): CMsgClientToGCCreatePlayerCardPack {
  return { cardDustItemId: "0", eventId: 0, premiumPack: false };
}

export const CMsgClientToGCCreatePlayerCardPack = {
  encode(message: CMsgClientToGCCreatePlayerCardPack, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cardDustItemId !== "0") {
      writer.uint32(8).uint64(message.cardDustItemId);
    }
    if (message.eventId !== 0) {
      writer.uint32(16).uint32(message.eventId);
    }
    if (message.premiumPack === true) {
      writer.uint32(24).bool(message.premiumPack);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCCreatePlayerCardPack {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCreatePlayerCardPack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.cardDustItemId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.premiumPack = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCreatePlayerCardPack {
    return {
      cardDustItemId: isSet(object.cardDustItemId) ? String(object.cardDustItemId) : "0",
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      premiumPack: isSet(object.premiumPack) ? Boolean(object.premiumPack) : false,
    };
  },

  toJSON(message: CMsgClientToGCCreatePlayerCardPack): unknown {
    const obj: any = {};
    message.cardDustItemId !== undefined && (obj.cardDustItemId = message.cardDustItemId);
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.premiumPack !== undefined && (obj.premiumPack = message.premiumPack);
    return obj;
  },
};

function createBaseCMsgClientToGCCreatePlayerCardPackResponse(): CMsgClientToGCCreatePlayerCardPackResponse {
  return { result: 1 };
}

export const CMsgClientToGCCreatePlayerCardPackResponse = {
  encode(message: CMsgClientToGCCreatePlayerCardPackResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 1) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCCreatePlayerCardPackResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCreatePlayerCardPackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCreatePlayerCardPackResponse {
    return {
      result: isSet(object.result) ? cMsgClientToGCCreatePlayerCardPackResponse_ResultFromJSON(object.result) : 1,
    };
  },

  toJSON(message: CMsgClientToGCCreatePlayerCardPackResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgClientToGCCreatePlayerCardPackResponse_ResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgClientToGCCreateTeamPlayerCardPack(): CMsgClientToGCCreateTeamPlayerCardPack {
  return { cardDustItemId: "0", eventId: 0, premiumPack: false, teamId: 0 };
}

export const CMsgClientToGCCreateTeamPlayerCardPack = {
  encode(message: CMsgClientToGCCreateTeamPlayerCardPack, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cardDustItemId !== "0") {
      writer.uint32(8).uint64(message.cardDustItemId);
    }
    if (message.eventId !== 0) {
      writer.uint32(16).uint32(message.eventId);
    }
    if (message.premiumPack === true) {
      writer.uint32(24).bool(message.premiumPack);
    }
    if (message.teamId !== 0) {
      writer.uint32(32).uint32(message.teamId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCCreateTeamPlayerCardPack {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCreateTeamPlayerCardPack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.cardDustItemId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.premiumPack = reader.bool();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCreateTeamPlayerCardPack {
    return {
      cardDustItemId: isSet(object.cardDustItemId) ? String(object.cardDustItemId) : "0",
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      premiumPack: isSet(object.premiumPack) ? Boolean(object.premiumPack) : false,
      teamId: isSet(object.teamId) ? Number(object.teamId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCCreateTeamPlayerCardPack): unknown {
    const obj: any = {};
    message.cardDustItemId !== undefined && (obj.cardDustItemId = message.cardDustItemId);
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.premiumPack !== undefined && (obj.premiumPack = message.premiumPack);
    message.teamId !== undefined && (obj.teamId = Math.round(message.teamId));
    return obj;
  },
};

function createBaseCMsgClientToGCCreateTeamPlayerCardPackResponse(): CMsgClientToGCCreateTeamPlayerCardPackResponse {
  return { result: 1 };
}

export const CMsgClientToGCCreateTeamPlayerCardPackResponse = {
  encode(
    message: CMsgClientToGCCreateTeamPlayerCardPackResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.result !== 1) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCCreateTeamPlayerCardPackResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCreateTeamPlayerCardPackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCreateTeamPlayerCardPackResponse {
    return {
      result: isSet(object.result) ? cMsgClientToGCCreateTeamPlayerCardPackResponse_ResultFromJSON(object.result) : 1,
    };
  },

  toJSON(message: CMsgClientToGCCreateTeamPlayerCardPackResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgClientToGCCreateTeamPlayerCardPackResponse_ResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupInternational2016(): CMsgGCToClientBattlePassRollupInternational2016 {
  return {
    battlePassLevel: 0,
    questlines: [],
    wagering: undefined,
    achievements: undefined,
    battleCup: undefined,
    predictions: undefined,
    bracket: undefined,
    playerCards: [],
    fantasyChallenge: undefined,
  };
}

export const CMsgGCToClientBattlePassRollupInternational2016 = {
  encode(
    message: CMsgGCToClientBattlePassRollupInternational2016,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.battlePassLevel !== 0) {
      writer.uint32(8).uint32(message.battlePassLevel);
    }
    for (const v of message.questlines) {
      CMsgGCToClientBattlePassRollupInternational2016_Questlines.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.wagering !== undefined) {
      CMsgGCToClientBattlePassRollupInternational2016_Wagering.encode(message.wagering, writer.uint32(26).fork())
        .ldelim();
    }
    if (message.achievements !== undefined) {
      CMsgGCToClientBattlePassRollupInternational2016_Achievements.encode(
        message.achievements,
        writer.uint32(34).fork(),
      ).ldelim();
    }
    if (message.battleCup !== undefined) {
      CMsgGCToClientBattlePassRollupInternational2016_BattleCup.encode(message.battleCup, writer.uint32(42).fork())
        .ldelim();
    }
    if (message.predictions !== undefined) {
      CMsgGCToClientBattlePassRollupInternational2016_Predictions.encode(message.predictions, writer.uint32(50).fork())
        .ldelim();
    }
    if (message.bracket !== undefined) {
      CMsgGCToClientBattlePassRollupInternational2016_Bracket.encode(message.bracket, writer.uint32(58).fork())
        .ldelim();
    }
    for (const v of message.playerCards) {
      CMsgGCToClientBattlePassRollupInternational2016_PlayerCard.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    if (message.fantasyChallenge !== undefined) {
      CMsgGCToClientBattlePassRollupInternational2016_FantasyChallenge.encode(
        message.fantasyChallenge,
        writer.uint32(74).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupInternational2016 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupInternational2016();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.battlePassLevel = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.questlines.push(
            CMsgGCToClientBattlePassRollupInternational2016_Questlines.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.wagering = CMsgGCToClientBattlePassRollupInternational2016_Wagering.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.achievements = CMsgGCToClientBattlePassRollupInternational2016_Achievements.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 5:
          if (tag != 42) {
            break;
          }

          message.battleCup = CMsgGCToClientBattlePassRollupInternational2016_BattleCup.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }

          message.predictions = CMsgGCToClientBattlePassRollupInternational2016_Predictions.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 7:
          if (tag != 58) {
            break;
          }

          message.bracket = CMsgGCToClientBattlePassRollupInternational2016_Bracket.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag != 66) {
            break;
          }

          message.playerCards.push(
            CMsgGCToClientBattlePassRollupInternational2016_PlayerCard.decode(reader, reader.uint32()),
          );
          continue;
        case 9:
          if (tag != 74) {
            break;
          }

          message.fantasyChallenge = CMsgGCToClientBattlePassRollupInternational2016_FantasyChallenge.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupInternational2016 {
    return {
      battlePassLevel: isSet(object.battlePassLevel) ? Number(object.battlePassLevel) : 0,
      questlines: Array.isArray(object?.questlines)
        ? object.questlines.map((e: any) => CMsgGCToClientBattlePassRollupInternational2016_Questlines.fromJSON(e))
        : [],
      wagering: isSet(object.wagering)
        ? CMsgGCToClientBattlePassRollupInternational2016_Wagering.fromJSON(object.wagering)
        : undefined,
      achievements: isSet(object.achievements)
        ? CMsgGCToClientBattlePassRollupInternational2016_Achievements.fromJSON(object.achievements)
        : undefined,
      battleCup: isSet(object.battleCup)
        ? CMsgGCToClientBattlePassRollupInternational2016_BattleCup.fromJSON(object.battleCup)
        : undefined,
      predictions: isSet(object.predictions)
        ? CMsgGCToClientBattlePassRollupInternational2016_Predictions.fromJSON(object.predictions)
        : undefined,
      bracket: isSet(object.bracket)
        ? CMsgGCToClientBattlePassRollupInternational2016_Bracket.fromJSON(object.bracket)
        : undefined,
      playerCards: Array.isArray(object?.playerCards)
        ? object.playerCards.map((e: any) => CMsgGCToClientBattlePassRollupInternational2016_PlayerCard.fromJSON(e))
        : [],
      fantasyChallenge: isSet(object.fantasyChallenge)
        ? CMsgGCToClientBattlePassRollupInternational2016_FantasyChallenge.fromJSON(object.fantasyChallenge)
        : undefined,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupInternational2016): unknown {
    const obj: any = {};
    message.battlePassLevel !== undefined && (obj.battlePassLevel = Math.round(message.battlePassLevel));
    if (message.questlines) {
      obj.questlines = message.questlines.map((e) =>
        e ? CMsgGCToClientBattlePassRollupInternational2016_Questlines.toJSON(e) : undefined
      );
    } else {
      obj.questlines = [];
    }
    message.wagering !== undefined && (obj.wagering = message.wagering
      ? CMsgGCToClientBattlePassRollupInternational2016_Wagering.toJSON(message.wagering)
      : undefined);
    message.achievements !== undefined && (obj.achievements = message.achievements
      ? CMsgGCToClientBattlePassRollupInternational2016_Achievements.toJSON(message.achievements)
      : undefined);
    message.battleCup !== undefined && (obj.battleCup = message.battleCup
      ? CMsgGCToClientBattlePassRollupInternational2016_BattleCup.toJSON(message.battleCup)
      : undefined);
    message.predictions !== undefined && (obj.predictions = message.predictions
      ? CMsgGCToClientBattlePassRollupInternational2016_Predictions.toJSON(message.predictions)
      : undefined);
    message.bracket !== undefined && (obj.bracket = message.bracket
      ? CMsgGCToClientBattlePassRollupInternational2016_Bracket.toJSON(message.bracket)
      : undefined);
    if (message.playerCards) {
      obj.playerCards = message.playerCards.map((e) =>
        e ? CMsgGCToClientBattlePassRollupInternational2016_PlayerCard.toJSON(e) : undefined
      );
    } else {
      obj.playerCards = [];
    }
    message.fantasyChallenge !== undefined && (obj.fantasyChallenge = message.fantasyChallenge
      ? CMsgGCToClientBattlePassRollupInternational2016_FantasyChallenge.toJSON(message.fantasyChallenge)
      : undefined);
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupInternational2016_Questlines(): CMsgGCToClientBattlePassRollupInternational2016_Questlines {
  return { name: "", onestar: 0, twostar: 0, threestar: 0, total: 0 };
}

export const CMsgGCToClientBattlePassRollupInternational2016_Questlines = {
  encode(
    message: CMsgGCToClientBattlePassRollupInternational2016_Questlines,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.onestar !== 0) {
      writer.uint32(16).uint32(message.onestar);
    }
    if (message.twostar !== 0) {
      writer.uint32(24).uint32(message.twostar);
    }
    if (message.threestar !== 0) {
      writer.uint32(32).uint32(message.threestar);
    }
    if (message.total !== 0) {
      writer.uint32(40).uint32(message.total);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupInternational2016_Questlines {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupInternational2016_Questlines();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.onestar = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.twostar = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.threestar = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.total = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupInternational2016_Questlines {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      onestar: isSet(object.onestar) ? Number(object.onestar) : 0,
      twostar: isSet(object.twostar) ? Number(object.twostar) : 0,
      threestar: isSet(object.threestar) ? Number(object.threestar) : 0,
      total: isSet(object.total) ? Number(object.total) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupInternational2016_Questlines): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.onestar !== undefined && (obj.onestar = Math.round(message.onestar));
    message.twostar !== undefined && (obj.twostar = Math.round(message.twostar));
    message.threestar !== undefined && (obj.threestar = Math.round(message.threestar));
    message.total !== undefined && (obj.total = Math.round(message.total));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupInternational2016_Wagering(): CMsgGCToClientBattlePassRollupInternational2016_Wagering {
  return { totalWagered: 0, totalWon: 0, averageWon: 0, successRate: 0, totalTips: 0 };
}

export const CMsgGCToClientBattlePassRollupInternational2016_Wagering = {
  encode(
    message: CMsgGCToClientBattlePassRollupInternational2016_Wagering,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.totalWagered !== 0) {
      writer.uint32(8).uint32(message.totalWagered);
    }
    if (message.totalWon !== 0) {
      writer.uint32(16).uint32(message.totalWon);
    }
    if (message.averageWon !== 0) {
      writer.uint32(24).uint32(message.averageWon);
    }
    if (message.successRate !== 0) {
      writer.uint32(32).uint32(message.successRate);
    }
    if (message.totalTips !== 0) {
      writer.uint32(40).uint32(message.totalTips);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupInternational2016_Wagering {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupInternational2016_Wagering();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.totalWagered = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.totalWon = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.averageWon = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.successRate = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.totalTips = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupInternational2016_Wagering {
    return {
      totalWagered: isSet(object.totalWagered) ? Number(object.totalWagered) : 0,
      totalWon: isSet(object.totalWon) ? Number(object.totalWon) : 0,
      averageWon: isSet(object.averageWon) ? Number(object.averageWon) : 0,
      successRate: isSet(object.successRate) ? Number(object.successRate) : 0,
      totalTips: isSet(object.totalTips) ? Number(object.totalTips) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupInternational2016_Wagering): unknown {
    const obj: any = {};
    message.totalWagered !== undefined && (obj.totalWagered = Math.round(message.totalWagered));
    message.totalWon !== undefined && (obj.totalWon = Math.round(message.totalWon));
    message.averageWon !== undefined && (obj.averageWon = Math.round(message.averageWon));
    message.successRate !== undefined && (obj.successRate = Math.round(message.successRate));
    message.totalTips !== undefined && (obj.totalTips = Math.round(message.totalTips));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupInternational2016_Achievements(): CMsgGCToClientBattlePassRollupInternational2016_Achievements {
  return { completed: 0, total: 0, points: 0 };
}

export const CMsgGCToClientBattlePassRollupInternational2016_Achievements = {
  encode(
    message: CMsgGCToClientBattlePassRollupInternational2016_Achievements,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.completed !== 0) {
      writer.uint32(8).uint32(message.completed);
    }
    if (message.total !== 0) {
      writer.uint32(16).uint32(message.total);
    }
    if (message.points !== 0) {
      writer.uint32(24).uint32(message.points);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CMsgGCToClientBattlePassRollupInternational2016_Achievements {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupInternational2016_Achievements();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.completed = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.total = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.points = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupInternational2016_Achievements {
    return {
      completed: isSet(object.completed) ? Number(object.completed) : 0,
      total: isSet(object.total) ? Number(object.total) : 0,
      points: isSet(object.points) ? Number(object.points) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupInternational2016_Achievements): unknown {
    const obj: any = {};
    message.completed !== undefined && (obj.completed = Math.round(message.completed));
    message.total !== undefined && (obj.total = Math.round(message.total));
    message.points !== undefined && (obj.points = Math.round(message.points));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupInternational2016_BattleCup(): CMsgGCToClientBattlePassRollupInternational2016_BattleCup {
  return { wins: 0, score: 0 };
}

export const CMsgGCToClientBattlePassRollupInternational2016_BattleCup = {
  encode(
    message: CMsgGCToClientBattlePassRollupInternational2016_BattleCup,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.wins !== 0) {
      writer.uint32(8).uint32(message.wins);
    }
    if (message.score !== 0) {
      writer.uint32(16).uint32(message.score);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupInternational2016_BattleCup {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupInternational2016_BattleCup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.wins = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.score = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupInternational2016_BattleCup {
    return {
      wins: isSet(object.wins) ? Number(object.wins) : 0,
      score: isSet(object.score) ? Number(object.score) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupInternational2016_BattleCup): unknown {
    const obj: any = {};
    message.wins !== undefined && (obj.wins = Math.round(message.wins));
    message.score !== undefined && (obj.score = Math.round(message.score));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupInternational2016_Predictions(): CMsgGCToClientBattlePassRollupInternational2016_Predictions {
  return { correct: 0, total: 0, points: 0 };
}

export const CMsgGCToClientBattlePassRollupInternational2016_Predictions = {
  encode(
    message: CMsgGCToClientBattlePassRollupInternational2016_Predictions,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.correct !== 0) {
      writer.uint32(8).uint32(message.correct);
    }
    if (message.total !== 0) {
      writer.uint32(16).uint32(message.total);
    }
    if (message.points !== 0) {
      writer.uint32(24).uint32(message.points);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupInternational2016_Predictions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupInternational2016_Predictions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.correct = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.total = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.points = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupInternational2016_Predictions {
    return {
      correct: isSet(object.correct) ? Number(object.correct) : 0,
      total: isSet(object.total) ? Number(object.total) : 0,
      points: isSet(object.points) ? Number(object.points) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupInternational2016_Predictions): unknown {
    const obj: any = {};
    message.correct !== undefined && (obj.correct = Math.round(message.correct));
    message.total !== undefined && (obj.total = Math.round(message.total));
    message.points !== undefined && (obj.points = Math.round(message.points));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupInternational2016_Bracket(): CMsgGCToClientBattlePassRollupInternational2016_Bracket {
  return { correct: 0, points: 0 };
}

export const CMsgGCToClientBattlePassRollupInternational2016_Bracket = {
  encode(
    message: CMsgGCToClientBattlePassRollupInternational2016_Bracket,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.correct !== 0) {
      writer.uint32(8).uint32(message.correct);
    }
    if (message.points !== 0) {
      writer.uint32(16).uint32(message.points);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupInternational2016_Bracket {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupInternational2016_Bracket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.correct = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.points = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupInternational2016_Bracket {
    return {
      correct: isSet(object.correct) ? Number(object.correct) : 0,
      points: isSet(object.points) ? Number(object.points) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupInternational2016_Bracket): unknown {
    const obj: any = {};
    message.correct !== undefined && (obj.correct = Math.round(message.correct));
    message.points !== undefined && (obj.points = Math.round(message.points));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupInternational2016_PlayerCard(): CMsgGCToClientBattlePassRollupInternational2016_PlayerCard {
  return { accountId: 0, quality: 0 };
}

export const CMsgGCToClientBattlePassRollupInternational2016_PlayerCard = {
  encode(
    message: CMsgGCToClientBattlePassRollupInternational2016_PlayerCard,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.quality !== 0) {
      writer.uint32(16).uint32(message.quality);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupInternational2016_PlayerCard {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupInternational2016_PlayerCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.quality = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupInternational2016_PlayerCard {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      quality: isSet(object.quality) ? Number(object.quality) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupInternational2016_PlayerCard): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.quality !== undefined && (obj.quality = Math.round(message.quality));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupInternational2016_FantasyChallenge(): CMsgGCToClientBattlePassRollupInternational2016_FantasyChallenge {
  return { totalScore: 0, percentile: 0 };
}

export const CMsgGCToClientBattlePassRollupInternational2016_FantasyChallenge = {
  encode(
    message: CMsgGCToClientBattlePassRollupInternational2016_FantasyChallenge,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.totalScore !== 0) {
      writer.uint32(13).float(message.totalScore);
    }
    if (message.percentile !== 0) {
      writer.uint32(21).float(message.percentile);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CMsgGCToClientBattlePassRollupInternational2016_FantasyChallenge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupInternational2016_FantasyChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 13) {
            break;
          }

          message.totalScore = reader.float();
          continue;
        case 2:
          if (tag != 21) {
            break;
          }

          message.percentile = reader.float();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupInternational2016_FantasyChallenge {
    return {
      totalScore: isSet(object.totalScore) ? Number(object.totalScore) : 0,
      percentile: isSet(object.percentile) ? Number(object.percentile) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupInternational2016_FantasyChallenge): unknown {
    const obj: any = {};
    message.totalScore !== undefined && (obj.totalScore = message.totalScore);
    message.percentile !== undefined && (obj.percentile = message.percentile);
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupFall2016(): CMsgGCToClientBattlePassRollupFall2016 {
  return {
    battlePassLevel: 0,
    questlines: [],
    wagering: undefined,
    achievements: undefined,
    battleCup: undefined,
    predictions: undefined,
    bracket: undefined,
    playerCards: [],
    fantasyChallenge: undefined,
  };
}

export const CMsgGCToClientBattlePassRollupFall2016 = {
  encode(message: CMsgGCToClientBattlePassRollupFall2016, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.battlePassLevel !== 0) {
      writer.uint32(8).uint32(message.battlePassLevel);
    }
    for (const v of message.questlines) {
      CMsgGCToClientBattlePassRollupFall2016_Questlines.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.wagering !== undefined) {
      CMsgGCToClientBattlePassRollupFall2016_Wagering.encode(message.wagering, writer.uint32(26).fork()).ldelim();
    }
    if (message.achievements !== undefined) {
      CMsgGCToClientBattlePassRollupFall2016_Achievements.encode(message.achievements, writer.uint32(34).fork())
        .ldelim();
    }
    if (message.battleCup !== undefined) {
      CMsgGCToClientBattlePassRollupFall2016_BattleCup.encode(message.battleCup, writer.uint32(42).fork()).ldelim();
    }
    if (message.predictions !== undefined) {
      CMsgGCToClientBattlePassRollupFall2016_Predictions.encode(message.predictions, writer.uint32(50).fork()).ldelim();
    }
    if (message.bracket !== undefined) {
      CMsgGCToClientBattlePassRollupFall2016_Bracket.encode(message.bracket, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.playerCards) {
      CMsgGCToClientBattlePassRollupFall2016_PlayerCard.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    if (message.fantasyChallenge !== undefined) {
      CMsgGCToClientBattlePassRollupFall2016_FantasyChallenge.encode(message.fantasyChallenge, writer.uint32(74).fork())
        .ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupFall2016 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupFall2016();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.battlePassLevel = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.questlines.push(CMsgGCToClientBattlePassRollupFall2016_Questlines.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.wagering = CMsgGCToClientBattlePassRollupFall2016_Wagering.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.achievements = CMsgGCToClientBattlePassRollupFall2016_Achievements.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag != 42) {
            break;
          }

          message.battleCup = CMsgGCToClientBattlePassRollupFall2016_BattleCup.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }

          message.predictions = CMsgGCToClientBattlePassRollupFall2016_Predictions.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag != 58) {
            break;
          }

          message.bracket = CMsgGCToClientBattlePassRollupFall2016_Bracket.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag != 66) {
            break;
          }

          message.playerCards.push(CMsgGCToClientBattlePassRollupFall2016_PlayerCard.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag != 74) {
            break;
          }

          message.fantasyChallenge = CMsgGCToClientBattlePassRollupFall2016_FantasyChallenge.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupFall2016 {
    return {
      battlePassLevel: isSet(object.battlePassLevel) ? Number(object.battlePassLevel) : 0,
      questlines: Array.isArray(object?.questlines)
        ? object.questlines.map((e: any) => CMsgGCToClientBattlePassRollupFall2016_Questlines.fromJSON(e))
        : [],
      wagering: isSet(object.wagering)
        ? CMsgGCToClientBattlePassRollupFall2016_Wagering.fromJSON(object.wagering)
        : undefined,
      achievements: isSet(object.achievements)
        ? CMsgGCToClientBattlePassRollupFall2016_Achievements.fromJSON(object.achievements)
        : undefined,
      battleCup: isSet(object.battleCup)
        ? CMsgGCToClientBattlePassRollupFall2016_BattleCup.fromJSON(object.battleCup)
        : undefined,
      predictions: isSet(object.predictions)
        ? CMsgGCToClientBattlePassRollupFall2016_Predictions.fromJSON(object.predictions)
        : undefined,
      bracket: isSet(object.bracket)
        ? CMsgGCToClientBattlePassRollupFall2016_Bracket.fromJSON(object.bracket)
        : undefined,
      playerCards: Array.isArray(object?.playerCards)
        ? object.playerCards.map((e: any) => CMsgGCToClientBattlePassRollupFall2016_PlayerCard.fromJSON(e))
        : [],
      fantasyChallenge: isSet(object.fantasyChallenge)
        ? CMsgGCToClientBattlePassRollupFall2016_FantasyChallenge.fromJSON(object.fantasyChallenge)
        : undefined,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupFall2016): unknown {
    const obj: any = {};
    message.battlePassLevel !== undefined && (obj.battlePassLevel = Math.round(message.battlePassLevel));
    if (message.questlines) {
      obj.questlines = message.questlines.map((e) =>
        e ? CMsgGCToClientBattlePassRollupFall2016_Questlines.toJSON(e) : undefined
      );
    } else {
      obj.questlines = [];
    }
    message.wagering !== undefined && (obj.wagering = message.wagering
      ? CMsgGCToClientBattlePassRollupFall2016_Wagering.toJSON(message.wagering)
      : undefined);
    message.achievements !== undefined && (obj.achievements = message.achievements
      ? CMsgGCToClientBattlePassRollupFall2016_Achievements.toJSON(message.achievements)
      : undefined);
    message.battleCup !== undefined && (obj.battleCup = message.battleCup
      ? CMsgGCToClientBattlePassRollupFall2016_BattleCup.toJSON(message.battleCup)
      : undefined);
    message.predictions !== undefined && (obj.predictions = message.predictions
      ? CMsgGCToClientBattlePassRollupFall2016_Predictions.toJSON(message.predictions)
      : undefined);
    message.bracket !== undefined && (obj.bracket = message.bracket
      ? CMsgGCToClientBattlePassRollupFall2016_Bracket.toJSON(message.bracket)
      : undefined);
    if (message.playerCards) {
      obj.playerCards = message.playerCards.map((e) =>
        e ? CMsgGCToClientBattlePassRollupFall2016_PlayerCard.toJSON(e) : undefined
      );
    } else {
      obj.playerCards = [];
    }
    message.fantasyChallenge !== undefined && (obj.fantasyChallenge = message.fantasyChallenge
      ? CMsgGCToClientBattlePassRollupFall2016_FantasyChallenge.toJSON(message.fantasyChallenge)
      : undefined);
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupFall2016_Questlines(): CMsgGCToClientBattlePassRollupFall2016_Questlines {
  return { name: "", onestar: 0, twostar: 0, threestar: 0, total: 0 };
}

export const CMsgGCToClientBattlePassRollupFall2016_Questlines = {
  encode(
    message: CMsgGCToClientBattlePassRollupFall2016_Questlines,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.onestar !== 0) {
      writer.uint32(16).uint32(message.onestar);
    }
    if (message.twostar !== 0) {
      writer.uint32(24).uint32(message.twostar);
    }
    if (message.threestar !== 0) {
      writer.uint32(32).uint32(message.threestar);
    }
    if (message.total !== 0) {
      writer.uint32(40).uint32(message.total);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupFall2016_Questlines {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupFall2016_Questlines();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.onestar = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.twostar = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.threestar = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.total = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupFall2016_Questlines {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      onestar: isSet(object.onestar) ? Number(object.onestar) : 0,
      twostar: isSet(object.twostar) ? Number(object.twostar) : 0,
      threestar: isSet(object.threestar) ? Number(object.threestar) : 0,
      total: isSet(object.total) ? Number(object.total) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupFall2016_Questlines): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.onestar !== undefined && (obj.onestar = Math.round(message.onestar));
    message.twostar !== undefined && (obj.twostar = Math.round(message.twostar));
    message.threestar !== undefined && (obj.threestar = Math.round(message.threestar));
    message.total !== undefined && (obj.total = Math.round(message.total));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupFall2016_Wagering(): CMsgGCToClientBattlePassRollupFall2016_Wagering {
  return { totalWagered: 0, totalWon: 0, averageWon: 0, successRate: 0, totalTips: 0 };
}

export const CMsgGCToClientBattlePassRollupFall2016_Wagering = {
  encode(
    message: CMsgGCToClientBattlePassRollupFall2016_Wagering,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.totalWagered !== 0) {
      writer.uint32(8).uint32(message.totalWagered);
    }
    if (message.totalWon !== 0) {
      writer.uint32(16).uint32(message.totalWon);
    }
    if (message.averageWon !== 0) {
      writer.uint32(24).uint32(message.averageWon);
    }
    if (message.successRate !== 0) {
      writer.uint32(32).uint32(message.successRate);
    }
    if (message.totalTips !== 0) {
      writer.uint32(40).uint32(message.totalTips);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupFall2016_Wagering {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupFall2016_Wagering();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.totalWagered = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.totalWon = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.averageWon = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.successRate = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.totalTips = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupFall2016_Wagering {
    return {
      totalWagered: isSet(object.totalWagered) ? Number(object.totalWagered) : 0,
      totalWon: isSet(object.totalWon) ? Number(object.totalWon) : 0,
      averageWon: isSet(object.averageWon) ? Number(object.averageWon) : 0,
      successRate: isSet(object.successRate) ? Number(object.successRate) : 0,
      totalTips: isSet(object.totalTips) ? Number(object.totalTips) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupFall2016_Wagering): unknown {
    const obj: any = {};
    message.totalWagered !== undefined && (obj.totalWagered = Math.round(message.totalWagered));
    message.totalWon !== undefined && (obj.totalWon = Math.round(message.totalWon));
    message.averageWon !== undefined && (obj.averageWon = Math.round(message.averageWon));
    message.successRate !== undefined && (obj.successRate = Math.round(message.successRate));
    message.totalTips !== undefined && (obj.totalTips = Math.round(message.totalTips));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupFall2016_Achievements(): CMsgGCToClientBattlePassRollupFall2016_Achievements {
  return { completed: 0, total: 0, points: 0 };
}

export const CMsgGCToClientBattlePassRollupFall2016_Achievements = {
  encode(
    message: CMsgGCToClientBattlePassRollupFall2016_Achievements,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.completed !== 0) {
      writer.uint32(8).uint32(message.completed);
    }
    if (message.total !== 0) {
      writer.uint32(16).uint32(message.total);
    }
    if (message.points !== 0) {
      writer.uint32(24).uint32(message.points);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupFall2016_Achievements {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupFall2016_Achievements();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.completed = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.total = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.points = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupFall2016_Achievements {
    return {
      completed: isSet(object.completed) ? Number(object.completed) : 0,
      total: isSet(object.total) ? Number(object.total) : 0,
      points: isSet(object.points) ? Number(object.points) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupFall2016_Achievements): unknown {
    const obj: any = {};
    message.completed !== undefined && (obj.completed = Math.round(message.completed));
    message.total !== undefined && (obj.total = Math.round(message.total));
    message.points !== undefined && (obj.points = Math.round(message.points));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupFall2016_BattleCup(): CMsgGCToClientBattlePassRollupFall2016_BattleCup {
  return { wins: 0, score: 0 };
}

export const CMsgGCToClientBattlePassRollupFall2016_BattleCup = {
  encode(
    message: CMsgGCToClientBattlePassRollupFall2016_BattleCup,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.wins !== 0) {
      writer.uint32(8).uint32(message.wins);
    }
    if (message.score !== 0) {
      writer.uint32(16).uint32(message.score);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupFall2016_BattleCup {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupFall2016_BattleCup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.wins = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.score = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupFall2016_BattleCup {
    return {
      wins: isSet(object.wins) ? Number(object.wins) : 0,
      score: isSet(object.score) ? Number(object.score) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupFall2016_BattleCup): unknown {
    const obj: any = {};
    message.wins !== undefined && (obj.wins = Math.round(message.wins));
    message.score !== undefined && (obj.score = Math.round(message.score));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupFall2016_Predictions(): CMsgGCToClientBattlePassRollupFall2016_Predictions {
  return { correct: 0, total: 0, points: 0 };
}

export const CMsgGCToClientBattlePassRollupFall2016_Predictions = {
  encode(
    message: CMsgGCToClientBattlePassRollupFall2016_Predictions,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.correct !== 0) {
      writer.uint32(8).uint32(message.correct);
    }
    if (message.total !== 0) {
      writer.uint32(16).uint32(message.total);
    }
    if (message.points !== 0) {
      writer.uint32(24).uint32(message.points);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupFall2016_Predictions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupFall2016_Predictions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.correct = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.total = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.points = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupFall2016_Predictions {
    return {
      correct: isSet(object.correct) ? Number(object.correct) : 0,
      total: isSet(object.total) ? Number(object.total) : 0,
      points: isSet(object.points) ? Number(object.points) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupFall2016_Predictions): unknown {
    const obj: any = {};
    message.correct !== undefined && (obj.correct = Math.round(message.correct));
    message.total !== undefined && (obj.total = Math.round(message.total));
    message.points !== undefined && (obj.points = Math.round(message.points));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupFall2016_Bracket(): CMsgGCToClientBattlePassRollupFall2016_Bracket {
  return { correct: 0, points: 0 };
}

export const CMsgGCToClientBattlePassRollupFall2016_Bracket = {
  encode(
    message: CMsgGCToClientBattlePassRollupFall2016_Bracket,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.correct !== 0) {
      writer.uint32(8).uint32(message.correct);
    }
    if (message.points !== 0) {
      writer.uint32(16).uint32(message.points);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupFall2016_Bracket {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupFall2016_Bracket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.correct = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.points = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupFall2016_Bracket {
    return {
      correct: isSet(object.correct) ? Number(object.correct) : 0,
      points: isSet(object.points) ? Number(object.points) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupFall2016_Bracket): unknown {
    const obj: any = {};
    message.correct !== undefined && (obj.correct = Math.round(message.correct));
    message.points !== undefined && (obj.points = Math.round(message.points));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupFall2016_PlayerCard(): CMsgGCToClientBattlePassRollupFall2016_PlayerCard {
  return { accountId: 0, quality: 0 };
}

export const CMsgGCToClientBattlePassRollupFall2016_PlayerCard = {
  encode(
    message: CMsgGCToClientBattlePassRollupFall2016_PlayerCard,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.quality !== 0) {
      writer.uint32(16).uint32(message.quality);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupFall2016_PlayerCard {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupFall2016_PlayerCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.quality = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupFall2016_PlayerCard {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      quality: isSet(object.quality) ? Number(object.quality) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupFall2016_PlayerCard): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.quality !== undefined && (obj.quality = Math.round(message.quality));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupFall2016_FantasyChallenge(): CMsgGCToClientBattlePassRollupFall2016_FantasyChallenge {
  return { totalScore: 0, percentile: 0 };
}

export const CMsgGCToClientBattlePassRollupFall2016_FantasyChallenge = {
  encode(
    message: CMsgGCToClientBattlePassRollupFall2016_FantasyChallenge,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.totalScore !== 0) {
      writer.uint32(13).float(message.totalScore);
    }
    if (message.percentile !== 0) {
      writer.uint32(21).float(message.percentile);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupFall2016_FantasyChallenge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupFall2016_FantasyChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 13) {
            break;
          }

          message.totalScore = reader.float();
          continue;
        case 2:
          if (tag != 21) {
            break;
          }

          message.percentile = reader.float();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupFall2016_FantasyChallenge {
    return {
      totalScore: isSet(object.totalScore) ? Number(object.totalScore) : 0,
      percentile: isSet(object.percentile) ? Number(object.percentile) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupFall2016_FantasyChallenge): unknown {
    const obj: any = {};
    message.totalScore !== undefined && (obj.totalScore = message.totalScore);
    message.percentile !== undefined && (obj.percentile = message.percentile);
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupWinter2017(): CMsgGCToClientBattlePassRollupWinter2017 {
  return {
    battlePassLevel: 0,
    questlines: [],
    wagering: undefined,
    achievements: undefined,
    battleCup: undefined,
    predictions: undefined,
    bracket: undefined,
    playerCards: [],
    fantasyChallenge: undefined,
  };
}

export const CMsgGCToClientBattlePassRollupWinter2017 = {
  encode(message: CMsgGCToClientBattlePassRollupWinter2017, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.battlePassLevel !== 0) {
      writer.uint32(8).uint32(message.battlePassLevel);
    }
    for (const v of message.questlines) {
      CMsgGCToClientBattlePassRollupWinter2017_Questlines.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.wagering !== undefined) {
      CMsgGCToClientBattlePassRollupWinter2017_Wagering.encode(message.wagering, writer.uint32(26).fork()).ldelim();
    }
    if (message.achievements !== undefined) {
      CMsgGCToClientBattlePassRollupWinter2017_Achievements.encode(message.achievements, writer.uint32(34).fork())
        .ldelim();
    }
    if (message.battleCup !== undefined) {
      CMsgGCToClientBattlePassRollupWinter2017_BattleCup.encode(message.battleCup, writer.uint32(42).fork()).ldelim();
    }
    if (message.predictions !== undefined) {
      CMsgGCToClientBattlePassRollupWinter2017_Predictions.encode(message.predictions, writer.uint32(50).fork())
        .ldelim();
    }
    if (message.bracket !== undefined) {
      CMsgGCToClientBattlePassRollupWinter2017_Bracket.encode(message.bracket, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.playerCards) {
      CMsgGCToClientBattlePassRollupWinter2017_PlayerCard.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    if (message.fantasyChallenge !== undefined) {
      CMsgGCToClientBattlePassRollupWinter2017_FantasyChallenge.encode(
        message.fantasyChallenge,
        writer.uint32(74).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupWinter2017 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupWinter2017();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.battlePassLevel = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.questlines.push(CMsgGCToClientBattlePassRollupWinter2017_Questlines.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.wagering = CMsgGCToClientBattlePassRollupWinter2017_Wagering.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.achievements = CMsgGCToClientBattlePassRollupWinter2017_Achievements.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag != 42) {
            break;
          }

          message.battleCup = CMsgGCToClientBattlePassRollupWinter2017_BattleCup.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }

          message.predictions = CMsgGCToClientBattlePassRollupWinter2017_Predictions.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag != 58) {
            break;
          }

          message.bracket = CMsgGCToClientBattlePassRollupWinter2017_Bracket.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag != 66) {
            break;
          }

          message.playerCards.push(CMsgGCToClientBattlePassRollupWinter2017_PlayerCard.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag != 74) {
            break;
          }

          message.fantasyChallenge = CMsgGCToClientBattlePassRollupWinter2017_FantasyChallenge.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupWinter2017 {
    return {
      battlePassLevel: isSet(object.battlePassLevel) ? Number(object.battlePassLevel) : 0,
      questlines: Array.isArray(object?.questlines)
        ? object.questlines.map((e: any) => CMsgGCToClientBattlePassRollupWinter2017_Questlines.fromJSON(e))
        : [],
      wagering: isSet(object.wagering)
        ? CMsgGCToClientBattlePassRollupWinter2017_Wagering.fromJSON(object.wagering)
        : undefined,
      achievements: isSet(object.achievements)
        ? CMsgGCToClientBattlePassRollupWinter2017_Achievements.fromJSON(object.achievements)
        : undefined,
      battleCup: isSet(object.battleCup)
        ? CMsgGCToClientBattlePassRollupWinter2017_BattleCup.fromJSON(object.battleCup)
        : undefined,
      predictions: isSet(object.predictions)
        ? CMsgGCToClientBattlePassRollupWinter2017_Predictions.fromJSON(object.predictions)
        : undefined,
      bracket: isSet(object.bracket)
        ? CMsgGCToClientBattlePassRollupWinter2017_Bracket.fromJSON(object.bracket)
        : undefined,
      playerCards: Array.isArray(object?.playerCards)
        ? object.playerCards.map((e: any) => CMsgGCToClientBattlePassRollupWinter2017_PlayerCard.fromJSON(e))
        : [],
      fantasyChallenge: isSet(object.fantasyChallenge)
        ? CMsgGCToClientBattlePassRollupWinter2017_FantasyChallenge.fromJSON(object.fantasyChallenge)
        : undefined,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupWinter2017): unknown {
    const obj: any = {};
    message.battlePassLevel !== undefined && (obj.battlePassLevel = Math.round(message.battlePassLevel));
    if (message.questlines) {
      obj.questlines = message.questlines.map((e) =>
        e ? CMsgGCToClientBattlePassRollupWinter2017_Questlines.toJSON(e) : undefined
      );
    } else {
      obj.questlines = [];
    }
    message.wagering !== undefined && (obj.wagering = message.wagering
      ? CMsgGCToClientBattlePassRollupWinter2017_Wagering.toJSON(message.wagering)
      : undefined);
    message.achievements !== undefined && (obj.achievements = message.achievements
      ? CMsgGCToClientBattlePassRollupWinter2017_Achievements.toJSON(message.achievements)
      : undefined);
    message.battleCup !== undefined && (obj.battleCup = message.battleCup
      ? CMsgGCToClientBattlePassRollupWinter2017_BattleCup.toJSON(message.battleCup)
      : undefined);
    message.predictions !== undefined && (obj.predictions = message.predictions
      ? CMsgGCToClientBattlePassRollupWinter2017_Predictions.toJSON(message.predictions)
      : undefined);
    message.bracket !== undefined && (obj.bracket = message.bracket
      ? CMsgGCToClientBattlePassRollupWinter2017_Bracket.toJSON(message.bracket)
      : undefined);
    if (message.playerCards) {
      obj.playerCards = message.playerCards.map((e) =>
        e ? CMsgGCToClientBattlePassRollupWinter2017_PlayerCard.toJSON(e) : undefined
      );
    } else {
      obj.playerCards = [];
    }
    message.fantasyChallenge !== undefined && (obj.fantasyChallenge = message.fantasyChallenge
      ? CMsgGCToClientBattlePassRollupWinter2017_FantasyChallenge.toJSON(message.fantasyChallenge)
      : undefined);
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupWinter2017_Questlines(): CMsgGCToClientBattlePassRollupWinter2017_Questlines {
  return { name: "", onestar: 0, twostar: 0, threestar: 0, total: 0 };
}

export const CMsgGCToClientBattlePassRollupWinter2017_Questlines = {
  encode(
    message: CMsgGCToClientBattlePassRollupWinter2017_Questlines,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.onestar !== 0) {
      writer.uint32(16).uint32(message.onestar);
    }
    if (message.twostar !== 0) {
      writer.uint32(24).uint32(message.twostar);
    }
    if (message.threestar !== 0) {
      writer.uint32(32).uint32(message.threestar);
    }
    if (message.total !== 0) {
      writer.uint32(40).uint32(message.total);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupWinter2017_Questlines {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupWinter2017_Questlines();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.onestar = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.twostar = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.threestar = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.total = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupWinter2017_Questlines {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      onestar: isSet(object.onestar) ? Number(object.onestar) : 0,
      twostar: isSet(object.twostar) ? Number(object.twostar) : 0,
      threestar: isSet(object.threestar) ? Number(object.threestar) : 0,
      total: isSet(object.total) ? Number(object.total) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupWinter2017_Questlines): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.onestar !== undefined && (obj.onestar = Math.round(message.onestar));
    message.twostar !== undefined && (obj.twostar = Math.round(message.twostar));
    message.threestar !== undefined && (obj.threestar = Math.round(message.threestar));
    message.total !== undefined && (obj.total = Math.round(message.total));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupWinter2017_Wagering(): CMsgGCToClientBattlePassRollupWinter2017_Wagering {
  return { totalWagered: 0, totalWon: 0, averageWon: 0, successRate: 0, totalTips: 0 };
}

export const CMsgGCToClientBattlePassRollupWinter2017_Wagering = {
  encode(
    message: CMsgGCToClientBattlePassRollupWinter2017_Wagering,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.totalWagered !== 0) {
      writer.uint32(8).uint32(message.totalWagered);
    }
    if (message.totalWon !== 0) {
      writer.uint32(16).uint32(message.totalWon);
    }
    if (message.averageWon !== 0) {
      writer.uint32(24).uint32(message.averageWon);
    }
    if (message.successRate !== 0) {
      writer.uint32(32).uint32(message.successRate);
    }
    if (message.totalTips !== 0) {
      writer.uint32(40).uint32(message.totalTips);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupWinter2017_Wagering {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupWinter2017_Wagering();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.totalWagered = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.totalWon = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.averageWon = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.successRate = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.totalTips = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupWinter2017_Wagering {
    return {
      totalWagered: isSet(object.totalWagered) ? Number(object.totalWagered) : 0,
      totalWon: isSet(object.totalWon) ? Number(object.totalWon) : 0,
      averageWon: isSet(object.averageWon) ? Number(object.averageWon) : 0,
      successRate: isSet(object.successRate) ? Number(object.successRate) : 0,
      totalTips: isSet(object.totalTips) ? Number(object.totalTips) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupWinter2017_Wagering): unknown {
    const obj: any = {};
    message.totalWagered !== undefined && (obj.totalWagered = Math.round(message.totalWagered));
    message.totalWon !== undefined && (obj.totalWon = Math.round(message.totalWon));
    message.averageWon !== undefined && (obj.averageWon = Math.round(message.averageWon));
    message.successRate !== undefined && (obj.successRate = Math.round(message.successRate));
    message.totalTips !== undefined && (obj.totalTips = Math.round(message.totalTips));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupWinter2017_Achievements(): CMsgGCToClientBattlePassRollupWinter2017_Achievements {
  return { completed: 0, total: 0, points: 0 };
}

export const CMsgGCToClientBattlePassRollupWinter2017_Achievements = {
  encode(
    message: CMsgGCToClientBattlePassRollupWinter2017_Achievements,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.completed !== 0) {
      writer.uint32(8).uint32(message.completed);
    }
    if (message.total !== 0) {
      writer.uint32(16).uint32(message.total);
    }
    if (message.points !== 0) {
      writer.uint32(24).uint32(message.points);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupWinter2017_Achievements {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupWinter2017_Achievements();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.completed = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.total = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.points = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupWinter2017_Achievements {
    return {
      completed: isSet(object.completed) ? Number(object.completed) : 0,
      total: isSet(object.total) ? Number(object.total) : 0,
      points: isSet(object.points) ? Number(object.points) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupWinter2017_Achievements): unknown {
    const obj: any = {};
    message.completed !== undefined && (obj.completed = Math.round(message.completed));
    message.total !== undefined && (obj.total = Math.round(message.total));
    message.points !== undefined && (obj.points = Math.round(message.points));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupWinter2017_BattleCup(): CMsgGCToClientBattlePassRollupWinter2017_BattleCup {
  return { wins: 0, score: 0 };
}

export const CMsgGCToClientBattlePassRollupWinter2017_BattleCup = {
  encode(
    message: CMsgGCToClientBattlePassRollupWinter2017_BattleCup,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.wins !== 0) {
      writer.uint32(8).uint32(message.wins);
    }
    if (message.score !== 0) {
      writer.uint32(16).uint32(message.score);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupWinter2017_BattleCup {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupWinter2017_BattleCup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.wins = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.score = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupWinter2017_BattleCup {
    return {
      wins: isSet(object.wins) ? Number(object.wins) : 0,
      score: isSet(object.score) ? Number(object.score) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupWinter2017_BattleCup): unknown {
    const obj: any = {};
    message.wins !== undefined && (obj.wins = Math.round(message.wins));
    message.score !== undefined && (obj.score = Math.round(message.score));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupWinter2017_Predictions(): CMsgGCToClientBattlePassRollupWinter2017_Predictions {
  return { correct: 0, total: 0, points: 0 };
}

export const CMsgGCToClientBattlePassRollupWinter2017_Predictions = {
  encode(
    message: CMsgGCToClientBattlePassRollupWinter2017_Predictions,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.correct !== 0) {
      writer.uint32(8).uint32(message.correct);
    }
    if (message.total !== 0) {
      writer.uint32(16).uint32(message.total);
    }
    if (message.points !== 0) {
      writer.uint32(24).uint32(message.points);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupWinter2017_Predictions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupWinter2017_Predictions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.correct = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.total = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.points = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupWinter2017_Predictions {
    return {
      correct: isSet(object.correct) ? Number(object.correct) : 0,
      total: isSet(object.total) ? Number(object.total) : 0,
      points: isSet(object.points) ? Number(object.points) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupWinter2017_Predictions): unknown {
    const obj: any = {};
    message.correct !== undefined && (obj.correct = Math.round(message.correct));
    message.total !== undefined && (obj.total = Math.round(message.total));
    message.points !== undefined && (obj.points = Math.round(message.points));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupWinter2017_Bracket(): CMsgGCToClientBattlePassRollupWinter2017_Bracket {
  return { correct: 0, points: 0 };
}

export const CMsgGCToClientBattlePassRollupWinter2017_Bracket = {
  encode(
    message: CMsgGCToClientBattlePassRollupWinter2017_Bracket,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.correct !== 0) {
      writer.uint32(8).uint32(message.correct);
    }
    if (message.points !== 0) {
      writer.uint32(16).uint32(message.points);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupWinter2017_Bracket {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupWinter2017_Bracket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.correct = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.points = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupWinter2017_Bracket {
    return {
      correct: isSet(object.correct) ? Number(object.correct) : 0,
      points: isSet(object.points) ? Number(object.points) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupWinter2017_Bracket): unknown {
    const obj: any = {};
    message.correct !== undefined && (obj.correct = Math.round(message.correct));
    message.points !== undefined && (obj.points = Math.round(message.points));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupWinter2017_PlayerCard(): CMsgGCToClientBattlePassRollupWinter2017_PlayerCard {
  return { accountId: 0, quality: 0 };
}

export const CMsgGCToClientBattlePassRollupWinter2017_PlayerCard = {
  encode(
    message: CMsgGCToClientBattlePassRollupWinter2017_PlayerCard,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.quality !== 0) {
      writer.uint32(16).uint32(message.quality);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupWinter2017_PlayerCard {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupWinter2017_PlayerCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.quality = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupWinter2017_PlayerCard {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      quality: isSet(object.quality) ? Number(object.quality) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupWinter2017_PlayerCard): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.quality !== undefined && (obj.quality = Math.round(message.quality));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupWinter2017_FantasyChallenge(): CMsgGCToClientBattlePassRollupWinter2017_FantasyChallenge {
  return { totalScore: 0, percentile: 0 };
}

export const CMsgGCToClientBattlePassRollupWinter2017_FantasyChallenge = {
  encode(
    message: CMsgGCToClientBattlePassRollupWinter2017_FantasyChallenge,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.totalScore !== 0) {
      writer.uint32(13).float(message.totalScore);
    }
    if (message.percentile !== 0) {
      writer.uint32(21).float(message.percentile);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupWinter2017_FantasyChallenge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupWinter2017_FantasyChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 13) {
            break;
          }

          message.totalScore = reader.float();
          continue;
        case 2:
          if (tag != 21) {
            break;
          }

          message.percentile = reader.float();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupWinter2017_FantasyChallenge {
    return {
      totalScore: isSet(object.totalScore) ? Number(object.totalScore) : 0,
      percentile: isSet(object.percentile) ? Number(object.percentile) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupWinter2017_FantasyChallenge): unknown {
    const obj: any = {};
    message.totalScore !== undefined && (obj.totalScore = message.totalScore);
    message.percentile !== undefined && (obj.percentile = message.percentile);
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupTI7(): CMsgGCToClientBattlePassRollupTI7 {
  return {
    battlePassLevel: 0,
    questlines: [],
    wagering: undefined,
    achievements: undefined,
    battleCup: undefined,
    predictions: undefined,
    bracket: undefined,
    playerCards: [],
    fantasyChallenge: undefined,
  };
}

export const CMsgGCToClientBattlePassRollupTI7 = {
  encode(message: CMsgGCToClientBattlePassRollupTI7, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.battlePassLevel !== 0) {
      writer.uint32(8).uint32(message.battlePassLevel);
    }
    for (const v of message.questlines) {
      CMsgGCToClientBattlePassRollupTI7_Questlines.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.wagering !== undefined) {
      CMsgGCToClientBattlePassRollupTI7_Wagering.encode(message.wagering, writer.uint32(26).fork()).ldelim();
    }
    if (message.achievements !== undefined) {
      CMsgGCToClientBattlePassRollupTI7_Achievements.encode(message.achievements, writer.uint32(34).fork()).ldelim();
    }
    if (message.battleCup !== undefined) {
      CMsgGCToClientBattlePassRollupTI7_BattleCup.encode(message.battleCup, writer.uint32(42).fork()).ldelim();
    }
    if (message.predictions !== undefined) {
      CMsgGCToClientBattlePassRollupTI7_Predictions.encode(message.predictions, writer.uint32(50).fork()).ldelim();
    }
    if (message.bracket !== undefined) {
      CMsgGCToClientBattlePassRollupTI7_Bracket.encode(message.bracket, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.playerCards) {
      CMsgGCToClientBattlePassRollupTI7_PlayerCard.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    if (message.fantasyChallenge !== undefined) {
      CMsgGCToClientBattlePassRollupTI7_FantasyChallenge.encode(message.fantasyChallenge, writer.uint32(74).fork())
        .ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupTI7 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupTI7();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.battlePassLevel = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.questlines.push(CMsgGCToClientBattlePassRollupTI7_Questlines.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.wagering = CMsgGCToClientBattlePassRollupTI7_Wagering.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.achievements = CMsgGCToClientBattlePassRollupTI7_Achievements.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag != 42) {
            break;
          }

          message.battleCup = CMsgGCToClientBattlePassRollupTI7_BattleCup.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }

          message.predictions = CMsgGCToClientBattlePassRollupTI7_Predictions.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag != 58) {
            break;
          }

          message.bracket = CMsgGCToClientBattlePassRollupTI7_Bracket.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag != 66) {
            break;
          }

          message.playerCards.push(CMsgGCToClientBattlePassRollupTI7_PlayerCard.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag != 74) {
            break;
          }

          message.fantasyChallenge = CMsgGCToClientBattlePassRollupTI7_FantasyChallenge.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupTI7 {
    return {
      battlePassLevel: isSet(object.battlePassLevel) ? Number(object.battlePassLevel) : 0,
      questlines: Array.isArray(object?.questlines)
        ? object.questlines.map((e: any) => CMsgGCToClientBattlePassRollupTI7_Questlines.fromJSON(e))
        : [],
      wagering: isSet(object.wagering)
        ? CMsgGCToClientBattlePassRollupTI7_Wagering.fromJSON(object.wagering)
        : undefined,
      achievements: isSet(object.achievements)
        ? CMsgGCToClientBattlePassRollupTI7_Achievements.fromJSON(object.achievements)
        : undefined,
      battleCup: isSet(object.battleCup)
        ? CMsgGCToClientBattlePassRollupTI7_BattleCup.fromJSON(object.battleCup)
        : undefined,
      predictions: isSet(object.predictions)
        ? CMsgGCToClientBattlePassRollupTI7_Predictions.fromJSON(object.predictions)
        : undefined,
      bracket: isSet(object.bracket) ? CMsgGCToClientBattlePassRollupTI7_Bracket.fromJSON(object.bracket) : undefined,
      playerCards: Array.isArray(object?.playerCards)
        ? object.playerCards.map((e: any) => CMsgGCToClientBattlePassRollupTI7_PlayerCard.fromJSON(e))
        : [],
      fantasyChallenge: isSet(object.fantasyChallenge)
        ? CMsgGCToClientBattlePassRollupTI7_FantasyChallenge.fromJSON(object.fantasyChallenge)
        : undefined,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupTI7): unknown {
    const obj: any = {};
    message.battlePassLevel !== undefined && (obj.battlePassLevel = Math.round(message.battlePassLevel));
    if (message.questlines) {
      obj.questlines = message.questlines.map((e) =>
        e ? CMsgGCToClientBattlePassRollupTI7_Questlines.toJSON(e) : undefined
      );
    } else {
      obj.questlines = [];
    }
    message.wagering !== undefined &&
      (obj.wagering = message.wagering
        ? CMsgGCToClientBattlePassRollupTI7_Wagering.toJSON(message.wagering)
        : undefined);
    message.achievements !== undefined && (obj.achievements = message.achievements
      ? CMsgGCToClientBattlePassRollupTI7_Achievements.toJSON(message.achievements)
      : undefined);
    message.battleCup !== undefined && (obj.battleCup = message.battleCup
      ? CMsgGCToClientBattlePassRollupTI7_BattleCup.toJSON(message.battleCup)
      : undefined);
    message.predictions !== undefined && (obj.predictions = message.predictions
      ? CMsgGCToClientBattlePassRollupTI7_Predictions.toJSON(message.predictions)
      : undefined);
    message.bracket !== undefined &&
      (obj.bracket = message.bracket ? CMsgGCToClientBattlePassRollupTI7_Bracket.toJSON(message.bracket) : undefined);
    if (message.playerCards) {
      obj.playerCards = message.playerCards.map((e) =>
        e ? CMsgGCToClientBattlePassRollupTI7_PlayerCard.toJSON(e) : undefined
      );
    } else {
      obj.playerCards = [];
    }
    message.fantasyChallenge !== undefined && (obj.fantasyChallenge = message.fantasyChallenge
      ? CMsgGCToClientBattlePassRollupTI7_FantasyChallenge.toJSON(message.fantasyChallenge)
      : undefined);
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupTI7_Questlines(): CMsgGCToClientBattlePassRollupTI7_Questlines {
  return { name: "", onestar: 0, twostar: 0, threestar: 0, total: 0 };
}

export const CMsgGCToClientBattlePassRollupTI7_Questlines = {
  encode(message: CMsgGCToClientBattlePassRollupTI7_Questlines, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.onestar !== 0) {
      writer.uint32(16).uint32(message.onestar);
    }
    if (message.twostar !== 0) {
      writer.uint32(24).uint32(message.twostar);
    }
    if (message.threestar !== 0) {
      writer.uint32(32).uint32(message.threestar);
    }
    if (message.total !== 0) {
      writer.uint32(40).uint32(message.total);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupTI7_Questlines {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupTI7_Questlines();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.onestar = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.twostar = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.threestar = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.total = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupTI7_Questlines {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      onestar: isSet(object.onestar) ? Number(object.onestar) : 0,
      twostar: isSet(object.twostar) ? Number(object.twostar) : 0,
      threestar: isSet(object.threestar) ? Number(object.threestar) : 0,
      total: isSet(object.total) ? Number(object.total) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupTI7_Questlines): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.onestar !== undefined && (obj.onestar = Math.round(message.onestar));
    message.twostar !== undefined && (obj.twostar = Math.round(message.twostar));
    message.threestar !== undefined && (obj.threestar = Math.round(message.threestar));
    message.total !== undefined && (obj.total = Math.round(message.total));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupTI7_Wagering(): CMsgGCToClientBattlePassRollupTI7_Wagering {
  return { totalWagered: 0, totalWon: 0, averageWon: 0, successRate: 0, totalTips: 0 };
}

export const CMsgGCToClientBattlePassRollupTI7_Wagering = {
  encode(message: CMsgGCToClientBattlePassRollupTI7_Wagering, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.totalWagered !== 0) {
      writer.uint32(8).uint32(message.totalWagered);
    }
    if (message.totalWon !== 0) {
      writer.uint32(16).uint32(message.totalWon);
    }
    if (message.averageWon !== 0) {
      writer.uint32(24).uint32(message.averageWon);
    }
    if (message.successRate !== 0) {
      writer.uint32(32).uint32(message.successRate);
    }
    if (message.totalTips !== 0) {
      writer.uint32(40).uint32(message.totalTips);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupTI7_Wagering {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupTI7_Wagering();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.totalWagered = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.totalWon = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.averageWon = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.successRate = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.totalTips = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupTI7_Wagering {
    return {
      totalWagered: isSet(object.totalWagered) ? Number(object.totalWagered) : 0,
      totalWon: isSet(object.totalWon) ? Number(object.totalWon) : 0,
      averageWon: isSet(object.averageWon) ? Number(object.averageWon) : 0,
      successRate: isSet(object.successRate) ? Number(object.successRate) : 0,
      totalTips: isSet(object.totalTips) ? Number(object.totalTips) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupTI7_Wagering): unknown {
    const obj: any = {};
    message.totalWagered !== undefined && (obj.totalWagered = Math.round(message.totalWagered));
    message.totalWon !== undefined && (obj.totalWon = Math.round(message.totalWon));
    message.averageWon !== undefined && (obj.averageWon = Math.round(message.averageWon));
    message.successRate !== undefined && (obj.successRate = Math.round(message.successRate));
    message.totalTips !== undefined && (obj.totalTips = Math.round(message.totalTips));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupTI7_Achievements(): CMsgGCToClientBattlePassRollupTI7_Achievements {
  return { completed: 0, total: 0, points: 0 };
}

export const CMsgGCToClientBattlePassRollupTI7_Achievements = {
  encode(
    message: CMsgGCToClientBattlePassRollupTI7_Achievements,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.completed !== 0) {
      writer.uint32(8).uint32(message.completed);
    }
    if (message.total !== 0) {
      writer.uint32(16).uint32(message.total);
    }
    if (message.points !== 0) {
      writer.uint32(24).uint32(message.points);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupTI7_Achievements {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupTI7_Achievements();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.completed = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.total = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.points = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupTI7_Achievements {
    return {
      completed: isSet(object.completed) ? Number(object.completed) : 0,
      total: isSet(object.total) ? Number(object.total) : 0,
      points: isSet(object.points) ? Number(object.points) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupTI7_Achievements): unknown {
    const obj: any = {};
    message.completed !== undefined && (obj.completed = Math.round(message.completed));
    message.total !== undefined && (obj.total = Math.round(message.total));
    message.points !== undefined && (obj.points = Math.round(message.points));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupTI7_BattleCup(): CMsgGCToClientBattlePassRollupTI7_BattleCup {
  return { wins: 0, score: 0 };
}

export const CMsgGCToClientBattlePassRollupTI7_BattleCup = {
  encode(message: CMsgGCToClientBattlePassRollupTI7_BattleCup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wins !== 0) {
      writer.uint32(8).uint32(message.wins);
    }
    if (message.score !== 0) {
      writer.uint32(16).uint32(message.score);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupTI7_BattleCup {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupTI7_BattleCup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.wins = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.score = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupTI7_BattleCup {
    return {
      wins: isSet(object.wins) ? Number(object.wins) : 0,
      score: isSet(object.score) ? Number(object.score) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupTI7_BattleCup): unknown {
    const obj: any = {};
    message.wins !== undefined && (obj.wins = Math.round(message.wins));
    message.score !== undefined && (obj.score = Math.round(message.score));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupTI7_Predictions(): CMsgGCToClientBattlePassRollupTI7_Predictions {
  return { correct: 0, total: 0, points: 0 };
}

export const CMsgGCToClientBattlePassRollupTI7_Predictions = {
  encode(message: CMsgGCToClientBattlePassRollupTI7_Predictions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.correct !== 0) {
      writer.uint32(8).uint32(message.correct);
    }
    if (message.total !== 0) {
      writer.uint32(16).uint32(message.total);
    }
    if (message.points !== 0) {
      writer.uint32(24).uint32(message.points);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupTI7_Predictions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupTI7_Predictions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.correct = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.total = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.points = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupTI7_Predictions {
    return {
      correct: isSet(object.correct) ? Number(object.correct) : 0,
      total: isSet(object.total) ? Number(object.total) : 0,
      points: isSet(object.points) ? Number(object.points) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupTI7_Predictions): unknown {
    const obj: any = {};
    message.correct !== undefined && (obj.correct = Math.round(message.correct));
    message.total !== undefined && (obj.total = Math.round(message.total));
    message.points !== undefined && (obj.points = Math.round(message.points));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupTI7_Bracket(): CMsgGCToClientBattlePassRollupTI7_Bracket {
  return { correct: 0, points: 0 };
}

export const CMsgGCToClientBattlePassRollupTI7_Bracket = {
  encode(message: CMsgGCToClientBattlePassRollupTI7_Bracket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.correct !== 0) {
      writer.uint32(8).uint32(message.correct);
    }
    if (message.points !== 0) {
      writer.uint32(16).uint32(message.points);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupTI7_Bracket {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupTI7_Bracket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.correct = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.points = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupTI7_Bracket {
    return {
      correct: isSet(object.correct) ? Number(object.correct) : 0,
      points: isSet(object.points) ? Number(object.points) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupTI7_Bracket): unknown {
    const obj: any = {};
    message.correct !== undefined && (obj.correct = Math.round(message.correct));
    message.points !== undefined && (obj.points = Math.round(message.points));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupTI7_PlayerCard(): CMsgGCToClientBattlePassRollupTI7_PlayerCard {
  return { accountId: 0, quality: 0 };
}

export const CMsgGCToClientBattlePassRollupTI7_PlayerCard = {
  encode(message: CMsgGCToClientBattlePassRollupTI7_PlayerCard, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.quality !== 0) {
      writer.uint32(16).uint32(message.quality);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupTI7_PlayerCard {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupTI7_PlayerCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.quality = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupTI7_PlayerCard {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      quality: isSet(object.quality) ? Number(object.quality) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupTI7_PlayerCard): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.quality !== undefined && (obj.quality = Math.round(message.quality));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupTI7_FantasyChallenge(): CMsgGCToClientBattlePassRollupTI7_FantasyChallenge {
  return { totalScore: 0, percentile: 0 };
}

export const CMsgGCToClientBattlePassRollupTI7_FantasyChallenge = {
  encode(
    message: CMsgGCToClientBattlePassRollupTI7_FantasyChallenge,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.totalScore !== 0) {
      writer.uint32(13).float(message.totalScore);
    }
    if (message.percentile !== 0) {
      writer.uint32(21).float(message.percentile);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupTI7_FantasyChallenge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupTI7_FantasyChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 13) {
            break;
          }

          message.totalScore = reader.float();
          continue;
        case 2:
          if (tag != 21) {
            break;
          }

          message.percentile = reader.float();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupTI7_FantasyChallenge {
    return {
      totalScore: isSet(object.totalScore) ? Number(object.totalScore) : 0,
      percentile: isSet(object.percentile) ? Number(object.percentile) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupTI7_FantasyChallenge): unknown {
    const obj: any = {};
    message.totalScore !== undefined && (obj.totalScore = message.totalScore);
    message.percentile !== undefined && (obj.percentile = message.percentile);
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupTI8(): CMsgGCToClientBattlePassRollupTI8 {
  return {
    battlePassLevel: 0,
    cavernCrawl: undefined,
    wagering: undefined,
    achievements: undefined,
    predictions: undefined,
    bracket: undefined,
    playerCards: [],
    fantasyChallenge: undefined,
  };
}

export const CMsgGCToClientBattlePassRollupTI8 = {
  encode(message: CMsgGCToClientBattlePassRollupTI8, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.battlePassLevel !== 0) {
      writer.uint32(8).uint32(message.battlePassLevel);
    }
    if (message.cavernCrawl !== undefined) {
      CMsgGCToClientBattlePassRollupTI8_CavernCrawl.encode(message.cavernCrawl, writer.uint32(18).fork()).ldelim();
    }
    if (message.wagering !== undefined) {
      CMsgGCToClientBattlePassRollupTI8_Wagering.encode(message.wagering, writer.uint32(26).fork()).ldelim();
    }
    if (message.achievements !== undefined) {
      CMsgGCToClientBattlePassRollupTI8_Achievements.encode(message.achievements, writer.uint32(34).fork()).ldelim();
    }
    if (message.predictions !== undefined) {
      CMsgGCToClientBattlePassRollupTI8_Predictions.encode(message.predictions, writer.uint32(50).fork()).ldelim();
    }
    if (message.bracket !== undefined) {
      CMsgGCToClientBattlePassRollupTI8_Bracket.encode(message.bracket, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.playerCards) {
      CMsgGCToClientBattlePassRollupTI8_PlayerCard.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    if (message.fantasyChallenge !== undefined) {
      CMsgGCToClientBattlePassRollupTI8_FantasyChallenge.encode(message.fantasyChallenge, writer.uint32(74).fork())
        .ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupTI8 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupTI8();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.battlePassLevel = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.cavernCrawl = CMsgGCToClientBattlePassRollupTI8_CavernCrawl.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.wagering = CMsgGCToClientBattlePassRollupTI8_Wagering.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.achievements = CMsgGCToClientBattlePassRollupTI8_Achievements.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }

          message.predictions = CMsgGCToClientBattlePassRollupTI8_Predictions.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag != 58) {
            break;
          }

          message.bracket = CMsgGCToClientBattlePassRollupTI8_Bracket.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag != 66) {
            break;
          }

          message.playerCards.push(CMsgGCToClientBattlePassRollupTI8_PlayerCard.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag != 74) {
            break;
          }

          message.fantasyChallenge = CMsgGCToClientBattlePassRollupTI8_FantasyChallenge.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupTI8 {
    return {
      battlePassLevel: isSet(object.battlePassLevel) ? Number(object.battlePassLevel) : 0,
      cavernCrawl: isSet(object.cavernCrawl)
        ? CMsgGCToClientBattlePassRollupTI8_CavernCrawl.fromJSON(object.cavernCrawl)
        : undefined,
      wagering: isSet(object.wagering)
        ? CMsgGCToClientBattlePassRollupTI8_Wagering.fromJSON(object.wagering)
        : undefined,
      achievements: isSet(object.achievements)
        ? CMsgGCToClientBattlePassRollupTI8_Achievements.fromJSON(object.achievements)
        : undefined,
      predictions: isSet(object.predictions)
        ? CMsgGCToClientBattlePassRollupTI8_Predictions.fromJSON(object.predictions)
        : undefined,
      bracket: isSet(object.bracket) ? CMsgGCToClientBattlePassRollupTI8_Bracket.fromJSON(object.bracket) : undefined,
      playerCards: Array.isArray(object?.playerCards)
        ? object.playerCards.map((e: any) => CMsgGCToClientBattlePassRollupTI8_PlayerCard.fromJSON(e))
        : [],
      fantasyChallenge: isSet(object.fantasyChallenge)
        ? CMsgGCToClientBattlePassRollupTI8_FantasyChallenge.fromJSON(object.fantasyChallenge)
        : undefined,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupTI8): unknown {
    const obj: any = {};
    message.battlePassLevel !== undefined && (obj.battlePassLevel = Math.round(message.battlePassLevel));
    message.cavernCrawl !== undefined && (obj.cavernCrawl = message.cavernCrawl
      ? CMsgGCToClientBattlePassRollupTI8_CavernCrawl.toJSON(message.cavernCrawl)
      : undefined);
    message.wagering !== undefined &&
      (obj.wagering = message.wagering
        ? CMsgGCToClientBattlePassRollupTI8_Wagering.toJSON(message.wagering)
        : undefined);
    message.achievements !== undefined && (obj.achievements = message.achievements
      ? CMsgGCToClientBattlePassRollupTI8_Achievements.toJSON(message.achievements)
      : undefined);
    message.predictions !== undefined && (obj.predictions = message.predictions
      ? CMsgGCToClientBattlePassRollupTI8_Predictions.toJSON(message.predictions)
      : undefined);
    message.bracket !== undefined &&
      (obj.bracket = message.bracket ? CMsgGCToClientBattlePassRollupTI8_Bracket.toJSON(message.bracket) : undefined);
    if (message.playerCards) {
      obj.playerCards = message.playerCards.map((e) =>
        e ? CMsgGCToClientBattlePassRollupTI8_PlayerCard.toJSON(e) : undefined
      );
    } else {
      obj.playerCards = [];
    }
    message.fantasyChallenge !== undefined && (obj.fantasyChallenge = message.fantasyChallenge
      ? CMsgGCToClientBattlePassRollupTI8_FantasyChallenge.toJSON(message.fantasyChallenge)
      : undefined);
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupTI8_CavernCrawl(): CMsgGCToClientBattlePassRollupTI8_CavernCrawl {
  return { roomsCleared: 0, carryCompleted: false, supportCompleted: false, utilityCompleted: false };
}

export const CMsgGCToClientBattlePassRollupTI8_CavernCrawl = {
  encode(message: CMsgGCToClientBattlePassRollupTI8_CavernCrawl, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.roomsCleared !== 0) {
      writer.uint32(8).uint32(message.roomsCleared);
    }
    if (message.carryCompleted === true) {
      writer.uint32(16).bool(message.carryCompleted);
    }
    if (message.supportCompleted === true) {
      writer.uint32(24).bool(message.supportCompleted);
    }
    if (message.utilityCompleted === true) {
      writer.uint32(32).bool(message.utilityCompleted);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupTI8_CavernCrawl {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupTI8_CavernCrawl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.roomsCleared = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.carryCompleted = reader.bool();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.supportCompleted = reader.bool();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.utilityCompleted = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupTI8_CavernCrawl {
    return {
      roomsCleared: isSet(object.roomsCleared) ? Number(object.roomsCleared) : 0,
      carryCompleted: isSet(object.carryCompleted) ? Boolean(object.carryCompleted) : false,
      supportCompleted: isSet(object.supportCompleted) ? Boolean(object.supportCompleted) : false,
      utilityCompleted: isSet(object.utilityCompleted) ? Boolean(object.utilityCompleted) : false,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupTI8_CavernCrawl): unknown {
    const obj: any = {};
    message.roomsCleared !== undefined && (obj.roomsCleared = Math.round(message.roomsCleared));
    message.carryCompleted !== undefined && (obj.carryCompleted = message.carryCompleted);
    message.supportCompleted !== undefined && (obj.supportCompleted = message.supportCompleted);
    message.utilityCompleted !== undefined && (obj.utilityCompleted = message.utilityCompleted);
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupTI8_Wagering(): CMsgGCToClientBattlePassRollupTI8_Wagering {
  return { totalWagered: 0, totalWon: 0, averageWon: 0, successRate: 0, totalTips: 0 };
}

export const CMsgGCToClientBattlePassRollupTI8_Wagering = {
  encode(message: CMsgGCToClientBattlePassRollupTI8_Wagering, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.totalWagered !== 0) {
      writer.uint32(8).uint32(message.totalWagered);
    }
    if (message.totalWon !== 0) {
      writer.uint32(16).uint32(message.totalWon);
    }
    if (message.averageWon !== 0) {
      writer.uint32(24).uint32(message.averageWon);
    }
    if (message.successRate !== 0) {
      writer.uint32(32).uint32(message.successRate);
    }
    if (message.totalTips !== 0) {
      writer.uint32(40).uint32(message.totalTips);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupTI8_Wagering {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupTI8_Wagering();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.totalWagered = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.totalWon = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.averageWon = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.successRate = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.totalTips = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupTI8_Wagering {
    return {
      totalWagered: isSet(object.totalWagered) ? Number(object.totalWagered) : 0,
      totalWon: isSet(object.totalWon) ? Number(object.totalWon) : 0,
      averageWon: isSet(object.averageWon) ? Number(object.averageWon) : 0,
      successRate: isSet(object.successRate) ? Number(object.successRate) : 0,
      totalTips: isSet(object.totalTips) ? Number(object.totalTips) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupTI8_Wagering): unknown {
    const obj: any = {};
    message.totalWagered !== undefined && (obj.totalWagered = Math.round(message.totalWagered));
    message.totalWon !== undefined && (obj.totalWon = Math.round(message.totalWon));
    message.averageWon !== undefined && (obj.averageWon = Math.round(message.averageWon));
    message.successRate !== undefined && (obj.successRate = Math.round(message.successRate));
    message.totalTips !== undefined && (obj.totalTips = Math.round(message.totalTips));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupTI8_Achievements(): CMsgGCToClientBattlePassRollupTI8_Achievements {
  return { completed: 0, total: 0, points: 0 };
}

export const CMsgGCToClientBattlePassRollupTI8_Achievements = {
  encode(
    message: CMsgGCToClientBattlePassRollupTI8_Achievements,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.completed !== 0) {
      writer.uint32(8).uint32(message.completed);
    }
    if (message.total !== 0) {
      writer.uint32(16).uint32(message.total);
    }
    if (message.points !== 0) {
      writer.uint32(24).uint32(message.points);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupTI8_Achievements {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupTI8_Achievements();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.completed = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.total = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.points = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupTI8_Achievements {
    return {
      completed: isSet(object.completed) ? Number(object.completed) : 0,
      total: isSet(object.total) ? Number(object.total) : 0,
      points: isSet(object.points) ? Number(object.points) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupTI8_Achievements): unknown {
    const obj: any = {};
    message.completed !== undefined && (obj.completed = Math.round(message.completed));
    message.total !== undefined && (obj.total = Math.round(message.total));
    message.points !== undefined && (obj.points = Math.round(message.points));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupTI8_Predictions(): CMsgGCToClientBattlePassRollupTI8_Predictions {
  return { correct: 0, total: 0, points: 0 };
}

export const CMsgGCToClientBattlePassRollupTI8_Predictions = {
  encode(message: CMsgGCToClientBattlePassRollupTI8_Predictions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.correct !== 0) {
      writer.uint32(8).uint32(message.correct);
    }
    if (message.total !== 0) {
      writer.uint32(16).uint32(message.total);
    }
    if (message.points !== 0) {
      writer.uint32(24).uint32(message.points);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupTI8_Predictions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupTI8_Predictions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.correct = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.total = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.points = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupTI8_Predictions {
    return {
      correct: isSet(object.correct) ? Number(object.correct) : 0,
      total: isSet(object.total) ? Number(object.total) : 0,
      points: isSet(object.points) ? Number(object.points) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupTI8_Predictions): unknown {
    const obj: any = {};
    message.correct !== undefined && (obj.correct = Math.round(message.correct));
    message.total !== undefined && (obj.total = Math.round(message.total));
    message.points !== undefined && (obj.points = Math.round(message.points));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupTI8_Bracket(): CMsgGCToClientBattlePassRollupTI8_Bracket {
  return { correct: 0, points: 0 };
}

export const CMsgGCToClientBattlePassRollupTI8_Bracket = {
  encode(message: CMsgGCToClientBattlePassRollupTI8_Bracket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.correct !== 0) {
      writer.uint32(8).uint32(message.correct);
    }
    if (message.points !== 0) {
      writer.uint32(16).uint32(message.points);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupTI8_Bracket {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupTI8_Bracket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.correct = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.points = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupTI8_Bracket {
    return {
      correct: isSet(object.correct) ? Number(object.correct) : 0,
      points: isSet(object.points) ? Number(object.points) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupTI8_Bracket): unknown {
    const obj: any = {};
    message.correct !== undefined && (obj.correct = Math.round(message.correct));
    message.points !== undefined && (obj.points = Math.round(message.points));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupTI8_PlayerCard(): CMsgGCToClientBattlePassRollupTI8_PlayerCard {
  return { accountId: 0, quality: 0 };
}

export const CMsgGCToClientBattlePassRollupTI8_PlayerCard = {
  encode(message: CMsgGCToClientBattlePassRollupTI8_PlayerCard, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.quality !== 0) {
      writer.uint32(16).uint32(message.quality);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupTI8_PlayerCard {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupTI8_PlayerCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.quality = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupTI8_PlayerCard {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      quality: isSet(object.quality) ? Number(object.quality) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupTI8_PlayerCard): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.quality !== undefined && (obj.quality = Math.round(message.quality));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupTI8_FantasyChallenge(): CMsgGCToClientBattlePassRollupTI8_FantasyChallenge {
  return { totalScore: 0, percentile: 0 };
}

export const CMsgGCToClientBattlePassRollupTI8_FantasyChallenge = {
  encode(
    message: CMsgGCToClientBattlePassRollupTI8_FantasyChallenge,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.totalScore !== 0) {
      writer.uint32(13).float(message.totalScore);
    }
    if (message.percentile !== 0) {
      writer.uint32(21).float(message.percentile);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupTI8_FantasyChallenge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupTI8_FantasyChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 13) {
            break;
          }

          message.totalScore = reader.float();
          continue;
        case 2:
          if (tag != 21) {
            break;
          }

          message.percentile = reader.float();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupTI8_FantasyChallenge {
    return {
      totalScore: isSet(object.totalScore) ? Number(object.totalScore) : 0,
      percentile: isSet(object.percentile) ? Number(object.percentile) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupTI8_FantasyChallenge): unknown {
    const obj: any = {};
    message.totalScore !== undefined && (obj.totalScore = message.totalScore);
    message.percentile !== undefined && (obj.percentile = message.percentile);
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupTI9(): CMsgGCToClientBattlePassRollupTI9 {
  return { battlePassLevel: 0 };
}

export const CMsgGCToClientBattlePassRollupTI9 = {
  encode(message: CMsgGCToClientBattlePassRollupTI9, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.battlePassLevel !== 0) {
      writer.uint32(8).uint32(message.battlePassLevel);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupTI9 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupTI9();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.battlePassLevel = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupTI9 {
    return { battlePassLevel: isSet(object.battlePassLevel) ? Number(object.battlePassLevel) : 0 };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupTI9): unknown {
    const obj: any = {};
    message.battlePassLevel !== undefined && (obj.battlePassLevel = Math.round(message.battlePassLevel));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupTI10(): CMsgGCToClientBattlePassRollupTI10 {
  return { battlePassLevel: 0 };
}

export const CMsgGCToClientBattlePassRollupTI10 = {
  encode(message: CMsgGCToClientBattlePassRollupTI10, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.battlePassLevel !== 0) {
      writer.uint32(8).uint32(message.battlePassLevel);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupTI10 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupTI10();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.battlePassLevel = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupTI10 {
    return { battlePassLevel: isSet(object.battlePassLevel) ? Number(object.battlePassLevel) : 0 };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupTI10): unknown {
    const obj: any = {};
    message.battlePassLevel !== undefined && (obj.battlePassLevel = Math.round(message.battlePassLevel));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupRequest(): CMsgGCToClientBattlePassRollupRequest {
  return { eventId: 0, accountId: 0 };
}

export const CMsgGCToClientBattlePassRollupRequest = {
  encode(message: CMsgGCToClientBattlePassRollupRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    if (message.accountId !== 0) {
      writer.uint32(16).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupRequest {
    return {
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupRequest): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupResponse(): CMsgGCToClientBattlePassRollupResponse {
  return {
    eventTi6: undefined,
    eventFall2016: undefined,
    eventWinter2017: undefined,
    eventTi7: undefined,
    eventTi8: undefined,
    eventTi9: undefined,
    eventTi10: undefined,
  };
}

export const CMsgGCToClientBattlePassRollupResponse = {
  encode(message: CMsgGCToClientBattlePassRollupResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventTi6 !== undefined) {
      CMsgGCToClientBattlePassRollupInternational2016.encode(message.eventTi6, writer.uint32(10).fork()).ldelim();
    }
    if (message.eventFall2016 !== undefined) {
      CMsgGCToClientBattlePassRollupFall2016.encode(message.eventFall2016, writer.uint32(18).fork()).ldelim();
    }
    if (message.eventWinter2017 !== undefined) {
      CMsgGCToClientBattlePassRollupWinter2017.encode(message.eventWinter2017, writer.uint32(26).fork()).ldelim();
    }
    if (message.eventTi7 !== undefined) {
      CMsgGCToClientBattlePassRollupTI7.encode(message.eventTi7, writer.uint32(34).fork()).ldelim();
    }
    if (message.eventTi8 !== undefined) {
      CMsgGCToClientBattlePassRollupTI8.encode(message.eventTi8, writer.uint32(42).fork()).ldelim();
    }
    if (message.eventTi9 !== undefined) {
      CMsgGCToClientBattlePassRollupTI9.encode(message.eventTi9, writer.uint32(50).fork()).ldelim();
    }
    if (message.eventTi10 !== undefined) {
      CMsgGCToClientBattlePassRollupTI10.encode(message.eventTi10, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.eventTi6 = CMsgGCToClientBattlePassRollupInternational2016.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.eventFall2016 = CMsgGCToClientBattlePassRollupFall2016.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.eventWinter2017 = CMsgGCToClientBattlePassRollupWinter2017.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.eventTi7 = CMsgGCToClientBattlePassRollupTI7.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag != 42) {
            break;
          }

          message.eventTi8 = CMsgGCToClientBattlePassRollupTI8.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }

          message.eventTi9 = CMsgGCToClientBattlePassRollupTI9.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag != 58) {
            break;
          }

          message.eventTi10 = CMsgGCToClientBattlePassRollupTI10.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupResponse {
    return {
      eventTi6: isSet(object.eventTi6)
        ? CMsgGCToClientBattlePassRollupInternational2016.fromJSON(object.eventTi6)
        : undefined,
      eventFall2016: isSet(object.eventFall2016)
        ? CMsgGCToClientBattlePassRollupFall2016.fromJSON(object.eventFall2016)
        : undefined,
      eventWinter2017: isSet(object.eventWinter2017)
        ? CMsgGCToClientBattlePassRollupWinter2017.fromJSON(object.eventWinter2017)
        : undefined,
      eventTi7: isSet(object.eventTi7) ? CMsgGCToClientBattlePassRollupTI7.fromJSON(object.eventTi7) : undefined,
      eventTi8: isSet(object.eventTi8) ? CMsgGCToClientBattlePassRollupTI8.fromJSON(object.eventTi8) : undefined,
      eventTi9: isSet(object.eventTi9) ? CMsgGCToClientBattlePassRollupTI9.fromJSON(object.eventTi9) : undefined,
      eventTi10: isSet(object.eventTi10) ? CMsgGCToClientBattlePassRollupTI10.fromJSON(object.eventTi10) : undefined,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupResponse): unknown {
    const obj: any = {};
    message.eventTi6 !== undefined && (obj.eventTi6 = message.eventTi6
      ? CMsgGCToClientBattlePassRollupInternational2016.toJSON(message.eventTi6)
      : undefined);
    message.eventFall2016 !== undefined && (obj.eventFall2016 = message.eventFall2016
      ? CMsgGCToClientBattlePassRollupFall2016.toJSON(message.eventFall2016)
      : undefined);
    message.eventWinter2017 !== undefined && (obj.eventWinter2017 = message.eventWinter2017
      ? CMsgGCToClientBattlePassRollupWinter2017.toJSON(message.eventWinter2017)
      : undefined);
    message.eventTi7 !== undefined &&
      (obj.eventTi7 = message.eventTi7 ? CMsgGCToClientBattlePassRollupTI7.toJSON(message.eventTi7) : undefined);
    message.eventTi8 !== undefined &&
      (obj.eventTi8 = message.eventTi8 ? CMsgGCToClientBattlePassRollupTI8.toJSON(message.eventTi8) : undefined);
    message.eventTi9 !== undefined &&
      (obj.eventTi9 = message.eventTi9 ? CMsgGCToClientBattlePassRollupTI9.toJSON(message.eventTi9) : undefined);
    message.eventTi10 !== undefined &&
      (obj.eventTi10 = message.eventTi10 ? CMsgGCToClientBattlePassRollupTI10.toJSON(message.eventTi10) : undefined);
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupListRequest(): CMsgGCToClientBattlePassRollupListRequest {
  return { accountId: 0 };
}

export const CMsgGCToClientBattlePassRollupListRequest = {
  encode(message: CMsgGCToClientBattlePassRollupListRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupListRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupListRequest {
    return { accountId: isSet(object.accountId) ? Number(object.accountId) : 0 };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupListRequest): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupListResponse(): CMsgGCToClientBattlePassRollupListResponse {
  return { eventInfo: [] };
}

export const CMsgGCToClientBattlePassRollupListResponse = {
  encode(message: CMsgGCToClientBattlePassRollupListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.eventInfo) {
      CMsgGCToClientBattlePassRollupListResponse_EventInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupListResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.eventInfo.push(CMsgGCToClientBattlePassRollupListResponse_EventInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupListResponse {
    return {
      eventInfo: Array.isArray(object?.eventInfo)
        ? object.eventInfo.map((e: any) => CMsgGCToClientBattlePassRollupListResponse_EventInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupListResponse): unknown {
    const obj: any = {};
    if (message.eventInfo) {
      obj.eventInfo = message.eventInfo.map((e) =>
        e ? CMsgGCToClientBattlePassRollupListResponse_EventInfo.toJSON(e) : undefined
      );
    } else {
      obj.eventInfo = [];
    }
    return obj;
  },
};

function createBaseCMsgGCToClientBattlePassRollupListResponse_EventInfo(): CMsgGCToClientBattlePassRollupListResponse_EventInfo {
  return { eventId: 0, level: 0 };
}

export const CMsgGCToClientBattlePassRollupListResponse_EventInfo = {
  encode(
    message: CMsgGCToClientBattlePassRollupListResponse_EventInfo,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    if (message.level !== 0) {
      writer.uint32(16).uint32(message.level);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientBattlePassRollupListResponse_EventInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientBattlePassRollupListResponse_EventInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.level = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientBattlePassRollupListResponse_EventInfo {
    return {
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      level: isSet(object.level) ? Number(object.level) : 0,
    };
  },

  toJSON(message: CMsgGCToClientBattlePassRollupListResponse_EventInfo): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.level !== undefined && (obj.level = Math.round(message.level));
    return obj;
  },
};

function createBaseCMsgClientToGCTransferSeasonalMMRRequest(): CMsgClientToGCTransferSeasonalMMRRequest {
  return { isParty: false };
}

export const CMsgClientToGCTransferSeasonalMMRRequest = {
  encode(message: CMsgClientToGCTransferSeasonalMMRRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.isParty === true) {
      writer.uint32(8).bool(message.isParty);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCTransferSeasonalMMRRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCTransferSeasonalMMRRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.isParty = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCTransferSeasonalMMRRequest {
    return { isParty: isSet(object.isParty) ? Boolean(object.isParty) : false };
  },

  toJSON(message: CMsgClientToGCTransferSeasonalMMRRequest): unknown {
    const obj: any = {};
    message.isParty !== undefined && (obj.isParty = message.isParty);
    return obj;
  },
};

function createBaseCMsgClientToGCTransferSeasonalMMRResponse(): CMsgClientToGCTransferSeasonalMMRResponse {
  return { success: false };
}

export const CMsgClientToGCTransferSeasonalMMRResponse = {
  encode(message: CMsgClientToGCTransferSeasonalMMRResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success === true) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCTransferSeasonalMMRResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCTransferSeasonalMMRResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCTransferSeasonalMMRResponse {
    return { success: isSet(object.success) ? Boolean(object.success) : false };
  },

  toJSON(message: CMsgClientToGCTransferSeasonalMMRResponse): unknown {
    const obj: any = {};
    message.success !== undefined && (obj.success = message.success);
    return obj;
  },
};

function createBaseCMsgGCToClientPlaytestStatus(): CMsgGCToClientPlaytestStatus {
  return { active: false };
}

export const CMsgGCToClientPlaytestStatus = {
  encode(message: CMsgGCToClientPlaytestStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.active === true) {
      writer.uint32(8).bool(message.active);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientPlaytestStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientPlaytestStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.active = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientPlaytestStatus {
    return { active: isSet(object.active) ? Boolean(object.active) : false };
  },

  toJSON(message: CMsgGCToClientPlaytestStatus): unknown {
    const obj: any = {};
    message.active !== undefined && (obj.active = message.active);
    return obj;
  },
};

function createBaseCMsgClientToGCJoinPlaytest(): CMsgClientToGCJoinPlaytest {
  return { clientVersion: 0 };
}

export const CMsgClientToGCJoinPlaytest = {
  encode(message: CMsgClientToGCJoinPlaytest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientVersion !== 0) {
      writer.uint32(8).uint32(message.clientVersion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCJoinPlaytest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCJoinPlaytest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.clientVersion = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCJoinPlaytest {
    return { clientVersion: isSet(object.clientVersion) ? Number(object.clientVersion) : 0 };
  },

  toJSON(message: CMsgClientToGCJoinPlaytest): unknown {
    const obj: any = {};
    message.clientVersion !== undefined && (obj.clientVersion = Math.round(message.clientVersion));
    return obj;
  },
};

function createBaseCMsgClientToGCJoinPlaytestResponse(): CMsgClientToGCJoinPlaytestResponse {
  return { error: "" };
}

export const CMsgClientToGCJoinPlaytestResponse = {
  encode(message: CMsgClientToGCJoinPlaytestResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.error !== "") {
      writer.uint32(10).string(message.error);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCJoinPlaytestResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCJoinPlaytestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.error = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCJoinPlaytestResponse {
    return { error: isSet(object.error) ? String(object.error) : "" };
  },

  toJSON(message: CMsgClientToGCJoinPlaytestResponse): unknown {
    const obj: any = {};
    message.error !== undefined && (obj.error = message.error);
    return obj;
  },
};

function createBaseCMsgDOTASetFavoriteTeam(): CMsgDOTASetFavoriteTeam {
  return { teamId: 0, eventId: 0 };
}

export const CMsgDOTASetFavoriteTeam = {
  encode(message: CMsgDOTASetFavoriteTeam, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.teamId !== 0) {
      writer.uint32(8).uint32(message.teamId);
    }
    if (message.eventId !== 0) {
      writer.uint32(16).uint32(message.eventId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASetFavoriteTeam {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASetFavoriteTeam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASetFavoriteTeam {
    return {
      teamId: isSet(object.teamId) ? Number(object.teamId) : 0,
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
    };
  },

  toJSON(message: CMsgDOTASetFavoriteTeam): unknown {
    const obj: any = {};
    message.teamId !== undefined && (obj.teamId = Math.round(message.teamId));
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    return obj;
  },
};

function createBaseCMsgDOTATriviaCurrentQuestions(): CMsgDOTATriviaCurrentQuestions {
  return { questions: [], triviaEnabled: false };
}

export const CMsgDOTATriviaCurrentQuestions = {
  encode(message: CMsgDOTATriviaCurrentQuestions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.questions) {
      CMsgDOTATriviaQuestion.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.triviaEnabled === true) {
      writer.uint32(16).bool(message.triviaEnabled);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTATriviaCurrentQuestions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTATriviaCurrentQuestions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.questions.push(CMsgDOTATriviaQuestion.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.triviaEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTATriviaCurrentQuestions {
    return {
      questions: Array.isArray(object?.questions)
        ? object.questions.map((e: any) => CMsgDOTATriviaQuestion.fromJSON(e))
        : [],
      triviaEnabled: isSet(object.triviaEnabled) ? Boolean(object.triviaEnabled) : false,
    };
  },

  toJSON(message: CMsgDOTATriviaCurrentQuestions): unknown {
    const obj: any = {};
    if (message.questions) {
      obj.questions = message.questions.map((e) => e ? CMsgDOTATriviaQuestion.toJSON(e) : undefined);
    } else {
      obj.questions = [];
    }
    message.triviaEnabled !== undefined && (obj.triviaEnabled = message.triviaEnabled);
    return obj;
  },
};

function createBaseCMsgDOTASubmitTriviaQuestionAnswer(): CMsgDOTASubmitTriviaQuestionAnswer {
  return { questionId: 0, answerIndex: 0 };
}

export const CMsgDOTASubmitTriviaQuestionAnswer = {
  encode(message: CMsgDOTASubmitTriviaQuestionAnswer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.questionId !== 0) {
      writer.uint32(8).uint32(message.questionId);
    }
    if (message.answerIndex !== 0) {
      writer.uint32(16).uint32(message.answerIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASubmitTriviaQuestionAnswer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASubmitTriviaQuestionAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.questionId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.answerIndex = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASubmitTriviaQuestionAnswer {
    return {
      questionId: isSet(object.questionId) ? Number(object.questionId) : 0,
      answerIndex: isSet(object.answerIndex) ? Number(object.answerIndex) : 0,
    };
  },

  toJSON(message: CMsgDOTASubmitTriviaQuestionAnswer): unknown {
    const obj: any = {};
    message.questionId !== undefined && (obj.questionId = Math.round(message.questionId));
    message.answerIndex !== undefined && (obj.answerIndex = Math.round(message.answerIndex));
    return obj;
  },
};

function createBaseCMsgDOTASubmitTriviaQuestionAnswerResponse(): CMsgDOTASubmitTriviaQuestionAnswerResponse {
  return { result: 0 };
}

export const CMsgDOTASubmitTriviaQuestionAnswerResponse = {
  encode(message: CMsgDOTASubmitTriviaQuestionAnswerResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASubmitTriviaQuestionAnswerResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASubmitTriviaQuestionAnswerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASubmitTriviaQuestionAnswerResponse {
    return { result: isSet(object.result) ? eDOTATriviaAnswerResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgDOTASubmitTriviaQuestionAnswerResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = eDOTATriviaAnswerResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgDOTAStartTriviaSession(): CMsgDOTAStartTriviaSession {
  return {};
}

export const CMsgDOTAStartTriviaSession = {
  encode(_: CMsgDOTAStartTriviaSession, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAStartTriviaSession {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAStartTriviaSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgDOTAStartTriviaSession {
    return {};
  },

  toJSON(_: CMsgDOTAStartTriviaSession): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgDOTAStartTriviaSessionResponse(): CMsgDOTAStartTriviaSessionResponse {
  return { triviaEnabled: false, currentTimestamp: 0 };
}

export const CMsgDOTAStartTriviaSessionResponse = {
  encode(message: CMsgDOTAStartTriviaSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.triviaEnabled === true) {
      writer.uint32(8).bool(message.triviaEnabled);
    }
    if (message.currentTimestamp !== 0) {
      writer.uint32(16).uint32(message.currentTimestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAStartTriviaSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAStartTriviaSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.triviaEnabled = reader.bool();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.currentTimestamp = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAStartTriviaSessionResponse {
    return {
      triviaEnabled: isSet(object.triviaEnabled) ? Boolean(object.triviaEnabled) : false,
      currentTimestamp: isSet(object.currentTimestamp) ? Number(object.currentTimestamp) : 0,
    };
  },

  toJSON(message: CMsgDOTAStartTriviaSessionResponse): unknown {
    const obj: any = {};
    message.triviaEnabled !== undefined && (obj.triviaEnabled = message.triviaEnabled);
    message.currentTimestamp !== undefined && (obj.currentTimestamp = Math.round(message.currentTimestamp));
    return obj;
  },
};

function createBaseCMsgDOTAAnchorPhoneNumberRequest(): CMsgDOTAAnchorPhoneNumberRequest {
  return {};
}

export const CMsgDOTAAnchorPhoneNumberRequest = {
  encode(_: CMsgDOTAAnchorPhoneNumberRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAAnchorPhoneNumberRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAAnchorPhoneNumberRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgDOTAAnchorPhoneNumberRequest {
    return {};
  },

  toJSON(_: CMsgDOTAAnchorPhoneNumberRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgDOTAAnchorPhoneNumberResponse(): CMsgDOTAAnchorPhoneNumberResponse {
  return { result: 0 };
}

export const CMsgDOTAAnchorPhoneNumberResponse = {
  encode(message: CMsgDOTAAnchorPhoneNumberResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAAnchorPhoneNumberResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAAnchorPhoneNumberResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAAnchorPhoneNumberResponse {
    return { result: isSet(object.result) ? cMsgDOTAAnchorPhoneNumberResponse_ResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgDOTAAnchorPhoneNumberResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = cMsgDOTAAnchorPhoneNumberResponse_ResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgDOTAUnanchorPhoneNumberRequest(): CMsgDOTAUnanchorPhoneNumberRequest {
  return {};
}

export const CMsgDOTAUnanchorPhoneNumberRequest = {
  encode(_: CMsgDOTAUnanchorPhoneNumberRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAUnanchorPhoneNumberRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAUnanchorPhoneNumberRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgDOTAUnanchorPhoneNumberRequest {
    return {};
  },

  toJSON(_: CMsgDOTAUnanchorPhoneNumberRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgDOTAUnanchorPhoneNumberResponse(): CMsgDOTAUnanchorPhoneNumberResponse {
  return { result: 0 };
}

export const CMsgDOTAUnanchorPhoneNumberResponse = {
  encode(message: CMsgDOTAUnanchorPhoneNumberResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAUnanchorPhoneNumberResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAUnanchorPhoneNumberResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAUnanchorPhoneNumberResponse {
    return { result: isSet(object.result) ? cMsgDOTAUnanchorPhoneNumberResponse_ResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgDOTAUnanchorPhoneNumberResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = cMsgDOTAUnanchorPhoneNumberResponse_ResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgGCToClientCommendNotification(): CMsgGCToClientCommendNotification {
  return { commenderAccountId: 0, commenderName: "", flags: 0 };
}

export const CMsgGCToClientCommendNotification = {
  encode(message: CMsgGCToClientCommendNotification, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.commenderAccountId !== 0) {
      writer.uint32(8).uint32(message.commenderAccountId);
    }
    if (message.commenderName !== "") {
      writer.uint32(18).string(message.commenderName);
    }
    if (message.flags !== 0) {
      writer.uint32(24).uint32(message.flags);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientCommendNotification {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientCommendNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.commenderAccountId = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.commenderName = reader.string();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.flags = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientCommendNotification {
    return {
      commenderAccountId: isSet(object.commenderAccountId) ? Number(object.commenderAccountId) : 0,
      commenderName: isSet(object.commenderName) ? String(object.commenderName) : "",
      flags: isSet(object.flags) ? Number(object.flags) : 0,
    };
  },

  toJSON(message: CMsgGCToClientCommendNotification): unknown {
    const obj: any = {};
    message.commenderAccountId !== undefined && (obj.commenderAccountId = Math.round(message.commenderAccountId));
    message.commenderName !== undefined && (obj.commenderName = message.commenderName);
    message.flags !== undefined && (obj.flags = Math.round(message.flags));
    return obj;
  },
};

function createBaseCMsgDOTAClientToGCQuickStatsRequest(): CMsgDOTAClientToGCQuickStatsRequest {
  return { playerAccountId: 0, heroId: 0, itemId: 0, leagueId: 0 };
}

export const CMsgDOTAClientToGCQuickStatsRequest = {
  encode(message: CMsgDOTAClientToGCQuickStatsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerAccountId !== 0) {
      writer.uint32(8).uint32(message.playerAccountId);
    }
    if (message.heroId !== 0) {
      writer.uint32(16).uint32(message.heroId);
    }
    if (message.itemId !== 0) {
      writer.uint32(24).int32(message.itemId);
    }
    if (message.leagueId !== 0) {
      writer.uint32(32).uint32(message.leagueId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAClientToGCQuickStatsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAClientToGCQuickStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.playerAccountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.itemId = reader.int32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAClientToGCQuickStatsRequest {
    return {
      playerAccountId: isSet(object.playerAccountId) ? Number(object.playerAccountId) : 0,
      heroId: isSet(object.heroId) ? Number(object.heroId) : 0,
      itemId: isSet(object.itemId) ? Number(object.itemId) : 0,
      leagueId: isSet(object.leagueId) ? Number(object.leagueId) : 0,
    };
  },

  toJSON(message: CMsgDOTAClientToGCQuickStatsRequest): unknown {
    const obj: any = {};
    message.playerAccountId !== undefined && (obj.playerAccountId = Math.round(message.playerAccountId));
    message.heroId !== undefined && (obj.heroId = Math.round(message.heroId));
    message.itemId !== undefined && (obj.itemId = Math.round(message.itemId));
    message.leagueId !== undefined && (obj.leagueId = Math.round(message.leagueId));
    return obj;
  },
};

function createBaseCMsgDOTAClientToGCQuickStatsResponse(): CMsgDOTAClientToGCQuickStatsResponse {
  return {
    originalRequest: undefined,
    heroStats: undefined,
    itemStats: undefined,
    itemHeroStats: undefined,
    itemPlayerStats: undefined,
    heroPlayerStats: undefined,
    fullSetStats: undefined,
  };
}

export const CMsgDOTAClientToGCQuickStatsResponse = {
  encode(message: CMsgDOTAClientToGCQuickStatsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.originalRequest !== undefined) {
      CMsgDOTAClientToGCQuickStatsRequest.encode(message.originalRequest, writer.uint32(10).fork()).ldelim();
    }
    if (message.heroStats !== undefined) {
      CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.encode(message.heroStats, writer.uint32(18).fork()).ldelim();
    }
    if (message.itemStats !== undefined) {
      CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.encode(message.itemStats, writer.uint32(26).fork()).ldelim();
    }
    if (message.itemHeroStats !== undefined) {
      CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.encode(message.itemHeroStats, writer.uint32(34).fork()).ldelim();
    }
    if (message.itemPlayerStats !== undefined) {
      CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.encode(message.itemPlayerStats, writer.uint32(42).fork())
        .ldelim();
    }
    if (message.heroPlayerStats !== undefined) {
      CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.encode(message.heroPlayerStats, writer.uint32(50).fork())
        .ldelim();
    }
    if (message.fullSetStats !== undefined) {
      CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.encode(message.fullSetStats, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAClientToGCQuickStatsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAClientToGCQuickStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.originalRequest = CMsgDOTAClientToGCQuickStatsRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.heroStats = CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.itemStats = CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.itemHeroStats = CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag != 42) {
            break;
          }

          message.itemPlayerStats = CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }

          message.heroPlayerStats = CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag != 58) {
            break;
          }

          message.fullSetStats = CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAClientToGCQuickStatsResponse {
    return {
      originalRequest: isSet(object.originalRequest)
        ? CMsgDOTAClientToGCQuickStatsRequest.fromJSON(object.originalRequest)
        : undefined,
      heroStats: isSet(object.heroStats)
        ? CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.fromJSON(object.heroStats)
        : undefined,
      itemStats: isSet(object.itemStats)
        ? CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.fromJSON(object.itemStats)
        : undefined,
      itemHeroStats: isSet(object.itemHeroStats)
        ? CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.fromJSON(object.itemHeroStats)
        : undefined,
      itemPlayerStats: isSet(object.itemPlayerStats)
        ? CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.fromJSON(object.itemPlayerStats)
        : undefined,
      heroPlayerStats: isSet(object.heroPlayerStats)
        ? CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.fromJSON(object.heroPlayerStats)
        : undefined,
      fullSetStats: isSet(object.fullSetStats)
        ? CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.fromJSON(object.fullSetStats)
        : undefined,
    };
  },

  toJSON(message: CMsgDOTAClientToGCQuickStatsResponse): unknown {
    const obj: any = {};
    message.originalRequest !== undefined && (obj.originalRequest = message.originalRequest
      ? CMsgDOTAClientToGCQuickStatsRequest.toJSON(message.originalRequest)
      : undefined);
    message.heroStats !== undefined && (obj.heroStats = message.heroStats
      ? CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.toJSON(message.heroStats)
      : undefined);
    message.itemStats !== undefined && (obj.itemStats = message.itemStats
      ? CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.toJSON(message.itemStats)
      : undefined);
    message.itemHeroStats !== undefined && (obj.itemHeroStats = message.itemHeroStats
      ? CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.toJSON(message.itemHeroStats)
      : undefined);
    message.itemPlayerStats !== undefined && (obj.itemPlayerStats = message.itemPlayerStats
      ? CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.toJSON(message.itemPlayerStats)
      : undefined);
    message.heroPlayerStats !== undefined && (obj.heroPlayerStats = message.heroPlayerStats
      ? CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.toJSON(message.heroPlayerStats)
      : undefined);
    message.fullSetStats !== undefined && (obj.fullSetStats = message.fullSetStats
      ? CMsgDOTAClientToGCQuickStatsResponse_SimpleStats.toJSON(message.fullSetStats)
      : undefined);
    return obj;
  },
};

function createBaseCMsgDOTAClientToGCQuickStatsResponse_SimpleStats(): CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
  return { winPercent: 0, pickPercent: 0, winCount: 0, pickCount: 0 };
}

export const CMsgDOTAClientToGCQuickStatsResponse_SimpleStats = {
  encode(
    message: CMsgDOTAClientToGCQuickStatsResponse_SimpleStats,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.winPercent !== 0) {
      writer.uint32(13).float(message.winPercent);
    }
    if (message.pickPercent !== 0) {
      writer.uint32(21).float(message.pickPercent);
    }
    if (message.winCount !== 0) {
      writer.uint32(24).uint32(message.winCount);
    }
    if (message.pickCount !== 0) {
      writer.uint32(32).uint32(message.pickCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAClientToGCQuickStatsResponse_SimpleStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 13) {
            break;
          }

          message.winPercent = reader.float();
          continue;
        case 2:
          if (tag != 21) {
            break;
          }

          message.pickPercent = reader.float();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.winCount = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.pickCount = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
    return {
      winPercent: isSet(object.winPercent) ? Number(object.winPercent) : 0,
      pickPercent: isSet(object.pickPercent) ? Number(object.pickPercent) : 0,
      winCount: isSet(object.winCount) ? Number(object.winCount) : 0,
      pickCount: isSet(object.pickCount) ? Number(object.pickCount) : 0,
    };
  },

  toJSON(message: CMsgDOTAClientToGCQuickStatsResponse_SimpleStats): unknown {
    const obj: any = {};
    message.winPercent !== undefined && (obj.winPercent = message.winPercent);
    message.pickPercent !== undefined && (obj.pickPercent = message.pickPercent);
    message.winCount !== undefined && (obj.winCount = Math.round(message.winCount));
    message.pickCount !== undefined && (obj.pickCount = Math.round(message.pickCount));
    return obj;
  },
};

function createBaseCMsgDOTASelectionPriorityChoiceRequest(): CMsgDOTASelectionPriorityChoiceRequest {
  return { choice: 0 };
}

export const CMsgDOTASelectionPriorityChoiceRequest = {
  encode(message: CMsgDOTASelectionPriorityChoiceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.choice !== 0) {
      writer.uint32(8).int32(message.choice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASelectionPriorityChoiceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASelectionPriorityChoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.choice = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASelectionPriorityChoiceRequest {
    return { choice: isSet(object.choice) ? dOTASelectionPriorityChoiceFromJSON(object.choice) : 0 };
  },

  toJSON(message: CMsgDOTASelectionPriorityChoiceRequest): unknown {
    const obj: any = {};
    message.choice !== undefined && (obj.choice = dOTASelectionPriorityChoiceToJSON(message.choice));
    return obj;
  },
};

function createBaseCMsgDOTASelectionPriorityChoiceResponse(): CMsgDOTASelectionPriorityChoiceResponse {
  return { result: 0 };
}

export const CMsgDOTASelectionPriorityChoiceResponse = {
  encode(message: CMsgDOTASelectionPriorityChoiceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASelectionPriorityChoiceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASelectionPriorityChoiceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASelectionPriorityChoiceResponse {
    return { result: isSet(object.result) ? cMsgDOTASelectionPriorityChoiceResponse_ResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgDOTASelectionPriorityChoiceResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = cMsgDOTASelectionPriorityChoiceResponse_ResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgDOTAGameAutographReward(): CMsgDOTAGameAutographReward {
  return { badgeId: "" };
}

export const CMsgDOTAGameAutographReward = {
  encode(message: CMsgDOTAGameAutographReward, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.badgeId !== "") {
      writer.uint32(10).string(message.badgeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAGameAutographReward {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAGameAutographReward();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.badgeId = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAGameAutographReward {
    return { badgeId: isSet(object.badgeId) ? String(object.badgeId) : "" };
  },

  toJSON(message: CMsgDOTAGameAutographReward): unknown {
    const obj: any = {};
    message.badgeId !== undefined && (obj.badgeId = message.badgeId);
    return obj;
  },
};

function createBaseCMsgDOTAGameAutographRewardResponse(): CMsgDOTAGameAutographRewardResponse {
  return { result: 0 };
}

export const CMsgDOTAGameAutographRewardResponse = {
  encode(message: CMsgDOTAGameAutographRewardResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAGameAutographRewardResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAGameAutographRewardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAGameAutographRewardResponse {
    return { result: isSet(object.result) ? cMsgDOTAGameAutographRewardResponse_ResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgDOTAGameAutographRewardResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = cMsgDOTAGameAutographRewardResponse_ResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgDOTADestroyLobbyRequest(): CMsgDOTADestroyLobbyRequest {
  return {};
}

export const CMsgDOTADestroyLobbyRequest = {
  encode(_: CMsgDOTADestroyLobbyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTADestroyLobbyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTADestroyLobbyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgDOTADestroyLobbyRequest {
    return {};
  },

  toJSON(_: CMsgDOTADestroyLobbyRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgDOTADestroyLobbyResponse(): CMsgDOTADestroyLobbyResponse {
  return { result: 0 };
}

export const CMsgDOTADestroyLobbyResponse = {
  encode(message: CMsgDOTADestroyLobbyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTADestroyLobbyResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTADestroyLobbyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTADestroyLobbyResponse {
    return { result: isSet(object.result) ? cMsgDOTADestroyLobbyResponse_ResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgDOTADestroyLobbyResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = cMsgDOTADestroyLobbyResponse_ResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgDOTAGetRecentPlayTimeFriendsRequest(): CMsgDOTAGetRecentPlayTimeFriendsRequest {
  return {};
}

export const CMsgDOTAGetRecentPlayTimeFriendsRequest = {
  encode(_: CMsgDOTAGetRecentPlayTimeFriendsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAGetRecentPlayTimeFriendsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAGetRecentPlayTimeFriendsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgDOTAGetRecentPlayTimeFriendsRequest {
    return {};
  },

  toJSON(_: CMsgDOTAGetRecentPlayTimeFriendsRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgDOTAGetRecentPlayTimeFriendsResponse(): CMsgDOTAGetRecentPlayTimeFriendsResponse {
  return { accountIds: [] };
}

export const CMsgDOTAGetRecentPlayTimeFriendsResponse = {
  encode(message: CMsgDOTAGetRecentPlayTimeFriendsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.accountIds) {
      writer.fixed32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAGetRecentPlayTimeFriendsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAGetRecentPlayTimeFriendsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag == 13) {
            message.accountIds.push(reader.fixed32());
            continue;
          }

          if (tag == 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.accountIds.push(reader.fixed32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAGetRecentPlayTimeFriendsResponse {
    return { accountIds: Array.isArray(object?.accountIds) ? object.accountIds.map((e: any) => Number(e)) : [] };
  },

  toJSON(message: CMsgDOTAGetRecentPlayTimeFriendsResponse): unknown {
    const obj: any = {};
    if (message.accountIds) {
      obj.accountIds = message.accountIds.map((e) => Math.round(e));
    } else {
      obj.accountIds = [];
    }
    return obj;
  },
};

function createBaseCMsgPurchaseItemWithEventPoints(): CMsgPurchaseItemWithEventPoints {
  return { itemDef: 0, quantity: 0, eventId: 0, usePremiumPoints: false };
}

export const CMsgPurchaseItemWithEventPoints = {
  encode(message: CMsgPurchaseItemWithEventPoints, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemDef !== 0) {
      writer.uint32(8).uint32(message.itemDef);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).uint32(message.quantity);
    }
    if (message.eventId !== 0) {
      writer.uint32(24).int32(message.eventId);
    }
    if (message.usePremiumPoints === true) {
      writer.uint32(32).bool(message.usePremiumPoints);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPurchaseItemWithEventPoints {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPurchaseItemWithEventPoints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.itemDef = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.quantity = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.usePremiumPoints = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPurchaseItemWithEventPoints {
    return {
      itemDef: isSet(object.itemDef) ? Number(object.itemDef) : 0,
      quantity: isSet(object.quantity) ? Number(object.quantity) : 0,
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      usePremiumPoints: isSet(object.usePremiumPoints) ? Boolean(object.usePremiumPoints) : false,
    };
  },

  toJSON(message: CMsgPurchaseItemWithEventPoints): unknown {
    const obj: any = {};
    message.itemDef !== undefined && (obj.itemDef = Math.round(message.itemDef));
    message.quantity !== undefined && (obj.quantity = Math.round(message.quantity));
    message.eventId !== undefined && (obj.eventId = eEventToJSON(message.eventId));
    message.usePremiumPoints !== undefined && (obj.usePremiumPoints = message.usePremiumPoints);
    return obj;
  },
};

function createBaseCMsgPurchaseItemWithEventPointsResponse(): CMsgPurchaseItemWithEventPointsResponse {
  return { result: 0 };
}

export const CMsgPurchaseItemWithEventPointsResponse = {
  encode(message: CMsgPurchaseItemWithEventPointsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPurchaseItemWithEventPointsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPurchaseItemWithEventPointsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPurchaseItemWithEventPointsResponse {
    return { result: isSet(object.result) ? cMsgPurchaseItemWithEventPointsResponse_ResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgPurchaseItemWithEventPointsResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = cMsgPurchaseItemWithEventPointsResponse_ResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgPurchaseHeroRandomRelic(): CMsgPurchaseHeroRandomRelic {
  return { heroId: 0, relicRarity: 0 };
}

export const CMsgPurchaseHeroRandomRelic = {
  encode(message: CMsgPurchaseHeroRandomRelic, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroId !== 0) {
      writer.uint32(8).uint32(message.heroId);
    }
    if (message.relicRarity !== 0) {
      writer.uint32(16).int32(message.relicRarity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPurchaseHeroRandomRelic {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPurchaseHeroRandomRelic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.relicRarity = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPurchaseHeroRandomRelic {
    return {
      heroId: isSet(object.heroId) ? Number(object.heroId) : 0,
      relicRarity: isSet(object.relicRarity) ? eHeroRelicRarityFromJSON(object.relicRarity) : 0,
    };
  },

  toJSON(message: CMsgPurchaseHeroRandomRelic): unknown {
    const obj: any = {};
    message.heroId !== undefined && (obj.heroId = Math.round(message.heroId));
    message.relicRarity !== undefined && (obj.relicRarity = eHeroRelicRarityToJSON(message.relicRarity));
    return obj;
  },
};

function createBaseCMsgPurchaseHeroRandomRelicResponse(): CMsgPurchaseHeroRandomRelicResponse {
  return { result: 0, killEaterType: 0 };
}

export const CMsgPurchaseHeroRandomRelicResponse = {
  encode(message: CMsgPurchaseHeroRandomRelicResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.killEaterType !== 0) {
      writer.uint32(16).uint32(message.killEaterType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPurchaseHeroRandomRelicResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPurchaseHeroRandomRelicResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.killEaterType = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPurchaseHeroRandomRelicResponse {
    return {
      result: isSet(object.result) ? ePurchaseHeroRelicResultFromJSON(object.result) : 0,
      killEaterType: isSet(object.killEaterType) ? Number(object.killEaterType) : 0,
    };
  },

  toJSON(message: CMsgPurchaseHeroRandomRelicResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = ePurchaseHeroRelicResultToJSON(message.result));
    message.killEaterType !== undefined && (obj.killEaterType = Math.round(message.killEaterType));
    return obj;
  },
};

function createBaseCMsgClientToGCRequestPlusWeeklyChallengeResult(): CMsgClientToGCRequestPlusWeeklyChallengeResult {
  return { eventId: 0, week: 0 };
}

export const CMsgClientToGCRequestPlusWeeklyChallengeResult = {
  encode(
    message: CMsgClientToGCRequestPlusWeeklyChallengeResult,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).int32(message.eventId);
    }
    if (message.week !== 0) {
      writer.uint32(16).uint32(message.week);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRequestPlusWeeklyChallengeResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRequestPlusWeeklyChallengeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.week = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRequestPlusWeeklyChallengeResult {
    return {
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      week: isSet(object.week) ? Number(object.week) : 0,
    };
  },

  toJSON(message: CMsgClientToGCRequestPlusWeeklyChallengeResult): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = eEventToJSON(message.eventId));
    message.week !== undefined && (obj.week = Math.round(message.week));
    return obj;
  },
};

function createBaseCMsgClientToGCRequestPlusWeeklyChallengeResultResponse(): CMsgClientToGCRequestPlusWeeklyChallengeResultResponse {
  return {};
}

export const CMsgClientToGCRequestPlusWeeklyChallengeResultResponse = {
  encode(
    _: CMsgClientToGCRequestPlusWeeklyChallengeResultResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRequestPlusWeeklyChallengeResultResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRequestPlusWeeklyChallengeResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientToGCRequestPlusWeeklyChallengeResultResponse {
    return {};
  },

  toJSON(_: CMsgClientToGCRequestPlusWeeklyChallengeResultResponse): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgProfileRequest(): CMsgProfileRequest {
  return { accountId: 0 };
}

export const CMsgProfileRequest = {
  encode(message: CMsgProfileRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgProfileRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgProfileRequest {
    return { accountId: isSet(object.accountId) ? Number(object.accountId) : 0 };
  },

  toJSON(message: CMsgProfileRequest): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    return obj;
  },
};

function createBaseCMsgProfileResponse(): CMsgProfileResponse {
  return {
    backgroundItem: undefined,
    featuredHeroes: [],
    recentMatches: [],
    successfulHeroes: [],
    recentMatchDetails: undefined,
    result: 0,
    stickerbookPage: undefined,
  };
}

export const CMsgProfileResponse = {
  encode(message: CMsgProfileResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.backgroundItem !== undefined) {
      CSOEconItem.encode(message.backgroundItem, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.featuredHeroes) {
      CMsgProfileResponse_FeaturedHero.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.recentMatches) {
      CMsgProfileResponse_MatchInfo.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.successfulHeroes) {
      CMsgSuccessfulHero.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.recentMatchDetails !== undefined) {
      CMsgRecentMatchInfo.encode(message.recentMatchDetails, writer.uint32(42).fork()).ldelim();
    }
    if (message.result !== 0) {
      writer.uint32(48).int32(message.result);
    }
    if (message.stickerbookPage !== undefined) {
      CMsgStickerbookPage.encode(message.stickerbookPage, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgProfileResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgProfileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.backgroundItem = CSOEconItem.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.featuredHeroes.push(CMsgProfileResponse_FeaturedHero.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.recentMatches.push(CMsgProfileResponse_MatchInfo.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.successfulHeroes.push(CMsgSuccessfulHero.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag != 42) {
            break;
          }

          message.recentMatchDetails = CMsgRecentMatchInfo.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag != 48) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 7:
          if (tag != 58) {
            break;
          }

          message.stickerbookPage = CMsgStickerbookPage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgProfileResponse {
    return {
      backgroundItem: isSet(object.backgroundItem) ? CSOEconItem.fromJSON(object.backgroundItem) : undefined,
      featuredHeroes: Array.isArray(object?.featuredHeroes)
        ? object.featuredHeroes.map((e: any) => CMsgProfileResponse_FeaturedHero.fromJSON(e))
        : [],
      recentMatches: Array.isArray(object?.recentMatches)
        ? object.recentMatches.map((e: any) => CMsgProfileResponse_MatchInfo.fromJSON(e))
        : [],
      successfulHeroes: Array.isArray(object?.successfulHeroes)
        ? object.successfulHeroes.map((e: any) => CMsgSuccessfulHero.fromJSON(e))
        : [],
      recentMatchDetails: isSet(object.recentMatchDetails)
        ? CMsgRecentMatchInfo.fromJSON(object.recentMatchDetails)
        : undefined,
      result: isSet(object.result) ? cMsgProfileResponse_EResponseFromJSON(object.result) : 0,
      stickerbookPage: isSet(object.stickerbookPage) ? CMsgStickerbookPage.fromJSON(object.stickerbookPage) : undefined,
    };
  },

  toJSON(message: CMsgProfileResponse): unknown {
    const obj: any = {};
    message.backgroundItem !== undefined &&
      (obj.backgroundItem = message.backgroundItem ? CSOEconItem.toJSON(message.backgroundItem) : undefined);
    if (message.featuredHeroes) {
      obj.featuredHeroes = message.featuredHeroes.map((e) =>
        e ? CMsgProfileResponse_FeaturedHero.toJSON(e) : undefined
      );
    } else {
      obj.featuredHeroes = [];
    }
    if (message.recentMatches) {
      obj.recentMatches = message.recentMatches.map((e) => e ? CMsgProfileResponse_MatchInfo.toJSON(e) : undefined);
    } else {
      obj.recentMatches = [];
    }
    if (message.successfulHeroes) {
      obj.successfulHeroes = message.successfulHeroes.map((e) => e ? CMsgSuccessfulHero.toJSON(e) : undefined);
    } else {
      obj.successfulHeroes = [];
    }
    message.recentMatchDetails !== undefined && (obj.recentMatchDetails = message.recentMatchDetails
      ? CMsgRecentMatchInfo.toJSON(message.recentMatchDetails)
      : undefined);
    message.result !== undefined && (obj.result = cMsgProfileResponse_EResponseToJSON(message.result));
    message.stickerbookPage !== undefined &&
      (obj.stickerbookPage = message.stickerbookPage ? CMsgStickerbookPage.toJSON(message.stickerbookPage) : undefined);
    return obj;
  },
};

function createBaseCMsgProfileResponse_FeaturedHero(): CMsgProfileResponse_FeaturedHero {
  return { heroId: 0, equippedEconItems: [], manuallySet: false, plusHeroXp: 0, plusHeroRelicsItem: undefined };
}

export const CMsgProfileResponse_FeaturedHero = {
  encode(message: CMsgProfileResponse_FeaturedHero, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroId !== 0) {
      writer.uint32(8).uint32(message.heroId);
    }
    for (const v of message.equippedEconItems) {
      CSOEconItem.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.manuallySet === true) {
      writer.uint32(24).bool(message.manuallySet);
    }
    if (message.plusHeroXp !== 0) {
      writer.uint32(32).uint32(message.plusHeroXp);
    }
    if (message.plusHeroRelicsItem !== undefined) {
      CSOEconItem.encode(message.plusHeroRelicsItem, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgProfileResponse_FeaturedHero {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgProfileResponse_FeaturedHero();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.equippedEconItems.push(CSOEconItem.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.manuallySet = reader.bool();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.plusHeroXp = reader.uint32();
          continue;
        case 5:
          if (tag != 42) {
            break;
          }

          message.plusHeroRelicsItem = CSOEconItem.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgProfileResponse_FeaturedHero {
    return {
      heroId: isSet(object.heroId) ? Number(object.heroId) : 0,
      equippedEconItems: Array.isArray(object?.equippedEconItems)
        ? object.equippedEconItems.map((e: any) => CSOEconItem.fromJSON(e))
        : [],
      manuallySet: isSet(object.manuallySet) ? Boolean(object.manuallySet) : false,
      plusHeroXp: isSet(object.plusHeroXp) ? Number(object.plusHeroXp) : 0,
      plusHeroRelicsItem: isSet(object.plusHeroRelicsItem)
        ? CSOEconItem.fromJSON(object.plusHeroRelicsItem)
        : undefined,
    };
  },

  toJSON(message: CMsgProfileResponse_FeaturedHero): unknown {
    const obj: any = {};
    message.heroId !== undefined && (obj.heroId = Math.round(message.heroId));
    if (message.equippedEconItems) {
      obj.equippedEconItems = message.equippedEconItems.map((e) => e ? CSOEconItem.toJSON(e) : undefined);
    } else {
      obj.equippedEconItems = [];
    }
    message.manuallySet !== undefined && (obj.manuallySet = message.manuallySet);
    message.plusHeroXp !== undefined && (obj.plusHeroXp = Math.round(message.plusHeroXp));
    message.plusHeroRelicsItem !== undefined &&
      (obj.plusHeroRelicsItem = message.plusHeroRelicsItem
        ? CSOEconItem.toJSON(message.plusHeroRelicsItem)
        : undefined);
    return obj;
  },
};

function createBaseCMsgProfileResponse_MatchInfo(): CMsgProfileResponse_MatchInfo {
  return { matchId: "0", matchTimestamp: 0, performanceRating: 0, heroId: 0, wonMatch: false };
}

export const CMsgProfileResponse_MatchInfo = {
  encode(message: CMsgProfileResponse_MatchInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.matchTimestamp !== 0) {
      writer.uint32(16).uint32(message.matchTimestamp);
    }
    if (message.performanceRating !== 0) {
      writer.uint32(24).sint32(message.performanceRating);
    }
    if (message.heroId !== 0) {
      writer.uint32(32).uint32(message.heroId);
    }
    if (message.wonMatch === true) {
      writer.uint32(40).bool(message.wonMatch);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgProfileResponse_MatchInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgProfileResponse_MatchInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.matchTimestamp = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.performanceRating = reader.sint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.wonMatch = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgProfileResponse_MatchInfo {
    return {
      matchId: isSet(object.matchId) ? String(object.matchId) : "0",
      matchTimestamp: isSet(object.matchTimestamp) ? Number(object.matchTimestamp) : 0,
      performanceRating: isSet(object.performanceRating) ? Number(object.performanceRating) : 0,
      heroId: isSet(object.heroId) ? Number(object.heroId) : 0,
      wonMatch: isSet(object.wonMatch) ? Boolean(object.wonMatch) : false,
    };
  },

  toJSON(message: CMsgProfileResponse_MatchInfo): unknown {
    const obj: any = {};
    message.matchId !== undefined && (obj.matchId = message.matchId);
    message.matchTimestamp !== undefined && (obj.matchTimestamp = Math.round(message.matchTimestamp));
    message.performanceRating !== undefined && (obj.performanceRating = Math.round(message.performanceRating));
    message.heroId !== undefined && (obj.heroId = Math.round(message.heroId));
    message.wonMatch !== undefined && (obj.wonMatch = message.wonMatch);
    return obj;
  },
};

function createBaseCMsgProfileUpdate(): CMsgProfileUpdate {
  return { backgroundItemId: "0", featuredHeroIds: [] };
}

export const CMsgProfileUpdate = {
  encode(message: CMsgProfileUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.backgroundItemId !== "0") {
      writer.uint32(8).uint64(message.backgroundItemId);
    }
    writer.uint32(18).fork();
    for (const v of message.featuredHeroIds) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgProfileUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgProfileUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.backgroundItemId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag == 16) {
            message.featuredHeroIds.push(reader.uint32());
            continue;
          }

          if (tag == 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.featuredHeroIds.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgProfileUpdate {
    return {
      backgroundItemId: isSet(object.backgroundItemId) ? String(object.backgroundItemId) : "0",
      featuredHeroIds: Array.isArray(object?.featuredHeroIds) ? object.featuredHeroIds.map((e: any) => Number(e)) : [],
    };
  },

  toJSON(message: CMsgProfileUpdate): unknown {
    const obj: any = {};
    message.backgroundItemId !== undefined && (obj.backgroundItemId = message.backgroundItemId);
    if (message.featuredHeroIds) {
      obj.featuredHeroIds = message.featuredHeroIds.map((e) => Math.round(e));
    } else {
      obj.featuredHeroIds = [];
    }
    return obj;
  },
};

function createBaseCMsgProfileUpdateResponse(): CMsgProfileUpdateResponse {
  return { result: 0 };
}

export const CMsgProfileUpdateResponse = {
  encode(message: CMsgProfileUpdateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgProfileUpdateResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgProfileUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgProfileUpdateResponse {
    return { result: isSet(object.result) ? cMsgProfileUpdateResponse_ResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgProfileUpdateResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = cMsgProfileUpdateResponse_ResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgTalentWinRates(): CMsgTalentWinRates {
  return { lastRun: 0, abilityId: 0, gameCount: 0, winCount: 0 };
}

export const CMsgTalentWinRates = {
  encode(message: CMsgTalentWinRates, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lastRun !== 0) {
      writer.uint32(8).uint32(message.lastRun);
    }
    if (message.abilityId !== 0) {
      writer.uint32(16).int32(message.abilityId);
    }
    if (message.gameCount !== 0) {
      writer.uint32(24).uint32(message.gameCount);
    }
    if (message.winCount !== 0) {
      writer.uint32(32).uint32(message.winCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTalentWinRates {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTalentWinRates();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.lastRun = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.abilityId = reader.int32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.gameCount = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.winCount = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTalentWinRates {
    return {
      lastRun: isSet(object.lastRun) ? Number(object.lastRun) : 0,
      abilityId: isSet(object.abilityId) ? Number(object.abilityId) : 0,
      gameCount: isSet(object.gameCount) ? Number(object.gameCount) : 0,
      winCount: isSet(object.winCount) ? Number(object.winCount) : 0,
    };
  },

  toJSON(message: CMsgTalentWinRates): unknown {
    const obj: any = {};
    message.lastRun !== undefined && (obj.lastRun = Math.round(message.lastRun));
    message.abilityId !== undefined && (obj.abilityId = Math.round(message.abilityId));
    message.gameCount !== undefined && (obj.gameCount = Math.round(message.gameCount));
    message.winCount !== undefined && (obj.winCount = Math.round(message.winCount));
    return obj;
  },
};

function createBaseCMsgGlobalHeroAverages(): CMsgGlobalHeroAverages {
  return {
    lastRun: 0,
    avgGoldPerMin: 0,
    avgXpPerMin: 0,
    avgKills: 0,
    avgDeaths: 0,
    avgAssists: 0,
    avgLastHits: 0,
    avgDenies: 0,
    avgNetWorth: 0,
  };
}

export const CMsgGlobalHeroAverages = {
  encode(message: CMsgGlobalHeroAverages, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lastRun !== 0) {
      writer.uint32(8).uint32(message.lastRun);
    }
    if (message.avgGoldPerMin !== 0) {
      writer.uint32(24).uint32(message.avgGoldPerMin);
    }
    if (message.avgXpPerMin !== 0) {
      writer.uint32(32).uint32(message.avgXpPerMin);
    }
    if (message.avgKills !== 0) {
      writer.uint32(40).uint32(message.avgKills);
    }
    if (message.avgDeaths !== 0) {
      writer.uint32(48).uint32(message.avgDeaths);
    }
    if (message.avgAssists !== 0) {
      writer.uint32(56).uint32(message.avgAssists);
    }
    if (message.avgLastHits !== 0) {
      writer.uint32(64).uint32(message.avgLastHits);
    }
    if (message.avgDenies !== 0) {
      writer.uint32(72).uint32(message.avgDenies);
    }
    if (message.avgNetWorth !== 0) {
      writer.uint32(80).uint32(message.avgNetWorth);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGlobalHeroAverages {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGlobalHeroAverages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.lastRun = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.avgGoldPerMin = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.avgXpPerMin = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.avgKills = reader.uint32();
          continue;
        case 6:
          if (tag != 48) {
            break;
          }

          message.avgDeaths = reader.uint32();
          continue;
        case 7:
          if (tag != 56) {
            break;
          }

          message.avgAssists = reader.uint32();
          continue;
        case 8:
          if (tag != 64) {
            break;
          }

          message.avgLastHits = reader.uint32();
          continue;
        case 9:
          if (tag != 72) {
            break;
          }

          message.avgDenies = reader.uint32();
          continue;
        case 10:
          if (tag != 80) {
            break;
          }

          message.avgNetWorth = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGlobalHeroAverages {
    return {
      lastRun: isSet(object.lastRun) ? Number(object.lastRun) : 0,
      avgGoldPerMin: isSet(object.avgGoldPerMin) ? Number(object.avgGoldPerMin) : 0,
      avgXpPerMin: isSet(object.avgXpPerMin) ? Number(object.avgXpPerMin) : 0,
      avgKills: isSet(object.avgKills) ? Number(object.avgKills) : 0,
      avgDeaths: isSet(object.avgDeaths) ? Number(object.avgDeaths) : 0,
      avgAssists: isSet(object.avgAssists) ? Number(object.avgAssists) : 0,
      avgLastHits: isSet(object.avgLastHits) ? Number(object.avgLastHits) : 0,
      avgDenies: isSet(object.avgDenies) ? Number(object.avgDenies) : 0,
      avgNetWorth: isSet(object.avgNetWorth) ? Number(object.avgNetWorth) : 0,
    };
  },

  toJSON(message: CMsgGlobalHeroAverages): unknown {
    const obj: any = {};
    message.lastRun !== undefined && (obj.lastRun = Math.round(message.lastRun));
    message.avgGoldPerMin !== undefined && (obj.avgGoldPerMin = Math.round(message.avgGoldPerMin));
    message.avgXpPerMin !== undefined && (obj.avgXpPerMin = Math.round(message.avgXpPerMin));
    message.avgKills !== undefined && (obj.avgKills = Math.round(message.avgKills));
    message.avgDeaths !== undefined && (obj.avgDeaths = Math.round(message.avgDeaths));
    message.avgAssists !== undefined && (obj.avgAssists = Math.round(message.avgAssists));
    message.avgLastHits !== undefined && (obj.avgLastHits = Math.round(message.avgLastHits));
    message.avgDenies !== undefined && (obj.avgDenies = Math.round(message.avgDenies));
    message.avgNetWorth !== undefined && (obj.avgNetWorth = Math.round(message.avgNetWorth));
    return obj;
  },
};

function createBaseCMsgHeroGlobalDataRequest(): CMsgHeroGlobalDataRequest {
  return { heroId: 0 };
}

export const CMsgHeroGlobalDataRequest = {
  encode(message: CMsgHeroGlobalDataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroId !== 0) {
      writer.uint32(8).uint32(message.heroId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgHeroGlobalDataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHeroGlobalDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHeroGlobalDataRequest {
    return { heroId: isSet(object.heroId) ? Number(object.heroId) : 0 };
  },

  toJSON(message: CMsgHeroGlobalDataRequest): unknown {
    const obj: any = {};
    message.heroId !== undefined && (obj.heroId = Math.round(message.heroId));
    return obj;
  },
};

function createBaseCMsgHeroGlobalDataResponse(): CMsgHeroGlobalDataResponse {
  return { heroId: 0, heroDataPerChunk: [] };
}

export const CMsgHeroGlobalDataResponse = {
  encode(message: CMsgHeroGlobalDataResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroId !== 0) {
      writer.uint32(8).uint32(message.heroId);
    }
    for (const v of message.heroDataPerChunk) {
      CMsgHeroGlobalDataResponse_HeroDataPerRankChunk.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgHeroGlobalDataResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHeroGlobalDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.heroDataPerChunk.push(
            CMsgHeroGlobalDataResponse_HeroDataPerRankChunk.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHeroGlobalDataResponse {
    return {
      heroId: isSet(object.heroId) ? Number(object.heroId) : 0,
      heroDataPerChunk: Array.isArray(object?.heroDataPerChunk)
        ? object.heroDataPerChunk.map((e: any) => CMsgHeroGlobalDataResponse_HeroDataPerRankChunk.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgHeroGlobalDataResponse): unknown {
    const obj: any = {};
    message.heroId !== undefined && (obj.heroId = Math.round(message.heroId));
    if (message.heroDataPerChunk) {
      obj.heroDataPerChunk = message.heroDataPerChunk.map((e) =>
        e ? CMsgHeroGlobalDataResponse_HeroDataPerRankChunk.toJSON(e) : undefined
      );
    } else {
      obj.heroDataPerChunk = [];
    }
    return obj;
  },
};

function createBaseCMsgHeroGlobalDataResponse_GraphData(): CMsgHeroGlobalDataResponse_GraphData {
  return { day: 0, winPercent: 0, pickPercent: 0, banPercent: 0 };
}

export const CMsgHeroGlobalDataResponse_GraphData = {
  encode(message: CMsgHeroGlobalDataResponse_GraphData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.day !== 0) {
      writer.uint32(8).uint32(message.day);
    }
    if (message.winPercent !== 0) {
      writer.uint32(21).float(message.winPercent);
    }
    if (message.pickPercent !== 0) {
      writer.uint32(29).float(message.pickPercent);
    }
    if (message.banPercent !== 0) {
      writer.uint32(37).float(message.banPercent);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgHeroGlobalDataResponse_GraphData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHeroGlobalDataResponse_GraphData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.day = reader.uint32();
          continue;
        case 2:
          if (tag != 21) {
            break;
          }

          message.winPercent = reader.float();
          continue;
        case 3:
          if (tag != 29) {
            break;
          }

          message.pickPercent = reader.float();
          continue;
        case 4:
          if (tag != 37) {
            break;
          }

          message.banPercent = reader.float();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHeroGlobalDataResponse_GraphData {
    return {
      day: isSet(object.day) ? Number(object.day) : 0,
      winPercent: isSet(object.winPercent) ? Number(object.winPercent) : 0,
      pickPercent: isSet(object.pickPercent) ? Number(object.pickPercent) : 0,
      banPercent: isSet(object.banPercent) ? Number(object.banPercent) : 0,
    };
  },

  toJSON(message: CMsgHeroGlobalDataResponse_GraphData): unknown {
    const obj: any = {};
    message.day !== undefined && (obj.day = Math.round(message.day));
    message.winPercent !== undefined && (obj.winPercent = message.winPercent);
    message.pickPercent !== undefined && (obj.pickPercent = message.pickPercent);
    message.banPercent !== undefined && (obj.banPercent = message.banPercent);
    return obj;
  },
};

function createBaseCMsgHeroGlobalDataResponse_WeekData(): CMsgHeroGlobalDataResponse_WeekData {
  return { week: 0, winPercent: 0, pickPercent: 0, banPercent: 0 };
}

export const CMsgHeroGlobalDataResponse_WeekData = {
  encode(message: CMsgHeroGlobalDataResponse_WeekData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.week !== 0) {
      writer.uint32(8).uint32(message.week);
    }
    if (message.winPercent !== 0) {
      writer.uint32(21).float(message.winPercent);
    }
    if (message.pickPercent !== 0) {
      writer.uint32(29).float(message.pickPercent);
    }
    if (message.banPercent !== 0) {
      writer.uint32(37).float(message.banPercent);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgHeroGlobalDataResponse_WeekData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHeroGlobalDataResponse_WeekData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.week = reader.uint32();
          continue;
        case 2:
          if (tag != 21) {
            break;
          }

          message.winPercent = reader.float();
          continue;
        case 3:
          if (tag != 29) {
            break;
          }

          message.pickPercent = reader.float();
          continue;
        case 4:
          if (tag != 37) {
            break;
          }

          message.banPercent = reader.float();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHeroGlobalDataResponse_WeekData {
    return {
      week: isSet(object.week) ? Number(object.week) : 0,
      winPercent: isSet(object.winPercent) ? Number(object.winPercent) : 0,
      pickPercent: isSet(object.pickPercent) ? Number(object.pickPercent) : 0,
      banPercent: isSet(object.banPercent) ? Number(object.banPercent) : 0,
    };
  },

  toJSON(message: CMsgHeroGlobalDataResponse_WeekData): unknown {
    const obj: any = {};
    message.week !== undefined && (obj.week = Math.round(message.week));
    message.winPercent !== undefined && (obj.winPercent = message.winPercent);
    message.pickPercent !== undefined && (obj.pickPercent = message.pickPercent);
    message.banPercent !== undefined && (obj.banPercent = message.banPercent);
    return obj;
  },
};

function createBaseCMsgHeroGlobalDataResponse_HeroDataPerRankChunk(): CMsgHeroGlobalDataResponse_HeroDataPerRankChunk {
  return { rankChunk: 0, talentWinRates: [], heroAverages: undefined, graphData: [], weekData: [] };
}

export const CMsgHeroGlobalDataResponse_HeroDataPerRankChunk = {
  encode(
    message: CMsgHeroGlobalDataResponse_HeroDataPerRankChunk,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.rankChunk !== 0) {
      writer.uint32(8).uint32(message.rankChunk);
    }
    for (const v of message.talentWinRates) {
      CMsgTalentWinRates.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.heroAverages !== undefined) {
      CMsgGlobalHeroAverages.encode(message.heroAverages, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.graphData) {
      CMsgHeroGlobalDataResponse_GraphData.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.weekData) {
      CMsgHeroGlobalDataResponse_WeekData.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgHeroGlobalDataResponse_HeroDataPerRankChunk {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHeroGlobalDataResponse_HeroDataPerRankChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.rankChunk = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.talentWinRates.push(CMsgTalentWinRates.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.heroAverages = CMsgGlobalHeroAverages.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.graphData.push(CMsgHeroGlobalDataResponse_GraphData.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag != 42) {
            break;
          }

          message.weekData.push(CMsgHeroGlobalDataResponse_WeekData.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHeroGlobalDataResponse_HeroDataPerRankChunk {
    return {
      rankChunk: isSet(object.rankChunk) ? Number(object.rankChunk) : 0,
      talentWinRates: Array.isArray(object?.talentWinRates)
        ? object.talentWinRates.map((e: any) => CMsgTalentWinRates.fromJSON(e))
        : [],
      heroAverages: isSet(object.heroAverages) ? CMsgGlobalHeroAverages.fromJSON(object.heroAverages) : undefined,
      graphData: Array.isArray(object?.graphData)
        ? object.graphData.map((e: any) => CMsgHeroGlobalDataResponse_GraphData.fromJSON(e))
        : [],
      weekData: Array.isArray(object?.weekData)
        ? object.weekData.map((e: any) => CMsgHeroGlobalDataResponse_WeekData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgHeroGlobalDataResponse_HeroDataPerRankChunk): unknown {
    const obj: any = {};
    message.rankChunk !== undefined && (obj.rankChunk = Math.round(message.rankChunk));
    if (message.talentWinRates) {
      obj.talentWinRates = message.talentWinRates.map((e) => e ? CMsgTalentWinRates.toJSON(e) : undefined);
    } else {
      obj.talentWinRates = [];
    }
    message.heroAverages !== undefined &&
      (obj.heroAverages = message.heroAverages ? CMsgGlobalHeroAverages.toJSON(message.heroAverages) : undefined);
    if (message.graphData) {
      obj.graphData = message.graphData.map((e) => e ? CMsgHeroGlobalDataResponse_GraphData.toJSON(e) : undefined);
    } else {
      obj.graphData = [];
    }
    if (message.weekData) {
      obj.weekData = message.weekData.map((e) => e ? CMsgHeroGlobalDataResponse_WeekData.toJSON(e) : undefined);
    } else {
      obj.weekData = [];
    }
    return obj;
  },
};

function createBaseCMsgHeroGlobalDataAllHeroes(): CMsgHeroGlobalDataAllHeroes {
  return { heroes: [] };
}

export const CMsgHeroGlobalDataAllHeroes = {
  encode(message: CMsgHeroGlobalDataAllHeroes, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.heroes) {
      CMsgHeroGlobalDataResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgHeroGlobalDataAllHeroes {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHeroGlobalDataAllHeroes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.heroes.push(CMsgHeroGlobalDataResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHeroGlobalDataAllHeroes {
    return {
      heroes: Array.isArray(object?.heroes)
        ? object.heroes.map((e: any) => CMsgHeroGlobalDataResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgHeroGlobalDataAllHeroes): unknown {
    const obj: any = {};
    if (message.heroes) {
      obj.heroes = message.heroes.map((e) => e ? CMsgHeroGlobalDataResponse.toJSON(e) : undefined);
    } else {
      obj.heroes = [];
    }
    return obj;
  },
};

function createBaseCMsgHeroGlobalDataHeroesAlliesAndEnemies(): CMsgHeroGlobalDataHeroesAlliesAndEnemies {
  return { rankedHeroData: [] };
}

export const CMsgHeroGlobalDataHeroesAlliesAndEnemies = {
  encode(message: CMsgHeroGlobalDataHeroesAlliesAndEnemies, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.rankedHeroData) {
      CMsgHeroGlobalDataHeroesAlliesAndEnemies_RankedHeroData.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgHeroGlobalDataHeroesAlliesAndEnemies {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHeroGlobalDataHeroesAlliesAndEnemies();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.rankedHeroData.push(
            CMsgHeroGlobalDataHeroesAlliesAndEnemies_RankedHeroData.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHeroGlobalDataHeroesAlliesAndEnemies {
    return {
      rankedHeroData: Array.isArray(object?.rankedHeroData)
        ? object.rankedHeroData.map((e: any) => CMsgHeroGlobalDataHeroesAlliesAndEnemies_RankedHeroData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgHeroGlobalDataHeroesAlliesAndEnemies): unknown {
    const obj: any = {};
    if (message.rankedHeroData) {
      obj.rankedHeroData = message.rankedHeroData.map((e) =>
        e ? CMsgHeroGlobalDataHeroesAlliesAndEnemies_RankedHeroData.toJSON(e) : undefined
      );
    } else {
      obj.rankedHeroData = [];
    }
    return obj;
  },
};

function createBaseCMsgHeroGlobalDataHeroesAlliesAndEnemies_HeroData(): CMsgHeroGlobalDataHeroesAlliesAndEnemies_HeroData {
  return { heroId: 0, winRate: 0, firstOtherHeroId: 0, allyWinRate: [], enemyWinRate: [] };
}

export const CMsgHeroGlobalDataHeroesAlliesAndEnemies_HeroData = {
  encode(
    message: CMsgHeroGlobalDataHeroesAlliesAndEnemies_HeroData,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.heroId !== 0) {
      writer.uint32(8).uint32(message.heroId);
    }
    if (message.winRate !== 0) {
      writer.uint32(16).uint32(message.winRate);
    }
    if (message.firstOtherHeroId !== 0) {
      writer.uint32(24).uint32(message.firstOtherHeroId);
    }
    writer.uint32(42).fork();
    for (const v of message.allyWinRate) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(50).fork();
    for (const v of message.enemyWinRate) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgHeroGlobalDataHeroesAlliesAndEnemies_HeroData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHeroGlobalDataHeroesAlliesAndEnemies_HeroData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.winRate = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.firstOtherHeroId = reader.uint32();
          continue;
        case 5:
          if (tag == 40) {
            message.allyWinRate.push(reader.uint32());
            continue;
          }

          if (tag == 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allyWinRate.push(reader.uint32());
            }

            continue;
          }

          break;
        case 6:
          if (tag == 48) {
            message.enemyWinRate.push(reader.uint32());
            continue;
          }

          if (tag == 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.enemyWinRate.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHeroGlobalDataHeroesAlliesAndEnemies_HeroData {
    return {
      heroId: isSet(object.heroId) ? Number(object.heroId) : 0,
      winRate: isSet(object.winRate) ? Number(object.winRate) : 0,
      firstOtherHeroId: isSet(object.firstOtherHeroId) ? Number(object.firstOtherHeroId) : 0,
      allyWinRate: Array.isArray(object?.allyWinRate) ? object.allyWinRate.map((e: any) => Number(e)) : [],
      enemyWinRate: Array.isArray(object?.enemyWinRate) ? object.enemyWinRate.map((e: any) => Number(e)) : [],
    };
  },

  toJSON(message: CMsgHeroGlobalDataHeroesAlliesAndEnemies_HeroData): unknown {
    const obj: any = {};
    message.heroId !== undefined && (obj.heroId = Math.round(message.heroId));
    message.winRate !== undefined && (obj.winRate = Math.round(message.winRate));
    message.firstOtherHeroId !== undefined && (obj.firstOtherHeroId = Math.round(message.firstOtherHeroId));
    if (message.allyWinRate) {
      obj.allyWinRate = message.allyWinRate.map((e) => Math.round(e));
    } else {
      obj.allyWinRate = [];
    }
    if (message.enemyWinRate) {
      obj.enemyWinRate = message.enemyWinRate.map((e) => Math.round(e));
    } else {
      obj.enemyWinRate = [];
    }
    return obj;
  },
};

function createBaseCMsgHeroGlobalDataHeroesAlliesAndEnemies_RankedHeroData(): CMsgHeroGlobalDataHeroesAlliesAndEnemies_RankedHeroData {
  return { rank: 0, heroData: [] };
}

export const CMsgHeroGlobalDataHeroesAlliesAndEnemies_RankedHeroData = {
  encode(
    message: CMsgHeroGlobalDataHeroesAlliesAndEnemies_RankedHeroData,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.rank !== 0) {
      writer.uint32(8).uint32(message.rank);
    }
    for (const v of message.heroData) {
      CMsgHeroGlobalDataHeroesAlliesAndEnemies_HeroData.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgHeroGlobalDataHeroesAlliesAndEnemies_RankedHeroData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHeroGlobalDataHeroesAlliesAndEnemies_RankedHeroData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.rank = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.heroData.push(CMsgHeroGlobalDataHeroesAlliesAndEnemies_HeroData.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHeroGlobalDataHeroesAlliesAndEnemies_RankedHeroData {
    return {
      rank: isSet(object.rank) ? Number(object.rank) : 0,
      heroData: Array.isArray(object?.heroData)
        ? object.heroData.map((e: any) => CMsgHeroGlobalDataHeroesAlliesAndEnemies_HeroData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgHeroGlobalDataHeroesAlliesAndEnemies_RankedHeroData): unknown {
    const obj: any = {};
    message.rank !== undefined && (obj.rank = Math.round(message.rank));
    if (message.heroData) {
      obj.heroData = message.heroData.map((e) =>
        e ? CMsgHeroGlobalDataHeroesAlliesAndEnemies_HeroData.toJSON(e) : undefined
      );
    } else {
      obj.heroData = [];
    }
    return obj;
  },
};

function createBaseCMsgPrivateMetadataKeyRequest(): CMsgPrivateMetadataKeyRequest {
  return { matchId: "0" };
}

export const CMsgPrivateMetadataKeyRequest = {
  encode(message: CMsgPrivateMetadataKeyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPrivateMetadataKeyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPrivateMetadataKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPrivateMetadataKeyRequest {
    return { matchId: isSet(object.matchId) ? String(object.matchId) : "0" };
  },

  toJSON(message: CMsgPrivateMetadataKeyRequest): unknown {
    const obj: any = {};
    message.matchId !== undefined && (obj.matchId = message.matchId);
    return obj;
  },
};

function createBaseCMsgPrivateMetadataKeyResponse(): CMsgPrivateMetadataKeyResponse {
  return { privateKey: 0 };
}

export const CMsgPrivateMetadataKeyResponse = {
  encode(message: CMsgPrivateMetadataKeyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.privateKey !== 0) {
      writer.uint32(8).uint32(message.privateKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPrivateMetadataKeyResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPrivateMetadataKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.privateKey = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPrivateMetadataKeyResponse {
    return { privateKey: isSet(object.privateKey) ? Number(object.privateKey) : 0 };
  },

  toJSON(message: CMsgPrivateMetadataKeyResponse): unknown {
    const obj: any = {};
    message.privateKey !== undefined && (obj.privateKey = Math.round(message.privateKey));
    return obj;
  },
};

function createBaseCMsgActivatePlusFreeTrialResponse(): CMsgActivatePlusFreeTrialResponse {
  return { result: 0 };
}

export const CMsgActivatePlusFreeTrialResponse = {
  encode(message: CMsgActivatePlusFreeTrialResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgActivatePlusFreeTrialResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgActivatePlusFreeTrialResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgActivatePlusFreeTrialResponse {
    return { result: isSet(object.result) ? cMsgActivatePlusFreeTrialResponse_ResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgActivatePlusFreeTrialResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = cMsgActivatePlusFreeTrialResponse_ResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgGCToClientCavernCrawlMapPathCompleted(): CMsgGCToClientCavernCrawlMapPathCompleted {
  return { eventId: 0, heroIdCompleted: 0, completedPaths: [], mapVariant: 0 };
}

export const CMsgGCToClientCavernCrawlMapPathCompleted = {
  encode(message: CMsgGCToClientCavernCrawlMapPathCompleted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    if (message.heroIdCompleted !== 0) {
      writer.uint32(16).uint32(message.heroIdCompleted);
    }
    for (const v of message.completedPaths) {
      CMsgGCToClientCavernCrawlMapPathCompleted_CompletedPathInfo.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.mapVariant !== 0) {
      writer.uint32(32).uint32(message.mapVariant);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientCavernCrawlMapPathCompleted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientCavernCrawlMapPathCompleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.heroIdCompleted = reader.uint32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.completedPaths.push(
            CMsgGCToClientCavernCrawlMapPathCompleted_CompletedPathInfo.decode(reader, reader.uint32()),
          );
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.mapVariant = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientCavernCrawlMapPathCompleted {
    return {
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      heroIdCompleted: isSet(object.heroIdCompleted) ? Number(object.heroIdCompleted) : 0,
      completedPaths: Array.isArray(object?.completedPaths)
        ? object.completedPaths.map((e: any) => CMsgGCToClientCavernCrawlMapPathCompleted_CompletedPathInfo.fromJSON(e))
        : [],
      mapVariant: isSet(object.mapVariant) ? Number(object.mapVariant) : 0,
    };
  },

  toJSON(message: CMsgGCToClientCavernCrawlMapPathCompleted): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.heroIdCompleted !== undefined && (obj.heroIdCompleted = Math.round(message.heroIdCompleted));
    if (message.completedPaths) {
      obj.completedPaths = message.completedPaths.map((e) =>
        e ? CMsgGCToClientCavernCrawlMapPathCompleted_CompletedPathInfo.toJSON(e) : undefined
      );
    } else {
      obj.completedPaths = [];
    }
    message.mapVariant !== undefined && (obj.mapVariant = Math.round(message.mapVariant));
    return obj;
  },
};

function createBaseCMsgGCToClientCavernCrawlMapPathCompleted_CompletedPathInfo(): CMsgGCToClientCavernCrawlMapPathCompleted_CompletedPathInfo {
  return { pathIdCompleted: 0, receivedUltraRareReward: false, halfCompleted: false };
}

export const CMsgGCToClientCavernCrawlMapPathCompleted_CompletedPathInfo = {
  encode(
    message: CMsgGCToClientCavernCrawlMapPathCompleted_CompletedPathInfo,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.pathIdCompleted !== 0) {
      writer.uint32(8).uint32(message.pathIdCompleted);
    }
    if (message.receivedUltraRareReward === true) {
      writer.uint32(16).bool(message.receivedUltraRareReward);
    }
    if (message.halfCompleted === true) {
      writer.uint32(24).bool(message.halfCompleted);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientCavernCrawlMapPathCompleted_CompletedPathInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientCavernCrawlMapPathCompleted_CompletedPathInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.pathIdCompleted = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.receivedUltraRareReward = reader.bool();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.halfCompleted = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientCavernCrawlMapPathCompleted_CompletedPathInfo {
    return {
      pathIdCompleted: isSet(object.pathIdCompleted) ? Number(object.pathIdCompleted) : 0,
      receivedUltraRareReward: isSet(object.receivedUltraRareReward) ? Boolean(object.receivedUltraRareReward) : false,
      halfCompleted: isSet(object.halfCompleted) ? Boolean(object.halfCompleted) : false,
    };
  },

  toJSON(message: CMsgGCToClientCavernCrawlMapPathCompleted_CompletedPathInfo): unknown {
    const obj: any = {};
    message.pathIdCompleted !== undefined && (obj.pathIdCompleted = Math.round(message.pathIdCompleted));
    message.receivedUltraRareReward !== undefined && (obj.receivedUltraRareReward = message.receivedUltraRareReward);
    message.halfCompleted !== undefined && (obj.halfCompleted = message.halfCompleted);
    return obj;
  },
};

function createBaseCMsgGCToClientCavernCrawlMapUpdated(): CMsgGCToClientCavernCrawlMapUpdated {
  return { eventId: 0 };
}

export const CMsgGCToClientCavernCrawlMapUpdated = {
  encode(message: CMsgGCToClientCavernCrawlMapUpdated, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientCavernCrawlMapUpdated {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientCavernCrawlMapUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientCavernCrawlMapUpdated {
    return { eventId: isSet(object.eventId) ? Number(object.eventId) : 0 };
  },

  toJSON(message: CMsgGCToClientCavernCrawlMapUpdated): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    return obj;
  },
};

function createBaseCMsgClientToGCCavernCrawlClaimRoom(): CMsgClientToGCCavernCrawlClaimRoom {
  return { eventId: 0, roomId: 0, mapVariant: 0 };
}

export const CMsgClientToGCCavernCrawlClaimRoom = {
  encode(message: CMsgClientToGCCavernCrawlClaimRoom, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    if (message.roomId !== 0) {
      writer.uint32(16).uint32(message.roomId);
    }
    if (message.mapVariant !== 0) {
      writer.uint32(24).uint32(message.mapVariant);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCCavernCrawlClaimRoom {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCavernCrawlClaimRoom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.roomId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.mapVariant = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCavernCrawlClaimRoom {
    return {
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      roomId: isSet(object.roomId) ? Number(object.roomId) : 0,
      mapVariant: isSet(object.mapVariant) ? Number(object.mapVariant) : 0,
    };
  },

  toJSON(message: CMsgClientToGCCavernCrawlClaimRoom): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.roomId !== undefined && (obj.roomId = Math.round(message.roomId));
    message.mapVariant !== undefined && (obj.mapVariant = Math.round(message.mapVariant));
    return obj;
  },
};

function createBaseCMsgClientToGCCavernCrawlClaimRoomResponse(): CMsgClientToGCCavernCrawlClaimRoomResponse {
  return { result: 0 };
}

export const CMsgClientToGCCavernCrawlClaimRoomResponse = {
  encode(message: CMsgClientToGCCavernCrawlClaimRoomResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCCavernCrawlClaimRoomResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCavernCrawlClaimRoomResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCavernCrawlClaimRoomResponse {
    return {
      result: isSet(object.result) ? cMsgClientToGCCavernCrawlClaimRoomResponse_ResultFromJSON(object.result) : 0,
    };
  },

  toJSON(message: CMsgClientToGCCavernCrawlClaimRoomResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgClientToGCCavernCrawlClaimRoomResponse_ResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgClientToGCCavernCrawlUseItemOnRoom(): CMsgClientToGCCavernCrawlUseItemOnRoom {
  return { eventId: 0, roomId: 0, itemType: 0, mapVariant: 0 };
}

export const CMsgClientToGCCavernCrawlUseItemOnRoom = {
  encode(message: CMsgClientToGCCavernCrawlUseItemOnRoom, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    if (message.roomId !== 0) {
      writer.uint32(16).uint32(message.roomId);
    }
    if (message.itemType !== 0) {
      writer.uint32(24).uint32(message.itemType);
    }
    if (message.mapVariant !== 0) {
      writer.uint32(32).uint32(message.mapVariant);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCCavernCrawlUseItemOnRoom {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCavernCrawlUseItemOnRoom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.roomId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.itemType = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.mapVariant = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCavernCrawlUseItemOnRoom {
    return {
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      roomId: isSet(object.roomId) ? Number(object.roomId) : 0,
      itemType: isSet(object.itemType) ? Number(object.itemType) : 0,
      mapVariant: isSet(object.mapVariant) ? Number(object.mapVariant) : 0,
    };
  },

  toJSON(message: CMsgClientToGCCavernCrawlUseItemOnRoom): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.roomId !== undefined && (obj.roomId = Math.round(message.roomId));
    message.itemType !== undefined && (obj.itemType = Math.round(message.itemType));
    message.mapVariant !== undefined && (obj.mapVariant = Math.round(message.mapVariant));
    return obj;
  },
};

function createBaseCMsgClientToGCCavernCrawlUseItemOnRoomResponse(): CMsgClientToGCCavernCrawlUseItemOnRoomResponse {
  return { result: 0 };
}

export const CMsgClientToGCCavernCrawlUseItemOnRoomResponse = {
  encode(
    message: CMsgClientToGCCavernCrawlUseItemOnRoomResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCCavernCrawlUseItemOnRoomResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCavernCrawlUseItemOnRoomResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCavernCrawlUseItemOnRoomResponse {
    return {
      result: isSet(object.result) ? cMsgClientToGCCavernCrawlUseItemOnRoomResponse_ResultFromJSON(object.result) : 0,
    };
  },

  toJSON(message: CMsgClientToGCCavernCrawlUseItemOnRoomResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgClientToGCCavernCrawlUseItemOnRoomResponse_ResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgClientToGCCavernCrawlUseItemOnPath(): CMsgClientToGCCavernCrawlUseItemOnPath {
  return { eventId: 0, pathId: 0, itemType: 0, mapVariant: 0 };
}

export const CMsgClientToGCCavernCrawlUseItemOnPath = {
  encode(message: CMsgClientToGCCavernCrawlUseItemOnPath, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    if (message.pathId !== 0) {
      writer.uint32(16).uint32(message.pathId);
    }
    if (message.itemType !== 0) {
      writer.uint32(24).uint32(message.itemType);
    }
    if (message.mapVariant !== 0) {
      writer.uint32(32).uint32(message.mapVariant);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCCavernCrawlUseItemOnPath {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCavernCrawlUseItemOnPath();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.pathId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.itemType = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.mapVariant = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCavernCrawlUseItemOnPath {
    return {
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      pathId: isSet(object.pathId) ? Number(object.pathId) : 0,
      itemType: isSet(object.itemType) ? Number(object.itemType) : 0,
      mapVariant: isSet(object.mapVariant) ? Number(object.mapVariant) : 0,
    };
  },

  toJSON(message: CMsgClientToGCCavernCrawlUseItemOnPath): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.pathId !== undefined && (obj.pathId = Math.round(message.pathId));
    message.itemType !== undefined && (obj.itemType = Math.round(message.itemType));
    message.mapVariant !== undefined && (obj.mapVariant = Math.round(message.mapVariant));
    return obj;
  },
};

function createBaseCMsgClientToGCCavernCrawlUseItemOnPathResponse(): CMsgClientToGCCavernCrawlUseItemOnPathResponse {
  return { result: 0 };
}

export const CMsgClientToGCCavernCrawlUseItemOnPathResponse = {
  encode(
    message: CMsgClientToGCCavernCrawlUseItemOnPathResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCCavernCrawlUseItemOnPathResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCavernCrawlUseItemOnPathResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCavernCrawlUseItemOnPathResponse {
    return {
      result: isSet(object.result) ? cMsgClientToGCCavernCrawlUseItemOnPathResponse_ResultFromJSON(object.result) : 0,
    };
  },

  toJSON(message: CMsgClientToGCCavernCrawlUseItemOnPathResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgClientToGCCavernCrawlUseItemOnPathResponse_ResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgClientToGCCavernCrawlRequestMapState(): CMsgClientToGCCavernCrawlRequestMapState {
  return { eventId: 0 };
}

export const CMsgClientToGCCavernCrawlRequestMapState = {
  encode(message: CMsgClientToGCCavernCrawlRequestMapState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCCavernCrawlRequestMapState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCavernCrawlRequestMapState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCavernCrawlRequestMapState {
    return { eventId: isSet(object.eventId) ? Number(object.eventId) : 0 };
  },

  toJSON(message: CMsgClientToGCCavernCrawlRequestMapState): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    return obj;
  },
};

function createBaseCMsgClientToGCCavernCrawlRequestMapStateResponse(): CMsgClientToGCCavernCrawlRequestMapStateResponse {
  return { result: 0, availableMapVariantsMask: 0, inventoryItem: [], mapVariants: [] };
}

export const CMsgClientToGCCavernCrawlRequestMapStateResponse = {
  encode(
    message: CMsgClientToGCCavernCrawlRequestMapStateResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.availableMapVariantsMask !== 0) {
      writer.uint32(16).uint32(message.availableMapVariantsMask);
    }
    for (const v of message.inventoryItem) {
      CMsgClientToGCCavernCrawlRequestMapStateResponse_InventoryItem.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.mapVariants) {
      CMsgClientToGCCavernCrawlRequestMapStateResponse_MapVariant.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCCavernCrawlRequestMapStateResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCavernCrawlRequestMapStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.availableMapVariantsMask = reader.uint32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.inventoryItem.push(
            CMsgClientToGCCavernCrawlRequestMapStateResponse_InventoryItem.decode(reader, reader.uint32()),
          );
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.mapVariants.push(
            CMsgClientToGCCavernCrawlRequestMapStateResponse_MapVariant.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCavernCrawlRequestMapStateResponse {
    return {
      result: isSet(object.result) ? cMsgClientToGCCavernCrawlRequestMapStateResponse_ResultFromJSON(object.result) : 0,
      availableMapVariantsMask: isSet(object.availableMapVariantsMask) ? Number(object.availableMapVariantsMask) : 0,
      inventoryItem: Array.isArray(object?.inventoryItem)
        ? object.inventoryItem.map((e: any) =>
          CMsgClientToGCCavernCrawlRequestMapStateResponse_InventoryItem.fromJSON(e)
        )
        : [],
      mapVariants: Array.isArray(object?.mapVariants)
        ? object.mapVariants.map((e: any) => CMsgClientToGCCavernCrawlRequestMapStateResponse_MapVariant.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientToGCCavernCrawlRequestMapStateResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgClientToGCCavernCrawlRequestMapStateResponse_ResultToJSON(message.result));
    message.availableMapVariantsMask !== undefined &&
      (obj.availableMapVariantsMask = Math.round(message.availableMapVariantsMask));
    if (message.inventoryItem) {
      obj.inventoryItem = message.inventoryItem.map((e) =>
        e ? CMsgClientToGCCavernCrawlRequestMapStateResponse_InventoryItem.toJSON(e) : undefined
      );
    } else {
      obj.inventoryItem = [];
    }
    if (message.mapVariants) {
      obj.mapVariants = message.mapVariants.map((e) =>
        e ? CMsgClientToGCCavernCrawlRequestMapStateResponse_MapVariant.toJSON(e) : undefined
      );
    } else {
      obj.mapVariants = [];
    }
    return obj;
  },
};

function createBaseCMsgClientToGCCavernCrawlRequestMapStateResponse_SwappedChallenge(): CMsgClientToGCCavernCrawlRequestMapStateResponse_SwappedChallenge {
  return { pathId1: 0, pathId2: 0 };
}

export const CMsgClientToGCCavernCrawlRequestMapStateResponse_SwappedChallenge = {
  encode(
    message: CMsgClientToGCCavernCrawlRequestMapStateResponse_SwappedChallenge,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.pathId1 !== 0) {
      writer.uint32(8).uint32(message.pathId1);
    }
    if (message.pathId2 !== 0) {
      writer.uint32(16).uint32(message.pathId2);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CMsgClientToGCCavernCrawlRequestMapStateResponse_SwappedChallenge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCavernCrawlRequestMapStateResponse_SwappedChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.pathId1 = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.pathId2 = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCavernCrawlRequestMapStateResponse_SwappedChallenge {
    return {
      pathId1: isSet(object.pathId1) ? Number(object.pathId1) : 0,
      pathId2: isSet(object.pathId2) ? Number(object.pathId2) : 0,
    };
  },

  toJSON(message: CMsgClientToGCCavernCrawlRequestMapStateResponse_SwappedChallenge): unknown {
    const obj: any = {};
    message.pathId1 !== undefined && (obj.pathId1 = Math.round(message.pathId1));
    message.pathId2 !== undefined && (obj.pathId2 = Math.round(message.pathId2));
    return obj;
  },
};

function createBaseCMsgClientToGCCavernCrawlRequestMapStateResponse_InventoryItem(): CMsgClientToGCCavernCrawlRequestMapStateResponse_InventoryItem {
  return { itemType: 0, count: 0 };
}

export const CMsgClientToGCCavernCrawlRequestMapStateResponse_InventoryItem = {
  encode(
    message: CMsgClientToGCCavernCrawlRequestMapStateResponse_InventoryItem,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.itemType !== 0) {
      writer.uint32(8).uint32(message.itemType);
    }
    if (message.count !== 0) {
      writer.uint32(16).uint32(message.count);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CMsgClientToGCCavernCrawlRequestMapStateResponse_InventoryItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCavernCrawlRequestMapStateResponse_InventoryItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.itemType = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.count = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCavernCrawlRequestMapStateResponse_InventoryItem {
    return {
      itemType: isSet(object.itemType) ? Number(object.itemType) : 0,
      count: isSet(object.count) ? Number(object.count) : 0,
    };
  },

  toJSON(message: CMsgClientToGCCavernCrawlRequestMapStateResponse_InventoryItem): unknown {
    const obj: any = {};
    message.itemType !== undefined && (obj.itemType = Math.round(message.itemType));
    message.count !== undefined && (obj.count = Math.round(message.count));
    return obj;
  },
};

function createBaseCMsgClientToGCCavernCrawlRequestMapStateResponse_TreasureMap(): CMsgClientToGCCavernCrawlRequestMapStateResponse_TreasureMap {
  return { mapRoomId: 0, revealedRoomId: 0 };
}

export const CMsgClientToGCCavernCrawlRequestMapStateResponse_TreasureMap = {
  encode(
    message: CMsgClientToGCCavernCrawlRequestMapStateResponse_TreasureMap,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.mapRoomId !== 0) {
      writer.uint32(8).uint32(message.mapRoomId);
    }
    if (message.revealedRoomId !== 0) {
      writer.uint32(16).uint32(message.revealedRoomId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CMsgClientToGCCavernCrawlRequestMapStateResponse_TreasureMap {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCavernCrawlRequestMapStateResponse_TreasureMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.mapRoomId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.revealedRoomId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCavernCrawlRequestMapStateResponse_TreasureMap {
    return {
      mapRoomId: isSet(object.mapRoomId) ? Number(object.mapRoomId) : 0,
      revealedRoomId: isSet(object.revealedRoomId) ? Number(object.revealedRoomId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCCavernCrawlRequestMapStateResponse_TreasureMap): unknown {
    const obj: any = {};
    message.mapRoomId !== undefined && (obj.mapRoomId = Math.round(message.mapRoomId));
    message.revealedRoomId !== undefined && (obj.revealedRoomId = Math.round(message.revealedRoomId));
    return obj;
  },
};

function createBaseCMsgClientToGCCavernCrawlRequestMapStateResponse_MapVariant(): CMsgClientToGCCavernCrawlRequestMapStateResponse_MapVariant {
  return {
    mapVariant: 0,
    claimedRooms1: "0",
    claimedRooms2: "0",
    revealedRooms1: "0",
    revealedRooms2: "0",
    completedPaths1: "0",
    completedPaths2: "0",
    completedPaths3: "0",
    completedPaths4: "0",
    halfCompletedPaths1: "0",
    halfCompletedPaths2: "0",
    halfCompletedPaths3: "0",
    halfCompletedPaths4: "0",
    swappedChallenge: [],
    ultraRareRewardRoomNumber: 0,
    treasureMap: [],
  };
}

export const CMsgClientToGCCavernCrawlRequestMapStateResponse_MapVariant = {
  encode(
    message: CMsgClientToGCCavernCrawlRequestMapStateResponse_MapVariant,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.mapVariant !== 0) {
      writer.uint32(8).uint32(message.mapVariant);
    }
    if (message.claimedRooms1 !== "0") {
      writer.uint32(17).fixed64(message.claimedRooms1);
    }
    if (message.claimedRooms2 !== "0") {
      writer.uint32(25).fixed64(message.claimedRooms2);
    }
    if (message.revealedRooms1 !== "0") {
      writer.uint32(33).fixed64(message.revealedRooms1);
    }
    if (message.revealedRooms2 !== "0") {
      writer.uint32(41).fixed64(message.revealedRooms2);
    }
    if (message.completedPaths1 !== "0") {
      writer.uint32(49).fixed64(message.completedPaths1);
    }
    if (message.completedPaths2 !== "0") {
      writer.uint32(57).fixed64(message.completedPaths2);
    }
    if (message.completedPaths3 !== "0") {
      writer.uint32(65).fixed64(message.completedPaths3);
    }
    if (message.completedPaths4 !== "0") {
      writer.uint32(73).fixed64(message.completedPaths4);
    }
    if (message.halfCompletedPaths1 !== "0") {
      writer.uint32(81).fixed64(message.halfCompletedPaths1);
    }
    if (message.halfCompletedPaths2 !== "0") {
      writer.uint32(89).fixed64(message.halfCompletedPaths2);
    }
    if (message.halfCompletedPaths3 !== "0") {
      writer.uint32(97).fixed64(message.halfCompletedPaths3);
    }
    if (message.halfCompletedPaths4 !== "0") {
      writer.uint32(105).fixed64(message.halfCompletedPaths4);
    }
    for (const v of message.swappedChallenge) {
      CMsgClientToGCCavernCrawlRequestMapStateResponse_SwappedChallenge.encode(v!, writer.uint32(114).fork()).ldelim();
    }
    if (message.ultraRareRewardRoomNumber !== 0) {
      writer.uint32(120).uint32(message.ultraRareRewardRoomNumber);
    }
    for (const v of message.treasureMap) {
      CMsgClientToGCCavernCrawlRequestMapStateResponse_TreasureMap.encode(v!, writer.uint32(130).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCCavernCrawlRequestMapStateResponse_MapVariant {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCavernCrawlRequestMapStateResponse_MapVariant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.mapVariant = reader.uint32();
          continue;
        case 2:
          if (tag != 17) {
            break;
          }

          message.claimedRooms1 = longToString(reader.fixed64() as Long);
          continue;
        case 3:
          if (tag != 25) {
            break;
          }

          message.claimedRooms2 = longToString(reader.fixed64() as Long);
          continue;
        case 4:
          if (tag != 33) {
            break;
          }

          message.revealedRooms1 = longToString(reader.fixed64() as Long);
          continue;
        case 5:
          if (tag != 41) {
            break;
          }

          message.revealedRooms2 = longToString(reader.fixed64() as Long);
          continue;
        case 6:
          if (tag != 49) {
            break;
          }

          message.completedPaths1 = longToString(reader.fixed64() as Long);
          continue;
        case 7:
          if (tag != 57) {
            break;
          }

          message.completedPaths2 = longToString(reader.fixed64() as Long);
          continue;
        case 8:
          if (tag != 65) {
            break;
          }

          message.completedPaths3 = longToString(reader.fixed64() as Long);
          continue;
        case 9:
          if (tag != 73) {
            break;
          }

          message.completedPaths4 = longToString(reader.fixed64() as Long);
          continue;
        case 10:
          if (tag != 81) {
            break;
          }

          message.halfCompletedPaths1 = longToString(reader.fixed64() as Long);
          continue;
        case 11:
          if (tag != 89) {
            break;
          }

          message.halfCompletedPaths2 = longToString(reader.fixed64() as Long);
          continue;
        case 12:
          if (tag != 97) {
            break;
          }

          message.halfCompletedPaths3 = longToString(reader.fixed64() as Long);
          continue;
        case 13:
          if (tag != 105) {
            break;
          }

          message.halfCompletedPaths4 = longToString(reader.fixed64() as Long);
          continue;
        case 14:
          if (tag != 114) {
            break;
          }

          message.swappedChallenge.push(
            CMsgClientToGCCavernCrawlRequestMapStateResponse_SwappedChallenge.decode(reader, reader.uint32()),
          );
          continue;
        case 15:
          if (tag != 120) {
            break;
          }

          message.ultraRareRewardRoomNumber = reader.uint32();
          continue;
        case 16:
          if (tag != 130) {
            break;
          }

          message.treasureMap.push(
            CMsgClientToGCCavernCrawlRequestMapStateResponse_TreasureMap.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCavernCrawlRequestMapStateResponse_MapVariant {
    return {
      mapVariant: isSet(object.mapVariant) ? Number(object.mapVariant) : 0,
      claimedRooms1: isSet(object.claimedRooms1) ? String(object.claimedRooms1) : "0",
      claimedRooms2: isSet(object.claimedRooms2) ? String(object.claimedRooms2) : "0",
      revealedRooms1: isSet(object.revealedRooms1) ? String(object.revealedRooms1) : "0",
      revealedRooms2: isSet(object.revealedRooms2) ? String(object.revealedRooms2) : "0",
      completedPaths1: isSet(object.completedPaths1) ? String(object.completedPaths1) : "0",
      completedPaths2: isSet(object.completedPaths2) ? String(object.completedPaths2) : "0",
      completedPaths3: isSet(object.completedPaths3) ? String(object.completedPaths3) : "0",
      completedPaths4: isSet(object.completedPaths4) ? String(object.completedPaths4) : "0",
      halfCompletedPaths1: isSet(object.halfCompletedPaths1) ? String(object.halfCompletedPaths1) : "0",
      halfCompletedPaths2: isSet(object.halfCompletedPaths2) ? String(object.halfCompletedPaths2) : "0",
      halfCompletedPaths3: isSet(object.halfCompletedPaths3) ? String(object.halfCompletedPaths3) : "0",
      halfCompletedPaths4: isSet(object.halfCompletedPaths4) ? String(object.halfCompletedPaths4) : "0",
      swappedChallenge: Array.isArray(object?.swappedChallenge)
        ? object.swappedChallenge.map((e: any) =>
          CMsgClientToGCCavernCrawlRequestMapStateResponse_SwappedChallenge.fromJSON(e)
        )
        : [],
      ultraRareRewardRoomNumber: isSet(object.ultraRareRewardRoomNumber) ? Number(object.ultraRareRewardRoomNumber) : 0,
      treasureMap: Array.isArray(object?.treasureMap)
        ? object.treasureMap.map((e: any) => CMsgClientToGCCavernCrawlRequestMapStateResponse_TreasureMap.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientToGCCavernCrawlRequestMapStateResponse_MapVariant): unknown {
    const obj: any = {};
    message.mapVariant !== undefined && (obj.mapVariant = Math.round(message.mapVariant));
    message.claimedRooms1 !== undefined && (obj.claimedRooms1 = message.claimedRooms1);
    message.claimedRooms2 !== undefined && (obj.claimedRooms2 = message.claimedRooms2);
    message.revealedRooms1 !== undefined && (obj.revealedRooms1 = message.revealedRooms1);
    message.revealedRooms2 !== undefined && (obj.revealedRooms2 = message.revealedRooms2);
    message.completedPaths1 !== undefined && (obj.completedPaths1 = message.completedPaths1);
    message.completedPaths2 !== undefined && (obj.completedPaths2 = message.completedPaths2);
    message.completedPaths3 !== undefined && (obj.completedPaths3 = message.completedPaths3);
    message.completedPaths4 !== undefined && (obj.completedPaths4 = message.completedPaths4);
    message.halfCompletedPaths1 !== undefined && (obj.halfCompletedPaths1 = message.halfCompletedPaths1);
    message.halfCompletedPaths2 !== undefined && (obj.halfCompletedPaths2 = message.halfCompletedPaths2);
    message.halfCompletedPaths3 !== undefined && (obj.halfCompletedPaths3 = message.halfCompletedPaths3);
    message.halfCompletedPaths4 !== undefined && (obj.halfCompletedPaths4 = message.halfCompletedPaths4);
    if (message.swappedChallenge) {
      obj.swappedChallenge = message.swappedChallenge.map((e) =>
        e ? CMsgClientToGCCavernCrawlRequestMapStateResponse_SwappedChallenge.toJSON(e) : undefined
      );
    } else {
      obj.swappedChallenge = [];
    }
    message.ultraRareRewardRoomNumber !== undefined &&
      (obj.ultraRareRewardRoomNumber = Math.round(message.ultraRareRewardRoomNumber));
    if (message.treasureMap) {
      obj.treasureMap = message.treasureMap.map((e) =>
        e ? CMsgClientToGCCavernCrawlRequestMapStateResponse_TreasureMap.toJSON(e) : undefined
      );
    } else {
      obj.treasureMap = [];
    }
    return obj;
  },
};

function createBaseCMsgClientToGCCavernCrawlGetClaimedRoomCount(): CMsgClientToGCCavernCrawlGetClaimedRoomCount {
  return { eventId: 0 };
}

export const CMsgClientToGCCavernCrawlGetClaimedRoomCount = {
  encode(message: CMsgClientToGCCavernCrawlGetClaimedRoomCount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCCavernCrawlGetClaimedRoomCount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCavernCrawlGetClaimedRoomCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCavernCrawlGetClaimedRoomCount {
    return { eventId: isSet(object.eventId) ? Number(object.eventId) : 0 };
  },

  toJSON(message: CMsgClientToGCCavernCrawlGetClaimedRoomCount): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    return obj;
  },
};

function createBaseCMsgClientToGCCavernCrawlGetClaimedRoomCountResponse(): CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse {
  return { result: 0, mapVariants: [], availableMapVariantsMask: 0 };
}

export const CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse = {
  encode(
    message: CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    for (const v of message.mapVariants) {
      CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_MapVariant.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.availableMapVariantsMask !== 0) {
      writer.uint32(24).uint32(message.availableMapVariantsMask);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCavernCrawlGetClaimedRoomCountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.mapVariants.push(
            CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_MapVariant.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.availableMapVariantsMask = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse {
    return {
      result: isSet(object.result)
        ? cMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_ResultFromJSON(object.result)
        : 0,
      mapVariants: Array.isArray(object?.mapVariants)
        ? object.mapVariants.map((e: any) =>
          CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_MapVariant.fromJSON(e)
        )
        : [],
      availableMapVariantsMask: isSet(object.availableMapVariantsMask) ? Number(object.availableMapVariantsMask) : 0,
    };
  },

  toJSON(message: CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_ResultToJSON(message.result));
    if (message.mapVariants) {
      obj.mapVariants = message.mapVariants.map((e) =>
        e ? CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_MapVariant.toJSON(e) : undefined
      );
    } else {
      obj.mapVariants = [];
    }
    message.availableMapVariantsMask !== undefined &&
      (obj.availableMapVariantsMask = Math.round(message.availableMapVariantsMask));
    return obj;
  },
};

function createBaseCMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_MapVariant(): CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_MapVariant {
  return { mapVariant: 0, count: 0 };
}

export const CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_MapVariant = {
  encode(
    message: CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_MapVariant,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.mapVariant !== 0) {
      writer.uint32(8).uint32(message.mapVariant);
    }
    if (message.count !== 0) {
      writer.uint32(16).uint32(message.count);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_MapVariant {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_MapVariant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.mapVariant = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.count = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_MapVariant {
    return {
      mapVariant: isSet(object.mapVariant) ? Number(object.mapVariant) : 0,
      count: isSet(object.count) ? Number(object.count) : 0,
    };
  },

  toJSON(message: CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse_MapVariant): unknown {
    const obj: any = {};
    message.mapVariant !== undefined && (obj.mapVariant = Math.round(message.mapVariant));
    message.count !== undefined && (obj.count = Math.round(message.count));
    return obj;
  },
};

function createBaseCMsgDOTAMutationList(): CMsgDOTAMutationList {
  return { mutations: [] };
}

export const CMsgDOTAMutationList = {
  encode(message: CMsgDOTAMutationList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.mutations) {
      CMsgDOTAMutationList_Mutation.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAMutationList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMutationList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.mutations.push(CMsgDOTAMutationList_Mutation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMutationList {
    return {
      mutations: Array.isArray(object?.mutations)
        ? object.mutations.map((e: any) => CMsgDOTAMutationList_Mutation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTAMutationList): unknown {
    const obj: any = {};
    if (message.mutations) {
      obj.mutations = message.mutations.map((e) => e ? CMsgDOTAMutationList_Mutation.toJSON(e) : undefined);
    } else {
      obj.mutations = [];
    }
    return obj;
  },
};

function createBaseCMsgDOTAMutationList_Mutation(): CMsgDOTAMutationList_Mutation {
  return { id: 0, name: "", description: "" };
}

export const CMsgDOTAMutationList_Mutation = {
  encode(message: CMsgDOTAMutationList_Mutation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAMutationList_Mutation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMutationList_Mutation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMutationList_Mutation {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      name: isSet(object.name) ? String(object.name) : "",
      description: isSet(object.description) ? String(object.description) : "",
    };
  },

  toJSON(message: CMsgDOTAMutationList_Mutation): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.name !== undefined && (obj.name = message.name);
    message.description !== undefined && (obj.description = message.description);
    return obj;
  },
};

function createBaseCMsgEventTipsSummaryRequest(): CMsgEventTipsSummaryRequest {
  return { eventId: 0, accountId: 0 };
}

export const CMsgEventTipsSummaryRequest = {
  encode(message: CMsgEventTipsSummaryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).int32(message.eventId);
    }
    if (message.accountId !== 0) {
      writer.uint32(16).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgEventTipsSummaryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgEventTipsSummaryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgEventTipsSummaryRequest {
    return {
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
    };
  },

  toJSON(message: CMsgEventTipsSummaryRequest): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = eEventToJSON(message.eventId));
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    return obj;
  },
};

function createBaseCMsgEventTipsSummaryResponse(): CMsgEventTipsSummaryResponse {
  return { result: false, tipsReceived: [] };
}

export const CMsgEventTipsSummaryResponse = {
  encode(message: CMsgEventTipsSummaryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result === true) {
      writer.uint32(8).bool(message.result);
    }
    for (const v of message.tipsReceived) {
      CMsgEventTipsSummaryResponse_Tipper.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgEventTipsSummaryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgEventTipsSummaryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.bool();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.tipsReceived.push(CMsgEventTipsSummaryResponse_Tipper.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgEventTipsSummaryResponse {
    return {
      result: isSet(object.result) ? Boolean(object.result) : false,
      tipsReceived: Array.isArray(object?.tipsReceived)
        ? object.tipsReceived.map((e: any) => CMsgEventTipsSummaryResponse_Tipper.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgEventTipsSummaryResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = message.result);
    if (message.tipsReceived) {
      obj.tipsReceived = message.tipsReceived.map((e) => e ? CMsgEventTipsSummaryResponse_Tipper.toJSON(e) : undefined);
    } else {
      obj.tipsReceived = [];
    }
    return obj;
  },
};

function createBaseCMsgEventTipsSummaryResponse_Tipper(): CMsgEventTipsSummaryResponse_Tipper {
  return { tipperAccountId: 0, tipCount: 0 };
}

export const CMsgEventTipsSummaryResponse_Tipper = {
  encode(message: CMsgEventTipsSummaryResponse_Tipper, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tipperAccountId !== 0) {
      writer.uint32(8).uint32(message.tipperAccountId);
    }
    if (message.tipCount !== 0) {
      writer.uint32(16).uint32(message.tipCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgEventTipsSummaryResponse_Tipper {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgEventTipsSummaryResponse_Tipper();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.tipperAccountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.tipCount = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgEventTipsSummaryResponse_Tipper {
    return {
      tipperAccountId: isSet(object.tipperAccountId) ? Number(object.tipperAccountId) : 0,
      tipCount: isSet(object.tipCount) ? Number(object.tipCount) : 0,
    };
  },

  toJSON(message: CMsgEventTipsSummaryResponse_Tipper): unknown {
    const obj: any = {};
    message.tipperAccountId !== undefined && (obj.tipperAccountId = Math.round(message.tipperAccountId));
    message.tipCount !== undefined && (obj.tipCount = Math.round(message.tipCount));
    return obj;
  },
};

function createBaseCMsgSocialFeedRequest(): CMsgSocialFeedRequest {
  return { accountId: 0, selfOnly: false };
}

export const CMsgSocialFeedRequest = {
  encode(message: CMsgSocialFeedRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.selfOnly === true) {
      writer.uint32(16).bool(message.selfOnly);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSocialFeedRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSocialFeedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.selfOnly = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSocialFeedRequest {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      selfOnly: isSet(object.selfOnly) ? Boolean(object.selfOnly) : false,
    };
  },

  toJSON(message: CMsgSocialFeedRequest): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.selfOnly !== undefined && (obj.selfOnly = message.selfOnly);
    return obj;
  },
};

function createBaseCMsgSocialFeedResponse(): CMsgSocialFeedResponse {
  return { result: 0, feedEvents: [] };
}

export const CMsgSocialFeedResponse = {
  encode(message: CMsgSocialFeedResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    for (const v of message.feedEvents) {
      CMsgSocialFeedResponse_FeedEvent.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSocialFeedResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSocialFeedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.feedEvents.push(CMsgSocialFeedResponse_FeedEvent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSocialFeedResponse {
    return {
      result: isSet(object.result) ? cMsgSocialFeedResponse_ResultFromJSON(object.result) : 0,
      feedEvents: Array.isArray(object?.feedEvents)
        ? object.feedEvents.map((e: any) => CMsgSocialFeedResponse_FeedEvent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSocialFeedResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = cMsgSocialFeedResponse_ResultToJSON(message.result));
    if (message.feedEvents) {
      obj.feedEvents = message.feedEvents.map((e) => e ? CMsgSocialFeedResponse_FeedEvent.toJSON(e) : undefined);
    } else {
      obj.feedEvents = [];
    }
    return obj;
  },
};

function createBaseCMsgSocialFeedResponse_FeedEvent(): CMsgSocialFeedResponse_FeedEvent {
  return {
    feedEventId: "0",
    accountId: 0,
    timestamp: 0,
    commentCount: 0,
    eventType: 0,
    eventSubType: 0,
    paramBigInt1: "0",
    paramInt1: 0,
    paramInt2: 0,
    paramInt3: 0,
    paramString: "",
  };
}

export const CMsgSocialFeedResponse_FeedEvent = {
  encode(message: CMsgSocialFeedResponse_FeedEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.feedEventId !== "0") {
      writer.uint32(8).uint64(message.feedEventId);
    }
    if (message.accountId !== 0) {
      writer.uint32(16).uint32(message.accountId);
    }
    if (message.timestamp !== 0) {
      writer.uint32(24).uint32(message.timestamp);
    }
    if (message.commentCount !== 0) {
      writer.uint32(32).uint32(message.commentCount);
    }
    if (message.eventType !== 0) {
      writer.uint32(40).uint32(message.eventType);
    }
    if (message.eventSubType !== 0) {
      writer.uint32(48).uint32(message.eventSubType);
    }
    if (message.paramBigInt1 !== "0") {
      writer.uint32(56).uint64(message.paramBigInt1);
    }
    if (message.paramInt1 !== 0) {
      writer.uint32(64).uint32(message.paramInt1);
    }
    if (message.paramInt2 !== 0) {
      writer.uint32(72).uint32(message.paramInt2);
    }
    if (message.paramInt3 !== 0) {
      writer.uint32(80).uint32(message.paramInt3);
    }
    if (message.paramString !== "") {
      writer.uint32(90).string(message.paramString);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSocialFeedResponse_FeedEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSocialFeedResponse_FeedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.feedEventId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.commentCount = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.eventType = reader.uint32();
          continue;
        case 6:
          if (tag != 48) {
            break;
          }

          message.eventSubType = reader.uint32();
          continue;
        case 7:
          if (tag != 56) {
            break;
          }

          message.paramBigInt1 = longToString(reader.uint64() as Long);
          continue;
        case 8:
          if (tag != 64) {
            break;
          }

          message.paramInt1 = reader.uint32();
          continue;
        case 9:
          if (tag != 72) {
            break;
          }

          message.paramInt2 = reader.uint32();
          continue;
        case 10:
          if (tag != 80) {
            break;
          }

          message.paramInt3 = reader.uint32();
          continue;
        case 11:
          if (tag != 90) {
            break;
          }

          message.paramString = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSocialFeedResponse_FeedEvent {
    return {
      feedEventId: isSet(object.feedEventId) ? String(object.feedEventId) : "0",
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      timestamp: isSet(object.timestamp) ? Number(object.timestamp) : 0,
      commentCount: isSet(object.commentCount) ? Number(object.commentCount) : 0,
      eventType: isSet(object.eventType) ? Number(object.eventType) : 0,
      eventSubType: isSet(object.eventSubType) ? Number(object.eventSubType) : 0,
      paramBigInt1: isSet(object.paramBigInt1) ? String(object.paramBigInt1) : "0",
      paramInt1: isSet(object.paramInt1) ? Number(object.paramInt1) : 0,
      paramInt2: isSet(object.paramInt2) ? Number(object.paramInt2) : 0,
      paramInt3: isSet(object.paramInt3) ? Number(object.paramInt3) : 0,
      paramString: isSet(object.paramString) ? String(object.paramString) : "",
    };
  },

  toJSON(message: CMsgSocialFeedResponse_FeedEvent): unknown {
    const obj: any = {};
    message.feedEventId !== undefined && (obj.feedEventId = message.feedEventId);
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.timestamp !== undefined && (obj.timestamp = Math.round(message.timestamp));
    message.commentCount !== undefined && (obj.commentCount = Math.round(message.commentCount));
    message.eventType !== undefined && (obj.eventType = Math.round(message.eventType));
    message.eventSubType !== undefined && (obj.eventSubType = Math.round(message.eventSubType));
    message.paramBigInt1 !== undefined && (obj.paramBigInt1 = message.paramBigInt1);
    message.paramInt1 !== undefined && (obj.paramInt1 = Math.round(message.paramInt1));
    message.paramInt2 !== undefined && (obj.paramInt2 = Math.round(message.paramInt2));
    message.paramInt3 !== undefined && (obj.paramInt3 = Math.round(message.paramInt3));
    message.paramString !== undefined && (obj.paramString = message.paramString);
    return obj;
  },
};

function createBaseCMsgSocialFeedCommentsRequest(): CMsgSocialFeedCommentsRequest {
  return { feedEventId: "0" };
}

export const CMsgSocialFeedCommentsRequest = {
  encode(message: CMsgSocialFeedCommentsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.feedEventId !== "0") {
      writer.uint32(8).uint64(message.feedEventId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSocialFeedCommentsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSocialFeedCommentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.feedEventId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSocialFeedCommentsRequest {
    return { feedEventId: isSet(object.feedEventId) ? String(object.feedEventId) : "0" };
  },

  toJSON(message: CMsgSocialFeedCommentsRequest): unknown {
    const obj: any = {};
    message.feedEventId !== undefined && (obj.feedEventId = message.feedEventId);
    return obj;
  },
};

function createBaseCMsgSocialFeedCommentsResponse(): CMsgSocialFeedCommentsResponse {
  return { result: 0, feedComments: [] };
}

export const CMsgSocialFeedCommentsResponse = {
  encode(message: CMsgSocialFeedCommentsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    for (const v of message.feedComments) {
      CMsgSocialFeedCommentsResponse_FeedComment.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSocialFeedCommentsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSocialFeedCommentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.feedComments.push(CMsgSocialFeedCommentsResponse_FeedComment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSocialFeedCommentsResponse {
    return {
      result: isSet(object.result) ? cMsgSocialFeedCommentsResponse_ResultFromJSON(object.result) : 0,
      feedComments: Array.isArray(object?.feedComments)
        ? object.feedComments.map((e: any) => CMsgSocialFeedCommentsResponse_FeedComment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSocialFeedCommentsResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = cMsgSocialFeedCommentsResponse_ResultToJSON(message.result));
    if (message.feedComments) {
      obj.feedComments = message.feedComments.map((e) =>
        e ? CMsgSocialFeedCommentsResponse_FeedComment.toJSON(e) : undefined
      );
    } else {
      obj.feedComments = [];
    }
    return obj;
  },
};

function createBaseCMsgSocialFeedCommentsResponse_FeedComment(): CMsgSocialFeedCommentsResponse_FeedComment {
  return { commenterAccountId: 0, timestamp: 0, commentText: "" };
}

export const CMsgSocialFeedCommentsResponse_FeedComment = {
  encode(message: CMsgSocialFeedCommentsResponse_FeedComment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.commenterAccountId !== 0) {
      writer.uint32(8).uint32(message.commenterAccountId);
    }
    if (message.timestamp !== 0) {
      writer.uint32(16).uint32(message.timestamp);
    }
    if (message.commentText !== "") {
      writer.uint32(26).string(message.commentText);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSocialFeedCommentsResponse_FeedComment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSocialFeedCommentsResponse_FeedComment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.commenterAccountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.commentText = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSocialFeedCommentsResponse_FeedComment {
    return {
      commenterAccountId: isSet(object.commenterAccountId) ? Number(object.commenterAccountId) : 0,
      timestamp: isSet(object.timestamp) ? Number(object.timestamp) : 0,
      commentText: isSet(object.commentText) ? String(object.commentText) : "",
    };
  },

  toJSON(message: CMsgSocialFeedCommentsResponse_FeedComment): unknown {
    const obj: any = {};
    message.commenterAccountId !== undefined && (obj.commenterAccountId = Math.round(message.commenterAccountId));
    message.timestamp !== undefined && (obj.timestamp = Math.round(message.timestamp));
    message.commentText !== undefined && (obj.commentText = message.commentText);
    return obj;
  },
};

function createBaseCMsgClientToGCPlayerCardSpecificPurchaseRequest(): CMsgClientToGCPlayerCardSpecificPurchaseRequest {
  return { playerAccountId: 0, eventId: 0, cardDustItemId: "0" };
}

export const CMsgClientToGCPlayerCardSpecificPurchaseRequest = {
  encode(
    message: CMsgClientToGCPlayerCardSpecificPurchaseRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.playerAccountId !== 0) {
      writer.uint32(8).uint32(message.playerAccountId);
    }
    if (message.eventId !== 0) {
      writer.uint32(16).uint32(message.eventId);
    }
    if (message.cardDustItemId !== "0") {
      writer.uint32(24).uint64(message.cardDustItemId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCPlayerCardSpecificPurchaseRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCPlayerCardSpecificPurchaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.playerAccountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.cardDustItemId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCPlayerCardSpecificPurchaseRequest {
    return {
      playerAccountId: isSet(object.playerAccountId) ? Number(object.playerAccountId) : 0,
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      cardDustItemId: isSet(object.cardDustItemId) ? String(object.cardDustItemId) : "0",
    };
  },

  toJSON(message: CMsgClientToGCPlayerCardSpecificPurchaseRequest): unknown {
    const obj: any = {};
    message.playerAccountId !== undefined && (obj.playerAccountId = Math.round(message.playerAccountId));
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.cardDustItemId !== undefined && (obj.cardDustItemId = message.cardDustItemId);
    return obj;
  },
};

function createBaseCMsgClientToGCPlayerCardSpecificPurchaseResponse(): CMsgClientToGCPlayerCardSpecificPurchaseResponse {
  return { result: 1, itemId: "0" };
}

export const CMsgClientToGCPlayerCardSpecificPurchaseResponse = {
  encode(
    message: CMsgClientToGCPlayerCardSpecificPurchaseResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.result !== 1) {
      writer.uint32(8).int32(message.result);
    }
    if (message.itemId !== "0") {
      writer.uint32(16).uint64(message.itemId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCPlayerCardSpecificPurchaseResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCPlayerCardSpecificPurchaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.itemId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCPlayerCardSpecificPurchaseResponse {
    return {
      result: isSet(object.result) ? cMsgClientToGCPlayerCardSpecificPurchaseResponse_ResultFromJSON(object.result) : 1,
      itemId: isSet(object.itemId) ? String(object.itemId) : "0",
    };
  },

  toJSON(message: CMsgClientToGCPlayerCardSpecificPurchaseResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgClientToGCPlayerCardSpecificPurchaseResponse_ResultToJSON(message.result));
    message.itemId !== undefined && (obj.itemId = message.itemId);
    return obj;
  },
};

function createBaseCMsgClientToGCRequestContestVotes(): CMsgClientToGCRequestContestVotes {
  return { contestId: 0 };
}

export const CMsgClientToGCRequestContestVotes = {
  encode(message: CMsgClientToGCRequestContestVotes, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contestId !== 0) {
      writer.uint32(8).uint32(message.contestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRequestContestVotes {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRequestContestVotes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.contestId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRequestContestVotes {
    return { contestId: isSet(object.contestId) ? Number(object.contestId) : 0 };
  },

  toJSON(message: CMsgClientToGCRequestContestVotes): unknown {
    const obj: any = {};
    message.contestId !== undefined && (obj.contestId = Math.round(message.contestId));
    return obj;
  },
};

function createBaseCMsgClientToGCRequestContestVotesResponse(): CMsgClientToGCRequestContestVotesResponse {
  return { result: 0, votes: [] };
}

export const CMsgClientToGCRequestContestVotesResponse = {
  encode(message: CMsgClientToGCRequestContestVotesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    for (const v of message.votes) {
      CMsgClientToGCRequestContestVotesResponse_ItemVote.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRequestContestVotesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRequestContestVotesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.votes.push(CMsgClientToGCRequestContestVotesResponse_ItemVote.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRequestContestVotesResponse {
    return {
      result: isSet(object.result) ? cMsgClientToGCRequestContestVotesResponse_EResponseFromJSON(object.result) : 0,
      votes: Array.isArray(object?.votes)
        ? object.votes.map((e: any) => CMsgClientToGCRequestContestVotesResponse_ItemVote.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientToGCRequestContestVotesResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgClientToGCRequestContestVotesResponse_EResponseToJSON(message.result));
    if (message.votes) {
      obj.votes = message.votes.map((e) =>
        e ? CMsgClientToGCRequestContestVotesResponse_ItemVote.toJSON(e) : undefined
      );
    } else {
      obj.votes = [];
    }
    return obj;
  },
};

function createBaseCMsgClientToGCRequestContestVotesResponse_ItemVote(): CMsgClientToGCRequestContestVotesResponse_ItemVote {
  return { contestItemId: "0", vote: 0 };
}

export const CMsgClientToGCRequestContestVotesResponse_ItemVote = {
  encode(
    message: CMsgClientToGCRequestContestVotesResponse_ItemVote,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.contestItemId !== "0") {
      writer.uint32(8).uint64(message.contestItemId);
    }
    if (message.vote !== 0) {
      writer.uint32(16).int32(message.vote);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRequestContestVotesResponse_ItemVote {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRequestContestVotesResponse_ItemVote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.contestItemId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.vote = reader.int32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRequestContestVotesResponse_ItemVote {
    return {
      contestItemId: isSet(object.contestItemId) ? String(object.contestItemId) : "0",
      vote: isSet(object.vote) ? Number(object.vote) : 0,
    };
  },

  toJSON(message: CMsgClientToGCRequestContestVotesResponse_ItemVote): unknown {
    const obj: any = {};
    message.contestItemId !== undefined && (obj.contestItemId = message.contestItemId);
    message.vote !== undefined && (obj.vote = Math.round(message.vote));
    return obj;
  },
};

function createBaseCMsgClientToGCRecordContestVote(): CMsgClientToGCRecordContestVote {
  return { contestId: 0, contestItemId: "0", vote: 0 };
}

export const CMsgClientToGCRecordContestVote = {
  encode(message: CMsgClientToGCRecordContestVote, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contestId !== 0) {
      writer.uint32(8).uint32(message.contestId);
    }
    if (message.contestItemId !== "0") {
      writer.uint32(16).uint64(message.contestItemId);
    }
    if (message.vote !== 0) {
      writer.uint32(24).int32(message.vote);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRecordContestVote {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRecordContestVote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.contestId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.contestItemId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.vote = reader.int32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRecordContestVote {
    return {
      contestId: isSet(object.contestId) ? Number(object.contestId) : 0,
      contestItemId: isSet(object.contestItemId) ? String(object.contestItemId) : "0",
      vote: isSet(object.vote) ? Number(object.vote) : 0,
    };
  },

  toJSON(message: CMsgClientToGCRecordContestVote): unknown {
    const obj: any = {};
    message.contestId !== undefined && (obj.contestId = Math.round(message.contestId));
    message.contestItemId !== undefined && (obj.contestItemId = message.contestItemId);
    message.vote !== undefined && (obj.vote = Math.round(message.vote));
    return obj;
  },
};

function createBaseCMsgGCToClientRecordContestVoteResponse(): CMsgGCToClientRecordContestVoteResponse {
  return { eresult: 0 };
}

export const CMsgGCToClientRecordContestVoteResponse = {
  encode(message: CMsgGCToClientRecordContestVoteResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== 0) {
      writer.uint32(8).int32(message.eresult);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientRecordContestVoteResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientRecordContestVoteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eresult = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientRecordContestVoteResponse {
    return {
      eresult: isSet(object.eresult) ? cMsgGCToClientRecordContestVoteResponse_EResultFromJSON(object.eresult) : 0,
    };
  },

  toJSON(message: CMsgGCToClientRecordContestVoteResponse): unknown {
    const obj: any = {};
    message.eresult !== undefined &&
      (obj.eresult = cMsgGCToClientRecordContestVoteResponse_EResultToJSON(message.eresult));
    return obj;
  },
};

function createBaseCMsgDevGrantEventPoints(): CMsgDevGrantEventPoints {
  return { eventId: 0, eventPoints: 0, premiumPoints: 0 };
}

export const CMsgDevGrantEventPoints = {
  encode(message: CMsgDevGrantEventPoints, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).int32(message.eventId);
    }
    if (message.eventPoints !== 0) {
      writer.uint32(16).uint32(message.eventPoints);
    }
    if (message.premiumPoints !== 0) {
      writer.uint32(24).uint32(message.premiumPoints);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDevGrantEventPoints {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDevGrantEventPoints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.eventPoints = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.premiumPoints = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDevGrantEventPoints {
    return {
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      eventPoints: isSet(object.eventPoints) ? Number(object.eventPoints) : 0,
      premiumPoints: isSet(object.premiumPoints) ? Number(object.premiumPoints) : 0,
    };
  },

  toJSON(message: CMsgDevGrantEventPoints): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = eEventToJSON(message.eventId));
    message.eventPoints !== undefined && (obj.eventPoints = Math.round(message.eventPoints));
    message.premiumPoints !== undefined && (obj.premiumPoints = Math.round(message.premiumPoints));
    return obj;
  },
};

function createBaseCMsgDevGrantEventPointsResponse(): CMsgDevGrantEventPointsResponse {
  return { result: 0 };
}

export const CMsgDevGrantEventPointsResponse = {
  encode(message: CMsgDevGrantEventPointsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDevGrantEventPointsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDevGrantEventPointsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDevGrantEventPointsResponse {
    return { result: isSet(object.result) ? eDevEventRequestResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgDevGrantEventPointsResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = eDevEventRequestResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgDevGrantEventAction(): CMsgDevGrantEventAction {
  return { eventId: 0, actionId: 0, actionScore: 0 };
}

export const CMsgDevGrantEventAction = {
  encode(message: CMsgDevGrantEventAction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).int32(message.eventId);
    }
    if (message.actionId !== 0) {
      writer.uint32(16).uint32(message.actionId);
    }
    if (message.actionScore !== 0) {
      writer.uint32(24).uint32(message.actionScore);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDevGrantEventAction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDevGrantEventAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.actionId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.actionScore = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDevGrantEventAction {
    return {
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      actionId: isSet(object.actionId) ? Number(object.actionId) : 0,
      actionScore: isSet(object.actionScore) ? Number(object.actionScore) : 0,
    };
  },

  toJSON(message: CMsgDevGrantEventAction): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = eEventToJSON(message.eventId));
    message.actionId !== undefined && (obj.actionId = Math.round(message.actionId));
    message.actionScore !== undefined && (obj.actionScore = Math.round(message.actionScore));
    return obj;
  },
};

function createBaseCMsgDevGrantEventActionResponse(): CMsgDevGrantEventActionResponse {
  return { result: 0 };
}

export const CMsgDevGrantEventActionResponse = {
  encode(message: CMsgDevGrantEventActionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDevGrantEventActionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDevGrantEventActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDevGrantEventActionResponse {
    return { result: isSet(object.result) ? eDevEventRequestResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgDevGrantEventActionResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = eDevEventRequestResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgDevDeleteEventActions(): CMsgDevDeleteEventActions {
  return { eventId: 0, startActionId: 0, endActionId: 0, removeAudit: false };
}

export const CMsgDevDeleteEventActions = {
  encode(message: CMsgDevDeleteEventActions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).int32(message.eventId);
    }
    if (message.startActionId !== 0) {
      writer.uint32(16).uint32(message.startActionId);
    }
    if (message.endActionId !== 0) {
      writer.uint32(24).uint32(message.endActionId);
    }
    if (message.removeAudit === true) {
      writer.uint32(32).bool(message.removeAudit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDevDeleteEventActions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDevDeleteEventActions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.startActionId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.endActionId = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.removeAudit = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDevDeleteEventActions {
    return {
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      startActionId: isSet(object.startActionId) ? Number(object.startActionId) : 0,
      endActionId: isSet(object.endActionId) ? Number(object.endActionId) : 0,
      removeAudit: isSet(object.removeAudit) ? Boolean(object.removeAudit) : false,
    };
  },

  toJSON(message: CMsgDevDeleteEventActions): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = eEventToJSON(message.eventId));
    message.startActionId !== undefined && (obj.startActionId = Math.round(message.startActionId));
    message.endActionId !== undefined && (obj.endActionId = Math.round(message.endActionId));
    message.removeAudit !== undefined && (obj.removeAudit = message.removeAudit);
    return obj;
  },
};

function createBaseCMsgDevDeleteEventActionsResponse(): CMsgDevDeleteEventActionsResponse {
  return { result: 0 };
}

export const CMsgDevDeleteEventActionsResponse = {
  encode(message: CMsgDevDeleteEventActionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDevDeleteEventActionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDevDeleteEventActionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDevDeleteEventActionsResponse {
    return { result: isSet(object.result) ? eDevEventRequestResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgDevDeleteEventActionsResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = eDevEventRequestResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgDevResetEventState(): CMsgDevResetEventState {
  return { eventId: 0, removeAudit: false };
}

export const CMsgDevResetEventState = {
  encode(message: CMsgDevResetEventState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).int32(message.eventId);
    }
    if (message.removeAudit === true) {
      writer.uint32(16).bool(message.removeAudit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDevResetEventState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDevResetEventState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.removeAudit = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDevResetEventState {
    return {
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      removeAudit: isSet(object.removeAudit) ? Boolean(object.removeAudit) : false,
    };
  },

  toJSON(message: CMsgDevResetEventState): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = eEventToJSON(message.eventId));
    message.removeAudit !== undefined && (obj.removeAudit = message.removeAudit);
    return obj;
  },
};

function createBaseCMsgDevResetEventStateResponse(): CMsgDevResetEventStateResponse {
  return { result: 0 };
}

export const CMsgDevResetEventStateResponse = {
  encode(message: CMsgDevResetEventStateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDevResetEventStateResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDevResetEventStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDevResetEventStateResponse {
    return { result: isSet(object.result) ? eDevEventRequestResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgDevResetEventStateResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = eDevEventRequestResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgConsumeEventSupportGrantItem(): CMsgConsumeEventSupportGrantItem {
  return { itemId: "0" };
}

export const CMsgConsumeEventSupportGrantItem = {
  encode(message: CMsgConsumeEventSupportGrantItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemId !== "0") {
      writer.uint32(8).uint64(message.itemId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgConsumeEventSupportGrantItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgConsumeEventSupportGrantItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.itemId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgConsumeEventSupportGrantItem {
    return { itemId: isSet(object.itemId) ? String(object.itemId) : "0" };
  },

  toJSON(message: CMsgConsumeEventSupportGrantItem): unknown {
    const obj: any = {};
    message.itemId !== undefined && (obj.itemId = message.itemId);
    return obj;
  },
};

function createBaseCMsgConsumeEventSupportGrantItemResponse(): CMsgConsumeEventSupportGrantItemResponse {
  return { result: 0 };
}

export const CMsgConsumeEventSupportGrantItemResponse = {
  encode(message: CMsgConsumeEventSupportGrantItemResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgConsumeEventSupportGrantItemResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgConsumeEventSupportGrantItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgConsumeEventSupportGrantItemResponse {
    return { result: isSet(object.result) ? eSupportEventRequestResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgConsumeEventSupportGrantItemResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = eSupportEventRequestResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgClientToGCGetFilteredPlayers(): CMsgClientToGCGetFilteredPlayers {
  return {};
}

export const CMsgClientToGCGetFilteredPlayers = {
  encode(_: CMsgClientToGCGetFilteredPlayers, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetFilteredPlayers {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetFilteredPlayers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientToGCGetFilteredPlayers {
    return {};
  },

  toJSON(_: CMsgClientToGCGetFilteredPlayers): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgGCToClientGetFilteredPlayersResponse(): CMsgGCToClientGetFilteredPlayersResponse {
  return { result: 0, filteredPlayers: [], baseSlots: 0, additionalSlots: 0, nextSlotCost: 0 };
}

export const CMsgGCToClientGetFilteredPlayersResponse = {
  encode(message: CMsgGCToClientGetFilteredPlayersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    for (const v of message.filteredPlayers) {
      CMsgGCToClientGetFilteredPlayersResponse_CFilterEntry.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.baseSlots !== 0) {
      writer.uint32(24).int32(message.baseSlots);
    }
    if (message.additionalSlots !== 0) {
      writer.uint32(32).int32(message.additionalSlots);
    }
    if (message.nextSlotCost !== 0) {
      writer.uint32(40).int32(message.nextSlotCost);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientGetFilteredPlayersResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientGetFilteredPlayersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.filteredPlayers.push(
            CMsgGCToClientGetFilteredPlayersResponse_CFilterEntry.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.baseSlots = reader.int32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.additionalSlots = reader.int32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.nextSlotCost = reader.int32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientGetFilteredPlayersResponse {
    return {
      result: isSet(object.result) ? cMsgGCToClientGetFilteredPlayersResponse_ResultFromJSON(object.result) : 0,
      filteredPlayers: Array.isArray(object?.filteredPlayers)
        ? object.filteredPlayers.map((e: any) => CMsgGCToClientGetFilteredPlayersResponse_CFilterEntry.fromJSON(e))
        : [],
      baseSlots: isSet(object.baseSlots) ? Number(object.baseSlots) : 0,
      additionalSlots: isSet(object.additionalSlots) ? Number(object.additionalSlots) : 0,
      nextSlotCost: isSet(object.nextSlotCost) ? Number(object.nextSlotCost) : 0,
    };
  },

  toJSON(message: CMsgGCToClientGetFilteredPlayersResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgGCToClientGetFilteredPlayersResponse_ResultToJSON(message.result));
    if (message.filteredPlayers) {
      obj.filteredPlayers = message.filteredPlayers.map((e) =>
        e ? CMsgGCToClientGetFilteredPlayersResponse_CFilterEntry.toJSON(e) : undefined
      );
    } else {
      obj.filteredPlayers = [];
    }
    message.baseSlots !== undefined && (obj.baseSlots = Math.round(message.baseSlots));
    message.additionalSlots !== undefined && (obj.additionalSlots = Math.round(message.additionalSlots));
    message.nextSlotCost !== undefined && (obj.nextSlotCost = Math.round(message.nextSlotCost));
    return obj;
  },
};

function createBaseCMsgGCToClientGetFilteredPlayersResponse_CFilterEntry(): CMsgGCToClientGetFilteredPlayersResponse_CFilterEntry {
  return { accountId: 0, timeAdded: 0, timeExpires: 0, note: "" };
}

export const CMsgGCToClientGetFilteredPlayersResponse_CFilterEntry = {
  encode(
    message: CMsgGCToClientGetFilteredPlayersResponse_CFilterEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(13).fixed32(message.accountId);
    }
    if (message.timeAdded !== 0) {
      writer.uint32(21).fixed32(message.timeAdded);
    }
    if (message.timeExpires !== 0) {
      writer.uint32(29).fixed32(message.timeExpires);
    }
    if (message.note !== "") {
      writer.uint32(34).string(message.note);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientGetFilteredPlayersResponse_CFilterEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientGetFilteredPlayersResponse_CFilterEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 13) {
            break;
          }

          message.accountId = reader.fixed32();
          continue;
        case 2:
          if (tag != 21) {
            break;
          }

          message.timeAdded = reader.fixed32();
          continue;
        case 3:
          if (tag != 29) {
            break;
          }

          message.timeExpires = reader.fixed32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.note = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientGetFilteredPlayersResponse_CFilterEntry {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      timeAdded: isSet(object.timeAdded) ? Number(object.timeAdded) : 0,
      timeExpires: isSet(object.timeExpires) ? Number(object.timeExpires) : 0,
      note: isSet(object.note) ? String(object.note) : "",
    };
  },

  toJSON(message: CMsgGCToClientGetFilteredPlayersResponse_CFilterEntry): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.timeAdded !== undefined && (obj.timeAdded = Math.round(message.timeAdded));
    message.timeExpires !== undefined && (obj.timeExpires = Math.round(message.timeExpires));
    message.note !== undefined && (obj.note = message.note);
    return obj;
  },
};

function createBaseCMsgClientToGCRemoveFilteredPlayer(): CMsgClientToGCRemoveFilteredPlayer {
  return { accountIdToRemove: 0 };
}

export const CMsgClientToGCRemoveFilteredPlayer = {
  encode(message: CMsgClientToGCRemoveFilteredPlayer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountIdToRemove !== 0) {
      writer.uint32(13).fixed32(message.accountIdToRemove);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRemoveFilteredPlayer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRemoveFilteredPlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 13) {
            break;
          }

          message.accountIdToRemove = reader.fixed32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRemoveFilteredPlayer {
    return { accountIdToRemove: isSet(object.accountIdToRemove) ? Number(object.accountIdToRemove) : 0 };
  },

  toJSON(message: CMsgClientToGCRemoveFilteredPlayer): unknown {
    const obj: any = {};
    message.accountIdToRemove !== undefined && (obj.accountIdToRemove = Math.round(message.accountIdToRemove));
    return obj;
  },
};

function createBaseCMsgGCToClientRemoveFilteredPlayerResponse(): CMsgGCToClientRemoveFilteredPlayerResponse {
  return { result: 0 };
}

export const CMsgGCToClientRemoveFilteredPlayerResponse = {
  encode(message: CMsgGCToClientRemoveFilteredPlayerResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientRemoveFilteredPlayerResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientRemoveFilteredPlayerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientRemoveFilteredPlayerResponse {
    return {
      result: isSet(object.result) ? cMsgGCToClientRemoveFilteredPlayerResponse_ResultFromJSON(object.result) : 0,
    };
  },

  toJSON(message: CMsgGCToClientRemoveFilteredPlayerResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgGCToClientRemoveFilteredPlayerResponse_ResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgClientToGCPurchaseFilteredPlayerSlot(): CMsgClientToGCPurchaseFilteredPlayerSlot {
  return { additionalSlotsCurrent: 0 };
}

export const CMsgClientToGCPurchaseFilteredPlayerSlot = {
  encode(message: CMsgClientToGCPurchaseFilteredPlayerSlot, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.additionalSlotsCurrent !== 0) {
      writer.uint32(8).int32(message.additionalSlotsCurrent);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCPurchaseFilteredPlayerSlot {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCPurchaseFilteredPlayerSlot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.additionalSlotsCurrent = reader.int32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCPurchaseFilteredPlayerSlot {
    return { additionalSlotsCurrent: isSet(object.additionalSlotsCurrent) ? Number(object.additionalSlotsCurrent) : 0 };
  },

  toJSON(message: CMsgClientToGCPurchaseFilteredPlayerSlot): unknown {
    const obj: any = {};
    message.additionalSlotsCurrent !== undefined &&
      (obj.additionalSlotsCurrent = Math.round(message.additionalSlotsCurrent));
    return obj;
  },
};

function createBaseCMsgGCToClientPurchaseFilteredPlayerSlotResponse(): CMsgGCToClientPurchaseFilteredPlayerSlotResponse {
  return { result: 0, additionalSlots: 0, nextSlotCost: 0 };
}

export const CMsgGCToClientPurchaseFilteredPlayerSlotResponse = {
  encode(
    message: CMsgGCToClientPurchaseFilteredPlayerSlotResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.additionalSlots !== 0) {
      writer.uint32(16).int32(message.additionalSlots);
    }
    if (message.nextSlotCost !== 0) {
      writer.uint32(24).int32(message.nextSlotCost);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientPurchaseFilteredPlayerSlotResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientPurchaseFilteredPlayerSlotResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.additionalSlots = reader.int32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.nextSlotCost = reader.int32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientPurchaseFilteredPlayerSlotResponse {
    return {
      result: isSet(object.result) ? cMsgGCToClientPurchaseFilteredPlayerSlotResponse_ResultFromJSON(object.result) : 0,
      additionalSlots: isSet(object.additionalSlots) ? Number(object.additionalSlots) : 0,
      nextSlotCost: isSet(object.nextSlotCost) ? Number(object.nextSlotCost) : 0,
    };
  },

  toJSON(message: CMsgGCToClientPurchaseFilteredPlayerSlotResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgGCToClientPurchaseFilteredPlayerSlotResponse_ResultToJSON(message.result));
    message.additionalSlots !== undefined && (obj.additionalSlots = Math.round(message.additionalSlots));
    message.nextSlotCost !== undefined && (obj.nextSlotCost = Math.round(message.nextSlotCost));
    return obj;
  },
};

function createBaseCMsgClientToGCUpdateFilteredPlayerNote(): CMsgClientToGCUpdateFilteredPlayerNote {
  return { targetAccountId: 0, newNote: "" };
}

export const CMsgClientToGCUpdateFilteredPlayerNote = {
  encode(message: CMsgClientToGCUpdateFilteredPlayerNote, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetAccountId !== 0) {
      writer.uint32(13).fixed32(message.targetAccountId);
    }
    if (message.newNote !== "") {
      writer.uint32(18).string(message.newNote);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCUpdateFilteredPlayerNote {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCUpdateFilteredPlayerNote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 13) {
            break;
          }

          message.targetAccountId = reader.fixed32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.newNote = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCUpdateFilteredPlayerNote {
    return {
      targetAccountId: isSet(object.targetAccountId) ? Number(object.targetAccountId) : 0,
      newNote: isSet(object.newNote) ? String(object.newNote) : "",
    };
  },

  toJSON(message: CMsgClientToGCUpdateFilteredPlayerNote): unknown {
    const obj: any = {};
    message.targetAccountId !== undefined && (obj.targetAccountId = Math.round(message.targetAccountId));
    message.newNote !== undefined && (obj.newNote = message.newNote);
    return obj;
  },
};

function createBaseCMsgGCToClientUpdateFilteredPlayerNoteResponse(): CMsgGCToClientUpdateFilteredPlayerNoteResponse {
  return { result: 0 };
}

export const CMsgGCToClientUpdateFilteredPlayerNoteResponse = {
  encode(
    message: CMsgGCToClientUpdateFilteredPlayerNoteResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientUpdateFilteredPlayerNoteResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientUpdateFilteredPlayerNoteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientUpdateFilteredPlayerNoteResponse {
    return {
      result: isSet(object.result) ? cMsgGCToClientUpdateFilteredPlayerNoteResponse_ResultFromJSON(object.result) : 0,
    };
  },

  toJSON(message: CMsgGCToClientUpdateFilteredPlayerNoteResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgGCToClientUpdateFilteredPlayerNoteResponse_ResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgPartySearchPlayer(): CMsgPartySearchPlayer {
  return { accountId: 0, matchId: "0", creationTime: 0 };
}

export const CMsgPartySearchPlayer = {
  encode(message: CMsgPartySearchPlayer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(13).fixed32(message.accountId);
    }
    if (message.matchId !== "0") {
      writer.uint32(17).fixed64(message.matchId);
    }
    if (message.creationTime !== 0) {
      writer.uint32(29).fixed32(message.creationTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPartySearchPlayer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPartySearchPlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 13) {
            break;
          }

          message.accountId = reader.fixed32();
          continue;
        case 2:
          if (tag != 17) {
            break;
          }

          message.matchId = longToString(reader.fixed64() as Long);
          continue;
        case 3:
          if (tag != 29) {
            break;
          }

          message.creationTime = reader.fixed32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPartySearchPlayer {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      matchId: isSet(object.matchId) ? String(object.matchId) : "0",
      creationTime: isSet(object.creationTime) ? Number(object.creationTime) : 0,
    };
  },

  toJSON(message: CMsgPartySearchPlayer): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.matchId !== undefined && (obj.matchId = message.matchId);
    message.creationTime !== undefined && (obj.creationTime = Math.round(message.creationTime));
    return obj;
  },
};

function createBaseCMsgGCToClientPlayerBeaconState(): CMsgGCToClientPlayerBeaconState {
  return { numActiveBeacons: [] };
}

export const CMsgGCToClientPlayerBeaconState = {
  encode(message: CMsgGCToClientPlayerBeaconState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.numActiveBeacons) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientPlayerBeaconState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientPlayerBeaconState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag == 8) {
            message.numActiveBeacons.push(reader.int32());
            continue;
          }

          if (tag == 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.numActiveBeacons.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientPlayerBeaconState {
    return {
      numActiveBeacons: Array.isArray(object?.numActiveBeacons)
        ? object.numActiveBeacons.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: CMsgGCToClientPlayerBeaconState): unknown {
    const obj: any = {};
    if (message.numActiveBeacons) {
      obj.numActiveBeacons = message.numActiveBeacons.map((e) => Math.round(e));
    } else {
      obj.numActiveBeacons = [];
    }
    return obj;
  },
};

function createBaseCMsgGCToClientPartyBeaconUpdate(): CMsgGCToClientPartyBeaconUpdate {
  return { beaconAdded: false, beaconType: 0, accountId: 0 };
}

export const CMsgGCToClientPartyBeaconUpdate = {
  encode(message: CMsgGCToClientPartyBeaconUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.beaconAdded === true) {
      writer.uint32(8).bool(message.beaconAdded);
    }
    if (message.beaconType !== 0) {
      writer.uint32(16).int32(message.beaconType);
    }
    if (message.accountId !== 0) {
      writer.uint32(29).fixed32(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientPartyBeaconUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientPartyBeaconUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.beaconAdded = reader.bool();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.beaconType = reader.int32();
          continue;
        case 3:
          if (tag != 29) {
            break;
          }

          message.accountId = reader.fixed32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientPartyBeaconUpdate {
    return {
      beaconAdded: isSet(object.beaconAdded) ? Boolean(object.beaconAdded) : false,
      beaconType: isSet(object.beaconType) ? Number(object.beaconType) : 0,
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
    };
  },

  toJSON(message: CMsgGCToClientPartyBeaconUpdate): unknown {
    const obj: any = {};
    message.beaconAdded !== undefined && (obj.beaconAdded = message.beaconAdded);
    message.beaconType !== undefined && (obj.beaconType = Math.round(message.beaconType));
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    return obj;
  },
};

function createBaseCMsgClientToGCUpdatePartyBeacon(): CMsgClientToGCUpdatePartyBeacon {
  return { action: 0 };
}

export const CMsgClientToGCUpdatePartyBeacon = {
  encode(message: CMsgClientToGCUpdatePartyBeacon, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.action !== 0) {
      writer.uint32(8).int32(message.action);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCUpdatePartyBeacon {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCUpdatePartyBeacon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCUpdatePartyBeacon {
    return { action: isSet(object.action) ? cMsgClientToGCUpdatePartyBeacon_ActionFromJSON(object.action) : 0 };
  },

  toJSON(message: CMsgClientToGCUpdatePartyBeacon): unknown {
    const obj: any = {};
    message.action !== undefined && (obj.action = cMsgClientToGCUpdatePartyBeacon_ActionToJSON(message.action));
    return obj;
  },
};

function createBaseCMsgClientToGCRequestActiveBeaconParties(): CMsgClientToGCRequestActiveBeaconParties {
  return {};
}

export const CMsgClientToGCRequestActiveBeaconParties = {
  encode(_: CMsgClientToGCRequestActiveBeaconParties, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRequestActiveBeaconParties {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRequestActiveBeaconParties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientToGCRequestActiveBeaconParties {
    return {};
  },

  toJSON(_: CMsgClientToGCRequestActiveBeaconParties): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgGCToClientRequestActiveBeaconPartiesResponse(): CMsgGCToClientRequestActiveBeaconPartiesResponse {
  return { response: 0, activeParties: [] };
}

export const CMsgGCToClientRequestActiveBeaconPartiesResponse = {
  encode(
    message: CMsgGCToClientRequestActiveBeaconPartiesResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    for (const v of message.activeParties) {
      CPartySearchClientParty.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientRequestActiveBeaconPartiesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientRequestActiveBeaconPartiesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.activeParties.push(CPartySearchClientParty.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientRequestActiveBeaconPartiesResponse {
    return {
      response: isSet(object.response)
        ? cMsgGCToClientRequestActiveBeaconPartiesResponse_EResponseFromJSON(object.response)
        : 0,
      activeParties: Array.isArray(object?.activeParties)
        ? object.activeParties.map((e: any) => CPartySearchClientParty.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCToClientRequestActiveBeaconPartiesResponse): unknown {
    const obj: any = {};
    message.response !== undefined &&
      (obj.response = cMsgGCToClientRequestActiveBeaconPartiesResponse_EResponseToJSON(message.response));
    if (message.activeParties) {
      obj.activeParties = message.activeParties.map((e) => e ? CPartySearchClientParty.toJSON(e) : undefined);
    } else {
      obj.activeParties = [];
    }
    return obj;
  },
};

function createBaseCMsgClientToGCJoinPartyFromBeacon(): CMsgClientToGCJoinPartyFromBeacon {
  return { partyId: "0", accountId: 0, beaconType: 0 };
}

export const CMsgClientToGCJoinPartyFromBeacon = {
  encode(message: CMsgClientToGCJoinPartyFromBeacon, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.partyId !== "0") {
      writer.uint32(9).fixed64(message.partyId);
    }
    if (message.accountId !== 0) {
      writer.uint32(21).fixed32(message.accountId);
    }
    if (message.beaconType !== 0) {
      writer.uint32(24).int32(message.beaconType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCJoinPartyFromBeacon {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCJoinPartyFromBeacon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 9) {
            break;
          }

          message.partyId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag != 21) {
            break;
          }

          message.accountId = reader.fixed32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.beaconType = reader.int32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCJoinPartyFromBeacon {
    return {
      partyId: isSet(object.partyId) ? String(object.partyId) : "0",
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      beaconType: isSet(object.beaconType) ? Number(object.beaconType) : 0,
    };
  },

  toJSON(message: CMsgClientToGCJoinPartyFromBeacon): unknown {
    const obj: any = {};
    message.partyId !== undefined && (obj.partyId = message.partyId);
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.beaconType !== undefined && (obj.beaconType = Math.round(message.beaconType));
    return obj;
  },
};

function createBaseCMsgGCToClientJoinPartyFromBeaconResponse(): CMsgGCToClientJoinPartyFromBeaconResponse {
  return { response: 0 };
}

export const CMsgGCToClientJoinPartyFromBeaconResponse = {
  encode(message: CMsgGCToClientJoinPartyFromBeaconResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientJoinPartyFromBeaconResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientJoinPartyFromBeaconResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientJoinPartyFromBeaconResponse {
    return {
      response: isSet(object.response)
        ? cMsgGCToClientJoinPartyFromBeaconResponse_EResponseFromJSON(object.response)
        : 0,
    };
  },

  toJSON(message: CMsgGCToClientJoinPartyFromBeaconResponse): unknown {
    const obj: any = {};
    message.response !== undefined &&
      (obj.response = cMsgGCToClientJoinPartyFromBeaconResponse_EResponseToJSON(message.response));
    return obj;
  },
};

function createBaseCMsgClientToGCManageFavorites(): CMsgClientToGCManageFavorites {
  return { action: 0, accountId: 0, favoriteName: "", inviteResponse: false, fromFriendlist: false, lobbyId: "0" };
}

export const CMsgClientToGCManageFavorites = {
  encode(message: CMsgClientToGCManageFavorites, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.action !== 0) {
      writer.uint32(8).int32(message.action);
    }
    if (message.accountId !== 0) {
      writer.uint32(21).fixed32(message.accountId);
    }
    if (message.favoriteName !== "") {
      writer.uint32(26).string(message.favoriteName);
    }
    if (message.inviteResponse === true) {
      writer.uint32(32).bool(message.inviteResponse);
    }
    if (message.fromFriendlist === true) {
      writer.uint32(40).bool(message.fromFriendlist);
    }
    if (message.lobbyId !== "0") {
      writer.uint32(49).fixed64(message.lobbyId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCManageFavorites {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCManageFavorites();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        case 2:
          if (tag != 21) {
            break;
          }

          message.accountId = reader.fixed32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.favoriteName = reader.string();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.inviteResponse = reader.bool();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.fromFriendlist = reader.bool();
          continue;
        case 6:
          if (tag != 49) {
            break;
          }

          message.lobbyId = longToString(reader.fixed64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCManageFavorites {
    return {
      action: isSet(object.action) ? cMsgClientToGCManageFavorites_ActionFromJSON(object.action) : 0,
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      favoriteName: isSet(object.favoriteName) ? String(object.favoriteName) : "",
      inviteResponse: isSet(object.inviteResponse) ? Boolean(object.inviteResponse) : false,
      fromFriendlist: isSet(object.fromFriendlist) ? Boolean(object.fromFriendlist) : false,
      lobbyId: isSet(object.lobbyId) ? String(object.lobbyId) : "0",
    };
  },

  toJSON(message: CMsgClientToGCManageFavorites): unknown {
    const obj: any = {};
    message.action !== undefined && (obj.action = cMsgClientToGCManageFavorites_ActionToJSON(message.action));
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.favoriteName !== undefined && (obj.favoriteName = message.favoriteName);
    message.inviteResponse !== undefined && (obj.inviteResponse = message.inviteResponse);
    message.fromFriendlist !== undefined && (obj.fromFriendlist = message.fromFriendlist);
    message.lobbyId !== undefined && (obj.lobbyId = message.lobbyId);
    return obj;
  },
};

function createBaseCMsgGCToClientManageFavoritesResponse(): CMsgGCToClientManageFavoritesResponse {
  return { response: 0, debugMessage: "", player: undefined };
}

export const CMsgGCToClientManageFavoritesResponse = {
  encode(message: CMsgGCToClientManageFavoritesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    if (message.debugMessage !== "") {
      writer.uint32(18).string(message.debugMessage);
    }
    if (message.player !== undefined) {
      CMsgPartySearchPlayer.encode(message.player, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientManageFavoritesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientManageFavoritesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.debugMessage = reader.string();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.player = CMsgPartySearchPlayer.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientManageFavoritesResponse {
    return {
      response: isSet(object.response) ? cMsgGCToClientManageFavoritesResponse_EResponseFromJSON(object.response) : 0,
      debugMessage: isSet(object.debugMessage) ? String(object.debugMessage) : "",
      player: isSet(object.player) ? CMsgPartySearchPlayer.fromJSON(object.player) : undefined,
    };
  },

  toJSON(message: CMsgGCToClientManageFavoritesResponse): unknown {
    const obj: any = {};
    message.response !== undefined &&
      (obj.response = cMsgGCToClientManageFavoritesResponse_EResponseToJSON(message.response));
    message.debugMessage !== undefined && (obj.debugMessage = message.debugMessage);
    message.player !== undefined &&
      (obj.player = message.player ? CMsgPartySearchPlayer.toJSON(message.player) : undefined);
    return obj;
  },
};

function createBaseCMsgClientToGCGetFavoritePlayers(): CMsgClientToGCGetFavoritePlayers {
  return { paginationKey: "0", paginationCount: 0 };
}

export const CMsgClientToGCGetFavoritePlayers = {
  encode(message: CMsgClientToGCGetFavoritePlayers, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.paginationKey !== "0") {
      writer.uint32(8).uint64(message.paginationKey);
    }
    if (message.paginationCount !== 0) {
      writer.uint32(16).int32(message.paginationCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetFavoritePlayers {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetFavoritePlayers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.paginationKey = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.paginationCount = reader.int32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetFavoritePlayers {
    return {
      paginationKey: isSet(object.paginationKey) ? String(object.paginationKey) : "0",
      paginationCount: isSet(object.paginationCount) ? Number(object.paginationCount) : 0,
    };
  },

  toJSON(message: CMsgClientToGCGetFavoritePlayers): unknown {
    const obj: any = {};
    message.paginationKey !== undefined && (obj.paginationKey = message.paginationKey);
    message.paginationCount !== undefined && (obj.paginationCount = Math.round(message.paginationCount));
    return obj;
  },
};

function createBaseCMsgGCToClientGetFavoritePlayersResponse(): CMsgGCToClientGetFavoritePlayersResponse {
  return { response: 0, players: [], nextPaginationKey: "0" };
}

export const CMsgGCToClientGetFavoritePlayersResponse = {
  encode(message: CMsgGCToClientGetFavoritePlayersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    for (const v of message.players) {
      CMsgPartySearchPlayer.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.nextPaginationKey !== "0") {
      writer.uint32(24).uint64(message.nextPaginationKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientGetFavoritePlayersResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientGetFavoritePlayersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.players.push(CMsgPartySearchPlayer.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.nextPaginationKey = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientGetFavoritePlayersResponse {
    return {
      response: isSet(object.response)
        ? cMsgGCToClientGetFavoritePlayersResponse_EResponseFromJSON(object.response)
        : 0,
      players: Array.isArray(object?.players) ? object.players.map((e: any) => CMsgPartySearchPlayer.fromJSON(e)) : [],
      nextPaginationKey: isSet(object.nextPaginationKey) ? String(object.nextPaginationKey) : "0",
    };
  },

  toJSON(message: CMsgGCToClientGetFavoritePlayersResponse): unknown {
    const obj: any = {};
    message.response !== undefined &&
      (obj.response = cMsgGCToClientGetFavoritePlayersResponse_EResponseToJSON(message.response));
    if (message.players) {
      obj.players = message.players.map((e) => e ? CMsgPartySearchPlayer.toJSON(e) : undefined);
    } else {
      obj.players = [];
    }
    message.nextPaginationKey !== undefined && (obj.nextPaginationKey = message.nextPaginationKey);
    return obj;
  },
};

function createBaseCMsgGCToClientPartySearchInvite(): CMsgGCToClientPartySearchInvite {
  return { accountId: 0 };
}

export const CMsgGCToClientPartySearchInvite = {
  encode(message: CMsgGCToClientPartySearchInvite, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(13).fixed32(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientPartySearchInvite {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientPartySearchInvite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 13) {
            break;
          }

          message.accountId = reader.fixed32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientPartySearchInvite {
    return { accountId: isSet(object.accountId) ? Number(object.accountId) : 0 };
  },

  toJSON(message: CMsgGCToClientPartySearchInvite): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    return obj;
  },
};

function createBaseCMsgClientToGCVerifyFavoritePlayers(): CMsgClientToGCVerifyFavoritePlayers {
  return { accountIds: [] };
}

export const CMsgClientToGCVerifyFavoritePlayers = {
  encode(message: CMsgClientToGCVerifyFavoritePlayers, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.accountIds) {
      writer.fixed32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCVerifyFavoritePlayers {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCVerifyFavoritePlayers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag == 13) {
            message.accountIds.push(reader.fixed32());
            continue;
          }

          if (tag == 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.accountIds.push(reader.fixed32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCVerifyFavoritePlayers {
    return { accountIds: Array.isArray(object?.accountIds) ? object.accountIds.map((e: any) => Number(e)) : [] };
  },

  toJSON(message: CMsgClientToGCVerifyFavoritePlayers): unknown {
    const obj: any = {};
    if (message.accountIds) {
      obj.accountIds = message.accountIds.map((e) => Math.round(e));
    } else {
      obj.accountIds = [];
    }
    return obj;
  },
};

function createBaseCMsgGCToClientVerifyFavoritePlayersResponse(): CMsgGCToClientVerifyFavoritePlayersResponse {
  return { results: [] };
}

export const CMsgGCToClientVerifyFavoritePlayersResponse = {
  encode(message: CMsgGCToClientVerifyFavoritePlayersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      CMsgGCToClientVerifyFavoritePlayersResponse_Result.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientVerifyFavoritePlayersResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientVerifyFavoritePlayersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.results.push(CMsgGCToClientVerifyFavoritePlayersResponse_Result.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientVerifyFavoritePlayersResponse {
    return {
      results: Array.isArray(object?.results)
        ? object.results.map((e: any) => CMsgGCToClientVerifyFavoritePlayersResponse_Result.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCToClientVerifyFavoritePlayersResponse): unknown {
    const obj: any = {};
    if (message.results) {
      obj.results = message.results.map((e) =>
        e ? CMsgGCToClientVerifyFavoritePlayersResponse_Result.toJSON(e) : undefined
      );
    } else {
      obj.results = [];
    }
    return obj;
  },
};

function createBaseCMsgGCToClientVerifyFavoritePlayersResponse_Result(): CMsgGCToClientVerifyFavoritePlayersResponse_Result {
  return { player: undefined, isFavorite: false };
}

export const CMsgGCToClientVerifyFavoritePlayersResponse_Result = {
  encode(
    message: CMsgGCToClientVerifyFavoritePlayersResponse_Result,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.player !== undefined) {
      CMsgPartySearchPlayer.encode(message.player, writer.uint32(10).fork()).ldelim();
    }
    if (message.isFavorite === true) {
      writer.uint32(16).bool(message.isFavorite);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientVerifyFavoritePlayersResponse_Result {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientVerifyFavoritePlayersResponse_Result();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.player = CMsgPartySearchPlayer.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.isFavorite = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientVerifyFavoritePlayersResponse_Result {
    return {
      player: isSet(object.player) ? CMsgPartySearchPlayer.fromJSON(object.player) : undefined,
      isFavorite: isSet(object.isFavorite) ? Boolean(object.isFavorite) : false,
    };
  },

  toJSON(message: CMsgGCToClientVerifyFavoritePlayersResponse_Result): unknown {
    const obj: any = {};
    message.player !== undefined &&
      (obj.player = message.player ? CMsgPartySearchPlayer.toJSON(message.player) : undefined);
    message.isFavorite !== undefined && (obj.isFavorite = message.isFavorite);
    return obj;
  },
};

function createBaseCMsgClientToGCRequestPlayerRecentAccomplishments(): CMsgClientToGCRequestPlayerRecentAccomplishments {
  return { accountId: 0 };
}

export const CMsgClientToGCRequestPlayerRecentAccomplishments = {
  encode(
    message: CMsgClientToGCRequestPlayerRecentAccomplishments,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRequestPlayerRecentAccomplishments {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRequestPlayerRecentAccomplishments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRequestPlayerRecentAccomplishments {
    return { accountId: isSet(object.accountId) ? Number(object.accountId) : 0 };
  },

  toJSON(message: CMsgClientToGCRequestPlayerRecentAccomplishments): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    return obj;
  },
};

function createBaseCMsgClientToGCRequestPlayerRecentAccomplishmentsResponse(): CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse {
  return { result: 0, playerAccomplishments: undefined };
}

export const CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse = {
  encode(
    message: CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.playerAccomplishments !== undefined) {
      CMsgPlayerRecentAccomplishments.encode(message.playerAccomplishments, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRequestPlayerRecentAccomplishmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.playerAccomplishments = CMsgPlayerRecentAccomplishments.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse {
    return {
      result: isSet(object.result)
        ? cMsgClientToGCRequestPlayerRecentAccomplishmentsResponse_EResponseFromJSON(object.result)
        : 0,
      playerAccomplishments: isSet(object.playerAccomplishments)
        ? CMsgPlayerRecentAccomplishments.fromJSON(object.playerAccomplishments)
        : undefined,
    };
  },

  toJSON(message: CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgClientToGCRequestPlayerRecentAccomplishmentsResponse_EResponseToJSON(message.result));
    message.playerAccomplishments !== undefined && (obj.playerAccomplishments = message.playerAccomplishments
      ? CMsgPlayerRecentAccomplishments.toJSON(message.playerAccomplishments)
      : undefined);
    return obj;
  },
};

function createBaseCMsgClientToGCRequestPlayerHeroRecentAccomplishments(): CMsgClientToGCRequestPlayerHeroRecentAccomplishments {
  return { accountId: 0, heroId: 0 };
}

export const CMsgClientToGCRequestPlayerHeroRecentAccomplishments = {
  encode(
    message: CMsgClientToGCRequestPlayerHeroRecentAccomplishments,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.heroId !== 0) {
      writer.uint32(16).uint32(message.heroId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRequestPlayerHeroRecentAccomplishments {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRequestPlayerHeroRecentAccomplishments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRequestPlayerHeroRecentAccomplishments {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      heroId: isSet(object.heroId) ? Number(object.heroId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCRequestPlayerHeroRecentAccomplishments): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.heroId !== undefined && (obj.heroId = Math.round(message.heroId));
    return obj;
  },
};

function createBaseCMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse(): CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse {
  return { result: 0, heroAccomplishments: undefined };
}

export const CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse = {
  encode(
    message: CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.heroAccomplishments !== undefined) {
      CMsgPlayerHeroRecentAccomplishments.encode(message.heroAccomplishments, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.heroAccomplishments = CMsgPlayerHeroRecentAccomplishments.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse {
    return {
      result: isSet(object.result)
        ? cMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse_EResponseFromJSON(object.result)
        : 0,
      heroAccomplishments: isSet(object.heroAccomplishments)
        ? CMsgPlayerHeroRecentAccomplishments.fromJSON(object.heroAccomplishments)
        : undefined,
    };
  },

  toJSON(message: CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse_EResponseToJSON(message.result));
    message.heroAccomplishments !== undefined && (obj.heroAccomplishments = message.heroAccomplishments
      ? CMsgPlayerHeroRecentAccomplishments.toJSON(message.heroAccomplishments)
      : undefined);
    return obj;
  },
};

function createBaseCMsgClientToGCSubmitPlayerMatchSurvey(): CMsgClientToGCSubmitPlayerMatchSurvey {
  return { matchId: "0", rating: 0, flags: 0 };
}

export const CMsgClientToGCSubmitPlayerMatchSurvey = {
  encode(message: CMsgClientToGCSubmitPlayerMatchSurvey, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.rating !== 0) {
      writer.uint32(24).sint32(message.rating);
    }
    if (message.flags !== 0) {
      writer.uint32(32).uint32(message.flags);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSubmitPlayerMatchSurvey {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSubmitPlayerMatchSurvey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.rating = reader.sint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.flags = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSubmitPlayerMatchSurvey {
    return {
      matchId: isSet(object.matchId) ? String(object.matchId) : "0",
      rating: isSet(object.rating) ? Number(object.rating) : 0,
      flags: isSet(object.flags) ? Number(object.flags) : 0,
    };
  },

  toJSON(message: CMsgClientToGCSubmitPlayerMatchSurvey): unknown {
    const obj: any = {};
    message.matchId !== undefined && (obj.matchId = message.matchId);
    message.rating !== undefined && (obj.rating = Math.round(message.rating));
    message.flags !== undefined && (obj.flags = Math.round(message.flags));
    return obj;
  },
};

function createBaseCMsgClientToGCSubmitPlayerMatchSurveyResponse(): CMsgClientToGCSubmitPlayerMatchSurveyResponse {
  return { eresult: 0, accountId: 0 };
}

export const CMsgClientToGCSubmitPlayerMatchSurveyResponse = {
  encode(message: CMsgClientToGCSubmitPlayerMatchSurveyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== 0) {
      writer.uint32(8).int32(message.eresult);
    }
    if (message.accountId !== 0) {
      writer.uint32(16).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSubmitPlayerMatchSurveyResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSubmitPlayerMatchSurveyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eresult = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSubmitPlayerMatchSurveyResponse {
    return {
      eresult: isSet(object.eresult)
        ? cMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponseFromJSON(object.eresult)
        : 0,
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCSubmitPlayerMatchSurveyResponse): unknown {
    const obj: any = {};
    message.eresult !== undefined &&
      (obj.eresult = cMsgClientToGCSubmitPlayerMatchSurveyResponse_EResponseToJSON(message.eresult));
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    return obj;
  },
};

function createBaseCMsgGCToClientVACReminder(): CMsgGCToClientVACReminder {
  return {};
}

export const CMsgGCToClientVACReminder = {
  encode(_: CMsgGCToClientVACReminder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientVACReminder {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientVACReminder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgGCToClientVACReminder {
    return {};
  },

  toJSON(_: CMsgGCToClientVACReminder): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgClientToGCUnderDraftRequest(): CMsgClientToGCUnderDraftRequest {
  return { accountId: 0, eventId: 0 };
}

export const CMsgClientToGCUnderDraftRequest = {
  encode(message: CMsgClientToGCUnderDraftRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.eventId !== 0) {
      writer.uint32(16).uint32(message.eventId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCUnderDraftRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCUnderDraftRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCUnderDraftRequest {
    return {
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCUnderDraftRequest): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    return obj;
  },
};

function createBaseCMsgClientToGCUnderDraftResponse(): CMsgClientToGCUnderDraftResponse {
  return { result: 0, accountId: 0, eventId: 0, draftData: undefined };
}

export const CMsgClientToGCUnderDraftResponse = {
  encode(message: CMsgClientToGCUnderDraftResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.accountId !== 0) {
      writer.uint32(16).uint32(message.accountId);
    }
    if (message.eventId !== 0) {
      writer.uint32(24).uint32(message.eventId);
    }
    if (message.draftData !== undefined) {
      CMsgUnderDraftData.encode(message.draftData, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCUnderDraftResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCUnderDraftResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.draftData = CMsgUnderDraftData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCUnderDraftResponse {
    return {
      result: isSet(object.result) ? eUnderDraftResponseFromJSON(object.result) : 0,
      accountId: isSet(object.accountId) ? Number(object.accountId) : 0,
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      draftData: isSet(object.draftData) ? CMsgUnderDraftData.fromJSON(object.draftData) : undefined,
    };
  },

  toJSON(message: CMsgClientToGCUnderDraftResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = eUnderDraftResponseToJSON(message.result));
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.draftData !== undefined &&
      (obj.draftData = message.draftData ? CMsgUnderDraftData.toJSON(message.draftData) : undefined);
    return obj;
  },
};

function createBaseCMsgClientToGCUnderDraftReroll(): CMsgClientToGCUnderDraftReroll {
  return { eventId: 0 };
}

export const CMsgClientToGCUnderDraftReroll = {
  encode(message: CMsgClientToGCUnderDraftReroll, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCUnderDraftReroll {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCUnderDraftReroll();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCUnderDraftReroll {
    return { eventId: isSet(object.eventId) ? Number(object.eventId) : 0 };
  },

  toJSON(message: CMsgClientToGCUnderDraftReroll): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    return obj;
  },
};

function createBaseCMsgClientToGCUnderDraftRerollResponse(): CMsgClientToGCUnderDraftRerollResponse {
  return { result: 0, eventId: 0, draftData: undefined };
}

export const CMsgClientToGCUnderDraftRerollResponse = {
  encode(message: CMsgClientToGCUnderDraftRerollResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.eventId !== 0) {
      writer.uint32(16).uint32(message.eventId);
    }
    if (message.draftData !== undefined) {
      CMsgUnderDraftData.encode(message.draftData, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCUnderDraftRerollResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCUnderDraftRerollResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.draftData = CMsgUnderDraftData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCUnderDraftRerollResponse {
    return {
      result: isSet(object.result) ? eUnderDraftResponseFromJSON(object.result) : 0,
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      draftData: isSet(object.draftData) ? CMsgUnderDraftData.fromJSON(object.draftData) : undefined,
    };
  },

  toJSON(message: CMsgClientToGCUnderDraftRerollResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = eUnderDraftResponseToJSON(message.result));
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.draftData !== undefined &&
      (obj.draftData = message.draftData ? CMsgUnderDraftData.toJSON(message.draftData) : undefined);
    return obj;
  },
};

function createBaseCMsgClientToGCUnderDraftBuy(): CMsgClientToGCUnderDraftBuy {
  return { eventId: 0, slotId: 0 };
}

export const CMsgClientToGCUnderDraftBuy = {
  encode(message: CMsgClientToGCUnderDraftBuy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    if (message.slotId !== 0) {
      writer.uint32(16).uint32(message.slotId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCUnderDraftBuy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCUnderDraftBuy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.slotId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCUnderDraftBuy {
    return {
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      slotId: isSet(object.slotId) ? Number(object.slotId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCUnderDraftBuy): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.slotId !== undefined && (obj.slotId = Math.round(message.slotId));
    return obj;
  },
};

function createBaseCMsgGCToClientGuildUnderDraftGoldUpdated(): CMsgGCToClientGuildUnderDraftGoldUpdated {
  return { eventId: 0 };
}

export const CMsgGCToClientGuildUnderDraftGoldUpdated = {
  encode(message: CMsgGCToClientGuildUnderDraftGoldUpdated, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientGuildUnderDraftGoldUpdated {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientGuildUnderDraftGoldUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientGuildUnderDraftGoldUpdated {
    return { eventId: isSet(object.eventId) ? Number(object.eventId) : 0 };
  },

  toJSON(message: CMsgGCToClientGuildUnderDraftGoldUpdated): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    return obj;
  },
};

function createBaseCMsgClientToGCUnderDraftBuyResponse(): CMsgClientToGCUnderDraftBuyResponse {
  return { result: 0, eventId: 0, slotId: 0, draftData: undefined };
}

export const CMsgClientToGCUnderDraftBuyResponse = {
  encode(message: CMsgClientToGCUnderDraftBuyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.eventId !== 0) {
      writer.uint32(16).uint32(message.eventId);
    }
    if (message.slotId !== 0) {
      writer.uint32(24).uint32(message.slotId);
    }
    if (message.draftData !== undefined) {
      CMsgUnderDraftData.encode(message.draftData, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCUnderDraftBuyResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCUnderDraftBuyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.slotId = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.draftData = CMsgUnderDraftData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCUnderDraftBuyResponse {
    return {
      result: isSet(object.result) ? eUnderDraftResponseFromJSON(object.result) : 0,
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      slotId: isSet(object.slotId) ? Number(object.slotId) : 0,
      draftData: isSet(object.draftData) ? CMsgUnderDraftData.fromJSON(object.draftData) : undefined,
    };
  },

  toJSON(message: CMsgClientToGCUnderDraftBuyResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = eUnderDraftResponseToJSON(message.result));
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.slotId !== undefined && (obj.slotId = Math.round(message.slotId));
    message.draftData !== undefined &&
      (obj.draftData = message.draftData ? CMsgUnderDraftData.toJSON(message.draftData) : undefined);
    return obj;
  },
};

function createBaseCMsgClientToGCUnderDraftRollBackBench(): CMsgClientToGCUnderDraftRollBackBench {
  return { eventId: 0 };
}

export const CMsgClientToGCUnderDraftRollBackBench = {
  encode(message: CMsgClientToGCUnderDraftRollBackBench, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCUnderDraftRollBackBench {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCUnderDraftRollBackBench();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCUnderDraftRollBackBench {
    return { eventId: isSet(object.eventId) ? Number(object.eventId) : 0 };
  },

  toJSON(message: CMsgClientToGCUnderDraftRollBackBench): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    return obj;
  },
};

function createBaseCMsgClientToGCUnderDraftRollBackBenchResponse(): CMsgClientToGCUnderDraftRollBackBenchResponse {
  return { result: 0, eventId: 0, draftData: undefined };
}

export const CMsgClientToGCUnderDraftRollBackBenchResponse = {
  encode(message: CMsgClientToGCUnderDraftRollBackBenchResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.eventId !== 0) {
      writer.uint32(16).uint32(message.eventId);
    }
    if (message.draftData !== undefined) {
      CMsgUnderDraftData.encode(message.draftData, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCUnderDraftRollBackBenchResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCUnderDraftRollBackBenchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.draftData = CMsgUnderDraftData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCUnderDraftRollBackBenchResponse {
    return {
      result: isSet(object.result) ? eUnderDraftResponseFromJSON(object.result) : 0,
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      draftData: isSet(object.draftData) ? CMsgUnderDraftData.fromJSON(object.draftData) : undefined,
    };
  },

  toJSON(message: CMsgClientToGCUnderDraftRollBackBenchResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = eUnderDraftResponseToJSON(message.result));
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.draftData !== undefined &&
      (obj.draftData = message.draftData ? CMsgUnderDraftData.toJSON(message.draftData) : undefined);
    return obj;
  },
};

function createBaseCMsgClientToGCUnderDraftSell(): CMsgClientToGCUnderDraftSell {
  return { eventId: 0, slotId: 0 };
}

export const CMsgClientToGCUnderDraftSell = {
  encode(message: CMsgClientToGCUnderDraftSell, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    if (message.slotId !== 0) {
      writer.uint32(16).uint32(message.slotId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCUnderDraftSell {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCUnderDraftSell();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.slotId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCUnderDraftSell {
    return {
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      slotId: isSet(object.slotId) ? Number(object.slotId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCUnderDraftSell): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.slotId !== undefined && (obj.slotId = Math.round(message.slotId));
    return obj;
  },
};

function createBaseCMsgClientToGCUnderDraftSellResponse(): CMsgClientToGCUnderDraftSellResponse {
  return { result: 0, eventId: 0, slotId: 0, draftData: undefined };
}

export const CMsgClientToGCUnderDraftSellResponse = {
  encode(message: CMsgClientToGCUnderDraftSellResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.eventId !== 0) {
      writer.uint32(16).uint32(message.eventId);
    }
    if (message.slotId !== 0) {
      writer.uint32(24).uint32(message.slotId);
    }
    if (message.draftData !== undefined) {
      CMsgUnderDraftData.encode(message.draftData, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCUnderDraftSellResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCUnderDraftSellResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.slotId = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }

          message.draftData = CMsgUnderDraftData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCUnderDraftSellResponse {
    return {
      result: isSet(object.result) ? eUnderDraftResponseFromJSON(object.result) : 0,
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      slotId: isSet(object.slotId) ? Number(object.slotId) : 0,
      draftData: isSet(object.draftData) ? CMsgUnderDraftData.fromJSON(object.draftData) : undefined,
    };
  },

  toJSON(message: CMsgClientToGCUnderDraftSellResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = eUnderDraftResponseToJSON(message.result));
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.slotId !== undefined && (obj.slotId = Math.round(message.slotId));
    message.draftData !== undefined &&
      (obj.draftData = message.draftData ? CMsgUnderDraftData.toJSON(message.draftData) : undefined);
    return obj;
  },
};

function createBaseCMsgClientToGCUnderDraftRedeemReward(): CMsgClientToGCUnderDraftRedeemReward {
  return { eventId: 0, actionId: 0 };
}

export const CMsgClientToGCUnderDraftRedeemReward = {
  encode(message: CMsgClientToGCUnderDraftRedeemReward, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    if (message.actionId !== 0) {
      writer.uint32(16).uint32(message.actionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCUnderDraftRedeemReward {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCUnderDraftRedeemReward();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.actionId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCUnderDraftRedeemReward {
    return {
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      actionId: isSet(object.actionId) ? Number(object.actionId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCUnderDraftRedeemReward): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.actionId !== undefined && (obj.actionId = Math.round(message.actionId));
    return obj;
  },
};

function createBaseCMsgClientToGCUnderDraftRedeemRewardResponse(): CMsgClientToGCUnderDraftRedeemRewardResponse {
  return { result: 0 };
}

export const CMsgClientToGCUnderDraftRedeemRewardResponse = {
  encode(message: CMsgClientToGCUnderDraftRedeemRewardResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCUnderDraftRedeemRewardResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCUnderDraftRedeemRewardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCUnderDraftRedeemRewardResponse {
    return { result: isSet(object.result) ? eUnderDraftResponseFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgClientToGCUnderDraftRedeemRewardResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = eUnderDraftResponseToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgClientToGCSubmitDraftTriviaMatchAnswer(): CMsgClientToGCSubmitDraftTriviaMatchAnswer {
  return { choseRadiantAsWinner: false, eventId: 0, endTime: 0 };
}

export const CMsgClientToGCSubmitDraftTriviaMatchAnswer = {
  encode(message: CMsgClientToGCSubmitDraftTriviaMatchAnswer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.choseRadiantAsWinner === true) {
      writer.uint32(8).bool(message.choseRadiantAsWinner);
    }
    if (message.eventId !== 0) {
      writer.uint32(16).uint32(message.eventId);
    }
    if (message.endTime !== 0) {
      writer.uint32(24).uint32(message.endTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSubmitDraftTriviaMatchAnswer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSubmitDraftTriviaMatchAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.choseRadiantAsWinner = reader.bool();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.endTime = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSubmitDraftTriviaMatchAnswer {
    return {
      choseRadiantAsWinner: isSet(object.choseRadiantAsWinner) ? Boolean(object.choseRadiantAsWinner) : false,
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      endTime: isSet(object.endTime) ? Number(object.endTime) : 0,
    };
  },

  toJSON(message: CMsgClientToGCSubmitDraftTriviaMatchAnswer): unknown {
    const obj: any = {};
    message.choseRadiantAsWinner !== undefined && (obj.choseRadiantAsWinner = message.choseRadiantAsWinner);
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.endTime !== undefined && (obj.endTime = Math.round(message.endTime));
    return obj;
  },
};

function createBaseCMsgClientToGCSubmitDraftTriviaMatchAnswerResponse(): CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse {
  return { result: 0 };
}

export const CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse = {
  encode(
    message: CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSubmitDraftTriviaMatchAnswerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse {
    return { result: isSet(object.result) ? eDOTADraftTriviaAnswerResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = eDOTADraftTriviaAnswerResultToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgDraftTriviaVoteCount(): CMsgDraftTriviaVoteCount {
  return { totalVotes: 0, radiantVotes: 0, direVotes: 0 };
}

export const CMsgDraftTriviaVoteCount = {
  encode(message: CMsgDraftTriviaVoteCount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.totalVotes !== 0) {
      writer.uint32(8).uint32(message.totalVotes);
    }
    if (message.radiantVotes !== 0) {
      writer.uint32(16).uint32(message.radiantVotes);
    }
    if (message.direVotes !== 0) {
      writer.uint32(24).uint32(message.direVotes);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDraftTriviaVoteCount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDraftTriviaVoteCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.totalVotes = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.radiantVotes = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.direVotes = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDraftTriviaVoteCount {
    return {
      totalVotes: isSet(object.totalVotes) ? Number(object.totalVotes) : 0,
      radiantVotes: isSet(object.radiantVotes) ? Number(object.radiantVotes) : 0,
      direVotes: isSet(object.direVotes) ? Number(object.direVotes) : 0,
    };
  },

  toJSON(message: CMsgDraftTriviaVoteCount): unknown {
    const obj: any = {};
    message.totalVotes !== undefined && (obj.totalVotes = Math.round(message.totalVotes));
    message.radiantVotes !== undefined && (obj.radiantVotes = Math.round(message.radiantVotes));
    message.direVotes !== undefined && (obj.direVotes = Math.round(message.direVotes));
    return obj;
  },
};

function createBaseCMsgClientToGCRecalibrateMMR(): CMsgClientToGCRecalibrateMMR {
  return {};
}

export const CMsgClientToGCRecalibrateMMR = {
  encode(_: CMsgClientToGCRecalibrateMMR, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRecalibrateMMR {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRecalibrateMMR();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientToGCRecalibrateMMR {
    return {};
  },

  toJSON(_: CMsgClientToGCRecalibrateMMR): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgClientToGCRecalibrateMMRResponse(): CMsgClientToGCRecalibrateMMRResponse {
  return { result: 0 };
}

export const CMsgClientToGCRecalibrateMMRResponse = {
  encode(message: CMsgClientToGCRecalibrateMMRResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRecalibrateMMRResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRecalibrateMMRResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRecalibrateMMRResponse {
    return { result: isSet(object.result) ? cMsgClientToGCRecalibrateMMRResponse_EResponseFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgClientToGCRecalibrateMMRResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = cMsgClientToGCRecalibrateMMRResponse_EResponseToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgDOTAPostGameItemAwardNotification(): CMsgDOTAPostGameItemAwardNotification {
  return { receiverAccountId: 0, itemDefIndex: [], actionId: 0 };
}

export const CMsgDOTAPostGameItemAwardNotification = {
  encode(message: CMsgDOTAPostGameItemAwardNotification, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.receiverAccountId !== 0) {
      writer.uint32(8).uint32(message.receiverAccountId);
    }
    writer.uint32(18).fork();
    for (const v of message.itemDefIndex) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.actionId !== 0) {
      writer.uint32(24).uint32(message.actionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAPostGameItemAwardNotification {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAPostGameItemAwardNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.receiverAccountId = reader.uint32();
          continue;
        case 2:
          if (tag == 16) {
            message.itemDefIndex.push(reader.uint32());
            continue;
          }

          if (tag == 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.itemDefIndex.push(reader.uint32());
            }

            continue;
          }

          break;
        case 3:
          if (tag != 24) {
            break;
          }

          message.actionId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAPostGameItemAwardNotification {
    return {
      receiverAccountId: isSet(object.receiverAccountId) ? Number(object.receiverAccountId) : 0,
      itemDefIndex: Array.isArray(object?.itemDefIndex) ? object.itemDefIndex.map((e: any) => Number(e)) : [],
      actionId: isSet(object.actionId) ? Number(object.actionId) : 0,
    };
  },

  toJSON(message: CMsgDOTAPostGameItemAwardNotification): unknown {
    const obj: any = {};
    message.receiverAccountId !== undefined && (obj.receiverAccountId = Math.round(message.receiverAccountId));
    if (message.itemDefIndex) {
      obj.itemDefIndex = message.itemDefIndex.map((e) => Math.round(e));
    } else {
      obj.itemDefIndex = [];
    }
    message.actionId !== undefined && (obj.actionId = Math.round(message.actionId));
    return obj;
  },
};

function createBaseCMsgClientToGCGetOWMatchDetails(): CMsgClientToGCGetOWMatchDetails {
  return {};
}

export const CMsgClientToGCGetOWMatchDetails = {
  encode(_: CMsgClientToGCGetOWMatchDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetOWMatchDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetOWMatchDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientToGCGetOWMatchDetails {
    return {};
  },

  toJSON(_: CMsgClientToGCGetOWMatchDetails): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgClientToGCGetOWMatchDetailsResponse(): CMsgClientToGCGetOWMatchDetailsResponse {
  return {
    result: 0,
    overwatchReplayId: "0",
    decryptionKey: "0",
    cluster: 0,
    overwatchSalt: 0,
    targetPlayerSlot: 0,
    markers: [],
    reportReason: 0,
    targetHeroId: 0,
    rankTier: 0,
    laneSelectionFlags: 0,
  };
}

export const CMsgClientToGCGetOWMatchDetailsResponse = {
  encode(message: CMsgClientToGCGetOWMatchDetailsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.overwatchReplayId !== "0") {
      writer.uint32(16).uint64(message.overwatchReplayId);
    }
    if (message.decryptionKey !== "0") {
      writer.uint32(24).uint64(message.decryptionKey);
    }
    if (message.cluster !== 0) {
      writer.uint32(32).uint32(message.cluster);
    }
    if (message.overwatchSalt !== 0) {
      writer.uint32(40).uint32(message.overwatchSalt);
    }
    if (message.targetPlayerSlot !== 0) {
      writer.uint32(48).uint32(message.targetPlayerSlot);
    }
    for (const v of message.markers) {
      CMsgClientToGCGetOWMatchDetailsResponse_Marker.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (message.reportReason !== 0) {
      writer.uint32(64).int32(message.reportReason);
    }
    if (message.targetHeroId !== 0) {
      writer.uint32(72).uint32(message.targetHeroId);
    }
    if (message.rankTier !== 0) {
      writer.uint32(80).uint32(message.rankTier);
    }
    if (message.laneSelectionFlags !== 0) {
      writer.uint32(88).uint32(message.laneSelectionFlags);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetOWMatchDetailsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetOWMatchDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.overwatchReplayId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.decryptionKey = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.cluster = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.overwatchSalt = reader.uint32();
          continue;
        case 6:
          if (tag != 48) {
            break;
          }

          message.targetPlayerSlot = reader.uint32();
          continue;
        case 7:
          if (tag != 58) {
            break;
          }

          message.markers.push(CMsgClientToGCGetOWMatchDetailsResponse_Marker.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag != 64) {
            break;
          }

          message.reportReason = reader.int32() as any;
          continue;
        case 9:
          if (tag != 72) {
            break;
          }

          message.targetHeroId = reader.uint32();
          continue;
        case 10:
          if (tag != 80) {
            break;
          }

          message.rankTier = reader.uint32();
          continue;
        case 11:
          if (tag != 88) {
            break;
          }

          message.laneSelectionFlags = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetOWMatchDetailsResponse {
    return {
      result: isSet(object.result) ? cMsgClientToGCGetOWMatchDetailsResponse_EResponseFromJSON(object.result) : 0,
      overwatchReplayId: isSet(object.overwatchReplayId) ? String(object.overwatchReplayId) : "0",
      decryptionKey: isSet(object.decryptionKey) ? String(object.decryptionKey) : "0",
      cluster: isSet(object.cluster) ? Number(object.cluster) : 0,
      overwatchSalt: isSet(object.overwatchSalt) ? Number(object.overwatchSalt) : 0,
      targetPlayerSlot: isSet(object.targetPlayerSlot) ? Number(object.targetPlayerSlot) : 0,
      markers: Array.isArray(object?.markers)
        ? object.markers.map((e: any) => CMsgClientToGCGetOWMatchDetailsResponse_Marker.fromJSON(e))
        : [],
      reportReason: isSet(object.reportReason) ? eOverwatchReportReasonFromJSON(object.reportReason) : 0,
      targetHeroId: isSet(object.targetHeroId) ? Number(object.targetHeroId) : 0,
      rankTier: isSet(object.rankTier) ? Number(object.rankTier) : 0,
      laneSelectionFlags: isSet(object.laneSelectionFlags) ? Number(object.laneSelectionFlags) : 0,
    };
  },

  toJSON(message: CMsgClientToGCGetOWMatchDetailsResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgClientToGCGetOWMatchDetailsResponse_EResponseToJSON(message.result));
    message.overwatchReplayId !== undefined && (obj.overwatchReplayId = message.overwatchReplayId);
    message.decryptionKey !== undefined && (obj.decryptionKey = message.decryptionKey);
    message.cluster !== undefined && (obj.cluster = Math.round(message.cluster));
    message.overwatchSalt !== undefined && (obj.overwatchSalt = Math.round(message.overwatchSalt));
    message.targetPlayerSlot !== undefined && (obj.targetPlayerSlot = Math.round(message.targetPlayerSlot));
    if (message.markers) {
      obj.markers = message.markers.map((e) =>
        e ? CMsgClientToGCGetOWMatchDetailsResponse_Marker.toJSON(e) : undefined
      );
    } else {
      obj.markers = [];
    }
    message.reportReason !== undefined && (obj.reportReason = eOverwatchReportReasonToJSON(message.reportReason));
    message.targetHeroId !== undefined && (obj.targetHeroId = Math.round(message.targetHeroId));
    message.rankTier !== undefined && (obj.rankTier = Math.round(message.rankTier));
    message.laneSelectionFlags !== undefined && (obj.laneSelectionFlags = Math.round(message.laneSelectionFlags));
    return obj;
  },
};

function createBaseCMsgClientToGCGetOWMatchDetailsResponse_Marker(): CMsgClientToGCGetOWMatchDetailsResponse_Marker {
  return { startGameTimeS: 0, endGameTimeS: 0 };
}

export const CMsgClientToGCGetOWMatchDetailsResponse_Marker = {
  encode(
    message: CMsgClientToGCGetOWMatchDetailsResponse_Marker,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.startGameTimeS !== 0) {
      writer.uint32(8).uint32(message.startGameTimeS);
    }
    if (message.endGameTimeS !== 0) {
      writer.uint32(16).uint32(message.endGameTimeS);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetOWMatchDetailsResponse_Marker {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetOWMatchDetailsResponse_Marker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.startGameTimeS = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.endGameTimeS = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetOWMatchDetailsResponse_Marker {
    return {
      startGameTimeS: isSet(object.startGameTimeS) ? Number(object.startGameTimeS) : 0,
      endGameTimeS: isSet(object.endGameTimeS) ? Number(object.endGameTimeS) : 0,
    };
  },

  toJSON(message: CMsgClientToGCGetOWMatchDetailsResponse_Marker): unknown {
    const obj: any = {};
    message.startGameTimeS !== undefined && (obj.startGameTimeS = Math.round(message.startGameTimeS));
    message.endGameTimeS !== undefined && (obj.endGameTimeS = Math.round(message.endGameTimeS));
    return obj;
  },
};

function createBaseCMsgClientToGCSubmitOWConviction(): CMsgClientToGCSubmitOWConviction {
  return { overwatchReplayId: "0", targetPlayerSlot: 0, cheatingConviction: 0, griefingConviction: 0 };
}

export const CMsgClientToGCSubmitOWConviction = {
  encode(message: CMsgClientToGCSubmitOWConviction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.overwatchReplayId !== "0") {
      writer.uint32(8).uint64(message.overwatchReplayId);
    }
    if (message.targetPlayerSlot !== 0) {
      writer.uint32(16).uint32(message.targetPlayerSlot);
    }
    if (message.cheatingConviction !== 0) {
      writer.uint32(24).int32(message.cheatingConviction);
    }
    if (message.griefingConviction !== 0) {
      writer.uint32(32).int32(message.griefingConviction);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSubmitOWConviction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSubmitOWConviction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.overwatchReplayId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.targetPlayerSlot = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.cheatingConviction = reader.int32() as any;
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.griefingConviction = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSubmitOWConviction {
    return {
      overwatchReplayId: isSet(object.overwatchReplayId) ? String(object.overwatchReplayId) : "0",
      targetPlayerSlot: isSet(object.targetPlayerSlot) ? Number(object.targetPlayerSlot) : 0,
      cheatingConviction: isSet(object.cheatingConviction)
        ? eOverwatchConvictionFromJSON(object.cheatingConviction)
        : 0,
      griefingConviction: isSet(object.griefingConviction)
        ? eOverwatchConvictionFromJSON(object.griefingConviction)
        : 0,
    };
  },

  toJSON(message: CMsgClientToGCSubmitOWConviction): unknown {
    const obj: any = {};
    message.overwatchReplayId !== undefined && (obj.overwatchReplayId = message.overwatchReplayId);
    message.targetPlayerSlot !== undefined && (obj.targetPlayerSlot = Math.round(message.targetPlayerSlot));
    message.cheatingConviction !== undefined &&
      (obj.cheatingConviction = eOverwatchConvictionToJSON(message.cheatingConviction));
    message.griefingConviction !== undefined &&
      (obj.griefingConviction = eOverwatchConvictionToJSON(message.griefingConviction));
    return obj;
  },
};

function createBaseCMsgClientToGCSubmitOWConvictionResponse(): CMsgClientToGCSubmitOWConvictionResponse {
  return { result: 0, overwatchReplayId: "0" };
}

export const CMsgClientToGCSubmitOWConvictionResponse = {
  encode(message: CMsgClientToGCSubmitOWConvictionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.overwatchReplayId !== "0") {
      writer.uint32(16).uint64(message.overwatchReplayId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSubmitOWConvictionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSubmitOWConvictionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.overwatchReplayId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSubmitOWConvictionResponse {
    return {
      result: isSet(object.result) ? cMsgClientToGCSubmitOWConvictionResponse_EResponseFromJSON(object.result) : 0,
      overwatchReplayId: isSet(object.overwatchReplayId) ? String(object.overwatchReplayId) : "0",
    };
  },

  toJSON(message: CMsgClientToGCSubmitOWConvictionResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgClientToGCSubmitOWConvictionResponse_EResponseToJSON(message.result));
    message.overwatchReplayId !== undefined && (obj.overwatchReplayId = message.overwatchReplayId);
    return obj;
  },
};

function createBaseCMsgClientToGCChinaSSAURLRequest(): CMsgClientToGCChinaSSAURLRequest {
  return {};
}

export const CMsgClientToGCChinaSSAURLRequest = {
  encode(_: CMsgClientToGCChinaSSAURLRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCChinaSSAURLRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCChinaSSAURLRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientToGCChinaSSAURLRequest {
    return {};
  },

  toJSON(_: CMsgClientToGCChinaSSAURLRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgClientToGCChinaSSAURLResponse(): CMsgClientToGCChinaSSAURLResponse {
  return { agreementUrl: "" };
}

export const CMsgClientToGCChinaSSAURLResponse = {
  encode(message: CMsgClientToGCChinaSSAURLResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.agreementUrl !== "") {
      writer.uint32(10).string(message.agreementUrl);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCChinaSSAURLResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCChinaSSAURLResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.agreementUrl = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCChinaSSAURLResponse {
    return { agreementUrl: isSet(object.agreementUrl) ? String(object.agreementUrl) : "" };
  },

  toJSON(message: CMsgClientToGCChinaSSAURLResponse): unknown {
    const obj: any = {};
    message.agreementUrl !== undefined && (obj.agreementUrl = message.agreementUrl);
    return obj;
  },
};

function createBaseCMsgClientToGCChinaSSAAcceptedRequest(): CMsgClientToGCChinaSSAAcceptedRequest {
  return {};
}

export const CMsgClientToGCChinaSSAAcceptedRequest = {
  encode(_: CMsgClientToGCChinaSSAAcceptedRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCChinaSSAAcceptedRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCChinaSSAAcceptedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientToGCChinaSSAAcceptedRequest {
    return {};
  },

  toJSON(_: CMsgClientToGCChinaSSAAcceptedRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgClientToGCChinaSSAAcceptedResponse(): CMsgClientToGCChinaSSAAcceptedResponse {
  return { agreementAccepted: false };
}

export const CMsgClientToGCChinaSSAAcceptedResponse = {
  encode(message: CMsgClientToGCChinaSSAAcceptedResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.agreementAccepted === true) {
      writer.uint32(8).bool(message.agreementAccepted);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCChinaSSAAcceptedResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCChinaSSAAcceptedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.agreementAccepted = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCChinaSSAAcceptedResponse {
    return { agreementAccepted: isSet(object.agreementAccepted) ? Boolean(object.agreementAccepted) : false };
  },

  toJSON(message: CMsgClientToGCChinaSSAAcceptedResponse): unknown {
    const obj: any = {};
    message.agreementAccepted !== undefined && (obj.agreementAccepted = message.agreementAccepted);
    return obj;
  },
};

function createBaseCMsgGCToClientOverwatchCasesAvailable(): CMsgGCToClientOverwatchCasesAvailable {
  return { expireTime: 0 };
}

export const CMsgGCToClientOverwatchCasesAvailable = {
  encode(message: CMsgGCToClientOverwatchCasesAvailable, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.expireTime !== 0) {
      writer.uint32(13).fixed32(message.expireTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientOverwatchCasesAvailable {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientOverwatchCasesAvailable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 13) {
            break;
          }

          message.expireTime = reader.fixed32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientOverwatchCasesAvailable {
    return { expireTime: isSet(object.expireTime) ? Number(object.expireTime) : 0 };
  },

  toJSON(message: CMsgGCToClientOverwatchCasesAvailable): unknown {
    const obj: any = {};
    message.expireTime !== undefined && (obj.expireTime = Math.round(message.expireTime));
    return obj;
  },
};

function createBaseCMsgClientToGCStartWatchingOverwatch(): CMsgClientToGCStartWatchingOverwatch {
  return { overwatchReplayId: "0", targetPlayerSlot: 0 };
}

export const CMsgClientToGCStartWatchingOverwatch = {
  encode(message: CMsgClientToGCStartWatchingOverwatch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.overwatchReplayId !== "0") {
      writer.uint32(8).uint64(message.overwatchReplayId);
    }
    if (message.targetPlayerSlot !== 0) {
      writer.uint32(16).uint32(message.targetPlayerSlot);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCStartWatchingOverwatch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCStartWatchingOverwatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.overwatchReplayId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.targetPlayerSlot = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCStartWatchingOverwatch {
    return {
      overwatchReplayId: isSet(object.overwatchReplayId) ? String(object.overwatchReplayId) : "0",
      targetPlayerSlot: isSet(object.targetPlayerSlot) ? Number(object.targetPlayerSlot) : 0,
    };
  },

  toJSON(message: CMsgClientToGCStartWatchingOverwatch): unknown {
    const obj: any = {};
    message.overwatchReplayId !== undefined && (obj.overwatchReplayId = message.overwatchReplayId);
    message.targetPlayerSlot !== undefined && (obj.targetPlayerSlot = Math.round(message.targetPlayerSlot));
    return obj;
  },
};

function createBaseCMsgClientToGCStopWatchingOverwatch(): CMsgClientToGCStopWatchingOverwatch {
  return { overwatchReplayId: "0", targetPlayerSlot: 0 };
}

export const CMsgClientToGCStopWatchingOverwatch = {
  encode(message: CMsgClientToGCStopWatchingOverwatch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.overwatchReplayId !== "0") {
      writer.uint32(8).uint64(message.overwatchReplayId);
    }
    if (message.targetPlayerSlot !== 0) {
      writer.uint32(16).uint32(message.targetPlayerSlot);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCStopWatchingOverwatch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCStopWatchingOverwatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.overwatchReplayId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.targetPlayerSlot = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCStopWatchingOverwatch {
    return {
      overwatchReplayId: isSet(object.overwatchReplayId) ? String(object.overwatchReplayId) : "0",
      targetPlayerSlot: isSet(object.targetPlayerSlot) ? Number(object.targetPlayerSlot) : 0,
    };
  },

  toJSON(message: CMsgClientToGCStopWatchingOverwatch): unknown {
    const obj: any = {};
    message.overwatchReplayId !== undefined && (obj.overwatchReplayId = message.overwatchReplayId);
    message.targetPlayerSlot !== undefined && (obj.targetPlayerSlot = Math.round(message.targetPlayerSlot));
    return obj;
  },
};

function createBaseCMsgClientToGCOverwatchReplayError(): CMsgClientToGCOverwatchReplayError {
  return { overwatchReplayId: "0" };
}

export const CMsgClientToGCOverwatchReplayError = {
  encode(message: CMsgClientToGCOverwatchReplayError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.overwatchReplayId !== "0") {
      writer.uint32(8).uint64(message.overwatchReplayId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCOverwatchReplayError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverwatchReplayError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.overwatchReplayId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverwatchReplayError {
    return { overwatchReplayId: isSet(object.overwatchReplayId) ? String(object.overwatchReplayId) : "0" };
  },

  toJSON(message: CMsgClientToGCOverwatchReplayError): unknown {
    const obj: any = {};
    message.overwatchReplayId !== undefined && (obj.overwatchReplayId = message.overwatchReplayId);
    return obj;
  },
};

function createBaseCMsgClientToGCGetDPCFavorites(): CMsgClientToGCGetDPCFavorites {
  return {};
}

export const CMsgClientToGCGetDPCFavorites = {
  encode(_: CMsgClientToGCGetDPCFavorites, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetDPCFavorites {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetDPCFavorites();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientToGCGetDPCFavorites {
    return {};
  },

  toJSON(_: CMsgClientToGCGetDPCFavorites): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgClientToGCGetDPCFavoritesResponse(): CMsgClientToGCGetDPCFavoritesResponse {
  return { result: 0, favorites: [] };
}

export const CMsgClientToGCGetDPCFavoritesResponse = {
  encode(message: CMsgClientToGCGetDPCFavoritesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    for (const v of message.favorites) {
      CMsgClientToGCGetDPCFavoritesResponse_Favorite.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetDPCFavoritesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetDPCFavoritesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.favorites.push(CMsgClientToGCGetDPCFavoritesResponse_Favorite.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetDPCFavoritesResponse {
    return {
      result: isSet(object.result) ? cMsgClientToGCGetDPCFavoritesResponse_EResponseFromJSON(object.result) : 0,
      favorites: Array.isArray(object?.favorites)
        ? object.favorites.map((e: any) => CMsgClientToGCGetDPCFavoritesResponse_Favorite.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientToGCGetDPCFavoritesResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgClientToGCGetDPCFavoritesResponse_EResponseToJSON(message.result));
    if (message.favorites) {
      obj.favorites = message.favorites.map((e) =>
        e ? CMsgClientToGCGetDPCFavoritesResponse_Favorite.toJSON(e) : undefined
      );
    } else {
      obj.favorites = [];
    }
    return obj;
  },
};

function createBaseCMsgClientToGCGetDPCFavoritesResponse_Favorite(): CMsgClientToGCGetDPCFavoritesResponse_Favorite {
  return { favoriteType: 0, favoriteId: 0 };
}

export const CMsgClientToGCGetDPCFavoritesResponse_Favorite = {
  encode(
    message: CMsgClientToGCGetDPCFavoritesResponse_Favorite,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.favoriteType !== 0) {
      writer.uint32(8).int32(message.favoriteType);
    }
    if (message.favoriteId !== 0) {
      writer.uint32(16).uint32(message.favoriteId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetDPCFavoritesResponse_Favorite {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetDPCFavoritesResponse_Favorite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.favoriteType = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.favoriteId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetDPCFavoritesResponse_Favorite {
    return {
      favoriteType: isSet(object.favoriteType) ? eDPCFavoriteTypeFromJSON(object.favoriteType) : 0,
      favoriteId: isSet(object.favoriteId) ? Number(object.favoriteId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCGetDPCFavoritesResponse_Favorite): unknown {
    const obj: any = {};
    message.favoriteType !== undefined && (obj.favoriteType = eDPCFavoriteTypeToJSON(message.favoriteType));
    message.favoriteId !== undefined && (obj.favoriteId = Math.round(message.favoriteId));
    return obj;
  },
};

function createBaseCMsgClientToGCSetDPCFavoriteState(): CMsgClientToGCSetDPCFavoriteState {
  return { favoriteType: 0, favoriteId: 0, enabled: false };
}

export const CMsgClientToGCSetDPCFavoriteState = {
  encode(message: CMsgClientToGCSetDPCFavoriteState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.favoriteType !== 0) {
      writer.uint32(8).int32(message.favoriteType);
    }
    if (message.favoriteId !== 0) {
      writer.uint32(16).uint32(message.favoriteId);
    }
    if (message.enabled === true) {
      writer.uint32(24).bool(message.enabled);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSetDPCFavoriteState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSetDPCFavoriteState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.favoriteType = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.favoriteId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSetDPCFavoriteState {
    return {
      favoriteType: isSet(object.favoriteType) ? eDPCFavoriteTypeFromJSON(object.favoriteType) : 0,
      favoriteId: isSet(object.favoriteId) ? Number(object.favoriteId) : 0,
      enabled: isSet(object.enabled) ? Boolean(object.enabled) : false,
    };
  },

  toJSON(message: CMsgClientToGCSetDPCFavoriteState): unknown {
    const obj: any = {};
    message.favoriteType !== undefined && (obj.favoriteType = eDPCFavoriteTypeToJSON(message.favoriteType));
    message.favoriteId !== undefined && (obj.favoriteId = Math.round(message.favoriteId));
    message.enabled !== undefined && (obj.enabled = message.enabled);
    return obj;
  },
};

function createBaseCMsgClientToGCSetDPCFavoriteStateResponse(): CMsgClientToGCSetDPCFavoriteStateResponse {
  return { result: 0 };
}

export const CMsgClientToGCSetDPCFavoriteStateResponse = {
  encode(message: CMsgClientToGCSetDPCFavoriteStateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSetDPCFavoriteStateResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSetDPCFavoriteStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSetDPCFavoriteStateResponse {
    return {
      result: isSet(object.result) ? cMsgClientToGCSetDPCFavoriteStateResponse_EResponseFromJSON(object.result) : 0,
    };
  },

  toJSON(message: CMsgClientToGCSetDPCFavoriteStateResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgClientToGCSetDPCFavoriteStateResponse_EResponseToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgClientToGCSetEventActiveSeasonID(): CMsgClientToGCSetEventActiveSeasonID {
  return { eventId: 0, activeSeasonId: 0 };
}

export const CMsgClientToGCSetEventActiveSeasonID = {
  encode(message: CMsgClientToGCSetEventActiveSeasonID, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    if (message.activeSeasonId !== 0) {
      writer.uint32(16).uint32(message.activeSeasonId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSetEventActiveSeasonID {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSetEventActiveSeasonID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.activeSeasonId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSetEventActiveSeasonID {
    return {
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      activeSeasonId: isSet(object.activeSeasonId) ? Number(object.activeSeasonId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCSetEventActiveSeasonID): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = Math.round(message.eventId));
    message.activeSeasonId !== undefined && (obj.activeSeasonId = Math.round(message.activeSeasonId));
    return obj;
  },
};

function createBaseCMsgClientToGCSetEventActiveSeasonIDResponse(): CMsgClientToGCSetEventActiveSeasonIDResponse {
  return { result: 0 };
}

export const CMsgClientToGCSetEventActiveSeasonIDResponse = {
  encode(message: CMsgClientToGCSetEventActiveSeasonIDResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSetEventActiveSeasonIDResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSetEventActiveSeasonIDResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSetEventActiveSeasonIDResponse {
    return {
      result: isSet(object.result) ? cMsgClientToGCSetEventActiveSeasonIDResponse_EResponseFromJSON(object.result) : 0,
    };
  },

  toJSON(message: CMsgClientToGCSetEventActiveSeasonIDResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgClientToGCSetEventActiveSeasonIDResponse_EResponseToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgClientToGCPurchaseLabyrinthBlessings(): CMsgClientToGCPurchaseLabyrinthBlessings {
  return { eventId: 0, blessingIds: [], debug: false, debugRemove: false };
}

export const CMsgClientToGCPurchaseLabyrinthBlessings = {
  encode(message: CMsgClientToGCPurchaseLabyrinthBlessings, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).int32(message.eventId);
    }
    writer.uint32(18).fork();
    for (const v of message.blessingIds) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.debug === true) {
      writer.uint32(24).bool(message.debug);
    }
    if (message.debugRemove === true) {
      writer.uint32(32).bool(message.debugRemove);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCPurchaseLabyrinthBlessings {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCPurchaseLabyrinthBlessings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 2:
          if (tag == 16) {
            message.blessingIds.push(reader.int32());
            continue;
          }

          if (tag == 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.blessingIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 3:
          if (tag != 24) {
            break;
          }

          message.debug = reader.bool();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.debugRemove = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCPurchaseLabyrinthBlessings {
    return {
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      blessingIds: Array.isArray(object?.blessingIds) ? object.blessingIds.map((e: any) => Number(e)) : [],
      debug: isSet(object.debug) ? Boolean(object.debug) : false,
      debugRemove: isSet(object.debugRemove) ? Boolean(object.debugRemove) : false,
    };
  },

  toJSON(message: CMsgClientToGCPurchaseLabyrinthBlessings): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = eEventToJSON(message.eventId));
    if (message.blessingIds) {
      obj.blessingIds = message.blessingIds.map((e) => Math.round(e));
    } else {
      obj.blessingIds = [];
    }
    message.debug !== undefined && (obj.debug = message.debug);
    message.debugRemove !== undefined && (obj.debugRemove = message.debugRemove);
    return obj;
  },
};

function createBaseCMsgClientToGCPurchaseLabyrinthBlessingsResponse(): CMsgClientToGCPurchaseLabyrinthBlessingsResponse {
  return { result: 0 };
}

export const CMsgClientToGCPurchaseLabyrinthBlessingsResponse = {
  encode(
    message: CMsgClientToGCPurchaseLabyrinthBlessingsResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCPurchaseLabyrinthBlessingsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCPurchaseLabyrinthBlessingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCPurchaseLabyrinthBlessingsResponse {
    return {
      result: isSet(object.result)
        ? cMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponseFromJSON(object.result)
        : 0,
    };
  },

  toJSON(message: CMsgClientToGCPurchaseLabyrinthBlessingsResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = cMsgClientToGCPurchaseLabyrinthBlessingsResponse_EResponseToJSON(message.result));
    return obj;
  },
};

function createBaseCMsgClientToGCGetStickerbookRequest(): CMsgClientToGCGetStickerbookRequest {
  return { accountId: 0 };
}

export const CMsgClientToGCGetStickerbookRequest = {
  encode(message: CMsgClientToGCGetStickerbookRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetStickerbookRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetStickerbookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetStickerbookRequest {
    return { accountId: isSet(object.accountId) ? Number(object.accountId) : 0 };
  },

  toJSON(message: CMsgClientToGCGetStickerbookRequest): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = Math.round(message.accountId));
    return obj;
  },
};

function createBaseCMsgClientToGCGetStickerbookResponse(): CMsgClientToGCGetStickerbookResponse {
  return { response: 0, stickerbook: undefined };
}

export const CMsgClientToGCGetStickerbookResponse = {
  encode(message: CMsgClientToGCGetStickerbookResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    if (message.stickerbook !== undefined) {
      CMsgStickerbook.encode(message.stickerbook, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetStickerbookResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetStickerbookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.stickerbook = CMsgStickerbook.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetStickerbookResponse {
    return {
      response: isSet(object.response) ? cMsgClientToGCGetStickerbookResponse_EResponseFromJSON(object.response) : 0,
      stickerbook: isSet(object.stickerbook) ? CMsgStickerbook.fromJSON(object.stickerbook) : undefined,
    };
  },

  toJSON(message: CMsgClientToGCGetStickerbookResponse): unknown {
    const obj: any = {};
    message.response !== undefined &&
      (obj.response = cMsgClientToGCGetStickerbookResponse_EResponseToJSON(message.response));
    message.stickerbook !== undefined &&
      (obj.stickerbook = message.stickerbook ? CMsgStickerbook.toJSON(message.stickerbook) : undefined);
    return obj;
  },
};

function createBaseCMsgClientToGCCreateStickerbookPageRequest(): CMsgClientToGCCreateStickerbookPageRequest {
  return { teamId: 0, eventId: 0, pageType: 0 };
}

export const CMsgClientToGCCreateStickerbookPageRequest = {
  encode(message: CMsgClientToGCCreateStickerbookPageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.teamId !== 0) {
      writer.uint32(8).uint32(message.teamId);
    }
    if (message.eventId !== 0) {
      writer.uint32(16).int32(message.eventId);
    }
    if (message.pageType !== 0) {
      writer.uint32(24).int32(message.pageType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCCreateStickerbookPageRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCreateStickerbookPageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.pageType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCreateStickerbookPageRequest {
    return {
      teamId: isSet(object.teamId) ? Number(object.teamId) : 0,
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      pageType: isSet(object.pageType) ? eStickerbookPageTypeFromJSON(object.pageType) : 0,
    };
  },

  toJSON(message: CMsgClientToGCCreateStickerbookPageRequest): unknown {
    const obj: any = {};
    message.teamId !== undefined && (obj.teamId = Math.round(message.teamId));
    message.eventId !== undefined && (obj.eventId = eEventToJSON(message.eventId));
    message.pageType !== undefined && (obj.pageType = eStickerbookPageTypeToJSON(message.pageType));
    return obj;
  },
};

function createBaseCMsgClientToGCCreateStickerbookPageResponse(): CMsgClientToGCCreateStickerbookPageResponse {
  return { response: 0, pageNumber: 0 };
}

export const CMsgClientToGCCreateStickerbookPageResponse = {
  encode(message: CMsgClientToGCCreateStickerbookPageResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    if (message.pageNumber !== 0) {
      writer.uint32(16).uint32(message.pageNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCCreateStickerbookPageResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCreateStickerbookPageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.pageNumber = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCreateStickerbookPageResponse {
    return {
      response: isSet(object.response)
        ? cMsgClientToGCCreateStickerbookPageResponse_EResponseFromJSON(object.response)
        : 0,
      pageNumber: isSet(object.pageNumber) ? Number(object.pageNumber) : 0,
    };
  },

  toJSON(message: CMsgClientToGCCreateStickerbookPageResponse): unknown {
    const obj: any = {};
    message.response !== undefined &&
      (obj.response = cMsgClientToGCCreateStickerbookPageResponse_EResponseToJSON(message.response));
    message.pageNumber !== undefined && (obj.pageNumber = Math.round(message.pageNumber));
    return obj;
  },
};

function createBaseCMsgClientToGCDeleteStickerbookPageRequest(): CMsgClientToGCDeleteStickerbookPageRequest {
  return { pageNum: 0, stickerCount: 0, stickerMax: 0 };
}

export const CMsgClientToGCDeleteStickerbookPageRequest = {
  encode(message: CMsgClientToGCDeleteStickerbookPageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageNum !== 0) {
      writer.uint32(8).uint32(message.pageNum);
    }
    if (message.stickerCount !== 0) {
      writer.uint32(16).uint32(message.stickerCount);
    }
    if (message.stickerMax !== 0) {
      writer.uint32(24).uint32(message.stickerMax);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCDeleteStickerbookPageRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCDeleteStickerbookPageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.pageNum = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.stickerCount = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.stickerMax = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCDeleteStickerbookPageRequest {
    return {
      pageNum: isSet(object.pageNum) ? Number(object.pageNum) : 0,
      stickerCount: isSet(object.stickerCount) ? Number(object.stickerCount) : 0,
      stickerMax: isSet(object.stickerMax) ? Number(object.stickerMax) : 0,
    };
  },

  toJSON(message: CMsgClientToGCDeleteStickerbookPageRequest): unknown {
    const obj: any = {};
    message.pageNum !== undefined && (obj.pageNum = Math.round(message.pageNum));
    message.stickerCount !== undefined && (obj.stickerCount = Math.round(message.stickerCount));
    message.stickerMax !== undefined && (obj.stickerMax = Math.round(message.stickerMax));
    return obj;
  },
};

function createBaseCMsgClientToGCDeleteStickerbookPageResponse(): CMsgClientToGCDeleteStickerbookPageResponse {
  return { response: 0 };
}

export const CMsgClientToGCDeleteStickerbookPageResponse = {
  encode(message: CMsgClientToGCDeleteStickerbookPageResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCDeleteStickerbookPageResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCDeleteStickerbookPageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCDeleteStickerbookPageResponse {
    return {
      response: isSet(object.response)
        ? cMsgClientToGCDeleteStickerbookPageResponse_EResponseFromJSON(object.response)
        : 0,
    };
  },

  toJSON(message: CMsgClientToGCDeleteStickerbookPageResponse): unknown {
    const obj: any = {};
    message.response !== undefined &&
      (obj.response = cMsgClientToGCDeleteStickerbookPageResponse_EResponseToJSON(message.response));
    return obj;
  },
};

function createBaseCMsgClientToGCPlaceStickersRequest(): CMsgClientToGCPlaceStickersRequest {
  return { stickerItems: [] };
}

export const CMsgClientToGCPlaceStickersRequest = {
  encode(message: CMsgClientToGCPlaceStickersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.stickerItems) {
      CMsgClientToGCPlaceStickersRequest_StickerItem.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCPlaceStickersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCPlaceStickersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.stickerItems.push(CMsgClientToGCPlaceStickersRequest_StickerItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCPlaceStickersRequest {
    return {
      stickerItems: Array.isArray(object?.stickerItems)
        ? object.stickerItems.map((e: any) => CMsgClientToGCPlaceStickersRequest_StickerItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientToGCPlaceStickersRequest): unknown {
    const obj: any = {};
    if (message.stickerItems) {
      obj.stickerItems = message.stickerItems.map((e) =>
        e ? CMsgClientToGCPlaceStickersRequest_StickerItem.toJSON(e) : undefined
      );
    } else {
      obj.stickerItems = [];
    }
    return obj;
  },
};

function createBaseCMsgClientToGCPlaceStickersRequest_StickerItem(): CMsgClientToGCPlaceStickersRequest_StickerItem {
  return { pageNum: 0, sticker: undefined };
}

export const CMsgClientToGCPlaceStickersRequest_StickerItem = {
  encode(
    message: CMsgClientToGCPlaceStickersRequest_StickerItem,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.pageNum !== 0) {
      writer.uint32(16).uint32(message.pageNum);
    }
    if (message.sticker !== undefined) {
      CMsgStickerbookSticker.encode(message.sticker, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCPlaceStickersRequest_StickerItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCPlaceStickersRequest_StickerItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag != 16) {
            break;
          }

          message.pageNum = reader.uint32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.sticker = CMsgStickerbookSticker.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCPlaceStickersRequest_StickerItem {
    return {
      pageNum: isSet(object.pageNum) ? Number(object.pageNum) : 0,
      sticker: isSet(object.sticker) ? CMsgStickerbookSticker.fromJSON(object.sticker) : undefined,
    };
  },

  toJSON(message: CMsgClientToGCPlaceStickersRequest_StickerItem): unknown {
    const obj: any = {};
    message.pageNum !== undefined && (obj.pageNum = Math.round(message.pageNum));
    message.sticker !== undefined &&
      (obj.sticker = message.sticker ? CMsgStickerbookSticker.toJSON(message.sticker) : undefined);
    return obj;
  },
};

function createBaseCMsgClientToGCPlaceStickersResponse(): CMsgClientToGCPlaceStickersResponse {
  return { response: 0 };
}

export const CMsgClientToGCPlaceStickersResponse = {
  encode(message: CMsgClientToGCPlaceStickersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCPlaceStickersResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCPlaceStickersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCPlaceStickersResponse {
    return {
      response: isSet(object.response) ? cMsgClientToGCPlaceStickersResponse_EResponseFromJSON(object.response) : 0,
    };
  },

  toJSON(message: CMsgClientToGCPlaceStickersResponse): unknown {
    const obj: any = {};
    message.response !== undefined &&
      (obj.response = cMsgClientToGCPlaceStickersResponse_EResponseToJSON(message.response));
    return obj;
  },
};

function createBaseCMsgClientToGCPlaceCollectionStickersRequest(): CMsgClientToGCPlaceCollectionStickersRequest {
  return { slots: [] };
}

export const CMsgClientToGCPlaceCollectionStickersRequest = {
  encode(message: CMsgClientToGCPlaceCollectionStickersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.slots) {
      CMsgClientToGCPlaceCollectionStickersRequest_Slot.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCPlaceCollectionStickersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCPlaceCollectionStickersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.slots.push(CMsgClientToGCPlaceCollectionStickersRequest_Slot.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCPlaceCollectionStickersRequest {
    return {
      slots: Array.isArray(object?.slots)
        ? object.slots.map((e: any) => CMsgClientToGCPlaceCollectionStickersRequest_Slot.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientToGCPlaceCollectionStickersRequest): unknown {
    const obj: any = {};
    if (message.slots) {
      obj.slots = message.slots.map((e) => e ? CMsgClientToGCPlaceCollectionStickersRequest_Slot.toJSON(e) : undefined);
    } else {
      obj.slots = [];
    }
    return obj;
  },
};

function createBaseCMsgClientToGCPlaceCollectionStickersRequest_Slot(): CMsgClientToGCPlaceCollectionStickersRequest_Slot {
  return { pageNum: 0, slot: 0, newItemId: "0", oldItemDefId: 0, oldQuality: 0 };
}

export const CMsgClientToGCPlaceCollectionStickersRequest_Slot = {
  encode(
    message: CMsgClientToGCPlaceCollectionStickersRequest_Slot,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.pageNum !== 0) {
      writer.uint32(8).uint32(message.pageNum);
    }
    if (message.slot !== 0) {
      writer.uint32(16).uint32(message.slot);
    }
    if (message.newItemId !== "0") {
      writer.uint32(24).uint64(message.newItemId);
    }
    if (message.oldItemDefId !== 0) {
      writer.uint32(32).uint32(message.oldItemDefId);
    }
    if (message.oldQuality !== 0) {
      writer.uint32(40).uint32(message.oldQuality);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCPlaceCollectionStickersRequest_Slot {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCPlaceCollectionStickersRequest_Slot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.pageNum = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.slot = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.newItemId = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag != 32) {
            break;
          }

          message.oldItemDefId = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }

          message.oldQuality = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCPlaceCollectionStickersRequest_Slot {
    return {
      pageNum: isSet(object.pageNum) ? Number(object.pageNum) : 0,
      slot: isSet(object.slot) ? Number(object.slot) : 0,
      newItemId: isSet(object.newItemId) ? String(object.newItemId) : "0",
      oldItemDefId: isSet(object.oldItemDefId) ? Number(object.oldItemDefId) : 0,
      oldQuality: isSet(object.oldQuality) ? Number(object.oldQuality) : 0,
    };
  },

  toJSON(message: CMsgClientToGCPlaceCollectionStickersRequest_Slot): unknown {
    const obj: any = {};
    message.pageNum !== undefined && (obj.pageNum = Math.round(message.pageNum));
    message.slot !== undefined && (obj.slot = Math.round(message.slot));
    message.newItemId !== undefined && (obj.newItemId = message.newItemId);
    message.oldItemDefId !== undefined && (obj.oldItemDefId = Math.round(message.oldItemDefId));
    message.oldQuality !== undefined && (obj.oldQuality = Math.round(message.oldQuality));
    return obj;
  },
};

function createBaseCMsgClientToGCPlaceCollectionStickersResponse(): CMsgClientToGCPlaceCollectionStickersResponse {
  return { response: 0 };
}

export const CMsgClientToGCPlaceCollectionStickersResponse = {
  encode(message: CMsgClientToGCPlaceCollectionStickersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCPlaceCollectionStickersResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCPlaceCollectionStickersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCPlaceCollectionStickersResponse {
    return {
      response: isSet(object.response)
        ? cMsgClientToGCPlaceCollectionStickersResponse_EResponseFromJSON(object.response)
        : 0,
    };
  },

  toJSON(message: CMsgClientToGCPlaceCollectionStickersResponse): unknown {
    const obj: any = {};
    message.response !== undefined &&
      (obj.response = cMsgClientToGCPlaceCollectionStickersResponse_EResponseToJSON(message.response));
    return obj;
  },
};

function createBaseCMsgClientToGCOrderStickerbookTeamPageRequest(): CMsgClientToGCOrderStickerbookTeamPageRequest {
  return { pageOrderSequence: undefined };
}

export const CMsgClientToGCOrderStickerbookTeamPageRequest = {
  encode(message: CMsgClientToGCOrderStickerbookTeamPageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageOrderSequence !== undefined) {
      CMsgStickerbookTeamPageOrderSequence.encode(message.pageOrderSequence, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCOrderStickerbookTeamPageRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOrderStickerbookTeamPageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.pageOrderSequence = CMsgStickerbookTeamPageOrderSequence.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOrderStickerbookTeamPageRequest {
    return {
      pageOrderSequence: isSet(object.pageOrderSequence)
        ? CMsgStickerbookTeamPageOrderSequence.fromJSON(object.pageOrderSequence)
        : undefined,
    };
  },

  toJSON(message: CMsgClientToGCOrderStickerbookTeamPageRequest): unknown {
    const obj: any = {};
    message.pageOrderSequence !== undefined && (obj.pageOrderSequence = message.pageOrderSequence
      ? CMsgStickerbookTeamPageOrderSequence.toJSON(message.pageOrderSequence)
      : undefined);
    return obj;
  },
};

function createBaseCMsgClientToGCOrderStickerbookTeamPageResponse(): CMsgClientToGCOrderStickerbookTeamPageResponse {
  return { response: 0 };
}

export const CMsgClientToGCOrderStickerbookTeamPageResponse = {
  encode(
    message: CMsgClientToGCOrderStickerbookTeamPageResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCOrderStickerbookTeamPageResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOrderStickerbookTeamPageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOrderStickerbookTeamPageResponse {
    return {
      response: isSet(object.response)
        ? cMsgClientToGCOrderStickerbookTeamPageResponse_EResponseFromJSON(object.response)
        : 0,
    };
  },

  toJSON(message: CMsgClientToGCOrderStickerbookTeamPageResponse): unknown {
    const obj: any = {};
    message.response !== undefined &&
      (obj.response = cMsgClientToGCOrderStickerbookTeamPageResponse_EResponseToJSON(message.response));
    return obj;
  },
};

function createBaseCMsgClientToGCSetHeroSticker(): CMsgClientToGCSetHeroSticker {
  return { heroId: 0, newItemId: "0", oldItemId: "0" };
}

export const CMsgClientToGCSetHeroSticker = {
  encode(message: CMsgClientToGCSetHeroSticker, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroId !== 0) {
      writer.uint32(8).uint32(message.heroId);
    }
    if (message.newItemId !== "0") {
      writer.uint32(16).uint64(message.newItemId);
    }
    if (message.oldItemId !== "0") {
      writer.uint32(24).uint64(message.oldItemId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSetHeroSticker {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSetHeroSticker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.newItemId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.oldItemId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSetHeroSticker {
    return {
      heroId: isSet(object.heroId) ? Number(object.heroId) : 0,
      newItemId: isSet(object.newItemId) ? String(object.newItemId) : "0",
      oldItemId: isSet(object.oldItemId) ? String(object.oldItemId) : "0",
    };
  },

  toJSON(message: CMsgClientToGCSetHeroSticker): unknown {
    const obj: any = {};
    message.heroId !== undefined && (obj.heroId = Math.round(message.heroId));
    message.newItemId !== undefined && (obj.newItemId = message.newItemId);
    message.oldItemId !== undefined && (obj.oldItemId = message.oldItemId);
    return obj;
  },
};

function createBaseCMsgClientToGCSetHeroStickerResponse(): CMsgClientToGCSetHeroStickerResponse {
  return { response: 0 };
}

export const CMsgClientToGCSetHeroStickerResponse = {
  encode(message: CMsgClientToGCSetHeroStickerResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSetHeroStickerResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSetHeroStickerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSetHeroStickerResponse {
    return {
      response: isSet(object.response) ? cMsgClientToGCSetHeroStickerResponse_EResponseFromJSON(object.response) : 0,
    };
  },

  toJSON(message: CMsgClientToGCSetHeroStickerResponse): unknown {
    const obj: any = {};
    message.response !== undefined &&
      (obj.response = cMsgClientToGCSetHeroStickerResponse_EResponseToJSON(message.response));
    return obj;
  },
};

function createBaseCMsgClientToGCGetHeroStickers(): CMsgClientToGCGetHeroStickers {
  return {};
}

export const CMsgClientToGCGetHeroStickers = {
  encode(_: CMsgClientToGCGetHeroStickers, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetHeroStickers {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetHeroStickers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientToGCGetHeroStickers {
    return {};
  },

  toJSON(_: CMsgClientToGCGetHeroStickers): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgClientToGCGetHeroStickersResponse(): CMsgClientToGCGetHeroStickersResponse {
  return { response: 0, stickerHeroes: undefined };
}

export const CMsgClientToGCGetHeroStickersResponse = {
  encode(message: CMsgClientToGCGetHeroStickersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    if (message.stickerHeroes !== undefined) {
      CMsgStickerHeroes.encode(message.stickerHeroes, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCGetHeroStickersResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCGetHeroStickersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.stickerHeroes = CMsgStickerHeroes.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCGetHeroStickersResponse {
    return {
      response: isSet(object.response) ? cMsgClientToGCGetHeroStickersResponse_EResponseFromJSON(object.response) : 0,
      stickerHeroes: isSet(object.stickerHeroes) ? CMsgStickerHeroes.fromJSON(object.stickerHeroes) : undefined,
    };
  },

  toJSON(message: CMsgClientToGCGetHeroStickersResponse): unknown {
    const obj: any = {};
    message.response !== undefined &&
      (obj.response = cMsgClientToGCGetHeroStickersResponse_EResponseToJSON(message.response));
    message.stickerHeroes !== undefined &&
      (obj.stickerHeroes = message.stickerHeroes ? CMsgStickerHeroes.toJSON(message.stickerHeroes) : undefined);
    return obj;
  },
};

function createBaseCMsgClientToGCSetFavoritePage(): CMsgClientToGCSetFavoritePage {
  return { pageNum: 0, clear: false };
}

export const CMsgClientToGCSetFavoritePage = {
  encode(message: CMsgClientToGCSetFavoritePage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageNum !== 0) {
      writer.uint32(8).uint32(message.pageNum);
    }
    if (message.clear === true) {
      writer.uint32(16).bool(message.clear);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSetFavoritePage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSetFavoritePage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.pageNum = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.clear = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSetFavoritePage {
    return {
      pageNum: isSet(object.pageNum) ? Number(object.pageNum) : 0,
      clear: isSet(object.clear) ? Boolean(object.clear) : false,
    };
  },

  toJSON(message: CMsgClientToGCSetFavoritePage): unknown {
    const obj: any = {};
    message.pageNum !== undefined && (obj.pageNum = Math.round(message.pageNum));
    message.clear !== undefined && (obj.clear = message.clear);
    return obj;
  },
};

function createBaseCMsgClientToGCSetFavoritePageResponse(): CMsgClientToGCSetFavoritePageResponse {
  return { response: 0 };
}

export const CMsgClientToGCSetFavoritePageResponse = {
  encode(message: CMsgClientToGCSetFavoritePageResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCSetFavoritePageResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCSetFavoritePageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCSetFavoritePageResponse {
    return {
      response: isSet(object.response) ? cMsgClientToGCSetFavoritePageResponse_EResponseFromJSON(object.response) : 0,
    };
  },

  toJSON(message: CMsgClientToGCSetFavoritePageResponse): unknown {
    const obj: any = {};
    message.response !== undefined &&
      (obj.response = cMsgClientToGCSetFavoritePageResponse_EResponseToJSON(message.response));
    return obj;
  },
};

function createBaseCMsgClientToGCClaimSwag(): CMsgClientToGCClaimSwag {
  return { eventId: 0, actionId: 0, data: 0 };
}

export const CMsgClientToGCClaimSwag = {
  encode(message: CMsgClientToGCClaimSwag, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).int32(message.eventId);
    }
    if (message.actionId !== 0) {
      writer.uint32(16).uint32(message.actionId);
    }
    if (message.data !== 0) {
      writer.uint32(24).uint32(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCClaimSwag {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCClaimSwag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.actionId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }

          message.data = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCClaimSwag {
    return {
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      actionId: isSet(object.actionId) ? Number(object.actionId) : 0,
      data: isSet(object.data) ? Number(object.data) : 0,
    };
  },

  toJSON(message: CMsgClientToGCClaimSwag): unknown {
    const obj: any = {};
    message.eventId !== undefined && (obj.eventId = eEventToJSON(message.eventId));
    message.actionId !== undefined && (obj.actionId = Math.round(message.actionId));
    message.data !== undefined && (obj.data = Math.round(message.data));
    return obj;
  },
};

function createBaseCMsgClientToGCClaimSwagResponse(): CMsgClientToGCClaimSwagResponse {
  return { response: 0 };
}

export const CMsgClientToGCClaimSwagResponse = {
  encode(message: CMsgClientToGCClaimSwagResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCClaimSwagResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCClaimSwagResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCClaimSwagResponse {
    return {
      response: isSet(object.response) ? cMsgClientToGCClaimSwagResponse_EResponseFromJSON(object.response) : 0,
    };
  },

  toJSON(message: CMsgClientToGCClaimSwagResponse): unknown {
    const obj: any = {};
    message.response !== undefined &&
      (obj.response = cMsgClientToGCClaimSwagResponse_EResponseToJSON(message.response));
    return obj;
  },
};

function createBaseCMsgClientToGCCollectorsCacheAvailableDataRequest(): CMsgClientToGCCollectorsCacheAvailableDataRequest {
  return { contestId: 0 };
}

export const CMsgClientToGCCollectorsCacheAvailableDataRequest = {
  encode(
    message: CMsgClientToGCCollectorsCacheAvailableDataRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.contestId !== 0) {
      writer.uint32(8).uint32(message.contestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCCollectorsCacheAvailableDataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCCollectorsCacheAvailableDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.contestId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCCollectorsCacheAvailableDataRequest {
    return { contestId: isSet(object.contestId) ? Number(object.contestId) : 0 };
  },

  toJSON(message: CMsgClientToGCCollectorsCacheAvailableDataRequest): unknown {
    const obj: any = {};
    message.contestId !== undefined && (obj.contestId = Math.round(message.contestId));
    return obj;
  },
};

function createBaseCMsgGCToClientCollectorsCacheAvailableDataResponse(): CMsgGCToClientCollectorsCacheAvailableDataResponse {
  return { votes: [] };
}

export const CMsgGCToClientCollectorsCacheAvailableDataResponse = {
  encode(
    message: CMsgGCToClientCollectorsCacheAvailableDataResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.votes) {
      CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientCollectorsCacheAvailableDataResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientCollectorsCacheAvailableDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.votes.push(CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientCollectorsCacheAvailableDataResponse {
    return {
      votes: Array.isArray(object?.votes)
        ? object.votes.map((e: any) => CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCToClientCollectorsCacheAvailableDataResponse): unknown {
    const obj: any = {};
    if (message.votes) {
      obj.votes = message.votes.map((e) =>
        e ? CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote.toJSON(e) : undefined
      );
    } else {
      obj.votes = [];
    }
    return obj;
  },
};

function createBaseCMsgGCToClientCollectorsCacheAvailableDataResponse_Vote(): CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote {
  return { itemDef: 0, voteType: 0 };
}

export const CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote = {
  encode(
    message: CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.itemDef !== 0) {
      writer.uint32(8).uint32(message.itemDef);
    }
    if (message.voteType !== 0) {
      writer.uint32(16).int32(message.voteType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientCollectorsCacheAvailableDataResponse_Vote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.itemDef = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }

          message.voteType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote {
    return {
      itemDef: isSet(object.itemDef) ? Number(object.itemDef) : 0,
      voteType: isSet(object.voteType)
        ? cMsgGCToClientCollectorsCacheAvailableDataResponse_Vote_EVoteTypeFromJSON(object.voteType)
        : 0,
    };
  },

  toJSON(message: CMsgGCToClientCollectorsCacheAvailableDataResponse_Vote): unknown {
    const obj: any = {};
    message.itemDef !== undefined && (obj.itemDef = Math.round(message.itemDef));
    message.voteType !== undefined &&
      (obj.voteType = cMsgGCToClientCollectorsCacheAvailableDataResponse_Vote_EVoteTypeToJSON(message.voteType));
    return obj;
  },
};

function createBaseCMsgClientToGCUploadMatchClip(): CMsgClientToGCUploadMatchClip {
  return { matchClip: undefined };
}

export const CMsgClientToGCUploadMatchClip = {
  encode(message: CMsgClientToGCUploadMatchClip, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchClip !== undefined) {
      CMatchClip.encode(message.matchClip, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCUploadMatchClip {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCUploadMatchClip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }

          message.matchClip = CMatchClip.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCUploadMatchClip {
    return { matchClip: isSet(object.matchClip) ? CMatchClip.fromJSON(object.matchClip) : undefined };
  },

  toJSON(message: CMsgClientToGCUploadMatchClip): unknown {
    const obj: any = {};
    message.matchClip !== undefined &&
      (obj.matchClip = message.matchClip ? CMatchClip.toJSON(message.matchClip) : undefined);
    return obj;
  },
};

function createBaseCMsgGCToClientUploadMatchClipResponse(): CMsgGCToClientUploadMatchClipResponse {
  return { response: 0 };
}

export const CMsgGCToClientUploadMatchClipResponse = {
  encode(message: CMsgGCToClientUploadMatchClipResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientUploadMatchClipResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientUploadMatchClipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientUploadMatchClipResponse {
    return {
      response: isSet(object.response) ? cMsgGCToClientUploadMatchClipResponse_EResponseFromJSON(object.response) : 0,
    };
  },

  toJSON(message: CMsgGCToClientUploadMatchClipResponse): unknown {
    const obj: any = {};
    message.response !== undefined &&
      (obj.response = cMsgGCToClientUploadMatchClipResponse_EResponseToJSON(message.response));
    return obj;
  },
};

function createBaseCMsgClientToGCMapStatsRequest(): CMsgClientToGCMapStatsRequest {
  return {};
}

export const CMsgClientToGCMapStatsRequest = {
  encode(_: CMsgClientToGCMapStatsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCMapStatsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCMapStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientToGCMapStatsRequest {
    return {};
  },

  toJSON(_: CMsgClientToGCMapStatsRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCMsgGCToClientMapStatsResponse(): CMsgGCToClientMapStatsResponse {
  return { response: 0, personalStats: undefined, globalStats: undefined };
}

export const CMsgGCToClientMapStatsResponse = {
  encode(message: CMsgGCToClientMapStatsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    if (message.personalStats !== undefined) {
      CMsgMapStatsSnapshot.encode(message.personalStats, writer.uint32(18).fork()).ldelim();
    }
    if (message.globalStats !== undefined) {
      CMsgGlobalMapStats.encode(message.globalStats, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientMapStatsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientMapStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        case 2:
          if (tag != 18) {
            break;
          }

          message.personalStats = CMsgMapStatsSnapshot.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }

          message.globalStats = CMsgGlobalMapStats.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientMapStatsResponse {
    return {
      response: isSet(object.response) ? cMsgGCToClientMapStatsResponse_EResponseFromJSON(object.response) : 0,
      personalStats: isSet(object.personalStats) ? CMsgMapStatsSnapshot.fromJSON(object.personalStats) : undefined,
      globalStats: isSet(object.globalStats) ? CMsgGlobalMapStats.fromJSON(object.globalStats) : undefined,
    };
  },

  toJSON(message: CMsgGCToClientMapStatsResponse): unknown {
    const obj: any = {};
    message.response !== undefined && (obj.response = cMsgGCToClientMapStatsResponse_EResponseToJSON(message.response));
    message.personalStats !== undefined &&
      (obj.personalStats = message.personalStats ? CMsgMapStatsSnapshot.toJSON(message.personalStats) : undefined);
    message.globalStats !== undefined &&
      (obj.globalStats = message.globalStats ? CMsgGlobalMapStats.toJSON(message.globalStats) : undefined);
    return obj;
  },
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

function bytesFromBase64(b64: string): Uint8Array {
  if (tsProtoGlobalThis.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if (tsProtoGlobalThis.Buffer) {
    return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis.btoa(bin.join(""));
  }
}

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
