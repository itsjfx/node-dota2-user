// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.4.1
//   protoc               v5.28.3
// source: dota_gcmessages_common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  CMsgPendingEventAward,
  DOTAGameMode,
  dOTAGameModeFromJSON,
  dOTAGameModeToJSON,
  dotaGcTeam,
  dotaGcTeamFromJSON,
  dotaGcTeamToJSON,
  EEvent,
  eEventFromJSON,
  eEventToJSON,
  ELeaguePhase,
  eLeaguePhaseFromJSON,
  eLeaguePhaseToJSON,
  ELeagueRegion,
  eLeagueRegionFromJSON,
  eLeagueRegionToJSON,
  EMatchOutcome,
  eMatchOutcomeFromJSON,
  eMatchOutcomeToJSON,
} from "./dota_shared_enums";

export enum ESpecialPingValue {
  k_ESpecialPingValue_NoData = 16382,
  k_ESpecialPingValue_Failed = 16383,
}

export function eSpecialPingValueFromJSON(object: any): ESpecialPingValue {
  switch (object) {
    case 16382:
    case "k_ESpecialPingValue_NoData":
      return ESpecialPingValue.k_ESpecialPingValue_NoData;
    case 16383:
    case "k_ESpecialPingValue_Failed":
      return ESpecialPingValue.k_ESpecialPingValue_Failed;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESpecialPingValue");
  }
}

export function eSpecialPingValueToJSON(object: ESpecialPingValue): string {
  switch (object) {
    case ESpecialPingValue.k_ESpecialPingValue_NoData:
      return "k_ESpecialPingValue_NoData";
    case ESpecialPingValue.k_ESpecialPingValue_Failed:
      return "k_ESpecialPingValue_Failed";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESpecialPingValue");
  }
}

export enum EDOTAGCSessionNeed {
  k_EDOTAGCSessionNeed_Unknown = 0,
  k_EDOTAGCSessionNeed_UserNoSessionNeeded = 100,
  k_EDOTAGCSessionNeed_UserInOnlineGame = 101,
  k_EDOTAGCSessionNeed_UserInLocalGame = 102,
  k_EDOTAGCSessionNeed_UserInUIWasConnected = 103,
  k_EDOTAGCSessionNeed_UserInUINeverConnected = 104,
  k_EDOTAGCSessionNeed_UserTutorials = 105,
  k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle = 106,
  k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle = 107,
  k_EDOTAGCSessionNeed_GameServerOnline = 200,
  k_EDOTAGCSessionNeed_GameServerLocal = 201,
  k_EDOTAGCSessionNeed_GameServerIdle = 202,
  k_EDOTAGCSessionNeed_GameServerRelay = 203,
  k_EDOTAGCSessionNeed_GameServerLocalUpload = 204,
}

export function eDOTAGCSessionNeedFromJSON(object: any): EDOTAGCSessionNeed {
  switch (object) {
    case 0:
    case "k_EDOTAGCSessionNeed_Unknown":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_Unknown;
    case 100:
    case "k_EDOTAGCSessionNeed_UserNoSessionNeeded":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserNoSessionNeeded;
    case 101:
    case "k_EDOTAGCSessionNeed_UserInOnlineGame":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInOnlineGame;
    case 102:
    case "k_EDOTAGCSessionNeed_UserInLocalGame":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInLocalGame;
    case 103:
    case "k_EDOTAGCSessionNeed_UserInUIWasConnected":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUIWasConnected;
    case 104:
    case "k_EDOTAGCSessionNeed_UserInUINeverConnected":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUINeverConnected;
    case 105:
    case "k_EDOTAGCSessionNeed_UserTutorials":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserTutorials;
    case 106:
    case "k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle;
    case 107:
    case "k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle;
    case 200:
    case "k_EDOTAGCSessionNeed_GameServerOnline":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerOnline;
    case 201:
    case "k_EDOTAGCSessionNeed_GameServerLocal":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerLocal;
    case 202:
    case "k_EDOTAGCSessionNeed_GameServerIdle":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerIdle;
    case 203:
    case "k_EDOTAGCSessionNeed_GameServerRelay":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerRelay;
    case 204:
    case "k_EDOTAGCSessionNeed_GameServerLocalUpload":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerLocalUpload;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EDOTAGCSessionNeed");
  }
}

export function eDOTAGCSessionNeedToJSON(object: EDOTAGCSessionNeed): string {
  switch (object) {
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_Unknown:
      return "k_EDOTAGCSessionNeed_Unknown";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserNoSessionNeeded:
      return "k_EDOTAGCSessionNeed_UserNoSessionNeeded";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInOnlineGame:
      return "k_EDOTAGCSessionNeed_UserInOnlineGame";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInLocalGame:
      return "k_EDOTAGCSessionNeed_UserInLocalGame";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUIWasConnected:
      return "k_EDOTAGCSessionNeed_UserInUIWasConnected";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUINeverConnected:
      return "k_EDOTAGCSessionNeed_UserInUINeverConnected";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserTutorials:
      return "k_EDOTAGCSessionNeed_UserTutorials";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle:
      return "k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle:
      return "k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerOnline:
      return "k_EDOTAGCSessionNeed_GameServerOnline";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerLocal:
      return "k_EDOTAGCSessionNeed_GameServerLocal";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerIdle:
      return "k_EDOTAGCSessionNeed_GameServerIdle";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerRelay:
      return "k_EDOTAGCSessionNeed_GameServerRelay";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerLocalUpload:
      return "k_EDOTAGCSessionNeed_GameServerLocalUpload";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EDOTAGCSessionNeed");
  }
}

export enum EDOTAMatchPlayerTimeCustomStat {
  k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers = 1,
  k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute = 2,
  k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP = 3,
}

export function eDOTAMatchPlayerTimeCustomStatFromJSON(object: any): EDOTAMatchPlayerTimeCustomStat {
  switch (object) {
    case 1:
    case "k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers":
      return EDOTAMatchPlayerTimeCustomStat.k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers;
    case 2:
    case "k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute":
      return EDOTAMatchPlayerTimeCustomStat.k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute;
    case 3:
    case "k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP":
      return EDOTAMatchPlayerTimeCustomStat
        .k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EDOTAMatchPlayerTimeCustomStat");
  }
}

export function eDOTAMatchPlayerTimeCustomStatToJSON(object: EDOTAMatchPlayerTimeCustomStat): string {
  switch (object) {
    case EDOTAMatchPlayerTimeCustomStat.k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers:
      return "k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers";
    case EDOTAMatchPlayerTimeCustomStat.k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute:
      return "k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute";
    case EDOTAMatchPlayerTimeCustomStat
      .k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP:
      return "k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EDOTAMatchPlayerTimeCustomStat");
  }
}

export enum DOTATournamentEvents {
  TE_FIRST_BLOOD = 0,
  TE_GAME_END = 1,
  TE_MULTI_KILL = 2,
  TE_HERO_DENY = 3,
  TE_AEGIS_DENY = 4,
  TE_AEGIS_STOLEN = 5,
  TE_GODLIKE = 6,
  TE_COURIER_KILL = 7,
  TE_ECHOSLAM = 8,
  TE_RAPIER = 9,
  TE_EARLY_ROSHAN = 10,
  TE_BLACK_HOLE = 11,
}

export function dOTATournamentEventsFromJSON(object: any): DOTATournamentEvents {
  switch (object) {
    case 0:
    case "TE_FIRST_BLOOD":
      return DOTATournamentEvents.TE_FIRST_BLOOD;
    case 1:
    case "TE_GAME_END":
      return DOTATournamentEvents.TE_GAME_END;
    case 2:
    case "TE_MULTI_KILL":
      return DOTATournamentEvents.TE_MULTI_KILL;
    case 3:
    case "TE_HERO_DENY":
      return DOTATournamentEvents.TE_HERO_DENY;
    case 4:
    case "TE_AEGIS_DENY":
      return DOTATournamentEvents.TE_AEGIS_DENY;
    case 5:
    case "TE_AEGIS_STOLEN":
      return DOTATournamentEvents.TE_AEGIS_STOLEN;
    case 6:
    case "TE_GODLIKE":
      return DOTATournamentEvents.TE_GODLIKE;
    case 7:
    case "TE_COURIER_KILL":
      return DOTATournamentEvents.TE_COURIER_KILL;
    case 8:
    case "TE_ECHOSLAM":
      return DOTATournamentEvents.TE_ECHOSLAM;
    case 9:
    case "TE_RAPIER":
      return DOTATournamentEvents.TE_RAPIER;
    case 10:
    case "TE_EARLY_ROSHAN":
      return DOTATournamentEvents.TE_EARLY_ROSHAN;
    case 11:
    case "TE_BLACK_HOLE":
      return DOTATournamentEvents.TE_BLACK_HOLE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum DOTATournamentEvents");
  }
}

export function dOTATournamentEventsToJSON(object: DOTATournamentEvents): string {
  switch (object) {
    case DOTATournamentEvents.TE_FIRST_BLOOD:
      return "TE_FIRST_BLOOD";
    case DOTATournamentEvents.TE_GAME_END:
      return "TE_GAME_END";
    case DOTATournamentEvents.TE_MULTI_KILL:
      return "TE_MULTI_KILL";
    case DOTATournamentEvents.TE_HERO_DENY:
      return "TE_HERO_DENY";
    case DOTATournamentEvents.TE_AEGIS_DENY:
      return "TE_AEGIS_DENY";
    case DOTATournamentEvents.TE_AEGIS_STOLEN:
      return "TE_AEGIS_STOLEN";
    case DOTATournamentEvents.TE_GODLIKE:
      return "TE_GODLIKE";
    case DOTATournamentEvents.TE_COURIER_KILL:
      return "TE_COURIER_KILL";
    case DOTATournamentEvents.TE_ECHOSLAM:
      return "TE_ECHOSLAM";
    case DOTATournamentEvents.TE_RAPIER:
      return "TE_RAPIER";
    case DOTATournamentEvents.TE_EARLY_ROSHAN:
      return "TE_EARLY_ROSHAN";
    case DOTATournamentEvents.TE_BLACK_HOLE:
      return "TE_BLACK_HOLE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum DOTATournamentEvents");
  }
}

export enum EBroadcastTimelineEvent {
  EBroadcastTimelineEvent_MatchStarted = 1,
  EBroadcastTimelineEvent_GameStateChanged = 2,
  EBroadcastTimelineEvent_TowerDeath = 3,
  EBroadcastTimelineEvent_BarracksDeath = 4,
  EBroadcastTimelineEvent_AncientDeath = 5,
  EBroadcastTimelineEvent_RoshanDeath = 6,
  EBroadcastTimelineEvent_HeroDeath = 7,
  EBroadcastTimelineEvent_TeamFight = 8,
  EBroadcastTimelineEvent_FirstBlood = 9,
}

export function eBroadcastTimelineEventFromJSON(object: any): EBroadcastTimelineEvent {
  switch (object) {
    case 1:
    case "EBroadcastTimelineEvent_MatchStarted":
      return EBroadcastTimelineEvent.EBroadcastTimelineEvent_MatchStarted;
    case 2:
    case "EBroadcastTimelineEvent_GameStateChanged":
      return EBroadcastTimelineEvent.EBroadcastTimelineEvent_GameStateChanged;
    case 3:
    case "EBroadcastTimelineEvent_TowerDeath":
      return EBroadcastTimelineEvent.EBroadcastTimelineEvent_TowerDeath;
    case 4:
    case "EBroadcastTimelineEvent_BarracksDeath":
      return EBroadcastTimelineEvent.EBroadcastTimelineEvent_BarracksDeath;
    case 5:
    case "EBroadcastTimelineEvent_AncientDeath":
      return EBroadcastTimelineEvent.EBroadcastTimelineEvent_AncientDeath;
    case 6:
    case "EBroadcastTimelineEvent_RoshanDeath":
      return EBroadcastTimelineEvent.EBroadcastTimelineEvent_RoshanDeath;
    case 7:
    case "EBroadcastTimelineEvent_HeroDeath":
      return EBroadcastTimelineEvent.EBroadcastTimelineEvent_HeroDeath;
    case 8:
    case "EBroadcastTimelineEvent_TeamFight":
      return EBroadcastTimelineEvent.EBroadcastTimelineEvent_TeamFight;
    case 9:
    case "EBroadcastTimelineEvent_FirstBlood":
      return EBroadcastTimelineEvent.EBroadcastTimelineEvent_FirstBlood;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EBroadcastTimelineEvent");
  }
}

export function eBroadcastTimelineEventToJSON(object: EBroadcastTimelineEvent): string {
  switch (object) {
    case EBroadcastTimelineEvent.EBroadcastTimelineEvent_MatchStarted:
      return "EBroadcastTimelineEvent_MatchStarted";
    case EBroadcastTimelineEvent.EBroadcastTimelineEvent_GameStateChanged:
      return "EBroadcastTimelineEvent_GameStateChanged";
    case EBroadcastTimelineEvent.EBroadcastTimelineEvent_TowerDeath:
      return "EBroadcastTimelineEvent_TowerDeath";
    case EBroadcastTimelineEvent.EBroadcastTimelineEvent_BarracksDeath:
      return "EBroadcastTimelineEvent_BarracksDeath";
    case EBroadcastTimelineEvent.EBroadcastTimelineEvent_AncientDeath:
      return "EBroadcastTimelineEvent_AncientDeath";
    case EBroadcastTimelineEvent.EBroadcastTimelineEvent_RoshanDeath:
      return "EBroadcastTimelineEvent_RoshanDeath";
    case EBroadcastTimelineEvent.EBroadcastTimelineEvent_HeroDeath:
      return "EBroadcastTimelineEvent_HeroDeath";
    case EBroadcastTimelineEvent.EBroadcastTimelineEvent_TeamFight:
      return "EBroadcastTimelineEvent_TeamFight";
    case EBroadcastTimelineEvent.EBroadcastTimelineEvent_FirstBlood:
      return "EBroadcastTimelineEvent_FirstBlood";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EBroadcastTimelineEvent");
  }
}

export enum ECustomGameWhitelistState {
  CUSTOM_GAME_WHITELIST_STATE_UNKNOWN = 0,
  CUSTOM_GAME_WHITELIST_STATE_APPROVED = 1,
  CUSTOM_GAME_WHITELIST_STATE_REJECTED = 2,
}

export function eCustomGameWhitelistStateFromJSON(object: any): ECustomGameWhitelistState {
  switch (object) {
    case 0:
    case "CUSTOM_GAME_WHITELIST_STATE_UNKNOWN":
      return ECustomGameWhitelistState.CUSTOM_GAME_WHITELIST_STATE_UNKNOWN;
    case 1:
    case "CUSTOM_GAME_WHITELIST_STATE_APPROVED":
      return ECustomGameWhitelistState.CUSTOM_GAME_WHITELIST_STATE_APPROVED;
    case 2:
    case "CUSTOM_GAME_WHITELIST_STATE_REJECTED":
      return ECustomGameWhitelistState.CUSTOM_GAME_WHITELIST_STATE_REJECTED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ECustomGameWhitelistState");
  }
}

export function eCustomGameWhitelistStateToJSON(object: ECustomGameWhitelistState): string {
  switch (object) {
    case ECustomGameWhitelistState.CUSTOM_GAME_WHITELIST_STATE_UNKNOWN:
      return "CUSTOM_GAME_WHITELIST_STATE_UNKNOWN";
    case ECustomGameWhitelistState.CUSTOM_GAME_WHITELIST_STATE_APPROVED:
      return "CUSTOM_GAME_WHITELIST_STATE_APPROVED";
    case ECustomGameWhitelistState.CUSTOM_GAME_WHITELIST_STATE_REJECTED:
      return "CUSTOM_GAME_WHITELIST_STATE_REJECTED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ECustomGameWhitelistState");
  }
}

export enum EDOTATriviaQuestionCategory {
  k_EDOTATriviaQuestionCategory_AbilityIcon = 0,
  k_EDOTATriviaQuestionCategory_AbilityCooldown = 1,
  k_EDOTATriviaQuestionCategory_HeroAttributes = 2,
  k_EDOTATriviaQuestionCategory_HeroMovementSpeed = 3,
  k_EDOTATriviaQuestionCategory_TalentTree = 4,
  k_EDOTATriviaQuestionCategory_HeroStats = 5,
  k_EDOTATriviaQuestionCategory_ItemPrice = 6,
  k_EDOTATriviaQuestionCategory_AbilitySound = 7,
  k_EDOTATriviaQuestionCategory_InvokerSpells = 8,
  k_EDOTATriviaQuestionCategory_AbilityManaCost = 9,
  k_EDOTATriviaQuestionCategory_HeroAttackSound = 10,
  k_EDOTATriviaQuestionCategory_AbilityName = 11,
  k_EDOTATriviaQuestionCategory_ItemComponents = 12,
  k_EDOTATriviaQuestionCategory_ItemLore = 13,
  k_EDOTATriviaQuestionCategory_ItemPassives = 14,
  k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END = 15,
  k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START = 99,
  k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild = 100,
}

export function eDOTATriviaQuestionCategoryFromJSON(object: any): EDOTATriviaQuestionCategory {
  switch (object) {
    case 0:
    case "k_EDOTATriviaQuestionCategory_AbilityIcon":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityIcon;
    case 1:
    case "k_EDOTATriviaQuestionCategory_AbilityCooldown":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityCooldown;
    case 2:
    case "k_EDOTATriviaQuestionCategory_HeroAttributes":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroAttributes;
    case 3:
    case "k_EDOTATriviaQuestionCategory_HeroMovementSpeed":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroMovementSpeed;
    case 4:
    case "k_EDOTATriviaQuestionCategory_TalentTree":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_TalentTree;
    case 5:
    case "k_EDOTATriviaQuestionCategory_HeroStats":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroStats;
    case 6:
    case "k_EDOTATriviaQuestionCategory_ItemPrice":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemPrice;
    case 7:
    case "k_EDOTATriviaQuestionCategory_AbilitySound":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilitySound;
    case 8:
    case "k_EDOTATriviaQuestionCategory_InvokerSpells":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_InvokerSpells;
    case 9:
    case "k_EDOTATriviaQuestionCategory_AbilityManaCost":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityManaCost;
    case 10:
    case "k_EDOTATriviaQuestionCategory_HeroAttackSound":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroAttackSound;
    case 11:
    case "k_EDOTATriviaQuestionCategory_AbilityName":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityName;
    case 12:
    case "k_EDOTATriviaQuestionCategory_ItemComponents":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemComponents;
    case 13:
    case "k_EDOTATriviaQuestionCategory_ItemLore":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemLore;
    case 14:
    case "k_EDOTATriviaQuestionCategory_ItemPassives":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemPassives;
    case 15:
    case "k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END;
    case 99:
    case "k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START;
    case 100:
    case "k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EDOTATriviaQuestionCategory");
  }
}

export function eDOTATriviaQuestionCategoryToJSON(object: EDOTATriviaQuestionCategory): string {
  switch (object) {
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityIcon:
      return "k_EDOTATriviaQuestionCategory_AbilityIcon";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityCooldown:
      return "k_EDOTATriviaQuestionCategory_AbilityCooldown";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroAttributes:
      return "k_EDOTATriviaQuestionCategory_HeroAttributes";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroMovementSpeed:
      return "k_EDOTATriviaQuestionCategory_HeroMovementSpeed";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_TalentTree:
      return "k_EDOTATriviaQuestionCategory_TalentTree";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroStats:
      return "k_EDOTATriviaQuestionCategory_HeroStats";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemPrice:
      return "k_EDOTATriviaQuestionCategory_ItemPrice";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilitySound:
      return "k_EDOTATriviaQuestionCategory_AbilitySound";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_InvokerSpells:
      return "k_EDOTATriviaQuestionCategory_InvokerSpells";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityManaCost:
      return "k_EDOTATriviaQuestionCategory_AbilityManaCost";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroAttackSound:
      return "k_EDOTATriviaQuestionCategory_HeroAttackSound";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityName:
      return "k_EDOTATriviaQuestionCategory_AbilityName";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemComponents:
      return "k_EDOTATriviaQuestionCategory_ItemComponents";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemLore:
      return "k_EDOTATriviaQuestionCategory_ItemLore";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemPassives:
      return "k_EDOTATriviaQuestionCategory_ItemPassives";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END:
      return "k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START:
      return "k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild:
      return "k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EDOTATriviaQuestionCategory");
  }
}

export enum EOverwatchConviction {
  k_EOverwatchConviction_None = 0,
  k_EOverwatchConviction_NotGuilty = 1,
  k_EOverwatchConviction_GuiltUnclear = 2,
  k_EOverwatchConviction_Guilty = 3,
}

export function eOverwatchConvictionFromJSON(object: any): EOverwatchConviction {
  switch (object) {
    case 0:
    case "k_EOverwatchConviction_None":
      return EOverwatchConviction.k_EOverwatchConviction_None;
    case 1:
    case "k_EOverwatchConviction_NotGuilty":
      return EOverwatchConviction.k_EOverwatchConviction_NotGuilty;
    case 2:
    case "k_EOverwatchConviction_GuiltUnclear":
      return EOverwatchConviction.k_EOverwatchConviction_GuiltUnclear;
    case 3:
    case "k_EOverwatchConviction_Guilty":
      return EOverwatchConviction.k_EOverwatchConviction_Guilty;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EOverwatchConviction");
  }
}

export function eOverwatchConvictionToJSON(object: EOverwatchConviction): string {
  switch (object) {
    case EOverwatchConviction.k_EOverwatchConviction_None:
      return "k_EOverwatchConviction_None";
    case EOverwatchConviction.k_EOverwatchConviction_NotGuilty:
      return "k_EOverwatchConviction_NotGuilty";
    case EOverwatchConviction.k_EOverwatchConviction_GuiltUnclear:
      return "k_EOverwatchConviction_GuiltUnclear";
    case EOverwatchConviction.k_EOverwatchConviction_Guilty:
      return "k_EOverwatchConviction_Guilty";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EOverwatchConviction");
  }
}

export enum EHeroRelicRarity {
  HERO_RELIC_RARITY_INVALID = -1,
  HERO_RELIC_RARITY_COMMON = 0,
  HERO_RELIC_RARITY_RARE = 1,
}

export function eHeroRelicRarityFromJSON(object: any): EHeroRelicRarity {
  switch (object) {
    case -1:
    case "HERO_RELIC_RARITY_INVALID":
      return EHeroRelicRarity.HERO_RELIC_RARITY_INVALID;
    case 0:
    case "HERO_RELIC_RARITY_COMMON":
      return EHeroRelicRarity.HERO_RELIC_RARITY_COMMON;
    case 1:
    case "HERO_RELIC_RARITY_RARE":
      return EHeroRelicRarity.HERO_RELIC_RARITY_RARE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EHeroRelicRarity");
  }
}

export function eHeroRelicRarityToJSON(object: EHeroRelicRarity): string {
  switch (object) {
    case EHeroRelicRarity.HERO_RELIC_RARITY_INVALID:
      return "HERO_RELIC_RARITY_INVALID";
    case EHeroRelicRarity.HERO_RELIC_RARITY_COMMON:
      return "HERO_RELIC_RARITY_COMMON";
    case EHeroRelicRarity.HERO_RELIC_RARITY_RARE:
      return "HERO_RELIC_RARITY_RARE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EHeroRelicRarity");
  }
}

export enum EStickerbookAuditAction {
  STICKERBOOK_AUDIT_CREATE_PAGE = 0,
  STICKERBOOK_AUDIT_DELETE_PAGE = 1,
  STICKERBOOK_AUDIT_STICK_STICKERS = 2,
  STICKERBOOK_AUDIT_REPLACE_STICKERS = 3,
  STICKERBOOK_AUDIT_HERO_STICKER = 4,
}

export function eStickerbookAuditActionFromJSON(object: any): EStickerbookAuditAction {
  switch (object) {
    case 0:
    case "STICKERBOOK_AUDIT_CREATE_PAGE":
      return EStickerbookAuditAction.STICKERBOOK_AUDIT_CREATE_PAGE;
    case 1:
    case "STICKERBOOK_AUDIT_DELETE_PAGE":
      return EStickerbookAuditAction.STICKERBOOK_AUDIT_DELETE_PAGE;
    case 2:
    case "STICKERBOOK_AUDIT_STICK_STICKERS":
      return EStickerbookAuditAction.STICKERBOOK_AUDIT_STICK_STICKERS;
    case 3:
    case "STICKERBOOK_AUDIT_REPLACE_STICKERS":
      return EStickerbookAuditAction.STICKERBOOK_AUDIT_REPLACE_STICKERS;
    case 4:
    case "STICKERBOOK_AUDIT_HERO_STICKER":
      return EStickerbookAuditAction.STICKERBOOK_AUDIT_HERO_STICKER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EStickerbookAuditAction");
  }
}

export function eStickerbookAuditActionToJSON(object: EStickerbookAuditAction): string {
  switch (object) {
    case EStickerbookAuditAction.STICKERBOOK_AUDIT_CREATE_PAGE:
      return "STICKERBOOK_AUDIT_CREATE_PAGE";
    case EStickerbookAuditAction.STICKERBOOK_AUDIT_DELETE_PAGE:
      return "STICKERBOOK_AUDIT_DELETE_PAGE";
    case EStickerbookAuditAction.STICKERBOOK_AUDIT_STICK_STICKERS:
      return "STICKERBOOK_AUDIT_STICK_STICKERS";
    case EStickerbookAuditAction.STICKERBOOK_AUDIT_REPLACE_STICKERS:
      return "STICKERBOOK_AUDIT_REPLACE_STICKERS";
    case EStickerbookAuditAction.STICKERBOOK_AUDIT_HERO_STICKER:
      return "STICKERBOOK_AUDIT_HERO_STICKER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EStickerbookAuditAction");
  }
}

export enum EStickerbookPageType {
  STICKER_PAGE_GENERIC = 0,
  STICKER_PAGE_TEAM = 1,
  STICKER_PAGE_TALENT = 2,
}

export function eStickerbookPageTypeFromJSON(object: any): EStickerbookPageType {
  switch (object) {
    case 0:
    case "STICKER_PAGE_GENERIC":
      return EStickerbookPageType.STICKER_PAGE_GENERIC;
    case 1:
    case "STICKER_PAGE_TEAM":
      return EStickerbookPageType.STICKER_PAGE_TEAM;
    case 2:
    case "STICKER_PAGE_TALENT":
      return EStickerbookPageType.STICKER_PAGE_TALENT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EStickerbookPageType");
  }
}

export function eStickerbookPageTypeToJSON(object: EStickerbookPageType): string {
  switch (object) {
    case EStickerbookPageType.STICKER_PAGE_GENERIC:
      return "STICKER_PAGE_GENERIC";
    case EStickerbookPageType.STICKER_PAGE_TEAM:
      return "STICKER_PAGE_TEAM";
    case EStickerbookPageType.STICKER_PAGE_TALENT:
      return "STICKER_PAGE_TALENT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EStickerbookPageType");
  }
}

export interface CSODOTAGameAccountClient {
  accountId: number;
  wins: number;
  losses: number;
  xp: number;
  level: number;
  initialSkill: number;
  leaverCount: number;
  secondaryLeaverCount: number;
  lowPriorityUntilDate: number;
  preventTextChatUntilDate: number;
  preventVoiceUntilDate: number;
  preventPublicTextChatUntilDate: number;
  preventNewPlayerChatUntilDate: number;
  lastAbandonedGameDate: number;
  lastSecondaryAbandonedGameDate: number;
  leaverPenaltyCount: number;
  completedGameStreak: number;
  accountDisabledUntilDate: number;
  accountDisabledCount: number;
  matchDisabledUntilDate: number;
  matchDisabledCount: number;
  shutdownlawterminatetimestamp: number;
  lowPriorityGamesRemaining: number;
  recruitmentLevel: number;
  hasNewNotifications: boolean;
  isLeagueAdmin: boolean;
  casualGamesPlayed: number;
  soloCompetitiveGamesPlayed: number;
  partyCompetitiveGamesPlayed: number;
  casual1v1GamesPlayed: number;
  currAllHeroChallengeId: number;
  playTimePoints: number;
  accountFlags: number;
  playTimeLevel: number;
  playerBehaviorSeqNumLastReport: number;
  playerBehaviorScoreLastReport: number;
  playerBehaviorReportOldData: boolean;
  tourneySkillLevel: number;
  tourneyRecentParticipationDate: number;
  anchoredPhoneNumberId: string;
  rankedMatchmakingBanUntilDate: number;
  recentGameTime1: number;
  recentGameTime2: number;
  recentGameTime3: number;
  favoriteTeamPacked: string;
  recentReportTime: number;
  customGameDisabledUntilDate: number;
  recentWinTime1: number;
  recentWinTime2: number;
  recentWinTime3: number;
  coachRating: number;
  queuePoints: number;
  roleHandicaps: CSODOTAGameAccountClient_RoleHandicap[];
  eventModeRecentTime: number;
  mmrRecalibrationTime: number;
}

export interface CSODOTAGameAccountClient_RoleHandicap {
  role: number;
  handicap: number;
}

export interface CSODOTAGameAccountPlus {
  accountId: number;
  originalStartDate: number;
  plusFlags: number;
  plusStatus: number;
  prepaidTimeStart: number;
  prepaidTimeBalance: number;
  nextPaymentDate: number;
  steamAgreementId: string;
}

export interface CMsgLobbyFeaturedGamemodeProgress {
  accounts: CMsgLobbyFeaturedGamemodeProgress_AccountProgress[];
}

export interface CMsgLobbyFeaturedGamemodeProgress_AccountProgress {
  accountId: number;
  currentValue: number;
  maxValue: number;
}

export interface CMsgBattleCupVictory {
  accountId: number;
  winDate: number;
  validUntil: number;
  skillLevel: number;
  tournamentId: number;
  divisionId: number;
  teamId: number;
  streak: number;
  trophyId: number;
}

export interface CMsgLobbyBattleCupVictoryList {
  winners: CMsgBattleCupVictory[];
}

export interface CMsgDOTABroadcastNotification {
  message: string;
}

export interface CProtoItemHeroStatue {
  heroId: number;
  statusEffectIndex: number;
  sequenceName: string;
  cycle: number;
  wearable: number[];
  inscription: string;
  style: number[];
  tournamentDrop: boolean;
}

export interface CMatchPlayerAbilityUpgrade {
  ability: number;
  time: number;
}

export interface CMatchPlayerTimedCustomStat {
  stat: EDOTAMatchPlayerTimeCustomStat;
  value: number;
}

export interface CMatchPlayerTimedStats {
  time: number;
  kills: number;
  deaths: number;
  assists: number;
  netWorth: number;
  xp: number;
  lastHits: number;
  denies: number;
  bountyRuneGold: number;
  rangeCreepUpgradeGold: number;
  observerWardsDewarded: number;
  reliableGoldEarned: number;
  goldLossPrevented: number;
  heroKillGold: number;
  creepKillGold: number;
  buildingGold: number;
  otherGold: number;
  comebackGold: number;
  experimentalGold: number;
  experimental2Gold: number;
  creepDenyGold: number;
  tpScrollsPurchased1: number;
  tpScrollsPurchased2: number;
  tpScrollsPurchased3: number;
  tpScrollsPurchased4: number;
  tpScrollsPurchased5: number;
  neutralGold: number;
  courierGold: number;
  roshanGold: number;
  incomeGold: number;
  itemValue: number;
  supportGoldSpent: number;
  campsStacked: number;
  wardsPlaced: number;
  tripleKills: number;
  rampages: number;
  customStats: CMatchPlayerTimedCustomStat[];
}

export interface CMatchTeamTimedStats {
  time: number;
  enemyTowersKilled: number;
  enemyBarracksKilled: number;
  enemyTowersStatus: number;
  enemyBarracksStatus: number;
}

export interface CMatchAdditionalUnitInventory {
  unitName: string;
  items: number[];
}

export interface CMatchPlayerPermanentBuff {
  permanentBuff: number;
  stackCount: number;
  grantTime: number;
}

export interface CMatchHeroSelectEvent {
  isPick: boolean;
  team: number;
  heroId: number;
}

export interface CMatchClip {
  matchId: string;
  playerAccountId: number;
  gameTimeSeconds: number;
  durationSeconds: number;
  playerId: number;
  heroId: number;
  abilityId: number;
  cameraMode: number;
  comment: string;
}

export interface CPartySearchClientParty {
  partyId: string;
  beaconType: number;
  partyMembers: number[];
}

export interface CMsgDOTAHasItemQuery {
  accountId: number;
  itemId: string;
}

export interface CMsgDOTAHasItemResponse {
  hasItem: boolean;
}

export interface CMsgGCGetPlayerCardItemInfo {
  accountId: number;
  playerCardItemIds: string[];
  allForEvent: number;
}

export interface CMsgGCGetPlayerCardItemInfoResponse {
  playerCardInfos: CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo[];
}

export interface CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
  playerCardItemId: string;
  accountId: number;
  packedBonuses: string;
}

export interface CSODOTAMapLocationState {
  accountId: number;
  locationId: number;
  completed: boolean;
}

export interface CMsgLeagueAdminList {
  accountIds: number[];
}

export interface CMsgDOTAProfileCard {
  accountId: number;
  slots: CMsgDOTAProfileCard_Slot[];
  badgePoints: number;
  eventPoints: number;
  eventId: number;
  recentBattleCupVictory: CMsgBattleCupVictory | undefined;
  rankTier: number;
  leaderboardRank: number;
  isPlusSubscriber: boolean;
  plusOriginalStartDate: number;
  rankTierScore: number;
  leaderboardRankCore: number;
  title: number;
  favoriteTeamPacked: string;
  lifetimeGames: number;
}

export enum CMsgDOTAProfileCard_EStatID {
  k_eStat_Wins = 3,
  k_eStat_Commends = 4,
  k_eStat_GamesPlayed = 5,
  k_eStat_FirstMatchDate = 6,
  k_eStat_PreviousSeasonRank = 7,
  k_eStat_GamesMVP = 8,
}

export function cMsgDOTAProfileCard_EStatIDFromJSON(object: any): CMsgDOTAProfileCard_EStatID {
  switch (object) {
    case 3:
    case "k_eStat_Wins":
      return CMsgDOTAProfileCard_EStatID.k_eStat_Wins;
    case 4:
    case "k_eStat_Commends":
      return CMsgDOTAProfileCard_EStatID.k_eStat_Commends;
    case 5:
    case "k_eStat_GamesPlayed":
      return CMsgDOTAProfileCard_EStatID.k_eStat_GamesPlayed;
    case 6:
    case "k_eStat_FirstMatchDate":
      return CMsgDOTAProfileCard_EStatID.k_eStat_FirstMatchDate;
    case 7:
    case "k_eStat_PreviousSeasonRank":
      return CMsgDOTAProfileCard_EStatID.k_eStat_PreviousSeasonRank;
    case 8:
    case "k_eStat_GamesMVP":
      return CMsgDOTAProfileCard_EStatID.k_eStat_GamesMVP;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgDOTAProfileCard_EStatID");
  }
}

export function cMsgDOTAProfileCard_EStatIDToJSON(object: CMsgDOTAProfileCard_EStatID): string {
  switch (object) {
    case CMsgDOTAProfileCard_EStatID.k_eStat_Wins:
      return "k_eStat_Wins";
    case CMsgDOTAProfileCard_EStatID.k_eStat_Commends:
      return "k_eStat_Commends";
    case CMsgDOTAProfileCard_EStatID.k_eStat_GamesPlayed:
      return "k_eStat_GamesPlayed";
    case CMsgDOTAProfileCard_EStatID.k_eStat_FirstMatchDate:
      return "k_eStat_FirstMatchDate";
    case CMsgDOTAProfileCard_EStatID.k_eStat_PreviousSeasonRank:
      return "k_eStat_PreviousSeasonRank";
    case CMsgDOTAProfileCard_EStatID.k_eStat_GamesMVP:
      return "k_eStat_GamesMVP";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgDOTAProfileCard_EStatID");
  }
}

export interface CMsgDOTAProfileCard_Slot {
  slotId: number;
  trophy: CMsgDOTAProfileCard_Slot_Trophy | undefined;
  stat: CMsgDOTAProfileCard_Slot_Stat | undefined;
  item: CMsgDOTAProfileCard_Slot_Item | undefined;
  hero: CMsgDOTAProfileCard_Slot_Hero | undefined;
  emoticon: CMsgDOTAProfileCard_Slot_Emoticon | undefined;
  team: CMsgDOTAProfileCard_Slot_Team | undefined;
}

export interface CMsgDOTAProfileCard_Slot_Trophy {
  trophyId: number;
  trophyScore: number;
}

export interface CMsgDOTAProfileCard_Slot_Stat {
  statId: CMsgDOTAProfileCard_EStatID;
  statScore: number;
}

export interface CMsgDOTAProfileCard_Slot_Item {
  serializedItem: Buffer;
  itemId: string;
}

export interface CMsgDOTAProfileCard_Slot_Hero {
  heroId: number;
  heroWins: number;
  heroLosses: number;
}

export interface CMsgDOTAProfileCard_Slot_Emoticon {
  emoticonId: number;
}

export interface CMsgDOTAProfileCard_Slot_Team {
  teamId: number;
}

export interface CSODOTAPlayerChallenge {
  accountId: number;
  eventId: number;
  slotId: number;
  intParam0: number;
  intParam1: number;
  createdTime: number;
  completed: number;
  sequenceId: number;
  challengeTier: number;
  flags: number;
  attempts: number;
  completeLimit: number;
  questRank: number;
  maxQuestRank: number;
  instanceId: number;
  heroId: number;
  templateId: number;
}

export interface CMsgClientToGCRerollPlayerChallenge {
  eventId: EEvent;
  sequenceId: number;
  heroId: number;
}

export interface CMsgGCRerollPlayerChallengeResponse {
  result: CMsgGCRerollPlayerChallengeResponse_EResult;
}

export enum CMsgGCRerollPlayerChallengeResponse_EResult {
  eResult_Success = 0,
  eResult_Dropped = 1,
  eResult_NotFound = 2,
  eResult_CantReroll = 3,
  eResult_ServerError = 4,
}

export function cMsgGCRerollPlayerChallengeResponse_EResultFromJSON(
  object: any,
): CMsgGCRerollPlayerChallengeResponse_EResult {
  switch (object) {
    case 0:
    case "eResult_Success":
      return CMsgGCRerollPlayerChallengeResponse_EResult.eResult_Success;
    case 1:
    case "eResult_Dropped":
      return CMsgGCRerollPlayerChallengeResponse_EResult.eResult_Dropped;
    case 2:
    case "eResult_NotFound":
      return CMsgGCRerollPlayerChallengeResponse_EResult.eResult_NotFound;
    case 3:
    case "eResult_CantReroll":
      return CMsgGCRerollPlayerChallengeResponse_EResult.eResult_CantReroll;
    case 4:
    case "eResult_ServerError":
      return CMsgGCRerollPlayerChallengeResponse_EResult.eResult_ServerError;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCRerollPlayerChallengeResponse_EResult",
      );
  }
}

export function cMsgGCRerollPlayerChallengeResponse_EResultToJSON(
  object: CMsgGCRerollPlayerChallengeResponse_EResult,
): string {
  switch (object) {
    case CMsgGCRerollPlayerChallengeResponse_EResult.eResult_Success:
      return "eResult_Success";
    case CMsgGCRerollPlayerChallengeResponse_EResult.eResult_Dropped:
      return "eResult_Dropped";
    case CMsgGCRerollPlayerChallengeResponse_EResult.eResult_NotFound:
      return "eResult_NotFound";
    case CMsgGCRerollPlayerChallengeResponse_EResult.eResult_CantReroll:
      return "eResult_CantReroll";
    case CMsgGCRerollPlayerChallengeResponse_EResult.eResult_ServerError:
      return "eResult_ServerError";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCRerollPlayerChallengeResponse_EResult",
      );
  }
}

export interface CMsgGCTopCustomGamesList {
  topCustomGames: string[];
  gameOfTheDay: string;
}

export interface CMsgDOTARealtimeGameStats {
  match: CMsgDOTARealtimeGameStats_MatchDetails | undefined;
  teams: CMsgDOTARealtimeGameStats_TeamDetails[];
  buildings: CMsgDOTARealtimeGameStats_BuildingDetails[];
  graphData: CMsgDOTARealtimeGameStats_GraphData | undefined;
  deltaFrame: boolean;
}

export interface CMsgDOTARealtimeGameStats_TeamDetails {
  teamNumber: number;
  teamId: number;
  teamName: string;
  teamLogo: string;
  teamTag: string;
  score: number;
  netWorth: number;
  players: CMsgDOTARealtimeGameStats_PlayerDetails[];
  onlyTeam: boolean;
  cheers: number;
  teamLogoUrl: string;
}

export interface CMsgDOTARealtimeGameStats_ItemDetails {
  itemAbilityId: number;
  name: string;
  time: number;
  sold: boolean;
  stackcount: number;
}

export interface CMsgDOTARealtimeGameStats_AbilityDetails {
  id: number;
  name: string;
  level: number;
  cooldown: number;
  cooldownMax: number;
}

export interface CMsgDOTARealtimeGameStats_HeroToHeroStats {
  victimid: number;
  kills: number;
  assists: number;
}

export interface CMsgDOTARealtimeGameStats_AbilityList {
  id: number[];
}

export interface CMsgDOTARealtimeGameStats_PlayerDetails {
  accountid: number;
  playerid: number;
  name: string;
  team: number;
  heroid: number;
  healthpoints: number;
  maxhealthpoints: number;
  healthregenrate: number;
  manapoints: number;
  maxmanapoints: number;
  manaregenrate: number;
  baseStrength: number;
  baseAgility: number;
  baseIntelligence: number;
  baseArmor: number;
  baseMovespeed: number;
  baseDamage: number;
  strength: number;
  agility: number;
  intelligence: number;
  armor: number;
  movespeed: number;
  damage: number;
  heroDamage: number;
  towerDamage: number;
  abilities: CMsgDOTARealtimeGameStats_AbilityDetails[];
  level: number;
  killCount: number;
  deathCount: number;
  assistsCount: number;
  deniesCount: number;
  lhCount: number;
  heroHealing: number;
  goldPerMin: number;
  xpPerMin: number;
  netGold: number;
  gold: number;
  x: number;
  y: number;
  respawnTime: number;
  ultimateCooldown: number;
  hasBuyback: boolean;
  items: CMsgDOTARealtimeGameStats_ItemDetails[];
  stashitems: CMsgDOTARealtimeGameStats_ItemDetails[];
  itemshoppinglist: CMsgDOTARealtimeGameStats_ItemDetails[];
  levelpoints: CMsgDOTARealtimeGameStats_AbilityList[];
  heroToHeroStats: CMsgDOTARealtimeGameStats_HeroToHeroStats[];
  hasUltimate: boolean;
  hasUltimateMana: boolean;
}

export interface CMsgDOTARealtimeGameStats_BuildingDetails {
  team: number;
  heading: number;
  lane: number;
  tier: number;
  type: number;
  x: number;
  y: number;
  destroyed: boolean;
}

export interface CMsgDOTARealtimeGameStats_KillDetails {
  playerId: number;
  deathTime: number;
  killerPlayerId: number;
}

export interface CMsgDOTARealtimeGameStats_BroadcasterDetails {
  playerId: number;
}

export interface CMsgDOTARealtimeGameStats_PickBanDetails {
  hero: number;
  team: number;
}

export interface CMsgDOTARealtimeGameStats_MatchDetails {
  serverSteamId: string;
  matchId: string;
  timestamp: number;
  timeOfDay: number;
  isNightstalkerNight: boolean;
  gameTime: number;
  gameState: number;
  teamidRadiant: number;
  teamidDire: number;
  picks: CMsgDOTARealtimeGameStats_PickBanDetails[];
  bans: CMsgDOTARealtimeGameStats_PickBanDetails[];
  kills: CMsgDOTARealtimeGameStats_KillDetails[];
  broadcasters: CMsgDOTARealtimeGameStats_BroadcasterDetails[];
  gameMode: number;
  leagueId: number;
  leagueNodeId: number;
  singleTeam: boolean;
  cheersPeak: number;
  lobbyType: number;
  startTimestamp: number;
}

export interface CMsgDOTARealtimeGameStats_GraphData {
  graphGold: number[];
  graphXp: number[];
  graphKill: number[];
  graphTower: number[];
  graphRax: number[];
  teamLocStats: CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats[];
}

export enum CMsgDOTARealtimeGameStats_GraphData_eStat {
  CreepGoldEarned = 0,
  KillGoldEarned = 1,
  DeathAndBuybackGoldLost = 2,
  XPEarned = 3,
}

export function cMsgDOTARealtimeGameStats_GraphData_eStatFromJSON(
  object: any,
): CMsgDOTARealtimeGameStats_GraphData_eStat {
  switch (object) {
    case 0:
    case "CreepGoldEarned":
      return CMsgDOTARealtimeGameStats_GraphData_eStat.CreepGoldEarned;
    case 1:
    case "KillGoldEarned":
      return CMsgDOTARealtimeGameStats_GraphData_eStat.KillGoldEarned;
    case 2:
    case "DeathAndBuybackGoldLost":
      return CMsgDOTARealtimeGameStats_GraphData_eStat.DeathAndBuybackGoldLost;
    case 3:
    case "XPEarned":
      return CMsgDOTARealtimeGameStats_GraphData_eStat.XPEarned;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTARealtimeGameStats_GraphData_eStat",
      );
  }
}

export function cMsgDOTARealtimeGameStats_GraphData_eStatToJSON(
  object: CMsgDOTARealtimeGameStats_GraphData_eStat,
): string {
  switch (object) {
    case CMsgDOTARealtimeGameStats_GraphData_eStat.CreepGoldEarned:
      return "CreepGoldEarned";
    case CMsgDOTARealtimeGameStats_GraphData_eStat.KillGoldEarned:
      return "KillGoldEarned";
    case CMsgDOTARealtimeGameStats_GraphData_eStat.DeathAndBuybackGoldLost:
      return "DeathAndBuybackGoldLost";
    case CMsgDOTARealtimeGameStats_GraphData_eStat.XPEarned:
      return "XPEarned";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTARealtimeGameStats_GraphData_eStat",
      );
  }
}

export enum CMsgDOTARealtimeGameStats_GraphData_eLocation {
  BotLane = 0,
  MidLane = 1,
  TopLane = 2,
  Jungle = 3,
  Ancients = 4,
  Other = 5,
}

export function cMsgDOTARealtimeGameStats_GraphData_eLocationFromJSON(
  object: any,
): CMsgDOTARealtimeGameStats_GraphData_eLocation {
  switch (object) {
    case 0:
    case "BotLane":
      return CMsgDOTARealtimeGameStats_GraphData_eLocation.BotLane;
    case 1:
    case "MidLane":
      return CMsgDOTARealtimeGameStats_GraphData_eLocation.MidLane;
    case 2:
    case "TopLane":
      return CMsgDOTARealtimeGameStats_GraphData_eLocation.TopLane;
    case 3:
    case "Jungle":
      return CMsgDOTARealtimeGameStats_GraphData_eLocation.Jungle;
    case 4:
    case "Ancients":
      return CMsgDOTARealtimeGameStats_GraphData_eLocation.Ancients;
    case 5:
    case "Other":
      return CMsgDOTARealtimeGameStats_GraphData_eLocation.Other;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTARealtimeGameStats_GraphData_eLocation",
      );
  }
}

export function cMsgDOTARealtimeGameStats_GraphData_eLocationToJSON(
  object: CMsgDOTARealtimeGameStats_GraphData_eLocation,
): string {
  switch (object) {
    case CMsgDOTARealtimeGameStats_GraphData_eLocation.BotLane:
      return "BotLane";
    case CMsgDOTARealtimeGameStats_GraphData_eLocation.MidLane:
      return "MidLane";
    case CMsgDOTARealtimeGameStats_GraphData_eLocation.TopLane:
      return "TopLane";
    case CMsgDOTARealtimeGameStats_GraphData_eLocation.Jungle:
      return "Jungle";
    case CMsgDOTARealtimeGameStats_GraphData_eLocation.Ancients:
      return "Ancients";
    case CMsgDOTARealtimeGameStats_GraphData_eLocation.Other:
      return "Other";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTARealtimeGameStats_GraphData_eLocation",
      );
  }
}

export interface CMsgDOTARealtimeGameStats_GraphData_LocationStats {
  stats: number[];
}

export interface CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
  locStats: CMsgDOTARealtimeGameStats_GraphData_LocationStats[];
}

export interface CMsgDOTARealtimeGameStatsTerse {
  match: CMsgDOTARealtimeGameStatsTerse_MatchDetails | undefined;
  teams: CMsgDOTARealtimeGameStatsTerse_TeamDetails[];
  buildings: CMsgDOTARealtimeGameStatsTerse_BuildingDetails[];
  graphData: CMsgDOTARealtimeGameStatsTerse_GraphData | undefined;
  deltaFrame: boolean;
}

export interface CMsgDOTARealtimeGameStatsTerse_TeamDetails {
  teamNumber: number;
  teamId: number;
  teamName: string;
  teamTag: string;
  teamLogo: string;
  score: number;
  netWorth: number;
  teamLogoUrl: string;
  players: CMsgDOTARealtimeGameStatsTerse_PlayerDetails[];
}

export interface CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
  accountid: number;
  playerid: number;
  name: string;
  team: number;
  heroid: number;
  level: number;
  killCount: number;
  deathCount: number;
  assistsCount: number;
  deniesCount: number;
  lhCount: number;
  gold: number;
  x: number;
  y: number;
  netWorth: number;
  abilities: number[];
  items: number[];
}

export interface CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
  team: number;
  heading: number;
  type: number;
  lane: number;
  tier: number;
  x: number;
  y: number;
  destroyed: boolean;
}

export interface CMsgDOTARealtimeGameStatsTerse_PickBanDetails {
  hero: number;
  team: number;
}

export interface CMsgDOTARealtimeGameStatsTerse_MatchDetails {
  serverSteamId: string;
  matchId: string;
  timestamp: number;
  gameTime: number;
  steamBroadcasterAccountIds: number[];
  gameMode: number;
  leagueId: number;
  leagueNodeId: number;
  gameState: number;
  picks: CMsgDOTARealtimeGameStatsTerse_PickBanDetails[];
  bans: CMsgDOTARealtimeGameStatsTerse_PickBanDetails[];
  lobbyType: number;
  startTimestamp: number;
}

export interface CMsgDOTARealtimeGameStatsTerse_GraphData {
  graphGold: number[];
}

export interface CMsgDOTABroadcastTimelineEvent {
  event: EBroadcastTimelineEvent;
  timestamp: number;
  data: number;
  stringData: string;
}

export interface CMsgGCToClientMatchGroupsVersion {
  matchgroupsVersion: number;
}

export interface CMsgDOTASDOHeroStatsHistory {
  matchId: string;
  gameMode: number;
  lobbyType: number;
  startTime: number;
  won: boolean;
  gpm: number;
  xpm: number;
  kills: number;
  deaths: number;
  assists: number;
}

export interface CMsgPredictionChoice {
  value: number;
  name: string;
  minRawValue: number;
  maxRawValue: number;
}

export interface CMsgInGamePrediction {
  id: number;
  name: string;
  type: CMsgInGamePrediction_EPredictionType;
  group: CMsgInGamePrediction_ERandomSelectionGroupT;
  question: string;
  choices: CMsgPredictionChoice[];
  requiredHeroes: string[];
  queryName: string;
  queryValues: CMsgInGamePrediction_QueryKeyValues[];
  answerResolutionType: CMsgInGamePrediction_EResolutionTypeT;
  pointsToGrant: number;
  rewardAction: number;
  debugForceSelection: number;
  rawValueType: CMsgInGamePrediction_ERawValueTypeT;
}

export enum CMsgInGamePrediction_ERawValueTypeT {
  Number = 0,
  Time = 1,
}

export function cMsgInGamePrediction_ERawValueTypeTFromJSON(object: any): CMsgInGamePrediction_ERawValueTypeT {
  switch (object) {
    case 0:
    case "Number":
      return CMsgInGamePrediction_ERawValueTypeT.Number;
    case 1:
    case "Time":
      return CMsgInGamePrediction_ERawValueTypeT.Time;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgInGamePrediction_ERawValueTypeT");
  }
}

export function cMsgInGamePrediction_ERawValueTypeTToJSON(object: CMsgInGamePrediction_ERawValueTypeT): string {
  switch (object) {
    case CMsgInGamePrediction_ERawValueTypeT.Number:
      return "Number";
    case CMsgInGamePrediction_ERawValueTypeT.Time:
      return "Time";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgInGamePrediction_ERawValueTypeT");
  }
}

export enum CMsgInGamePrediction_EPredictionType {
  Generic = 0,
  Hero = 1,
  Team = 2,
  Player = 3,
  Special = 4,
  YesNo = 5,
  QualifiersTeam = 6,
}

export function cMsgInGamePrediction_EPredictionTypeFromJSON(object: any): CMsgInGamePrediction_EPredictionType {
  switch (object) {
    case 0:
    case "Generic":
      return CMsgInGamePrediction_EPredictionType.Generic;
    case 1:
    case "Hero":
      return CMsgInGamePrediction_EPredictionType.Hero;
    case 2:
    case "Team":
      return CMsgInGamePrediction_EPredictionType.Team;
    case 3:
    case "Player":
      return CMsgInGamePrediction_EPredictionType.Player;
    case 4:
    case "Special":
      return CMsgInGamePrediction_EPredictionType.Special;
    case 5:
    case "YesNo":
      return CMsgInGamePrediction_EPredictionType.YesNo;
    case 6:
    case "QualifiersTeam":
      return CMsgInGamePrediction_EPredictionType.QualifiersTeam;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgInGamePrediction_EPredictionType",
      );
  }
}

export function cMsgInGamePrediction_EPredictionTypeToJSON(object: CMsgInGamePrediction_EPredictionType): string {
  switch (object) {
    case CMsgInGamePrediction_EPredictionType.Generic:
      return "Generic";
    case CMsgInGamePrediction_EPredictionType.Hero:
      return "Hero";
    case CMsgInGamePrediction_EPredictionType.Team:
      return "Team";
    case CMsgInGamePrediction_EPredictionType.Player:
      return "Player";
    case CMsgInGamePrediction_EPredictionType.Special:
      return "Special";
    case CMsgInGamePrediction_EPredictionType.YesNo:
      return "YesNo";
    case CMsgInGamePrediction_EPredictionType.QualifiersTeam:
      return "QualifiersTeam";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgInGamePrediction_EPredictionType",
      );
  }
}

export enum CMsgInGamePrediction_EResolutionTypeT {
  InvalidQuery = 0,
  FirstToPassQuery = 1,
  LastToPassQuery = 2,
  LastRemainingQuery = 3,
  MaxToPassQuery = 4,
  MinToPassQuery = 5,
  SumQuery = 6,
  MaxTeamSumToPassQuery = 7,
  MinTeamSumToPassQuery = 8,
}

export function cMsgInGamePrediction_EResolutionTypeTFromJSON(object: any): CMsgInGamePrediction_EResolutionTypeT {
  switch (object) {
    case 0:
    case "InvalidQuery":
      return CMsgInGamePrediction_EResolutionTypeT.InvalidQuery;
    case 1:
    case "FirstToPassQuery":
      return CMsgInGamePrediction_EResolutionTypeT.FirstToPassQuery;
    case 2:
    case "LastToPassQuery":
      return CMsgInGamePrediction_EResolutionTypeT.LastToPassQuery;
    case 3:
    case "LastRemainingQuery":
      return CMsgInGamePrediction_EResolutionTypeT.LastRemainingQuery;
    case 4:
    case "MaxToPassQuery":
      return CMsgInGamePrediction_EResolutionTypeT.MaxToPassQuery;
    case 5:
    case "MinToPassQuery":
      return CMsgInGamePrediction_EResolutionTypeT.MinToPassQuery;
    case 6:
    case "SumQuery":
      return CMsgInGamePrediction_EResolutionTypeT.SumQuery;
    case 7:
    case "MaxTeamSumToPassQuery":
      return CMsgInGamePrediction_EResolutionTypeT.MaxTeamSumToPassQuery;
    case 8:
    case "MinTeamSumToPassQuery":
      return CMsgInGamePrediction_EResolutionTypeT.MinTeamSumToPassQuery;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgInGamePrediction_EResolutionTypeT",
      );
  }
}

export function cMsgInGamePrediction_EResolutionTypeTToJSON(object: CMsgInGamePrediction_EResolutionTypeT): string {
  switch (object) {
    case CMsgInGamePrediction_EResolutionTypeT.InvalidQuery:
      return "InvalidQuery";
    case CMsgInGamePrediction_EResolutionTypeT.FirstToPassQuery:
      return "FirstToPassQuery";
    case CMsgInGamePrediction_EResolutionTypeT.LastToPassQuery:
      return "LastToPassQuery";
    case CMsgInGamePrediction_EResolutionTypeT.LastRemainingQuery:
      return "LastRemainingQuery";
    case CMsgInGamePrediction_EResolutionTypeT.MaxToPassQuery:
      return "MaxToPassQuery";
    case CMsgInGamePrediction_EResolutionTypeT.MinToPassQuery:
      return "MinToPassQuery";
    case CMsgInGamePrediction_EResolutionTypeT.SumQuery:
      return "SumQuery";
    case CMsgInGamePrediction_EResolutionTypeT.MaxTeamSumToPassQuery:
      return "MaxTeamSumToPassQuery";
    case CMsgInGamePrediction_EResolutionTypeT.MinTeamSumToPassQuery:
      return "MinTeamSumToPassQuery";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgInGamePrediction_EResolutionTypeT",
      );
  }
}

export enum CMsgInGamePrediction_ERandomSelectionGroupT {
  EarlyGame = 0,
  MidGame = 1,
  LateGame = 2,
  Count = 3,
}

export function cMsgInGamePrediction_ERandomSelectionGroupTFromJSON(
  object: any,
): CMsgInGamePrediction_ERandomSelectionGroupT {
  switch (object) {
    case 0:
    case "EarlyGame":
      return CMsgInGamePrediction_ERandomSelectionGroupT.EarlyGame;
    case 1:
    case "MidGame":
      return CMsgInGamePrediction_ERandomSelectionGroupT.MidGame;
    case 2:
    case "LateGame":
      return CMsgInGamePrediction_ERandomSelectionGroupT.LateGame;
    case 3:
    case "Count":
      return CMsgInGamePrediction_ERandomSelectionGroupT.Count;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgInGamePrediction_ERandomSelectionGroupT",
      );
  }
}

export function cMsgInGamePrediction_ERandomSelectionGroupTToJSON(
  object: CMsgInGamePrediction_ERandomSelectionGroupT,
): string {
  switch (object) {
    case CMsgInGamePrediction_ERandomSelectionGroupT.EarlyGame:
      return "EarlyGame";
    case CMsgInGamePrediction_ERandomSelectionGroupT.MidGame:
      return "MidGame";
    case CMsgInGamePrediction_ERandomSelectionGroupT.LateGame:
      return "LateGame";
    case CMsgInGamePrediction_ERandomSelectionGroupT.Count:
      return "Count";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgInGamePrediction_ERandomSelectionGroupT",
      );
  }
}

export interface CMsgInGamePrediction_QueryKeyValues {
  name: string;
  value: string;
}

export interface CMsgDOTASeasonPredictions {
  predictions: CMsgDOTASeasonPredictions_Prediction[];
  inGamePredictions: CMsgInGamePrediction[];
  inGamePredictionCountPerGame: number;
  inGamePredictionVotingPeriodMinutes: number;
}

export interface CMsgDOTASeasonPredictions_Prediction {
  type: CMsgDOTASeasonPredictions_Prediction_EPredictionType;
  question: string;
  choices: CMsgPredictionChoice[];
  selectionId: number;
  startDate: number;
  lockDate: number;
  reward: number;
  answerType: CMsgDOTASeasonPredictions_Prediction_EAnswerType;
  answerId: number;
  answers: CMsgDOTASeasonPredictions_Prediction_Answers[];
  queryName: string;
  lockOnSelectionId: number;
  lockOnSelectionValue: number;
  lockOnSelectionSet: boolean;
  useAnswerValueRanges: boolean;
  region: ELeagueRegion;
  phases: ELeaguePhase[];
  rewardEvent: EEvent;
}

export enum CMsgDOTASeasonPredictions_Prediction_EPredictionType {
  Generic = 0,
  Hero = 1,
  Team = 2,
  Player = 3,
  Special = 4,
  YesNo = 5,
  QualifiersTeam = 6,
  LastChanceTeam = 7,
}

export function cMsgDOTASeasonPredictions_Prediction_EPredictionTypeFromJSON(
  object: any,
): CMsgDOTASeasonPredictions_Prediction_EPredictionType {
  switch (object) {
    case 0:
    case "Generic":
      return CMsgDOTASeasonPredictions_Prediction_EPredictionType.Generic;
    case 1:
    case "Hero":
      return CMsgDOTASeasonPredictions_Prediction_EPredictionType.Hero;
    case 2:
    case "Team":
      return CMsgDOTASeasonPredictions_Prediction_EPredictionType.Team;
    case 3:
    case "Player":
      return CMsgDOTASeasonPredictions_Prediction_EPredictionType.Player;
    case 4:
    case "Special":
      return CMsgDOTASeasonPredictions_Prediction_EPredictionType.Special;
    case 5:
    case "YesNo":
      return CMsgDOTASeasonPredictions_Prediction_EPredictionType.YesNo;
    case 6:
    case "QualifiersTeam":
      return CMsgDOTASeasonPredictions_Prediction_EPredictionType.QualifiersTeam;
    case 7:
    case "LastChanceTeam":
      return CMsgDOTASeasonPredictions_Prediction_EPredictionType.LastChanceTeam;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTASeasonPredictions_Prediction_EPredictionType",
      );
  }
}

export function cMsgDOTASeasonPredictions_Prediction_EPredictionTypeToJSON(
  object: CMsgDOTASeasonPredictions_Prediction_EPredictionType,
): string {
  switch (object) {
    case CMsgDOTASeasonPredictions_Prediction_EPredictionType.Generic:
      return "Generic";
    case CMsgDOTASeasonPredictions_Prediction_EPredictionType.Hero:
      return "Hero";
    case CMsgDOTASeasonPredictions_Prediction_EPredictionType.Team:
      return "Team";
    case CMsgDOTASeasonPredictions_Prediction_EPredictionType.Player:
      return "Player";
    case CMsgDOTASeasonPredictions_Prediction_EPredictionType.Special:
      return "Special";
    case CMsgDOTASeasonPredictions_Prediction_EPredictionType.YesNo:
      return "YesNo";
    case CMsgDOTASeasonPredictions_Prediction_EPredictionType.QualifiersTeam:
      return "QualifiersTeam";
    case CMsgDOTASeasonPredictions_Prediction_EPredictionType.LastChanceTeam:
      return "LastChanceTeam";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTASeasonPredictions_Prediction_EPredictionType",
      );
  }
}

export enum CMsgDOTASeasonPredictions_Prediction_EAnswerType {
  SingleInt = 0,
  SingleFloat = 1,
  MultipleInt = 2,
  MultipleFloat = 3,
  AnswerTeam = 4,
  SingleTime = 5,
  MultipleTime = 6,
  NoAnswer = 7,
}

export function cMsgDOTASeasonPredictions_Prediction_EAnswerTypeFromJSON(
  object: any,
): CMsgDOTASeasonPredictions_Prediction_EAnswerType {
  switch (object) {
    case 0:
    case "SingleInt":
      return CMsgDOTASeasonPredictions_Prediction_EAnswerType.SingleInt;
    case 1:
    case "SingleFloat":
      return CMsgDOTASeasonPredictions_Prediction_EAnswerType.SingleFloat;
    case 2:
    case "MultipleInt":
      return CMsgDOTASeasonPredictions_Prediction_EAnswerType.MultipleInt;
    case 3:
    case "MultipleFloat":
      return CMsgDOTASeasonPredictions_Prediction_EAnswerType.MultipleFloat;
    case 4:
    case "AnswerTeam":
      return CMsgDOTASeasonPredictions_Prediction_EAnswerType.AnswerTeam;
    case 5:
    case "SingleTime":
      return CMsgDOTASeasonPredictions_Prediction_EAnswerType.SingleTime;
    case 6:
    case "MultipleTime":
      return CMsgDOTASeasonPredictions_Prediction_EAnswerType.MultipleTime;
    case 7:
    case "NoAnswer":
      return CMsgDOTASeasonPredictions_Prediction_EAnswerType.NoAnswer;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTASeasonPredictions_Prediction_EAnswerType",
      );
  }
}

export function cMsgDOTASeasonPredictions_Prediction_EAnswerTypeToJSON(
  object: CMsgDOTASeasonPredictions_Prediction_EAnswerType,
): string {
  switch (object) {
    case CMsgDOTASeasonPredictions_Prediction_EAnswerType.SingleInt:
      return "SingleInt";
    case CMsgDOTASeasonPredictions_Prediction_EAnswerType.SingleFloat:
      return "SingleFloat";
    case CMsgDOTASeasonPredictions_Prediction_EAnswerType.MultipleInt:
      return "MultipleInt";
    case CMsgDOTASeasonPredictions_Prediction_EAnswerType.MultipleFloat:
      return "MultipleFloat";
    case CMsgDOTASeasonPredictions_Prediction_EAnswerType.AnswerTeam:
      return "AnswerTeam";
    case CMsgDOTASeasonPredictions_Prediction_EAnswerType.SingleTime:
      return "SingleTime";
    case CMsgDOTASeasonPredictions_Prediction_EAnswerType.MultipleTime:
      return "MultipleTime";
    case CMsgDOTASeasonPredictions_Prediction_EAnswerType.NoAnswer:
      return "NoAnswer";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTASeasonPredictions_Prediction_EAnswerType",
      );
  }
}

export interface CMsgDOTASeasonPredictions_Prediction_Answers {
  answerId: number;
}

export interface CMsgAvailablePredictions {
  matchPredictions: CMsgAvailablePredictions_MatchPrediction[];
}

export interface CMsgAvailablePredictions_MatchPrediction {
  matchId: string;
  predictions: CMsgInGamePrediction[];
}

export interface CMsgLeagueWatchedGames {
  leagues: CMsgLeagueWatchedGames_League[];
}

export interface CMsgLeagueWatchedGames_Series {
  nodeId: number;
  game: number[];
}

export interface CMsgLeagueWatchedGames_League {
  leagueId: number;
  series: CMsgLeagueWatchedGames_Series[];
}

export interface CMsgDOTAMatch {
  duration: number;
  starttime: number;
  players: CMsgDOTAMatch_Player[];
  matchId: string;
  towerStatus: number[];
  barracksStatus: number[];
  cluster: number;
  firstBloodTime: number;
  replaySalt: number;
  serverIp: number;
  serverPort: number;
  lobbyType: number;
  humanPlayers: number;
  averageSkill: number;
  gameBalance: number;
  radiantTeamId: number;
  direTeamId: number;
  leagueid: number;
  radiantTeamName: string;
  direTeamName: string;
  radiantTeamLogo: string;
  direTeamLogo: string;
  radiantTeamLogoUrl: string;
  direTeamLogoUrl: string;
  radiantTeamComplete: number;
  direTeamComplete: number;
  positiveVotes: number;
  negativeVotes: number;
  gameMode: DOTAGameMode;
  picksBans: CMatchHeroSelectEvent[];
  matchSeqNum: string;
  replayState: CMsgDOTAMatch_ReplayState;
  radiantGuildId: number;
  direGuildId: number;
  radiantTeamTag: string;
  direTeamTag: string;
  seriesId: number;
  seriesType: number;
  broadcasterChannels: CMsgDOTAMatch_BroadcasterChannel[];
  engine: number;
  customGameData: CMsgDOTAMatch_CustomGameData | undefined;
  matchFlags: number;
  privateMetadataKey: number;
  radiantTeamScore: number;
  direTeamScore: number;
  matchOutcome: EMatchOutcome;
  tournamentId: number;
  tournamentRound: number;
  preGameDuration: number;
  coaches: CMsgDOTAMatch_Coach[];
}

export enum CMsgDOTAMatch_ReplayState {
  REPLAY_AVAILABLE = 0,
  REPLAY_NOT_RECORDED = 1,
  REPLAY_EXPIRED = 2,
}

export function cMsgDOTAMatch_ReplayStateFromJSON(object: any): CMsgDOTAMatch_ReplayState {
  switch (object) {
    case 0:
    case "REPLAY_AVAILABLE":
      return CMsgDOTAMatch_ReplayState.REPLAY_AVAILABLE;
    case 1:
    case "REPLAY_NOT_RECORDED":
      return CMsgDOTAMatch_ReplayState.REPLAY_NOT_RECORDED;
    case 2:
    case "REPLAY_EXPIRED":
      return CMsgDOTAMatch_ReplayState.REPLAY_EXPIRED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgDOTAMatch_ReplayState");
  }
}

export function cMsgDOTAMatch_ReplayStateToJSON(object: CMsgDOTAMatch_ReplayState): string {
  switch (object) {
    case CMsgDOTAMatch_ReplayState.REPLAY_AVAILABLE:
      return "REPLAY_AVAILABLE";
    case CMsgDOTAMatch_ReplayState.REPLAY_NOT_RECORDED:
      return "REPLAY_NOT_RECORDED";
    case CMsgDOTAMatch_ReplayState.REPLAY_EXPIRED:
      return "REPLAY_EXPIRED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgDOTAMatch_ReplayState");
  }
}

export interface CMsgDOTAMatch_Player {
  accountId: number;
  playerSlot: number;
  heroId: number;
  item0: number;
  item1: number;
  item2: number;
  item3: number;
  item4: number;
  item5: number;
  item6: number;
  item7: number;
  item8: number;
  item9: number;
  expectedTeamContribution: number;
  scaledMetric: number;
  previousRank: number;
  rankChange: number;
  mmrType: number;
  kills: number;
  deaths: number;
  assists: number;
  leaverStatus: number;
  gold: number;
  lastHits: number;
  denies: number;
  goldPerMin: number;
  xpPerMin: number;
  goldSpent: number;
  heroDamage: number;
  towerDamage: number;
  heroHealing: number;
  level: number;
  timeLastSeen: number;
  playerName: string;
  supportAbilityValue: number;
  feedingDetected: boolean;
  searchRank: number;
  searchRankUncertainty: number;
  rankUncertaintyChange: number;
  heroPlayCount: number;
  partyId: string;
  scaledHeroDamage: number;
  scaledTowerDamage: number;
  scaledHeroHealing: number;
  scaledKills: number;
  scaledDeaths: number;
  scaledAssists: number;
  claimedFarmGold: number;
  supportGold: number;
  claimedDenies: number;
  claimedMisses: number;
  misses: number;
  abilityUpgrades: CMatchPlayerAbilityUpgrade[];
  additionalUnitsInventory: CMatchAdditionalUnitInventory[];
  permanentBuffs: CMatchPlayerPermanentBuff[];
  proName: string;
  realName: string;
  customGameData: CMsgDOTAMatch_Player_CustomGameData | undefined;
  activePlusSubscription: boolean;
  netWorth: number;
  botDifficulty: number;
  heroPickOrder: number;
  heroWasRandomed: boolean;
  heroWasDotaPlusSuggestion: boolean;
  heroDamageReceived: CMsgDOTAMatch_Player_HeroDamageReceived[];
  heroDamageDealt: CMsgDOTAMatch_Player_HeroDamageReceived[];
  secondsDead: number;
  goldLostToDeath: number;
  laneSelectionFlags: number;
  bountyRunes: number;
  outpostsCaptured: number;
  teamNumber: dotaGcTeam;
  teamSlot: number;
}

export enum CMsgDOTAMatch_Player_HeroDamageType {
  HERO_DAMAGE_PHYSICAL = 0,
  HERO_DAMAGE_MAGICAL = 1,
  HERO_DAMAGE_PURE = 2,
}

export function cMsgDOTAMatch_Player_HeroDamageTypeFromJSON(object: any): CMsgDOTAMatch_Player_HeroDamageType {
  switch (object) {
    case 0:
    case "HERO_DAMAGE_PHYSICAL":
      return CMsgDOTAMatch_Player_HeroDamageType.HERO_DAMAGE_PHYSICAL;
    case 1:
    case "HERO_DAMAGE_MAGICAL":
      return CMsgDOTAMatch_Player_HeroDamageType.HERO_DAMAGE_MAGICAL;
    case 2:
    case "HERO_DAMAGE_PURE":
      return CMsgDOTAMatch_Player_HeroDamageType.HERO_DAMAGE_PURE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgDOTAMatch_Player_HeroDamageType");
  }
}

export function cMsgDOTAMatch_Player_HeroDamageTypeToJSON(object: CMsgDOTAMatch_Player_HeroDamageType): string {
  switch (object) {
    case CMsgDOTAMatch_Player_HeroDamageType.HERO_DAMAGE_PHYSICAL:
      return "HERO_DAMAGE_PHYSICAL";
    case CMsgDOTAMatch_Player_HeroDamageType.HERO_DAMAGE_MAGICAL:
      return "HERO_DAMAGE_MAGICAL";
    case CMsgDOTAMatch_Player_HeroDamageType.HERO_DAMAGE_PURE:
      return "HERO_DAMAGE_PURE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgDOTAMatch_Player_HeroDamageType");
  }
}

export interface CMsgDOTAMatch_Player_CustomGameData {
  dotaTeam: number;
  winner: boolean;
}

export interface CMsgDOTAMatch_Player_HeroDamageReceived {
  preReduction: number;
  postReduction: number;
  damageType: CMsgDOTAMatch_Player_HeroDamageType;
}

export interface CMsgDOTAMatch_BroadcasterInfo {
  accountId: number;
  name: string;
}

export interface CMsgDOTAMatch_BroadcasterChannel {
  countryCode: string;
  description: string;
  broadcasterInfos: CMsgDOTAMatch_BroadcasterInfo[];
  languageCode: string;
}

export interface CMsgDOTAMatch_Coach {
  accountId: number;
  coachName: string;
  coachRating: number;
  coachTeam: number;
  coachPartyId: string;
  isPrivateCoach: boolean;
}

export interface CMsgDOTAMatch_CustomGameData {
  customGameId: string;
  mapName: string;
}

export interface CMsgPlayerCard {
  accountId: number;
  statModifier: CMsgPlayerCard_StatModifier[];
}

export interface CMsgPlayerCard_StatModifier {
  stat: number;
  value: number;
}

export interface CMsgDOTAFantasyPlayerStats {
  playerAccountId: number;
  matchId: string;
  matchCompleted: boolean;
  teamId: number;
  leagueId: number;
  delay: number;
  seriesId: number;
  seriesType: number;
  kills: number;
  deaths: number;
  cs: number;
  gpm: number;
  towerKills: number;
  roshanKills: number;
  teamfightParticipation: number;
  wardsPlaced: number;
  campsStacked: number;
  runesGrabbed: number;
  firstBlood: number;
  stuns: number;
}

export interface CMsgDOTAFantasyPlayerMatchStats {
  matches: CMsgDOTAFantasyPlayerStats[];
}

export interface CMsgDOTABotDebugInfo {
  bots: CMsgDOTABotDebugInfo_Bot[];
  desirePushLaneTop: number;
  desirePushLaneMid: number;
  desirePushLaneBot: number;
  desireDefendLaneTop: number;
  desireDefendLaneMid: number;
  desireDefendLaneBot: number;
  desireFarmLaneTop: number;
  desireFarmLaneMid: number;
  desireFarmLaneBot: number;
  desireFarmRoshan: number;
  executionTime: number;
  runeStatus: number[];
}

export interface CMsgDOTABotDebugInfo_Bot {
  playerOwnerId: number;
  heroId: number;
  difficulty: number;
  powerCurrent: number;
  powerMax: number;
  moveTargetX: number;
  moveTargetY: number;
  moveTargetZ: number;
  activeModeId: number;
  executionTime: number;
  modes: CMsgDOTABotDebugInfo_Bot_Mode[];
  action: CMsgDOTABotDebugInfo_Bot_Action | undefined;
}

export interface CMsgDOTABotDebugInfo_Bot_Mode {
  modeId: number;
  desire: number;
  targetEntity: number;
  targetX: number;
  targetY: number;
  targetZ: number;
}

export interface CMsgDOTABotDebugInfo_Bot_Action {
  actionId: number;
  actionTarget: string;
}

export interface CMsgSuccessfulHero {
  heroId: number;
  winPercent: number;
  longestStreak: number;
}

export interface CMsgRecentMatchInfo {
  matchId: string;
  gameMode: DOTAGameMode;
  kills: number;
  deaths: number;
  assists: number;
  duration: number;
  playerSlot: number;
  matchOutcome: EMatchOutcome;
  timestamp: number;
  lobbyType: number;
  teamNumber: number;
}

export interface CMsgMatchTips {
  tips: CMsgMatchTips_SingleTip[];
}

export interface CMsgMatchTips_SingleTip {
  sourceAccountId: number;
  targetAccountId: number;
  tipAmount: number;
  eventId: EEvent;
}

export interface CMsgDOTAMatchMinimal {
  matchId: string;
  startTime: number;
  duration: number;
  gameMode: DOTAGameMode;
  players: CMsgDOTAMatchMinimal_Player[];
  tourney: CMsgDOTAMatchMinimal_Tourney | undefined;
  matchOutcome: EMatchOutcome;
  radiantScore: number;
  direScore: number;
  lobbyType: number;
}

export interface CMsgDOTAMatchMinimal_Player {
  accountId: number;
  heroId: number;
  kills: number;
  deaths: number;
  assists: number;
  items: number[];
  playerSlot: number;
  proName: string;
  level: number;
  teamNumber: dotaGcTeam;
}

export interface CMsgDOTAMatchMinimal_Tourney {
  leagueId: number;
  seriesType: number;
  seriesGame: number;
  weekendTourneyTournamentId: number;
  weekendTourneySeasonTrophyId: number;
  weekendTourneyDivision: number;
  weekendTourneySkillLevel: number;
  radiantTeamId: number;
  radiantTeamName: string;
  radiantTeamLogo: string;
  radiantTeamLogoUrl: string;
  direTeamId: number;
  direTeamName: string;
  direTeamLogo: string;
  direTeamLogoUrl: string;
}

export interface CMsgConsumableUsage {
  itemDef: number;
  quantityChange: number;
}

export interface CMsgMatchConsumableUsage {
  playerConsumablesUsed: CMsgMatchConsumableUsage_PlayerUsage[];
}

export interface CMsgMatchConsumableUsage_PlayerUsage {
  accountId: number;
  consumablesUsed: CMsgConsumableUsage[];
}

export interface CMsgMatchEventActionGrants {
  playerGrants: CMsgMatchEventActionGrants_PlayerGrants[];
}

export interface CMsgMatchEventActionGrants_PlayerGrants {
  accountId: number;
  actionsGranted: CMsgPendingEventAward[];
}

export interface CMsgCustomGameWhitelist {
  version: number;
  customGamesWhitelist: string[];
  disableWhitelist: boolean;
}

export interface CMsgCustomGameWhitelistForEdit {
  whitelistEntries: CMsgCustomGameWhitelistForEdit_WhitelistEntry[];
}

export interface CMsgCustomGameWhitelistForEdit_WhitelistEntry {
  customGameId: string;
  whitelistState: ECustomGameWhitelistState;
}

export interface CMsgPlayerRecentMatchInfo {
  matchId: string;
  timestamp: number;
  duration: number;
  win: boolean;
  heroId: number;
  kills: number;
  deaths: number;
  assists: number;
}

export interface CMsgPlayerMatchRecord {
  wins: number;
  losses: number;
}

export interface CMsgPlayerRecentMatchOutcomes {
  outcomes: number;
  matchCount: number;
}

export interface CMsgPlayerRecentCommends {
  commends: number;
  matchCount: number;
}

export interface CMsgPlayerRecentAccomplishments {
  recentOutcomes: CMsgPlayerRecentMatchOutcomes | undefined;
  totalRecord: CMsgPlayerMatchRecord | undefined;
  predictionStreak: number;
  plusPredictionStreak: number;
  recentCommends: CMsgPlayerRecentCommends | undefined;
  firstMatchTimestamp: number;
  lastMatch: CMsgPlayerRecentMatchInfo | undefined;
  recentMvps: CMsgPlayerRecentMatchOutcomes | undefined;
}

export interface CMsgPlayerHeroRecentAccomplishments {
  recentOutcomes: CMsgPlayerRecentMatchOutcomes | undefined;
  totalRecord: CMsgPlayerMatchRecord | undefined;
  lastMatch: CMsgPlayerRecentMatchInfo | undefined;
}

export interface CMsgRecentAccomplishments {
  playerAccomplishments: CMsgPlayerRecentAccomplishments | undefined;
  heroAccomplishments: CMsgPlayerHeroRecentAccomplishments | undefined;
}

export interface CMsgServerToGCRequestPlayerRecentAccomplishments {
  accountId: number;
  heroId: number;
}

export interface CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
  result: CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse;
  playerAccomplishments: CMsgRecentAccomplishments | undefined;
}

export enum CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
}

export function cMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponseFromJSON(
  object: any,
): CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eDisabled;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object +
          " for enum CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse",
      );
  }
}

export function cMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponseToJSON(
  object: CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse,
): string {
  switch (object) {
    case CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object +
          " for enum CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse",
      );
  }
}

export interface CMsgArcanaVoteMatchVotes {
  matchId: number;
  heroId: number;
  voteCount: number;
}

export interface CMsgGCtoGCAssociatedExploiterAccountInfo {
  accountId: number;
  numMatchesToSearch: number;
  minSharedMatchCount: number;
  numAdditionalPlayers: number;
}

export interface CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
  accounts: CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account[];
}

export interface CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account {
  accountId: number;
  numCommonMatches: number;
  earliestCommonMatch: number;
  latestCommonMatch: number;
  generation: number;
  persona: string;
  alreadyBanned: boolean;
}

export interface CMsgPullTabsData {
  slots: CMsgPullTabsData_Slot[];
  jackpots: CMsgPullTabsData_Jackpot[];
  lastBoard: number;
}

export interface CMsgPullTabsData_Slot {
  eventId: number;
  boardId: number;
  heroId: number;
  actionId: number;
  redeemed: boolean;
}

export interface CMsgPullTabsData_Jackpot {
  boardId: number;
  actionId: number;
  heroId: number;
}

export interface CMsgUnderDraftData {
  benchSlots: CMsgUnderDraftData_BenchSlot[];
  shopSlots: CMsgUnderDraftData_ShopSlot[];
  gold: number;
  totalGold: number;
  notRestorable: boolean;
}

export interface CMsgUnderDraftData_BenchSlot {
  slotId: number;
  heroId: number;
  stars: number;
}

export interface CMsgUnderDraftData_ShopSlot {
  slotId: number;
  heroId: number;
  isSpecialReward: boolean;
}

export interface CMsgPlayerTitleData {
  title: number[];
  eventId: number[];
  active: number;
}

export interface CMsgDOTATriviaQuestion {
  questionId: number;
  category: EDOTATriviaQuestionCategory;
  timestamp: number;
  questionValue: string;
  answerValues: string[];
  correctAnswerIndex: number;
}

export interface CMsgDOTATriviaQuestionAnswersSummary {
  summaryAvailable: boolean;
  pickedCount: number[];
}

export interface CMsgGameDataSpecialValueBonus {
  name: string;
  value: number;
  operation: number;
}

export interface CMsgGameDataSpecialValues {
  name: string;
  valuesFloat: number[];
  isPercentage: boolean;
  headingLoc: string;
  bonuses: CMsgGameDataSpecialValueBonus[];
  valuesShard: number[];
  valuesScepter: number[];
}

export interface CMsgGameDataAbilityOrItem {
  id: number;
  name: string;
  nameLoc: string;
  descLoc: string;
  loreLoc: string;
  notesLoc: string[];
  shardLoc: string;
  scepterLoc: string;
  type: number;
  behavior: string;
  targetTeam: number;
  targetType: number;
  flags: number;
  damage: number;
  immunity: number;
  dispellable: number;
  maxLevel: number;
  castRanges: number[];
  castPoints: number[];
  channelTimes: number[];
  cooldowns: number[];
  durations: number[];
  damages: number[];
  manaCosts: number[];
  goldCosts: number[];
  healthCosts: number[];
  specialValues: CMsgGameDataSpecialValues[];
  isItem: boolean;
  abilityHasScepter: boolean;
  abilityHasShard: boolean;
  abilityIsGrantedByScepter: boolean;
  abilityIsGrantedByShard: boolean;
  itemCost: number;
  itemInitialCharges: number;
  itemNeutralTier: number;
  itemStockMax: number;
  itemStockTime: number;
  itemQuality: number;
}

export interface CMsgGameDataHero {
  id: number;
  name: string;
  orderId: number;
  nameLoc: string;
  bioLoc: string;
  hypeLoc: string;
  npeDescLoc: string;
  strBase: number;
  strGain: number;
  agiBase: number;
  agiGain: number;
  intBase: number;
  intGain: number;
  primaryAttr: number;
  complexity: number;
  attackCapability: number;
  roleLevels: number[];
  damageMin: number;
  damageMax: number;
  attackRate: number;
  attackRange: number;
  projectileSpeed: number;
  armor: number;
  magicResistance: number;
  movementSpeed: number;
  turnRate: number;
  sightRangeDay: number;
  sightRangeNight: number;
  maxHealth: number;
  healthRegen: number;
  maxMana: number;
  manaRegen: number;
  abilities: CMsgGameDataAbilityOrItem[];
  talents: CMsgGameDataAbilityOrItem[];
}

export interface CMsgGameDataAbilities {
  abilities: CMsgGameDataAbilityOrItem[];
}

export interface CMsgGameDataItems {
  items: CMsgGameDataAbilityOrItem[];
}

export interface CMsgGameDataHeroes {
  heroes: CMsgGameDataHero[];
}

export interface CMsgGameDataHeroList {
  heroes: CMsgGameDataHeroList_HeroInfo[];
}

export interface CMsgGameDataHeroList_HeroInfo {
  id: number;
  name: string;
  nameLoc: string;
  nameEnglishLoc: string;
  primaryAttr: number;
  complexity: number;
}

export interface CMsgGameDataItemAbilityList {
  itemabilities: CMsgGameDataItemAbilityList_ItemAbilityInfo[];
}

export interface CMsgGameDataItemAbilityList_ItemAbilityInfo {
  id: number;
  name: string;
  nameLoc: string;
  nameEnglishLoc: string;
  neutralItemTier: number;
}

export interface CMsgLobbyAbilityDraftData {
  shuffleDraftOrder: boolean;
}

export interface CSOEconItemDropRateBonus {
  accountId: number;
  expirationDate: number;
  bonus: number;
  bonusCount: number;
  itemId: string;
  defIndex: number;
  secondsLeft: number;
  boosterType: number;
}

export interface CSOEconItemTournamentPassport {
  accountId: number;
  leagueId: number;
  itemId: string;
  originalPurchaserId: number;
  passportsBought: number;
  version: number;
  defIndex: number;
  rewardFlags: number;
}

export interface CMsgStickerbookSticker {
  itemDefId: number;
  stickerNum: number;
  quality: number;
  positionX: number;
  positionY: number;
  positionZ: number;
  rotation: number;
  scale: number;
  sourceItemId: string;
  depthBias: number;
}

export interface CMsgStickerbookPage {
  pageNum: number;
  eventId: EEvent;
  teamId: number;
  stickers: CMsgStickerbookSticker[];
  pageType: EStickerbookPageType;
}

export interface CMsgStickerbookTeamPageOrderSequence {
  pageNumbers: number[];
}

export interface CMsgStickerbook {
  pages: CMsgStickerbookPage[];
  teamPageOrderSequence: CMsgStickerbookTeamPageOrderSequence | undefined;
  favoritePageNum: number;
}

export interface CMsgStickerHero {
  heroId: number;
  itemDefId: number;
  quality: number;
  sourceItemId: string;
}

export interface CMsgStickerHeroes {
  heroes: CMsgStickerHero[];
}

export interface CMsgHeroRoleStats {
  laneSelectionFlags: number;
  matchCount: number;
  winCount: number;
}

export interface CMsgHeroRoleHeroStats {
  heroId: number;
  roleStats: CMsgHeroRoleStats[];
}

export interface CMsgHeroRoleRankStats {
  rankTier: number;
  heroStats: CMsgHeroRoleHeroStats[];
}

export interface CMsgHeroRoleAllRanksStats {
  startTimestamp: number;
  endTimestamp: number;
  rankStats: CMsgHeroRoleRankStats[];
}

export interface CMsgMapStatsSnapshot {
  timestamp: number;
  famangosGained: string;
  wisdomRunesGained: string;
  roshanKillsDay: string;
  roshanKillsNight: string;
  portalsUsed: string;
  lanternsLit: string;
  minibossKills: string;
  outpostsCaptured: string;
  shieldRunesGained: string;
}

export interface CMsgGlobalMapStats {
  current: CMsgMapStatsSnapshot | undefined;
  windowStart: CMsgMapStatsSnapshot | undefined;
  windowEnd: CMsgMapStatsSnapshot | undefined;
}

function createBaseCSODOTAGameAccountClient(): CSODOTAGameAccountClient {
  return {
    accountId: 0,
    wins: 0,
    losses: 0,
    xp: 0,
    level: 0,
    initialSkill: 0,
    leaverCount: 0,
    secondaryLeaverCount: 0,
    lowPriorityUntilDate: 0,
    preventTextChatUntilDate: 0,
    preventVoiceUntilDate: 0,
    preventPublicTextChatUntilDate: 0,
    preventNewPlayerChatUntilDate: 0,
    lastAbandonedGameDate: 0,
    lastSecondaryAbandonedGameDate: 0,
    leaverPenaltyCount: 0,
    completedGameStreak: 0,
    accountDisabledUntilDate: 0,
    accountDisabledCount: 0,
    matchDisabledUntilDate: 0,
    matchDisabledCount: 0,
    shutdownlawterminatetimestamp: 0,
    lowPriorityGamesRemaining: 0,
    recruitmentLevel: 0,
    hasNewNotifications: false,
    isLeagueAdmin: false,
    casualGamesPlayed: 0,
    soloCompetitiveGamesPlayed: 0,
    partyCompetitiveGamesPlayed: 0,
    casual1v1GamesPlayed: 0,
    currAllHeroChallengeId: 0,
    playTimePoints: 0,
    accountFlags: 0,
    playTimeLevel: 0,
    playerBehaviorSeqNumLastReport: 0,
    playerBehaviorScoreLastReport: 0,
    playerBehaviorReportOldData: false,
    tourneySkillLevel: 0,
    tourneyRecentParticipationDate: 0,
    anchoredPhoneNumberId: "0",
    rankedMatchmakingBanUntilDate: 0,
    recentGameTime1: 0,
    recentGameTime2: 0,
    recentGameTime3: 0,
    favoriteTeamPacked: "0",
    recentReportTime: 0,
    customGameDisabledUntilDate: 0,
    recentWinTime1: 0,
    recentWinTime2: 0,
    recentWinTime3: 0,
    coachRating: 0,
    queuePoints: 0,
    roleHandicaps: [],
    eventModeRecentTime: 0,
    mmrRecalibrationTime: 0,
  };
}

export const CSODOTAGameAccountClient: MessageFns<CSODOTAGameAccountClient> = {
  encode(message: CSODOTAGameAccountClient, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.wins !== 0) {
      writer.uint32(24).uint32(message.wins);
    }
    if (message.losses !== 0) {
      writer.uint32(32).uint32(message.losses);
    }
    if (message.xp !== 0) {
      writer.uint32(96).uint32(message.xp);
    }
    if (message.level !== 0) {
      writer.uint32(104).uint32(message.level);
    }
    if (message.initialSkill !== 0) {
      writer.uint32(112).uint32(message.initialSkill);
    }
    if (message.leaverCount !== 0) {
      writer.uint32(120).uint32(message.leaverCount);
    }
    if (message.secondaryLeaverCount !== 0) {
      writer.uint32(464).uint32(message.secondaryLeaverCount);
    }
    if (message.lowPriorityUntilDate !== 0) {
      writer.uint32(144).uint32(message.lowPriorityUntilDate);
    }
    if (message.preventTextChatUntilDate !== 0) {
      writer.uint32(160).uint32(message.preventTextChatUntilDate);
    }
    if (message.preventVoiceUntilDate !== 0) {
      writer.uint32(168).uint32(message.preventVoiceUntilDate);
    }
    if (message.preventPublicTextChatUntilDate !== 0) {
      writer.uint32(688).uint32(message.preventPublicTextChatUntilDate);
    }
    if (message.preventNewPlayerChatUntilDate !== 0) {
      writer.uint32(976).uint32(message.preventNewPlayerChatUntilDate);
    }
    if (message.lastAbandonedGameDate !== 0) {
      writer.uint32(176).uint32(message.lastAbandonedGameDate);
    }
    if (message.lastSecondaryAbandonedGameDate !== 0) {
      writer.uint32(472).uint32(message.lastSecondaryAbandonedGameDate);
    }
    if (message.leaverPenaltyCount !== 0) {
      writer.uint32(184).uint32(message.leaverPenaltyCount);
    }
    if (message.completedGameStreak !== 0) {
      writer.uint32(192).uint32(message.completedGameStreak);
    }
    if (message.accountDisabledUntilDate !== 0) {
      writer.uint32(304).uint32(message.accountDisabledUntilDate);
    }
    if (message.accountDisabledCount !== 0) {
      writer.uint32(312).uint32(message.accountDisabledCount);
    }
    if (message.matchDisabledUntilDate !== 0) {
      writer.uint32(328).uint32(message.matchDisabledUntilDate);
    }
    if (message.matchDisabledCount !== 0) {
      writer.uint32(336).uint32(message.matchDisabledCount);
    }
    if (message.shutdownlawterminatetimestamp !== 0) {
      writer.uint32(376).uint32(message.shutdownlawterminatetimestamp);
    }
    if (message.lowPriorityGamesRemaining !== 0) {
      writer.uint32(384).uint32(message.lowPriorityGamesRemaining);
    }
    if (message.recruitmentLevel !== 0) {
      writer.uint32(440).uint32(message.recruitmentLevel);
    }
    if (message.hasNewNotifications !== false) {
      writer.uint32(448).bool(message.hasNewNotifications);
    }
    if (message.isLeagueAdmin !== false) {
      writer.uint32(456).bool(message.isLeagueAdmin);
    }
    if (message.casualGamesPlayed !== 0) {
      writer.uint32(480).uint32(message.casualGamesPlayed);
    }
    if (message.soloCompetitiveGamesPlayed !== 0) {
      writer.uint32(488).uint32(message.soloCompetitiveGamesPlayed);
    }
    if (message.partyCompetitiveGamesPlayed !== 0) {
      writer.uint32(496).uint32(message.partyCompetitiveGamesPlayed);
    }
    if (message.casual1v1GamesPlayed !== 0) {
      writer.uint32(520).uint32(message.casual1v1GamesPlayed);
    }
    if (message.currAllHeroChallengeId !== 0) {
      writer.uint32(536).uint32(message.currAllHeroChallengeId);
    }
    if (message.playTimePoints !== 0) {
      writer.uint32(544).uint32(message.playTimePoints);
    }
    if (message.accountFlags !== 0) {
      writer.uint32(552).uint32(message.accountFlags);
    }
    if (message.playTimeLevel !== 0) {
      writer.uint32(560).uint32(message.playTimeLevel);
    }
    if (message.playerBehaviorSeqNumLastReport !== 0) {
      writer.uint32(568).uint32(message.playerBehaviorSeqNumLastReport);
    }
    if (message.playerBehaviorScoreLastReport !== 0) {
      writer.uint32(576).uint32(message.playerBehaviorScoreLastReport);
    }
    if (message.playerBehaviorReportOldData !== false) {
      writer.uint32(584).bool(message.playerBehaviorReportOldData);
    }
    if (message.tourneySkillLevel !== 0) {
      writer.uint32(592).uint32(message.tourneySkillLevel);
    }
    if (message.tourneyRecentParticipationDate !== 0) {
      writer.uint32(680).uint32(message.tourneyRecentParticipationDate);
    }
    if (message.anchoredPhoneNumberId !== "0") {
      writer.uint32(704).uint64(message.anchoredPhoneNumberId);
    }
    if (message.rankedMatchmakingBanUntilDate !== 0) {
      writer.uint32(712).uint32(message.rankedMatchmakingBanUntilDate);
    }
    if (message.recentGameTime1 !== 0) {
      writer.uint32(720).uint32(message.recentGameTime1);
    }
    if (message.recentGameTime2 !== 0) {
      writer.uint32(728).uint32(message.recentGameTime2);
    }
    if (message.recentGameTime3 !== 0) {
      writer.uint32(736).uint32(message.recentGameTime3);
    }
    if (message.favoriteTeamPacked !== "0") {
      writer.uint32(824).uint64(message.favoriteTeamPacked);
    }
    if (message.recentReportTime !== 0) {
      writer.uint32(832).uint32(message.recentReportTime);
    }
    if (message.customGameDisabledUntilDate !== 0) {
      writer.uint32(840).uint32(message.customGameDisabledUntilDate);
    }
    if (message.recentWinTime1 !== 0) {
      writer.uint32(848).uint32(message.recentWinTime1);
    }
    if (message.recentWinTime2 !== 0) {
      writer.uint32(856).uint32(message.recentWinTime2);
    }
    if (message.recentWinTime3 !== 0) {
      writer.uint32(864).uint32(message.recentWinTime3);
    }
    if (message.coachRating !== 0) {
      writer.uint32(872).uint32(message.coachRating);
    }
    if (message.queuePoints !== 0) {
      writer.uint32(912).uint32(message.queuePoints);
    }
    for (const v of message.roleHandicaps) {
      CSODOTAGameAccountClient_RoleHandicap.encode(v!, writer.uint32(922).fork()).join();
    }
    if (message.eventModeRecentTime !== 0) {
      writer.uint32(960).uint32(message.eventModeRecentTime);
    }
    if (message.mmrRecalibrationTime !== 0) {
      writer.uint32(968).uint32(message.mmrRecalibrationTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CSODOTAGameAccountClient {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSODOTAGameAccountClient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.wins = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.losses = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.xp = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.level = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.initialSkill = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.leaverCount = reader.uint32();
          continue;
        }
        case 58: {
          if (tag !== 464) {
            break;
          }

          message.secondaryLeaverCount = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.lowPriorityUntilDate = reader.uint32();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.preventTextChatUntilDate = reader.uint32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.preventVoiceUntilDate = reader.uint32();
          continue;
        }
        case 86: {
          if (tag !== 688) {
            break;
          }

          message.preventPublicTextChatUntilDate = reader.uint32();
          continue;
        }
        case 122: {
          if (tag !== 976) {
            break;
          }

          message.preventNewPlayerChatUntilDate = reader.uint32();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.lastAbandonedGameDate = reader.uint32();
          continue;
        }
        case 59: {
          if (tag !== 472) {
            break;
          }

          message.lastSecondaryAbandonedGameDate = reader.uint32();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.leaverPenaltyCount = reader.uint32();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.completedGameStreak = reader.uint32();
          continue;
        }
        case 38: {
          if (tag !== 304) {
            break;
          }

          message.accountDisabledUntilDate = reader.uint32();
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }

          message.accountDisabledCount = reader.uint32();
          continue;
        }
        case 41: {
          if (tag !== 328) {
            break;
          }

          message.matchDisabledUntilDate = reader.uint32();
          continue;
        }
        case 42: {
          if (tag !== 336) {
            break;
          }

          message.matchDisabledCount = reader.uint32();
          continue;
        }
        case 47: {
          if (tag !== 376) {
            break;
          }

          message.shutdownlawterminatetimestamp = reader.uint32();
          continue;
        }
        case 48: {
          if (tag !== 384) {
            break;
          }

          message.lowPriorityGamesRemaining = reader.uint32();
          continue;
        }
        case 55: {
          if (tag !== 440) {
            break;
          }

          message.recruitmentLevel = reader.uint32();
          continue;
        }
        case 56: {
          if (tag !== 448) {
            break;
          }

          message.hasNewNotifications = reader.bool();
          continue;
        }
        case 57: {
          if (tag !== 456) {
            break;
          }

          message.isLeagueAdmin = reader.bool();
          continue;
        }
        case 60: {
          if (tag !== 480) {
            break;
          }

          message.casualGamesPlayed = reader.uint32();
          continue;
        }
        case 61: {
          if (tag !== 488) {
            break;
          }

          message.soloCompetitiveGamesPlayed = reader.uint32();
          continue;
        }
        case 62: {
          if (tag !== 496) {
            break;
          }

          message.partyCompetitiveGamesPlayed = reader.uint32();
          continue;
        }
        case 65: {
          if (tag !== 520) {
            break;
          }

          message.casual1v1GamesPlayed = reader.uint32();
          continue;
        }
        case 67: {
          if (tag !== 536) {
            break;
          }

          message.currAllHeroChallengeId = reader.uint32();
          continue;
        }
        case 68: {
          if (tag !== 544) {
            break;
          }

          message.playTimePoints = reader.uint32();
          continue;
        }
        case 69: {
          if (tag !== 552) {
            break;
          }

          message.accountFlags = reader.uint32();
          continue;
        }
        case 70: {
          if (tag !== 560) {
            break;
          }

          message.playTimeLevel = reader.uint32();
          continue;
        }
        case 71: {
          if (tag !== 568) {
            break;
          }

          message.playerBehaviorSeqNumLastReport = reader.uint32();
          continue;
        }
        case 72: {
          if (tag !== 576) {
            break;
          }

          message.playerBehaviorScoreLastReport = reader.uint32();
          continue;
        }
        case 73: {
          if (tag !== 584) {
            break;
          }

          message.playerBehaviorReportOldData = reader.bool();
          continue;
        }
        case 74: {
          if (tag !== 592) {
            break;
          }

          message.tourneySkillLevel = reader.uint32();
          continue;
        }
        case 85: {
          if (tag !== 680) {
            break;
          }

          message.tourneyRecentParticipationDate = reader.uint32();
          continue;
        }
        case 88: {
          if (tag !== 704) {
            break;
          }

          message.anchoredPhoneNumberId = reader.uint64().toString();
          continue;
        }
        case 89: {
          if (tag !== 712) {
            break;
          }

          message.rankedMatchmakingBanUntilDate = reader.uint32();
          continue;
        }
        case 90: {
          if (tag !== 720) {
            break;
          }

          message.recentGameTime1 = reader.uint32();
          continue;
        }
        case 91: {
          if (tag !== 728) {
            break;
          }

          message.recentGameTime2 = reader.uint32();
          continue;
        }
        case 92: {
          if (tag !== 736) {
            break;
          }

          message.recentGameTime3 = reader.uint32();
          continue;
        }
        case 103: {
          if (tag !== 824) {
            break;
          }

          message.favoriteTeamPacked = reader.uint64().toString();
          continue;
        }
        case 104: {
          if (tag !== 832) {
            break;
          }

          message.recentReportTime = reader.uint32();
          continue;
        }
        case 105: {
          if (tag !== 840) {
            break;
          }

          message.customGameDisabledUntilDate = reader.uint32();
          continue;
        }
        case 106: {
          if (tag !== 848) {
            break;
          }

          message.recentWinTime1 = reader.uint32();
          continue;
        }
        case 107: {
          if (tag !== 856) {
            break;
          }

          message.recentWinTime2 = reader.uint32();
          continue;
        }
        case 108: {
          if (tag !== 864) {
            break;
          }

          message.recentWinTime3 = reader.uint32();
          continue;
        }
        case 109: {
          if (tag !== 872) {
            break;
          }

          message.coachRating = reader.uint32();
          continue;
        }
        case 114: {
          if (tag !== 912) {
            break;
          }

          message.queuePoints = reader.uint32();
          continue;
        }
        case 115: {
          if (tag !== 922) {
            break;
          }

          message.roleHandicaps.push(CSODOTAGameAccountClient_RoleHandicap.decode(reader, reader.uint32()));
          continue;
        }
        case 120: {
          if (tag !== 960) {
            break;
          }

          message.eventModeRecentTime = reader.uint32();
          continue;
        }
        case 121: {
          if (tag !== 968) {
            break;
          }

          message.mmrRecalibrationTime = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSODOTAGameAccountClient {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      wins: isSet(object.wins) ? globalThis.Number(object.wins) : 0,
      losses: isSet(object.losses) ? globalThis.Number(object.losses) : 0,
      xp: isSet(object.xp) ? globalThis.Number(object.xp) : 0,
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      initialSkill: isSet(object.initialSkill) ? globalThis.Number(object.initialSkill) : 0,
      leaverCount: isSet(object.leaverCount) ? globalThis.Number(object.leaverCount) : 0,
      secondaryLeaverCount: isSet(object.secondaryLeaverCount) ? globalThis.Number(object.secondaryLeaverCount) : 0,
      lowPriorityUntilDate: isSet(object.lowPriorityUntilDate) ? globalThis.Number(object.lowPriorityUntilDate) : 0,
      preventTextChatUntilDate: isSet(object.preventTextChatUntilDate)
        ? globalThis.Number(object.preventTextChatUntilDate)
        : 0,
      preventVoiceUntilDate: isSet(object.preventVoiceUntilDate) ? globalThis.Number(object.preventVoiceUntilDate) : 0,
      preventPublicTextChatUntilDate: isSet(object.preventPublicTextChatUntilDate)
        ? globalThis.Number(object.preventPublicTextChatUntilDate)
        : 0,
      preventNewPlayerChatUntilDate: isSet(object.preventNewPlayerChatUntilDate)
        ? globalThis.Number(object.preventNewPlayerChatUntilDate)
        : 0,
      lastAbandonedGameDate: isSet(object.lastAbandonedGameDate) ? globalThis.Number(object.lastAbandonedGameDate) : 0,
      lastSecondaryAbandonedGameDate: isSet(object.lastSecondaryAbandonedGameDate)
        ? globalThis.Number(object.lastSecondaryAbandonedGameDate)
        : 0,
      leaverPenaltyCount: isSet(object.leaverPenaltyCount) ? globalThis.Number(object.leaverPenaltyCount) : 0,
      completedGameStreak: isSet(object.completedGameStreak) ? globalThis.Number(object.completedGameStreak) : 0,
      accountDisabledUntilDate: isSet(object.accountDisabledUntilDate)
        ? globalThis.Number(object.accountDisabledUntilDate)
        : 0,
      accountDisabledCount: isSet(object.accountDisabledCount) ? globalThis.Number(object.accountDisabledCount) : 0,
      matchDisabledUntilDate: isSet(object.matchDisabledUntilDate)
        ? globalThis.Number(object.matchDisabledUntilDate)
        : 0,
      matchDisabledCount: isSet(object.matchDisabledCount) ? globalThis.Number(object.matchDisabledCount) : 0,
      shutdownlawterminatetimestamp: isSet(object.shutdownlawterminatetimestamp)
        ? globalThis.Number(object.shutdownlawterminatetimestamp)
        : 0,
      lowPriorityGamesRemaining: isSet(object.lowPriorityGamesRemaining)
        ? globalThis.Number(object.lowPriorityGamesRemaining)
        : 0,
      recruitmentLevel: isSet(object.recruitmentLevel) ? globalThis.Number(object.recruitmentLevel) : 0,
      hasNewNotifications: isSet(object.hasNewNotifications) ? globalThis.Boolean(object.hasNewNotifications) : false,
      isLeagueAdmin: isSet(object.isLeagueAdmin) ? globalThis.Boolean(object.isLeagueAdmin) : false,
      casualGamesPlayed: isSet(object.casualGamesPlayed) ? globalThis.Number(object.casualGamesPlayed) : 0,
      soloCompetitiveGamesPlayed: isSet(object.soloCompetitiveGamesPlayed)
        ? globalThis.Number(object.soloCompetitiveGamesPlayed)
        : 0,
      partyCompetitiveGamesPlayed: isSet(object.partyCompetitiveGamesPlayed)
        ? globalThis.Number(object.partyCompetitiveGamesPlayed)
        : 0,
      casual1v1GamesPlayed: isSet(object.casual1v1GamesPlayed) ? globalThis.Number(object.casual1v1GamesPlayed) : 0,
      currAllHeroChallengeId: isSet(object.currAllHeroChallengeId)
        ? globalThis.Number(object.currAllHeroChallengeId)
        : 0,
      playTimePoints: isSet(object.playTimePoints) ? globalThis.Number(object.playTimePoints) : 0,
      accountFlags: isSet(object.accountFlags) ? globalThis.Number(object.accountFlags) : 0,
      playTimeLevel: isSet(object.playTimeLevel) ? globalThis.Number(object.playTimeLevel) : 0,
      playerBehaviorSeqNumLastReport: isSet(object.playerBehaviorSeqNumLastReport)
        ? globalThis.Number(object.playerBehaviorSeqNumLastReport)
        : 0,
      playerBehaviorScoreLastReport: isSet(object.playerBehaviorScoreLastReport)
        ? globalThis.Number(object.playerBehaviorScoreLastReport)
        : 0,
      playerBehaviorReportOldData: isSet(object.playerBehaviorReportOldData)
        ? globalThis.Boolean(object.playerBehaviorReportOldData)
        : false,
      tourneySkillLevel: isSet(object.tourneySkillLevel) ? globalThis.Number(object.tourneySkillLevel) : 0,
      tourneyRecentParticipationDate: isSet(object.tourneyRecentParticipationDate)
        ? globalThis.Number(object.tourneyRecentParticipationDate)
        : 0,
      anchoredPhoneNumberId: isSet(object.anchoredPhoneNumberId)
        ? globalThis.String(object.anchoredPhoneNumberId)
        : "0",
      rankedMatchmakingBanUntilDate: isSet(object.rankedMatchmakingBanUntilDate)
        ? globalThis.Number(object.rankedMatchmakingBanUntilDate)
        : 0,
      recentGameTime1: isSet(object.recentGameTime1) ? globalThis.Number(object.recentGameTime1) : 0,
      recentGameTime2: isSet(object.recentGameTime2) ? globalThis.Number(object.recentGameTime2) : 0,
      recentGameTime3: isSet(object.recentGameTime3) ? globalThis.Number(object.recentGameTime3) : 0,
      favoriteTeamPacked: isSet(object.favoriteTeamPacked) ? globalThis.String(object.favoriteTeamPacked) : "0",
      recentReportTime: isSet(object.recentReportTime) ? globalThis.Number(object.recentReportTime) : 0,
      customGameDisabledUntilDate: isSet(object.customGameDisabledUntilDate)
        ? globalThis.Number(object.customGameDisabledUntilDate)
        : 0,
      recentWinTime1: isSet(object.recentWinTime1) ? globalThis.Number(object.recentWinTime1) : 0,
      recentWinTime2: isSet(object.recentWinTime2) ? globalThis.Number(object.recentWinTime2) : 0,
      recentWinTime3: isSet(object.recentWinTime3) ? globalThis.Number(object.recentWinTime3) : 0,
      coachRating: isSet(object.coachRating) ? globalThis.Number(object.coachRating) : 0,
      queuePoints: isSet(object.queuePoints) ? globalThis.Number(object.queuePoints) : 0,
      roleHandicaps: globalThis.Array.isArray(object?.roleHandicaps)
        ? object.roleHandicaps.map((e: any) => CSODOTAGameAccountClient_RoleHandicap.fromJSON(e))
        : [],
      eventModeRecentTime: isSet(object.eventModeRecentTime) ? globalThis.Number(object.eventModeRecentTime) : 0,
      mmrRecalibrationTime: isSet(object.mmrRecalibrationTime) ? globalThis.Number(object.mmrRecalibrationTime) : 0,
    };
  },

  toJSON(message: CSODOTAGameAccountClient): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.wins !== 0) {
      obj.wins = Math.round(message.wins);
    }
    if (message.losses !== 0) {
      obj.losses = Math.round(message.losses);
    }
    if (message.xp !== 0) {
      obj.xp = Math.round(message.xp);
    }
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.initialSkill !== 0) {
      obj.initialSkill = Math.round(message.initialSkill);
    }
    if (message.leaverCount !== 0) {
      obj.leaverCount = Math.round(message.leaverCount);
    }
    if (message.secondaryLeaverCount !== 0) {
      obj.secondaryLeaverCount = Math.round(message.secondaryLeaverCount);
    }
    if (message.lowPriorityUntilDate !== 0) {
      obj.lowPriorityUntilDate = Math.round(message.lowPriorityUntilDate);
    }
    if (message.preventTextChatUntilDate !== 0) {
      obj.preventTextChatUntilDate = Math.round(message.preventTextChatUntilDate);
    }
    if (message.preventVoiceUntilDate !== 0) {
      obj.preventVoiceUntilDate = Math.round(message.preventVoiceUntilDate);
    }
    if (message.preventPublicTextChatUntilDate !== 0) {
      obj.preventPublicTextChatUntilDate = Math.round(message.preventPublicTextChatUntilDate);
    }
    if (message.preventNewPlayerChatUntilDate !== 0) {
      obj.preventNewPlayerChatUntilDate = Math.round(message.preventNewPlayerChatUntilDate);
    }
    if (message.lastAbandonedGameDate !== 0) {
      obj.lastAbandonedGameDate = Math.round(message.lastAbandonedGameDate);
    }
    if (message.lastSecondaryAbandonedGameDate !== 0) {
      obj.lastSecondaryAbandonedGameDate = Math.round(message.lastSecondaryAbandonedGameDate);
    }
    if (message.leaverPenaltyCount !== 0) {
      obj.leaverPenaltyCount = Math.round(message.leaverPenaltyCount);
    }
    if (message.completedGameStreak !== 0) {
      obj.completedGameStreak = Math.round(message.completedGameStreak);
    }
    if (message.accountDisabledUntilDate !== 0) {
      obj.accountDisabledUntilDate = Math.round(message.accountDisabledUntilDate);
    }
    if (message.accountDisabledCount !== 0) {
      obj.accountDisabledCount = Math.round(message.accountDisabledCount);
    }
    if (message.matchDisabledUntilDate !== 0) {
      obj.matchDisabledUntilDate = Math.round(message.matchDisabledUntilDate);
    }
    if (message.matchDisabledCount !== 0) {
      obj.matchDisabledCount = Math.round(message.matchDisabledCount);
    }
    if (message.shutdownlawterminatetimestamp !== 0) {
      obj.shutdownlawterminatetimestamp = Math.round(message.shutdownlawterminatetimestamp);
    }
    if (message.lowPriorityGamesRemaining !== 0) {
      obj.lowPriorityGamesRemaining = Math.round(message.lowPriorityGamesRemaining);
    }
    if (message.recruitmentLevel !== 0) {
      obj.recruitmentLevel = Math.round(message.recruitmentLevel);
    }
    if (message.hasNewNotifications !== false) {
      obj.hasNewNotifications = message.hasNewNotifications;
    }
    if (message.isLeagueAdmin !== false) {
      obj.isLeagueAdmin = message.isLeagueAdmin;
    }
    if (message.casualGamesPlayed !== 0) {
      obj.casualGamesPlayed = Math.round(message.casualGamesPlayed);
    }
    if (message.soloCompetitiveGamesPlayed !== 0) {
      obj.soloCompetitiveGamesPlayed = Math.round(message.soloCompetitiveGamesPlayed);
    }
    if (message.partyCompetitiveGamesPlayed !== 0) {
      obj.partyCompetitiveGamesPlayed = Math.round(message.partyCompetitiveGamesPlayed);
    }
    if (message.casual1v1GamesPlayed !== 0) {
      obj.casual1v1GamesPlayed = Math.round(message.casual1v1GamesPlayed);
    }
    if (message.currAllHeroChallengeId !== 0) {
      obj.currAllHeroChallengeId = Math.round(message.currAllHeroChallengeId);
    }
    if (message.playTimePoints !== 0) {
      obj.playTimePoints = Math.round(message.playTimePoints);
    }
    if (message.accountFlags !== 0) {
      obj.accountFlags = Math.round(message.accountFlags);
    }
    if (message.playTimeLevel !== 0) {
      obj.playTimeLevel = Math.round(message.playTimeLevel);
    }
    if (message.playerBehaviorSeqNumLastReport !== 0) {
      obj.playerBehaviorSeqNumLastReport = Math.round(message.playerBehaviorSeqNumLastReport);
    }
    if (message.playerBehaviorScoreLastReport !== 0) {
      obj.playerBehaviorScoreLastReport = Math.round(message.playerBehaviorScoreLastReport);
    }
    if (message.playerBehaviorReportOldData !== false) {
      obj.playerBehaviorReportOldData = message.playerBehaviorReportOldData;
    }
    if (message.tourneySkillLevel !== 0) {
      obj.tourneySkillLevel = Math.round(message.tourneySkillLevel);
    }
    if (message.tourneyRecentParticipationDate !== 0) {
      obj.tourneyRecentParticipationDate = Math.round(message.tourneyRecentParticipationDate);
    }
    if (message.anchoredPhoneNumberId !== "0") {
      obj.anchoredPhoneNumberId = message.anchoredPhoneNumberId;
    }
    if (message.rankedMatchmakingBanUntilDate !== 0) {
      obj.rankedMatchmakingBanUntilDate = Math.round(message.rankedMatchmakingBanUntilDate);
    }
    if (message.recentGameTime1 !== 0) {
      obj.recentGameTime1 = Math.round(message.recentGameTime1);
    }
    if (message.recentGameTime2 !== 0) {
      obj.recentGameTime2 = Math.round(message.recentGameTime2);
    }
    if (message.recentGameTime3 !== 0) {
      obj.recentGameTime3 = Math.round(message.recentGameTime3);
    }
    if (message.favoriteTeamPacked !== "0") {
      obj.favoriteTeamPacked = message.favoriteTeamPacked;
    }
    if (message.recentReportTime !== 0) {
      obj.recentReportTime = Math.round(message.recentReportTime);
    }
    if (message.customGameDisabledUntilDate !== 0) {
      obj.customGameDisabledUntilDate = Math.round(message.customGameDisabledUntilDate);
    }
    if (message.recentWinTime1 !== 0) {
      obj.recentWinTime1 = Math.round(message.recentWinTime1);
    }
    if (message.recentWinTime2 !== 0) {
      obj.recentWinTime2 = Math.round(message.recentWinTime2);
    }
    if (message.recentWinTime3 !== 0) {
      obj.recentWinTime3 = Math.round(message.recentWinTime3);
    }
    if (message.coachRating !== 0) {
      obj.coachRating = Math.round(message.coachRating);
    }
    if (message.queuePoints !== 0) {
      obj.queuePoints = Math.round(message.queuePoints);
    }
    if (message.roleHandicaps?.length) {
      obj.roleHandicaps = message.roleHandicaps.map((e) => CSODOTAGameAccountClient_RoleHandicap.toJSON(e));
    }
    if (message.eventModeRecentTime !== 0) {
      obj.eventModeRecentTime = Math.round(message.eventModeRecentTime);
    }
    if (message.mmrRecalibrationTime !== 0) {
      obj.mmrRecalibrationTime = Math.round(message.mmrRecalibrationTime);
    }
    return obj;
  },

  create(base?: DeepPartial<CSODOTAGameAccountClient>): CSODOTAGameAccountClient {
    return CSODOTAGameAccountClient.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSODOTAGameAccountClient>): CSODOTAGameAccountClient {
    const message = createBaseCSODOTAGameAccountClient();
    message.accountId = object.accountId ?? 0;
    message.wins = object.wins ?? 0;
    message.losses = object.losses ?? 0;
    message.xp = object.xp ?? 0;
    message.level = object.level ?? 0;
    message.initialSkill = object.initialSkill ?? 0;
    message.leaverCount = object.leaverCount ?? 0;
    message.secondaryLeaverCount = object.secondaryLeaverCount ?? 0;
    message.lowPriorityUntilDate = object.lowPriorityUntilDate ?? 0;
    message.preventTextChatUntilDate = object.preventTextChatUntilDate ?? 0;
    message.preventVoiceUntilDate = object.preventVoiceUntilDate ?? 0;
    message.preventPublicTextChatUntilDate = object.preventPublicTextChatUntilDate ?? 0;
    message.preventNewPlayerChatUntilDate = object.preventNewPlayerChatUntilDate ?? 0;
    message.lastAbandonedGameDate = object.lastAbandonedGameDate ?? 0;
    message.lastSecondaryAbandonedGameDate = object.lastSecondaryAbandonedGameDate ?? 0;
    message.leaverPenaltyCount = object.leaverPenaltyCount ?? 0;
    message.completedGameStreak = object.completedGameStreak ?? 0;
    message.accountDisabledUntilDate = object.accountDisabledUntilDate ?? 0;
    message.accountDisabledCount = object.accountDisabledCount ?? 0;
    message.matchDisabledUntilDate = object.matchDisabledUntilDate ?? 0;
    message.matchDisabledCount = object.matchDisabledCount ?? 0;
    message.shutdownlawterminatetimestamp = object.shutdownlawterminatetimestamp ?? 0;
    message.lowPriorityGamesRemaining = object.lowPriorityGamesRemaining ?? 0;
    message.recruitmentLevel = object.recruitmentLevel ?? 0;
    message.hasNewNotifications = object.hasNewNotifications ?? false;
    message.isLeagueAdmin = object.isLeagueAdmin ?? false;
    message.casualGamesPlayed = object.casualGamesPlayed ?? 0;
    message.soloCompetitiveGamesPlayed = object.soloCompetitiveGamesPlayed ?? 0;
    message.partyCompetitiveGamesPlayed = object.partyCompetitiveGamesPlayed ?? 0;
    message.casual1v1GamesPlayed = object.casual1v1GamesPlayed ?? 0;
    message.currAllHeroChallengeId = object.currAllHeroChallengeId ?? 0;
    message.playTimePoints = object.playTimePoints ?? 0;
    message.accountFlags = object.accountFlags ?? 0;
    message.playTimeLevel = object.playTimeLevel ?? 0;
    message.playerBehaviorSeqNumLastReport = object.playerBehaviorSeqNumLastReport ?? 0;
    message.playerBehaviorScoreLastReport = object.playerBehaviorScoreLastReport ?? 0;
    message.playerBehaviorReportOldData = object.playerBehaviorReportOldData ?? false;
    message.tourneySkillLevel = object.tourneySkillLevel ?? 0;
    message.tourneyRecentParticipationDate = object.tourneyRecentParticipationDate ?? 0;
    message.anchoredPhoneNumberId = object.anchoredPhoneNumberId ?? "0";
    message.rankedMatchmakingBanUntilDate = object.rankedMatchmakingBanUntilDate ?? 0;
    message.recentGameTime1 = object.recentGameTime1 ?? 0;
    message.recentGameTime2 = object.recentGameTime2 ?? 0;
    message.recentGameTime3 = object.recentGameTime3 ?? 0;
    message.favoriteTeamPacked = object.favoriteTeamPacked ?? "0";
    message.recentReportTime = object.recentReportTime ?? 0;
    message.customGameDisabledUntilDate = object.customGameDisabledUntilDate ?? 0;
    message.recentWinTime1 = object.recentWinTime1 ?? 0;
    message.recentWinTime2 = object.recentWinTime2 ?? 0;
    message.recentWinTime3 = object.recentWinTime3 ?? 0;
    message.coachRating = object.coachRating ?? 0;
    message.queuePoints = object.queuePoints ?? 0;
    message.roleHandicaps = object.roleHandicaps?.map((e) => CSODOTAGameAccountClient_RoleHandicap.fromPartial(e)) ||
      [];
    message.eventModeRecentTime = object.eventModeRecentTime ?? 0;
    message.mmrRecalibrationTime = object.mmrRecalibrationTime ?? 0;
    return message;
  },
};

function createBaseCSODOTAGameAccountClient_RoleHandicap(): CSODOTAGameAccountClient_RoleHandicap {
  return { role: 0, handicap: 0 };
}

export const CSODOTAGameAccountClient_RoleHandicap: MessageFns<CSODOTAGameAccountClient_RoleHandicap> = {
  encode(message: CSODOTAGameAccountClient_RoleHandicap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.role !== 0) {
      writer.uint32(8).uint32(message.role);
    }
    if (message.handicap !== 0) {
      writer.uint32(21).float(message.handicap);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CSODOTAGameAccountClient_RoleHandicap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSODOTAGameAccountClient_RoleHandicap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.role = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.handicap = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSODOTAGameAccountClient_RoleHandicap {
    return {
      role: isSet(object.role) ? globalThis.Number(object.role) : 0,
      handicap: isSet(object.handicap) ? globalThis.Number(object.handicap) : 0,
    };
  },

  toJSON(message: CSODOTAGameAccountClient_RoleHandicap): unknown {
    const obj: any = {};
    if (message.role !== 0) {
      obj.role = Math.round(message.role);
    }
    if (message.handicap !== 0) {
      obj.handicap = message.handicap;
    }
    return obj;
  },

  create(base?: DeepPartial<CSODOTAGameAccountClient_RoleHandicap>): CSODOTAGameAccountClient_RoleHandicap {
    return CSODOTAGameAccountClient_RoleHandicap.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSODOTAGameAccountClient_RoleHandicap>): CSODOTAGameAccountClient_RoleHandicap {
    const message = createBaseCSODOTAGameAccountClient_RoleHandicap();
    message.role = object.role ?? 0;
    message.handicap = object.handicap ?? 0;
    return message;
  },
};

function createBaseCSODOTAGameAccountPlus(): CSODOTAGameAccountPlus {
  return {
    accountId: 0,
    originalStartDate: 0,
    plusFlags: 0,
    plusStatus: 0,
    prepaidTimeStart: 0,
    prepaidTimeBalance: 0,
    nextPaymentDate: 0,
    steamAgreementId: "0",
  };
}

export const CSODOTAGameAccountPlus: MessageFns<CSODOTAGameAccountPlus> = {
  encode(message: CSODOTAGameAccountPlus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.originalStartDate !== 0) {
      writer.uint32(16).uint32(message.originalStartDate);
    }
    if (message.plusFlags !== 0) {
      writer.uint32(24).uint32(message.plusFlags);
    }
    if (message.plusStatus !== 0) {
      writer.uint32(32).uint32(message.plusStatus);
    }
    if (message.prepaidTimeStart !== 0) {
      writer.uint32(40).uint32(message.prepaidTimeStart);
    }
    if (message.prepaidTimeBalance !== 0) {
      writer.uint32(48).uint32(message.prepaidTimeBalance);
    }
    if (message.nextPaymentDate !== 0) {
      writer.uint32(61).fixed32(message.nextPaymentDate);
    }
    if (message.steamAgreementId !== "0") {
      writer.uint32(65).fixed64(message.steamAgreementId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CSODOTAGameAccountPlus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSODOTAGameAccountPlus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.originalStartDate = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.plusFlags = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.plusStatus = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.prepaidTimeStart = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.prepaidTimeBalance = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.nextPaymentDate = reader.fixed32();
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.steamAgreementId = reader.fixed64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSODOTAGameAccountPlus {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      originalStartDate: isSet(object.originalStartDate) ? globalThis.Number(object.originalStartDate) : 0,
      plusFlags: isSet(object.plusFlags) ? globalThis.Number(object.plusFlags) : 0,
      plusStatus: isSet(object.plusStatus) ? globalThis.Number(object.plusStatus) : 0,
      prepaidTimeStart: isSet(object.prepaidTimeStart) ? globalThis.Number(object.prepaidTimeStart) : 0,
      prepaidTimeBalance: isSet(object.prepaidTimeBalance) ? globalThis.Number(object.prepaidTimeBalance) : 0,
      nextPaymentDate: isSet(object.nextPaymentDate) ? globalThis.Number(object.nextPaymentDate) : 0,
      steamAgreementId: isSet(object.steamAgreementId) ? globalThis.String(object.steamAgreementId) : "0",
    };
  },

  toJSON(message: CSODOTAGameAccountPlus): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.originalStartDate !== 0) {
      obj.originalStartDate = Math.round(message.originalStartDate);
    }
    if (message.plusFlags !== 0) {
      obj.plusFlags = Math.round(message.plusFlags);
    }
    if (message.plusStatus !== 0) {
      obj.plusStatus = Math.round(message.plusStatus);
    }
    if (message.prepaidTimeStart !== 0) {
      obj.prepaidTimeStart = Math.round(message.prepaidTimeStart);
    }
    if (message.prepaidTimeBalance !== 0) {
      obj.prepaidTimeBalance = Math.round(message.prepaidTimeBalance);
    }
    if (message.nextPaymentDate !== 0) {
      obj.nextPaymentDate = Math.round(message.nextPaymentDate);
    }
    if (message.steamAgreementId !== "0") {
      obj.steamAgreementId = message.steamAgreementId;
    }
    return obj;
  },

  create(base?: DeepPartial<CSODOTAGameAccountPlus>): CSODOTAGameAccountPlus {
    return CSODOTAGameAccountPlus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSODOTAGameAccountPlus>): CSODOTAGameAccountPlus {
    const message = createBaseCSODOTAGameAccountPlus();
    message.accountId = object.accountId ?? 0;
    message.originalStartDate = object.originalStartDate ?? 0;
    message.plusFlags = object.plusFlags ?? 0;
    message.plusStatus = object.plusStatus ?? 0;
    message.prepaidTimeStart = object.prepaidTimeStart ?? 0;
    message.prepaidTimeBalance = object.prepaidTimeBalance ?? 0;
    message.nextPaymentDate = object.nextPaymentDate ?? 0;
    message.steamAgreementId = object.steamAgreementId ?? "0";
    return message;
  },
};

function createBaseCMsgLobbyFeaturedGamemodeProgress(): CMsgLobbyFeaturedGamemodeProgress {
  return { accounts: [] };
}

export const CMsgLobbyFeaturedGamemodeProgress: MessageFns<CMsgLobbyFeaturedGamemodeProgress> = {
  encode(message: CMsgLobbyFeaturedGamemodeProgress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.accounts) {
      CMsgLobbyFeaturedGamemodeProgress_AccountProgress.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgLobbyFeaturedGamemodeProgress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLobbyFeaturedGamemodeProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accounts.push(CMsgLobbyFeaturedGamemodeProgress_AccountProgress.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLobbyFeaturedGamemodeProgress {
    return {
      accounts: globalThis.Array.isArray(object?.accounts)
        ? object.accounts.map((e: any) => CMsgLobbyFeaturedGamemodeProgress_AccountProgress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgLobbyFeaturedGamemodeProgress): unknown {
    const obj: any = {};
    if (message.accounts?.length) {
      obj.accounts = message.accounts.map((e) => CMsgLobbyFeaturedGamemodeProgress_AccountProgress.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLobbyFeaturedGamemodeProgress>): CMsgLobbyFeaturedGamemodeProgress {
    return CMsgLobbyFeaturedGamemodeProgress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLobbyFeaturedGamemodeProgress>): CMsgLobbyFeaturedGamemodeProgress {
    const message = createBaseCMsgLobbyFeaturedGamemodeProgress();
    message.accounts = object.accounts?.map((e) => CMsgLobbyFeaturedGamemodeProgress_AccountProgress.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseCMsgLobbyFeaturedGamemodeProgress_AccountProgress(): CMsgLobbyFeaturedGamemodeProgress_AccountProgress {
  return { accountId: 0, currentValue: 0, maxValue: 0 };
}

export const CMsgLobbyFeaturedGamemodeProgress_AccountProgress: MessageFns<
  CMsgLobbyFeaturedGamemodeProgress_AccountProgress
> = {
  encode(
    message: CMsgLobbyFeaturedGamemodeProgress_AccountProgress,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.currentValue !== 0) {
      writer.uint32(16).uint32(message.currentValue);
    }
    if (message.maxValue !== 0) {
      writer.uint32(24).uint32(message.maxValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgLobbyFeaturedGamemodeProgress_AccountProgress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLobbyFeaturedGamemodeProgress_AccountProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.currentValue = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxValue = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLobbyFeaturedGamemodeProgress_AccountProgress {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      currentValue: isSet(object.currentValue) ? globalThis.Number(object.currentValue) : 0,
      maxValue: isSet(object.maxValue) ? globalThis.Number(object.maxValue) : 0,
    };
  },

  toJSON(message: CMsgLobbyFeaturedGamemodeProgress_AccountProgress): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.currentValue !== 0) {
      obj.currentValue = Math.round(message.currentValue);
    }
    if (message.maxValue !== 0) {
      obj.maxValue = Math.round(message.maxValue);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgLobbyFeaturedGamemodeProgress_AccountProgress>,
  ): CMsgLobbyFeaturedGamemodeProgress_AccountProgress {
    return CMsgLobbyFeaturedGamemodeProgress_AccountProgress.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgLobbyFeaturedGamemodeProgress_AccountProgress>,
  ): CMsgLobbyFeaturedGamemodeProgress_AccountProgress {
    const message = createBaseCMsgLobbyFeaturedGamemodeProgress_AccountProgress();
    message.accountId = object.accountId ?? 0;
    message.currentValue = object.currentValue ?? 0;
    message.maxValue = object.maxValue ?? 0;
    return message;
  },
};

function createBaseCMsgBattleCupVictory(): CMsgBattleCupVictory {
  return {
    accountId: 0,
    winDate: 0,
    validUntil: 0,
    skillLevel: 0,
    tournamentId: 0,
    divisionId: 0,
    teamId: 0,
    streak: 0,
    trophyId: 0,
  };
}

export const CMsgBattleCupVictory: MessageFns<CMsgBattleCupVictory> = {
  encode(message: CMsgBattleCupVictory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.winDate !== 0) {
      writer.uint32(16).uint32(message.winDate);
    }
    if (message.validUntil !== 0) {
      writer.uint32(24).uint32(message.validUntil);
    }
    if (message.skillLevel !== 0) {
      writer.uint32(32).uint32(message.skillLevel);
    }
    if (message.tournamentId !== 0) {
      writer.uint32(40).uint32(message.tournamentId);
    }
    if (message.divisionId !== 0) {
      writer.uint32(48).uint32(message.divisionId);
    }
    if (message.teamId !== 0) {
      writer.uint32(56).uint32(message.teamId);
    }
    if (message.streak !== 0) {
      writer.uint32(64).uint32(message.streak);
    }
    if (message.trophyId !== 0) {
      writer.uint32(72).uint32(message.trophyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgBattleCupVictory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgBattleCupVictory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.winDate = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.validUntil = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.skillLevel = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.tournamentId = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.divisionId = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.streak = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.trophyId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgBattleCupVictory {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      winDate: isSet(object.winDate) ? globalThis.Number(object.winDate) : 0,
      validUntil: isSet(object.validUntil) ? globalThis.Number(object.validUntil) : 0,
      skillLevel: isSet(object.skillLevel) ? globalThis.Number(object.skillLevel) : 0,
      tournamentId: isSet(object.tournamentId) ? globalThis.Number(object.tournamentId) : 0,
      divisionId: isSet(object.divisionId) ? globalThis.Number(object.divisionId) : 0,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      streak: isSet(object.streak) ? globalThis.Number(object.streak) : 0,
      trophyId: isSet(object.trophyId) ? globalThis.Number(object.trophyId) : 0,
    };
  },

  toJSON(message: CMsgBattleCupVictory): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.winDate !== 0) {
      obj.winDate = Math.round(message.winDate);
    }
    if (message.validUntil !== 0) {
      obj.validUntil = Math.round(message.validUntil);
    }
    if (message.skillLevel !== 0) {
      obj.skillLevel = Math.round(message.skillLevel);
    }
    if (message.tournamentId !== 0) {
      obj.tournamentId = Math.round(message.tournamentId);
    }
    if (message.divisionId !== 0) {
      obj.divisionId = Math.round(message.divisionId);
    }
    if (message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.streak !== 0) {
      obj.streak = Math.round(message.streak);
    }
    if (message.trophyId !== 0) {
      obj.trophyId = Math.round(message.trophyId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgBattleCupVictory>): CMsgBattleCupVictory {
    return CMsgBattleCupVictory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgBattleCupVictory>): CMsgBattleCupVictory {
    const message = createBaseCMsgBattleCupVictory();
    message.accountId = object.accountId ?? 0;
    message.winDate = object.winDate ?? 0;
    message.validUntil = object.validUntil ?? 0;
    message.skillLevel = object.skillLevel ?? 0;
    message.tournamentId = object.tournamentId ?? 0;
    message.divisionId = object.divisionId ?? 0;
    message.teamId = object.teamId ?? 0;
    message.streak = object.streak ?? 0;
    message.trophyId = object.trophyId ?? 0;
    return message;
  },
};

function createBaseCMsgLobbyBattleCupVictoryList(): CMsgLobbyBattleCupVictoryList {
  return { winners: [] };
}

export const CMsgLobbyBattleCupVictoryList: MessageFns<CMsgLobbyBattleCupVictoryList> = {
  encode(message: CMsgLobbyBattleCupVictoryList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.winners) {
      CMsgBattleCupVictory.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgLobbyBattleCupVictoryList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLobbyBattleCupVictoryList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.winners.push(CMsgBattleCupVictory.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLobbyBattleCupVictoryList {
    return {
      winners: globalThis.Array.isArray(object?.winners)
        ? object.winners.map((e: any) => CMsgBattleCupVictory.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgLobbyBattleCupVictoryList): unknown {
    const obj: any = {};
    if (message.winners?.length) {
      obj.winners = message.winners.map((e) => CMsgBattleCupVictory.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLobbyBattleCupVictoryList>): CMsgLobbyBattleCupVictoryList {
    return CMsgLobbyBattleCupVictoryList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLobbyBattleCupVictoryList>): CMsgLobbyBattleCupVictoryList {
    const message = createBaseCMsgLobbyBattleCupVictoryList();
    message.winners = object.winners?.map((e) => CMsgBattleCupVictory.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTABroadcastNotification(): CMsgDOTABroadcastNotification {
  return { message: "" };
}

export const CMsgDOTABroadcastNotification: MessageFns<CMsgDOTABroadcastNotification> = {
  encode(message: CMsgDOTABroadcastNotification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTABroadcastNotification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTABroadcastNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTABroadcastNotification {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: CMsgDOTABroadcastNotification): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTABroadcastNotification>): CMsgDOTABroadcastNotification {
    return CMsgDOTABroadcastNotification.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTABroadcastNotification>): CMsgDOTABroadcastNotification {
    const message = createBaseCMsgDOTABroadcastNotification();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseCProtoItemHeroStatue(): CProtoItemHeroStatue {
  return {
    heroId: 0,
    statusEffectIndex: 0,
    sequenceName: "",
    cycle: 0,
    wearable: [],
    inscription: "",
    style: [],
    tournamentDrop: false,
  };
}

export const CProtoItemHeroStatue: MessageFns<CProtoItemHeroStatue> = {
  encode(message: CProtoItemHeroStatue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.heroId !== 0) {
      writer.uint32(8).uint32(message.heroId);
    }
    if (message.statusEffectIndex !== 0) {
      writer.uint32(16).uint32(message.statusEffectIndex);
    }
    if (message.sequenceName !== "") {
      writer.uint32(26).string(message.sequenceName);
    }
    if (message.cycle !== 0) {
      writer.uint32(37).float(message.cycle);
    }
    writer.uint32(42).fork();
    for (const v of message.wearable) {
      writer.uint32(v);
    }
    writer.join();
    if (message.inscription !== "") {
      writer.uint32(50).string(message.inscription);
    }
    writer.uint32(58).fork();
    for (const v of message.style) {
      writer.uint32(v);
    }
    writer.join();
    if (message.tournamentDrop !== false) {
      writer.uint32(64).bool(message.tournamentDrop);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CProtoItemHeroStatue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCProtoItemHeroStatue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.statusEffectIndex = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sequenceName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.cycle = reader.float();
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.wearable.push(reader.uint32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.wearable.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.inscription = reader.string();
          continue;
        }
        case 7: {
          if (tag === 56) {
            message.style.push(reader.uint32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.style.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.tournamentDrop = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CProtoItemHeroStatue {
    return {
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      statusEffectIndex: isSet(object.statusEffectIndex) ? globalThis.Number(object.statusEffectIndex) : 0,
      sequenceName: isSet(object.sequenceName) ? globalThis.String(object.sequenceName) : "",
      cycle: isSet(object.cycle) ? globalThis.Number(object.cycle) : 0,
      wearable: globalThis.Array.isArray(object?.wearable) ? object.wearable.map((e: any) => globalThis.Number(e)) : [],
      inscription: isSet(object.inscription) ? globalThis.String(object.inscription) : "",
      style: globalThis.Array.isArray(object?.style) ? object.style.map((e: any) => globalThis.Number(e)) : [],
      tournamentDrop: isSet(object.tournamentDrop) ? globalThis.Boolean(object.tournamentDrop) : false,
    };
  },

  toJSON(message: CProtoItemHeroStatue): unknown {
    const obj: any = {};
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.statusEffectIndex !== 0) {
      obj.statusEffectIndex = Math.round(message.statusEffectIndex);
    }
    if (message.sequenceName !== "") {
      obj.sequenceName = message.sequenceName;
    }
    if (message.cycle !== 0) {
      obj.cycle = message.cycle;
    }
    if (message.wearable?.length) {
      obj.wearable = message.wearable.map((e) => Math.round(e));
    }
    if (message.inscription !== "") {
      obj.inscription = message.inscription;
    }
    if (message.style?.length) {
      obj.style = message.style.map((e) => Math.round(e));
    }
    if (message.tournamentDrop !== false) {
      obj.tournamentDrop = message.tournamentDrop;
    }
    return obj;
  },

  create(base?: DeepPartial<CProtoItemHeroStatue>): CProtoItemHeroStatue {
    return CProtoItemHeroStatue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CProtoItemHeroStatue>): CProtoItemHeroStatue {
    const message = createBaseCProtoItemHeroStatue();
    message.heroId = object.heroId ?? 0;
    message.statusEffectIndex = object.statusEffectIndex ?? 0;
    message.sequenceName = object.sequenceName ?? "";
    message.cycle = object.cycle ?? 0;
    message.wearable = object.wearable?.map((e) => e) || [];
    message.inscription = object.inscription ?? "";
    message.style = object.style?.map((e) => e) || [];
    message.tournamentDrop = object.tournamentDrop ?? false;
    return message;
  },
};

function createBaseCMatchPlayerAbilityUpgrade(): CMatchPlayerAbilityUpgrade {
  return { ability: -1, time: 0 };
}

export const CMatchPlayerAbilityUpgrade: MessageFns<CMatchPlayerAbilityUpgrade> = {
  encode(message: CMatchPlayerAbilityUpgrade, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ability !== -1) {
      writer.uint32(8).int32(message.ability);
    }
    if (message.time !== 0) {
      writer.uint32(16).uint32(message.time);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMatchPlayerAbilityUpgrade {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMatchPlayerAbilityUpgrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ability = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.time = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMatchPlayerAbilityUpgrade {
    return {
      ability: isSet(object.ability) ? globalThis.Number(object.ability) : -1,
      time: isSet(object.time) ? globalThis.Number(object.time) : 0,
    };
  },

  toJSON(message: CMatchPlayerAbilityUpgrade): unknown {
    const obj: any = {};
    if (message.ability !== -1) {
      obj.ability = Math.round(message.ability);
    }
    if (message.time !== 0) {
      obj.time = Math.round(message.time);
    }
    return obj;
  },

  create(base?: DeepPartial<CMatchPlayerAbilityUpgrade>): CMatchPlayerAbilityUpgrade {
    return CMatchPlayerAbilityUpgrade.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMatchPlayerAbilityUpgrade>): CMatchPlayerAbilityUpgrade {
    const message = createBaseCMatchPlayerAbilityUpgrade();
    message.ability = object.ability ?? -1;
    message.time = object.time ?? 0;
    return message;
  },
};

function createBaseCMatchPlayerTimedCustomStat(): CMatchPlayerTimedCustomStat {
  return { stat: 1, value: 0 };
}

export const CMatchPlayerTimedCustomStat: MessageFns<CMatchPlayerTimedCustomStat> = {
  encode(message: CMatchPlayerTimedCustomStat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stat !== 1) {
      writer.uint32(16).int32(message.stat);
    }
    if (message.value !== 0) {
      writer.uint32(29).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMatchPlayerTimedCustomStat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMatchPlayerTimedCustomStat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.stat = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMatchPlayerTimedCustomStat {
    return {
      stat: isSet(object.stat) ? eDOTAMatchPlayerTimeCustomStatFromJSON(object.stat) : 1,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: CMatchPlayerTimedCustomStat): unknown {
    const obj: any = {};
    if (message.stat !== 1) {
      obj.stat = eDOTAMatchPlayerTimeCustomStatToJSON(message.stat);
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CMatchPlayerTimedCustomStat>): CMatchPlayerTimedCustomStat {
    return CMatchPlayerTimedCustomStat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMatchPlayerTimedCustomStat>): CMatchPlayerTimedCustomStat {
    const message = createBaseCMatchPlayerTimedCustomStat();
    message.stat = object.stat ?? 1;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCMatchPlayerTimedStats(): CMatchPlayerTimedStats {
  return {
    time: 0,
    kills: 0,
    deaths: 0,
    assists: 0,
    netWorth: 0,
    xp: 0,
    lastHits: 0,
    denies: 0,
    bountyRuneGold: 0,
    rangeCreepUpgradeGold: 0,
    observerWardsDewarded: 0,
    reliableGoldEarned: 0,
    goldLossPrevented: 0,
    heroKillGold: 0,
    creepKillGold: 0,
    buildingGold: 0,
    otherGold: 0,
    comebackGold: 0,
    experimentalGold: 0,
    experimental2Gold: 0,
    creepDenyGold: 0,
    tpScrollsPurchased1: 0,
    tpScrollsPurchased2: 0,
    tpScrollsPurchased3: 0,
    tpScrollsPurchased4: 0,
    tpScrollsPurchased5: 0,
    neutralGold: 0,
    courierGold: 0,
    roshanGold: 0,
    incomeGold: 0,
    itemValue: 0,
    supportGoldSpent: 0,
    campsStacked: 0,
    wardsPlaced: 0,
    tripleKills: 0,
    rampages: 0,
    customStats: [],
  };
}

export const CMatchPlayerTimedStats: MessageFns<CMatchPlayerTimedStats> = {
  encode(message: CMatchPlayerTimedStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.time !== 0) {
      writer.uint32(8).uint32(message.time);
    }
    if (message.kills !== 0) {
      writer.uint32(16).uint32(message.kills);
    }
    if (message.deaths !== 0) {
      writer.uint32(24).uint32(message.deaths);
    }
    if (message.assists !== 0) {
      writer.uint32(32).uint32(message.assists);
    }
    if (message.netWorth !== 0) {
      writer.uint32(40).uint32(message.netWorth);
    }
    if (message.xp !== 0) {
      writer.uint32(48).uint32(message.xp);
    }
    if (message.lastHits !== 0) {
      writer.uint32(56).uint32(message.lastHits);
    }
    if (message.denies !== 0) {
      writer.uint32(64).uint32(message.denies);
    }
    if (message.bountyRuneGold !== 0) {
      writer.uint32(72).uint32(message.bountyRuneGold);
    }
    if (message.rangeCreepUpgradeGold !== 0) {
      writer.uint32(80).uint32(message.rangeCreepUpgradeGold);
    }
    if (message.observerWardsDewarded !== 0) {
      writer.uint32(88).uint32(message.observerWardsDewarded);
    }
    if (message.reliableGoldEarned !== 0) {
      writer.uint32(96).uint32(message.reliableGoldEarned);
    }
    if (message.goldLossPrevented !== 0) {
      writer.uint32(104).uint32(message.goldLossPrevented);
    }
    if (message.heroKillGold !== 0) {
      writer.uint32(112).uint32(message.heroKillGold);
    }
    if (message.creepKillGold !== 0) {
      writer.uint32(120).uint32(message.creepKillGold);
    }
    if (message.buildingGold !== 0) {
      writer.uint32(128).uint32(message.buildingGold);
    }
    if (message.otherGold !== 0) {
      writer.uint32(136).uint32(message.otherGold);
    }
    if (message.comebackGold !== 0) {
      writer.uint32(144).uint32(message.comebackGold);
    }
    if (message.experimentalGold !== 0) {
      writer.uint32(152).uint32(message.experimentalGold);
    }
    if (message.experimental2Gold !== 0) {
      writer.uint32(160).uint32(message.experimental2Gold);
    }
    if (message.creepDenyGold !== 0) {
      writer.uint32(168).uint32(message.creepDenyGold);
    }
    if (message.tpScrollsPurchased1 !== 0) {
      writer.uint32(176).uint32(message.tpScrollsPurchased1);
    }
    if (message.tpScrollsPurchased2 !== 0) {
      writer.uint32(184).uint32(message.tpScrollsPurchased2);
    }
    if (message.tpScrollsPurchased3 !== 0) {
      writer.uint32(192).uint32(message.tpScrollsPurchased3);
    }
    if (message.tpScrollsPurchased4 !== 0) {
      writer.uint32(200).uint32(message.tpScrollsPurchased4);
    }
    if (message.tpScrollsPurchased5 !== 0) {
      writer.uint32(208).uint32(message.tpScrollsPurchased5);
    }
    if (message.neutralGold !== 0) {
      writer.uint32(216).uint32(message.neutralGold);
    }
    if (message.courierGold !== 0) {
      writer.uint32(224).uint32(message.courierGold);
    }
    if (message.roshanGold !== 0) {
      writer.uint32(232).uint32(message.roshanGold);
    }
    if (message.incomeGold !== 0) {
      writer.uint32(240).uint32(message.incomeGold);
    }
    if (message.itemValue !== 0) {
      writer.uint32(288).uint32(message.itemValue);
    }
    if (message.supportGoldSpent !== 0) {
      writer.uint32(296).uint32(message.supportGoldSpent);
    }
    if (message.campsStacked !== 0) {
      writer.uint32(304).uint32(message.campsStacked);
    }
    if (message.wardsPlaced !== 0) {
      writer.uint32(312).uint32(message.wardsPlaced);
    }
    if (message.tripleKills !== 0) {
      writer.uint32(320).uint32(message.tripleKills);
    }
    if (message.rampages !== 0) {
      writer.uint32(328).uint32(message.rampages);
    }
    for (const v of message.customStats) {
      CMatchPlayerTimedCustomStat.encode(v!, writer.uint32(338).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMatchPlayerTimedStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMatchPlayerTimedStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.time = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.assists = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.netWorth = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.xp = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.lastHits = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.denies = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.bountyRuneGold = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.rangeCreepUpgradeGold = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.observerWardsDewarded = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.reliableGoldEarned = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.goldLossPrevented = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.heroKillGold = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.creepKillGold = reader.uint32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.buildingGold = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.otherGold = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.comebackGold = reader.uint32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.experimentalGold = reader.uint32();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.experimental2Gold = reader.uint32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.creepDenyGold = reader.uint32();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.tpScrollsPurchased1 = reader.uint32();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.tpScrollsPurchased2 = reader.uint32();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.tpScrollsPurchased3 = reader.uint32();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.tpScrollsPurchased4 = reader.uint32();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.tpScrollsPurchased5 = reader.uint32();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.neutralGold = reader.uint32();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.courierGold = reader.uint32();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.roshanGold = reader.uint32();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.incomeGold = reader.uint32();
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }

          message.itemValue = reader.uint32();
          continue;
        }
        case 37: {
          if (tag !== 296) {
            break;
          }

          message.supportGoldSpent = reader.uint32();
          continue;
        }
        case 38: {
          if (tag !== 304) {
            break;
          }

          message.campsStacked = reader.uint32();
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }

          message.wardsPlaced = reader.uint32();
          continue;
        }
        case 40: {
          if (tag !== 320) {
            break;
          }

          message.tripleKills = reader.uint32();
          continue;
        }
        case 41: {
          if (tag !== 328) {
            break;
          }

          message.rampages = reader.uint32();
          continue;
        }
        case 42: {
          if (tag !== 338) {
            break;
          }

          message.customStats.push(CMatchPlayerTimedCustomStat.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMatchPlayerTimedStats {
    return {
      time: isSet(object.time) ? globalThis.Number(object.time) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      assists: isSet(object.assists) ? globalThis.Number(object.assists) : 0,
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      xp: isSet(object.xp) ? globalThis.Number(object.xp) : 0,
      lastHits: isSet(object.lastHits) ? globalThis.Number(object.lastHits) : 0,
      denies: isSet(object.denies) ? globalThis.Number(object.denies) : 0,
      bountyRuneGold: isSet(object.bountyRuneGold) ? globalThis.Number(object.bountyRuneGold) : 0,
      rangeCreepUpgradeGold: isSet(object.rangeCreepUpgradeGold) ? globalThis.Number(object.rangeCreepUpgradeGold) : 0,
      observerWardsDewarded: isSet(object.observerWardsDewarded) ? globalThis.Number(object.observerWardsDewarded) : 0,
      reliableGoldEarned: isSet(object.reliableGoldEarned) ? globalThis.Number(object.reliableGoldEarned) : 0,
      goldLossPrevented: isSet(object.goldLossPrevented) ? globalThis.Number(object.goldLossPrevented) : 0,
      heroKillGold: isSet(object.heroKillGold) ? globalThis.Number(object.heroKillGold) : 0,
      creepKillGold: isSet(object.creepKillGold) ? globalThis.Number(object.creepKillGold) : 0,
      buildingGold: isSet(object.buildingGold) ? globalThis.Number(object.buildingGold) : 0,
      otherGold: isSet(object.otherGold) ? globalThis.Number(object.otherGold) : 0,
      comebackGold: isSet(object.comebackGold) ? globalThis.Number(object.comebackGold) : 0,
      experimentalGold: isSet(object.experimentalGold) ? globalThis.Number(object.experimentalGold) : 0,
      experimental2Gold: isSet(object.experimental2Gold) ? globalThis.Number(object.experimental2Gold) : 0,
      creepDenyGold: isSet(object.creepDenyGold) ? globalThis.Number(object.creepDenyGold) : 0,
      tpScrollsPurchased1: isSet(object.tpScrollsPurchased1) ? globalThis.Number(object.tpScrollsPurchased1) : 0,
      tpScrollsPurchased2: isSet(object.tpScrollsPurchased2) ? globalThis.Number(object.tpScrollsPurchased2) : 0,
      tpScrollsPurchased3: isSet(object.tpScrollsPurchased3) ? globalThis.Number(object.tpScrollsPurchased3) : 0,
      tpScrollsPurchased4: isSet(object.tpScrollsPurchased4) ? globalThis.Number(object.tpScrollsPurchased4) : 0,
      tpScrollsPurchased5: isSet(object.tpScrollsPurchased5) ? globalThis.Number(object.tpScrollsPurchased5) : 0,
      neutralGold: isSet(object.neutralGold) ? globalThis.Number(object.neutralGold) : 0,
      courierGold: isSet(object.courierGold) ? globalThis.Number(object.courierGold) : 0,
      roshanGold: isSet(object.roshanGold) ? globalThis.Number(object.roshanGold) : 0,
      incomeGold: isSet(object.incomeGold) ? globalThis.Number(object.incomeGold) : 0,
      itemValue: isSet(object.itemValue) ? globalThis.Number(object.itemValue) : 0,
      supportGoldSpent: isSet(object.supportGoldSpent) ? globalThis.Number(object.supportGoldSpent) : 0,
      campsStacked: isSet(object.campsStacked) ? globalThis.Number(object.campsStacked) : 0,
      wardsPlaced: isSet(object.wardsPlaced) ? globalThis.Number(object.wardsPlaced) : 0,
      tripleKills: isSet(object.tripleKills) ? globalThis.Number(object.tripleKills) : 0,
      rampages: isSet(object.rampages) ? globalThis.Number(object.rampages) : 0,
      customStats: globalThis.Array.isArray(object?.customStats)
        ? object.customStats.map((e: any) => CMatchPlayerTimedCustomStat.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMatchPlayerTimedStats): unknown {
    const obj: any = {};
    if (message.time !== 0) {
      obj.time = Math.round(message.time);
    }
    if (message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.assists !== 0) {
      obj.assists = Math.round(message.assists);
    }
    if (message.netWorth !== 0) {
      obj.netWorth = Math.round(message.netWorth);
    }
    if (message.xp !== 0) {
      obj.xp = Math.round(message.xp);
    }
    if (message.lastHits !== 0) {
      obj.lastHits = Math.round(message.lastHits);
    }
    if (message.denies !== 0) {
      obj.denies = Math.round(message.denies);
    }
    if (message.bountyRuneGold !== 0) {
      obj.bountyRuneGold = Math.round(message.bountyRuneGold);
    }
    if (message.rangeCreepUpgradeGold !== 0) {
      obj.rangeCreepUpgradeGold = Math.round(message.rangeCreepUpgradeGold);
    }
    if (message.observerWardsDewarded !== 0) {
      obj.observerWardsDewarded = Math.round(message.observerWardsDewarded);
    }
    if (message.reliableGoldEarned !== 0) {
      obj.reliableGoldEarned = Math.round(message.reliableGoldEarned);
    }
    if (message.goldLossPrevented !== 0) {
      obj.goldLossPrevented = Math.round(message.goldLossPrevented);
    }
    if (message.heroKillGold !== 0) {
      obj.heroKillGold = Math.round(message.heroKillGold);
    }
    if (message.creepKillGold !== 0) {
      obj.creepKillGold = Math.round(message.creepKillGold);
    }
    if (message.buildingGold !== 0) {
      obj.buildingGold = Math.round(message.buildingGold);
    }
    if (message.otherGold !== 0) {
      obj.otherGold = Math.round(message.otherGold);
    }
    if (message.comebackGold !== 0) {
      obj.comebackGold = Math.round(message.comebackGold);
    }
    if (message.experimentalGold !== 0) {
      obj.experimentalGold = Math.round(message.experimentalGold);
    }
    if (message.experimental2Gold !== 0) {
      obj.experimental2Gold = Math.round(message.experimental2Gold);
    }
    if (message.creepDenyGold !== 0) {
      obj.creepDenyGold = Math.round(message.creepDenyGold);
    }
    if (message.tpScrollsPurchased1 !== 0) {
      obj.tpScrollsPurchased1 = Math.round(message.tpScrollsPurchased1);
    }
    if (message.tpScrollsPurchased2 !== 0) {
      obj.tpScrollsPurchased2 = Math.round(message.tpScrollsPurchased2);
    }
    if (message.tpScrollsPurchased3 !== 0) {
      obj.tpScrollsPurchased3 = Math.round(message.tpScrollsPurchased3);
    }
    if (message.tpScrollsPurchased4 !== 0) {
      obj.tpScrollsPurchased4 = Math.round(message.tpScrollsPurchased4);
    }
    if (message.tpScrollsPurchased5 !== 0) {
      obj.tpScrollsPurchased5 = Math.round(message.tpScrollsPurchased5);
    }
    if (message.neutralGold !== 0) {
      obj.neutralGold = Math.round(message.neutralGold);
    }
    if (message.courierGold !== 0) {
      obj.courierGold = Math.round(message.courierGold);
    }
    if (message.roshanGold !== 0) {
      obj.roshanGold = Math.round(message.roshanGold);
    }
    if (message.incomeGold !== 0) {
      obj.incomeGold = Math.round(message.incomeGold);
    }
    if (message.itemValue !== 0) {
      obj.itemValue = Math.round(message.itemValue);
    }
    if (message.supportGoldSpent !== 0) {
      obj.supportGoldSpent = Math.round(message.supportGoldSpent);
    }
    if (message.campsStacked !== 0) {
      obj.campsStacked = Math.round(message.campsStacked);
    }
    if (message.wardsPlaced !== 0) {
      obj.wardsPlaced = Math.round(message.wardsPlaced);
    }
    if (message.tripleKills !== 0) {
      obj.tripleKills = Math.round(message.tripleKills);
    }
    if (message.rampages !== 0) {
      obj.rampages = Math.round(message.rampages);
    }
    if (message.customStats?.length) {
      obj.customStats = message.customStats.map((e) => CMatchPlayerTimedCustomStat.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMatchPlayerTimedStats>): CMatchPlayerTimedStats {
    return CMatchPlayerTimedStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMatchPlayerTimedStats>): CMatchPlayerTimedStats {
    const message = createBaseCMatchPlayerTimedStats();
    message.time = object.time ?? 0;
    message.kills = object.kills ?? 0;
    message.deaths = object.deaths ?? 0;
    message.assists = object.assists ?? 0;
    message.netWorth = object.netWorth ?? 0;
    message.xp = object.xp ?? 0;
    message.lastHits = object.lastHits ?? 0;
    message.denies = object.denies ?? 0;
    message.bountyRuneGold = object.bountyRuneGold ?? 0;
    message.rangeCreepUpgradeGold = object.rangeCreepUpgradeGold ?? 0;
    message.observerWardsDewarded = object.observerWardsDewarded ?? 0;
    message.reliableGoldEarned = object.reliableGoldEarned ?? 0;
    message.goldLossPrevented = object.goldLossPrevented ?? 0;
    message.heroKillGold = object.heroKillGold ?? 0;
    message.creepKillGold = object.creepKillGold ?? 0;
    message.buildingGold = object.buildingGold ?? 0;
    message.otherGold = object.otherGold ?? 0;
    message.comebackGold = object.comebackGold ?? 0;
    message.experimentalGold = object.experimentalGold ?? 0;
    message.experimental2Gold = object.experimental2Gold ?? 0;
    message.creepDenyGold = object.creepDenyGold ?? 0;
    message.tpScrollsPurchased1 = object.tpScrollsPurchased1 ?? 0;
    message.tpScrollsPurchased2 = object.tpScrollsPurchased2 ?? 0;
    message.tpScrollsPurchased3 = object.tpScrollsPurchased3 ?? 0;
    message.tpScrollsPurchased4 = object.tpScrollsPurchased4 ?? 0;
    message.tpScrollsPurchased5 = object.tpScrollsPurchased5 ?? 0;
    message.neutralGold = object.neutralGold ?? 0;
    message.courierGold = object.courierGold ?? 0;
    message.roshanGold = object.roshanGold ?? 0;
    message.incomeGold = object.incomeGold ?? 0;
    message.itemValue = object.itemValue ?? 0;
    message.supportGoldSpent = object.supportGoldSpent ?? 0;
    message.campsStacked = object.campsStacked ?? 0;
    message.wardsPlaced = object.wardsPlaced ?? 0;
    message.tripleKills = object.tripleKills ?? 0;
    message.rampages = object.rampages ?? 0;
    message.customStats = object.customStats?.map((e) => CMatchPlayerTimedCustomStat.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMatchTeamTimedStats(): CMatchTeamTimedStats {
  return { time: 0, enemyTowersKilled: 0, enemyBarracksKilled: 0, enemyTowersStatus: 0, enemyBarracksStatus: 0 };
}

export const CMatchTeamTimedStats: MessageFns<CMatchTeamTimedStats> = {
  encode(message: CMatchTeamTimedStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.time !== 0) {
      writer.uint32(8).uint32(message.time);
    }
    if (message.enemyTowersKilled !== 0) {
      writer.uint32(16).uint32(message.enemyTowersKilled);
    }
    if (message.enemyBarracksKilled !== 0) {
      writer.uint32(24).uint32(message.enemyBarracksKilled);
    }
    if (message.enemyTowersStatus !== 0) {
      writer.uint32(32).uint32(message.enemyTowersStatus);
    }
    if (message.enemyBarracksStatus !== 0) {
      writer.uint32(40).uint32(message.enemyBarracksStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMatchTeamTimedStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMatchTeamTimedStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.time = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enemyTowersKilled = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.enemyBarracksKilled = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.enemyTowersStatus = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.enemyBarracksStatus = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMatchTeamTimedStats {
    return {
      time: isSet(object.time) ? globalThis.Number(object.time) : 0,
      enemyTowersKilled: isSet(object.enemyTowersKilled) ? globalThis.Number(object.enemyTowersKilled) : 0,
      enemyBarracksKilled: isSet(object.enemyBarracksKilled) ? globalThis.Number(object.enemyBarracksKilled) : 0,
      enemyTowersStatus: isSet(object.enemyTowersStatus) ? globalThis.Number(object.enemyTowersStatus) : 0,
      enemyBarracksStatus: isSet(object.enemyBarracksStatus) ? globalThis.Number(object.enemyBarracksStatus) : 0,
    };
  },

  toJSON(message: CMatchTeamTimedStats): unknown {
    const obj: any = {};
    if (message.time !== 0) {
      obj.time = Math.round(message.time);
    }
    if (message.enemyTowersKilled !== 0) {
      obj.enemyTowersKilled = Math.round(message.enemyTowersKilled);
    }
    if (message.enemyBarracksKilled !== 0) {
      obj.enemyBarracksKilled = Math.round(message.enemyBarracksKilled);
    }
    if (message.enemyTowersStatus !== 0) {
      obj.enemyTowersStatus = Math.round(message.enemyTowersStatus);
    }
    if (message.enemyBarracksStatus !== 0) {
      obj.enemyBarracksStatus = Math.round(message.enemyBarracksStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<CMatchTeamTimedStats>): CMatchTeamTimedStats {
    return CMatchTeamTimedStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMatchTeamTimedStats>): CMatchTeamTimedStats {
    const message = createBaseCMatchTeamTimedStats();
    message.time = object.time ?? 0;
    message.enemyTowersKilled = object.enemyTowersKilled ?? 0;
    message.enemyBarracksKilled = object.enemyBarracksKilled ?? 0;
    message.enemyTowersStatus = object.enemyTowersStatus ?? 0;
    message.enemyBarracksStatus = object.enemyBarracksStatus ?? 0;
    return message;
  },
};

function createBaseCMatchAdditionalUnitInventory(): CMatchAdditionalUnitInventory {
  return { unitName: "", items: [] };
}

export const CMatchAdditionalUnitInventory: MessageFns<CMatchAdditionalUnitInventory> = {
  encode(message: CMatchAdditionalUnitInventory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unitName !== "") {
      writer.uint32(10).string(message.unitName);
    }
    writer.uint32(18).fork();
    for (const v of message.items) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMatchAdditionalUnitInventory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMatchAdditionalUnitInventory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unitName = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.items.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.items.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMatchAdditionalUnitInventory {
    return {
      unitName: isSet(object.unitName) ? globalThis.String(object.unitName) : "",
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CMatchAdditionalUnitInventory): unknown {
    const obj: any = {};
    if (message.unitName !== "") {
      obj.unitName = message.unitName;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMatchAdditionalUnitInventory>): CMatchAdditionalUnitInventory {
    return CMatchAdditionalUnitInventory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMatchAdditionalUnitInventory>): CMatchAdditionalUnitInventory {
    const message = createBaseCMatchAdditionalUnitInventory();
    message.unitName = object.unitName ?? "";
    message.items = object.items?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMatchPlayerPermanentBuff(): CMatchPlayerPermanentBuff {
  return { permanentBuff: 0, stackCount: 0, grantTime: 0 };
}

export const CMatchPlayerPermanentBuff: MessageFns<CMatchPlayerPermanentBuff> = {
  encode(message: CMatchPlayerPermanentBuff, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.permanentBuff !== 0) {
      writer.uint32(8).uint32(message.permanentBuff);
    }
    if (message.stackCount !== 0) {
      writer.uint32(16).uint32(message.stackCount);
    }
    if (message.grantTime !== 0) {
      writer.uint32(24).uint32(message.grantTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMatchPlayerPermanentBuff {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMatchPlayerPermanentBuff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.permanentBuff = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.stackCount = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.grantTime = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMatchPlayerPermanentBuff {
    return {
      permanentBuff: isSet(object.permanentBuff) ? globalThis.Number(object.permanentBuff) : 0,
      stackCount: isSet(object.stackCount) ? globalThis.Number(object.stackCount) : 0,
      grantTime: isSet(object.grantTime) ? globalThis.Number(object.grantTime) : 0,
    };
  },

  toJSON(message: CMatchPlayerPermanentBuff): unknown {
    const obj: any = {};
    if (message.permanentBuff !== 0) {
      obj.permanentBuff = Math.round(message.permanentBuff);
    }
    if (message.stackCount !== 0) {
      obj.stackCount = Math.round(message.stackCount);
    }
    if (message.grantTime !== 0) {
      obj.grantTime = Math.round(message.grantTime);
    }
    return obj;
  },

  create(base?: DeepPartial<CMatchPlayerPermanentBuff>): CMatchPlayerPermanentBuff {
    return CMatchPlayerPermanentBuff.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMatchPlayerPermanentBuff>): CMatchPlayerPermanentBuff {
    const message = createBaseCMatchPlayerPermanentBuff();
    message.permanentBuff = object.permanentBuff ?? 0;
    message.stackCount = object.stackCount ?? 0;
    message.grantTime = object.grantTime ?? 0;
    return message;
  },
};

function createBaseCMatchHeroSelectEvent(): CMatchHeroSelectEvent {
  return { isPick: false, team: 0, heroId: 0 };
}

export const CMatchHeroSelectEvent: MessageFns<CMatchHeroSelectEvent> = {
  encode(message: CMatchHeroSelectEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isPick !== false) {
      writer.uint32(8).bool(message.isPick);
    }
    if (message.team !== 0) {
      writer.uint32(16).uint32(message.team);
    }
    if (message.heroId !== 0) {
      writer.uint32(24).uint32(message.heroId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMatchHeroSelectEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMatchHeroSelectEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isPick = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.team = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMatchHeroSelectEvent {
    return {
      isPick: isSet(object.isPick) ? globalThis.Boolean(object.isPick) : false,
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
    };
  },

  toJSON(message: CMatchHeroSelectEvent): unknown {
    const obj: any = {};
    if (message.isPick !== false) {
      obj.isPick = message.isPick;
    }
    if (message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMatchHeroSelectEvent>): CMatchHeroSelectEvent {
    return CMatchHeroSelectEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMatchHeroSelectEvent>): CMatchHeroSelectEvent {
    const message = createBaseCMatchHeroSelectEvent();
    message.isPick = object.isPick ?? false;
    message.team = object.team ?? 0;
    message.heroId = object.heroId ?? 0;
    return message;
  },
};

function createBaseCMatchClip(): CMatchClip {
  return {
    matchId: "0",
    playerAccountId: 0,
    gameTimeSeconds: 0,
    durationSeconds: 0,
    playerId: 0,
    heroId: 0,
    abilityId: -1,
    cameraMode: 0,
    comment: "",
  };
}

export const CMatchClip: MessageFns<CMatchClip> = {
  encode(message: CMatchClip, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.playerAccountId !== 0) {
      writer.uint32(16).uint32(message.playerAccountId);
    }
    if (message.gameTimeSeconds !== 0) {
      writer.uint32(24).uint32(message.gameTimeSeconds);
    }
    if (message.durationSeconds !== 0) {
      writer.uint32(32).uint32(message.durationSeconds);
    }
    if (message.playerId !== 0) {
      writer.uint32(40).uint32(message.playerId);
    }
    if (message.heroId !== 0) {
      writer.uint32(48).uint32(message.heroId);
    }
    if (message.abilityId !== -1) {
      writer.uint32(56).int32(message.abilityId);
    }
    if (message.cameraMode !== 0) {
      writer.uint32(64).uint32(message.cameraMode);
    }
    if (message.comment !== "") {
      writer.uint32(74).string(message.comment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMatchClip {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMatchClip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.matchId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.playerAccountId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.gameTimeSeconds = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.durationSeconds = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.playerId = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.abilityId = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.cameraMode = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMatchClip {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      playerAccountId: isSet(object.playerAccountId) ? globalThis.Number(object.playerAccountId) : 0,
      gameTimeSeconds: isSet(object.gameTimeSeconds) ? globalThis.Number(object.gameTimeSeconds) : 0,
      durationSeconds: isSet(object.durationSeconds) ? globalThis.Number(object.durationSeconds) : 0,
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      abilityId: isSet(object.abilityId) ? globalThis.Number(object.abilityId) : -1,
      cameraMode: isSet(object.cameraMode) ? globalThis.Number(object.cameraMode) : 0,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
    };
  },

  toJSON(message: CMatchClip): unknown {
    const obj: any = {};
    if (message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.playerAccountId !== 0) {
      obj.playerAccountId = Math.round(message.playerAccountId);
    }
    if (message.gameTimeSeconds !== 0) {
      obj.gameTimeSeconds = Math.round(message.gameTimeSeconds);
    }
    if (message.durationSeconds !== 0) {
      obj.durationSeconds = Math.round(message.durationSeconds);
    }
    if (message.playerId !== 0) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.abilityId !== -1) {
      obj.abilityId = Math.round(message.abilityId);
    }
    if (message.cameraMode !== 0) {
      obj.cameraMode = Math.round(message.cameraMode);
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    return obj;
  },

  create(base?: DeepPartial<CMatchClip>): CMatchClip {
    return CMatchClip.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMatchClip>): CMatchClip {
    const message = createBaseCMatchClip();
    message.matchId = object.matchId ?? "0";
    message.playerAccountId = object.playerAccountId ?? 0;
    message.gameTimeSeconds = object.gameTimeSeconds ?? 0;
    message.durationSeconds = object.durationSeconds ?? 0;
    message.playerId = object.playerId ?? 0;
    message.heroId = object.heroId ?? 0;
    message.abilityId = object.abilityId ?? -1;
    message.cameraMode = object.cameraMode ?? 0;
    message.comment = object.comment ?? "";
    return message;
  },
};

function createBaseCPartySearchClientParty(): CPartySearchClientParty {
  return { partyId: "0", beaconType: 0, partyMembers: [] };
}

export const CPartySearchClientParty: MessageFns<CPartySearchClientParty> = {
  encode(message: CPartySearchClientParty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.partyId !== "0") {
      writer.uint32(9).fixed64(message.partyId);
    }
    if (message.beaconType !== 0) {
      writer.uint32(16).int32(message.beaconType);
    }
    writer.uint32(26).fork();
    for (const v of message.partyMembers) {
      writer.fixed32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CPartySearchClientParty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCPartySearchClientParty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.partyId = reader.fixed64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.beaconType = reader.int32();
          continue;
        }
        case 3: {
          if (tag === 29) {
            message.partyMembers.push(reader.fixed32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.partyMembers.push(reader.fixed32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CPartySearchClientParty {
    return {
      partyId: isSet(object.partyId) ? globalThis.String(object.partyId) : "0",
      beaconType: isSet(object.beaconType) ? globalThis.Number(object.beaconType) : 0,
      partyMembers: globalThis.Array.isArray(object?.partyMembers)
        ? object.partyMembers.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CPartySearchClientParty): unknown {
    const obj: any = {};
    if (message.partyId !== "0") {
      obj.partyId = message.partyId;
    }
    if (message.beaconType !== 0) {
      obj.beaconType = Math.round(message.beaconType);
    }
    if (message.partyMembers?.length) {
      obj.partyMembers = message.partyMembers.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CPartySearchClientParty>): CPartySearchClientParty {
    return CPartySearchClientParty.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CPartySearchClientParty>): CPartySearchClientParty {
    const message = createBaseCPartySearchClientParty();
    message.partyId = object.partyId ?? "0";
    message.beaconType = object.beaconType ?? 0;
    message.partyMembers = object.partyMembers?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgDOTAHasItemQuery(): CMsgDOTAHasItemQuery {
  return { accountId: 0, itemId: "0" };
}

export const CMsgDOTAHasItemQuery: MessageFns<CMsgDOTAHasItemQuery> = {
  encode(message: CMsgDOTAHasItemQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.itemId !== "0") {
      writer.uint32(16).uint64(message.itemId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAHasItemQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAHasItemQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.itemId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAHasItemQuery {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "0",
    };
  },

  toJSON(message: CMsgDOTAHasItemQuery): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.itemId !== "0") {
      obj.itemId = message.itemId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAHasItemQuery>): CMsgDOTAHasItemQuery {
    return CMsgDOTAHasItemQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAHasItemQuery>): CMsgDOTAHasItemQuery {
    const message = createBaseCMsgDOTAHasItemQuery();
    message.accountId = object.accountId ?? 0;
    message.itemId = object.itemId ?? "0";
    return message;
  },
};

function createBaseCMsgDOTAHasItemResponse(): CMsgDOTAHasItemResponse {
  return { hasItem: false };
}

export const CMsgDOTAHasItemResponse: MessageFns<CMsgDOTAHasItemResponse> = {
  encode(message: CMsgDOTAHasItemResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hasItem !== false) {
      writer.uint32(8).bool(message.hasItem);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAHasItemResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAHasItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hasItem = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAHasItemResponse {
    return { hasItem: isSet(object.hasItem) ? globalThis.Boolean(object.hasItem) : false };
  },

  toJSON(message: CMsgDOTAHasItemResponse): unknown {
    const obj: any = {};
    if (message.hasItem !== false) {
      obj.hasItem = message.hasItem;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAHasItemResponse>): CMsgDOTAHasItemResponse {
    return CMsgDOTAHasItemResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAHasItemResponse>): CMsgDOTAHasItemResponse {
    const message = createBaseCMsgDOTAHasItemResponse();
    message.hasItem = object.hasItem ?? false;
    return message;
  },
};

function createBaseCMsgGCGetPlayerCardItemInfo(): CMsgGCGetPlayerCardItemInfo {
  return { accountId: 0, playerCardItemIds: [], allForEvent: 0 };
}

export const CMsgGCGetPlayerCardItemInfo: MessageFns<CMsgGCGetPlayerCardItemInfo> = {
  encode(message: CMsgGCGetPlayerCardItemInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    writer.uint32(18).fork();
    for (const v of message.playerCardItemIds) {
      writer.uint64(v);
    }
    writer.join();
    if (message.allForEvent !== 0) {
      writer.uint32(24).uint32(message.allForEvent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCGetPlayerCardItemInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetPlayerCardItemInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.playerCardItemIds.push(reader.uint64().toString());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.playerCardItemIds.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.allForEvent = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetPlayerCardItemInfo {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      playerCardItemIds: globalThis.Array.isArray(object?.playerCardItemIds)
        ? object.playerCardItemIds.map((e: any) => globalThis.String(e))
        : [],
      allForEvent: isSet(object.allForEvent) ? globalThis.Number(object.allForEvent) : 0,
    };
  },

  toJSON(message: CMsgGCGetPlayerCardItemInfo): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.playerCardItemIds?.length) {
      obj.playerCardItemIds = message.playerCardItemIds;
    }
    if (message.allForEvent !== 0) {
      obj.allForEvent = Math.round(message.allForEvent);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCGetPlayerCardItemInfo>): CMsgGCGetPlayerCardItemInfo {
    return CMsgGCGetPlayerCardItemInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCGetPlayerCardItemInfo>): CMsgGCGetPlayerCardItemInfo {
    const message = createBaseCMsgGCGetPlayerCardItemInfo();
    message.accountId = object.accountId ?? 0;
    message.playerCardItemIds = object.playerCardItemIds?.map((e) => e) || [];
    message.allForEvent = object.allForEvent ?? 0;
    return message;
  },
};

function createBaseCMsgGCGetPlayerCardItemInfoResponse(): CMsgGCGetPlayerCardItemInfoResponse {
  return { playerCardInfos: [] };
}

export const CMsgGCGetPlayerCardItemInfoResponse: MessageFns<CMsgGCGetPlayerCardItemInfoResponse> = {
  encode(message: CMsgGCGetPlayerCardItemInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.playerCardInfos) {
      CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCGetPlayerCardItemInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetPlayerCardItemInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerCardInfos.push(
            CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetPlayerCardItemInfoResponse {
    return {
      playerCardInfos: globalThis.Array.isArray(object?.playerCardInfos)
        ? object.playerCardInfos.map((e: any) => CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCGetPlayerCardItemInfoResponse): unknown {
    const obj: any = {};
    if (message.playerCardInfos?.length) {
      obj.playerCardInfos = message.playerCardInfos.map((e) =>
        CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCGetPlayerCardItemInfoResponse>): CMsgGCGetPlayerCardItemInfoResponse {
    return CMsgGCGetPlayerCardItemInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCGetPlayerCardItemInfoResponse>): CMsgGCGetPlayerCardItemInfoResponse {
    const message = createBaseCMsgGCGetPlayerCardItemInfoResponse();
    message.playerCardInfos =
      object.playerCardInfos?.map((e) => CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo(): CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
  return { playerCardItemId: "0", accountId: 0, packedBonuses: "0" };
}

export const CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo: MessageFns<
  CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo
> = {
  encode(
    message: CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.playerCardItemId !== "0") {
      writer.uint32(8).uint64(message.playerCardItemId);
    }
    if (message.accountId !== 0) {
      writer.uint32(16).uint32(message.accountId);
    }
    if (message.packedBonuses !== "0") {
      writer.uint32(24).uint64(message.packedBonuses);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.playerCardItemId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.packedBonuses = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
    return {
      playerCardItemId: isSet(object.playerCardItemId) ? globalThis.String(object.playerCardItemId) : "0",
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      packedBonuses: isSet(object.packedBonuses) ? globalThis.String(object.packedBonuses) : "0",
    };
  },

  toJSON(message: CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo): unknown {
    const obj: any = {};
    if (message.playerCardItemId !== "0") {
      obj.playerCardItemId = message.playerCardItemId;
    }
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.packedBonuses !== "0") {
      obj.packedBonuses = message.packedBonuses;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo>,
  ): CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
    return CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo>,
  ): CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
    const message = createBaseCMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo();
    message.playerCardItemId = object.playerCardItemId ?? "0";
    message.accountId = object.accountId ?? 0;
    message.packedBonuses = object.packedBonuses ?? "0";
    return message;
  },
};

function createBaseCSODOTAMapLocationState(): CSODOTAMapLocationState {
  return { accountId: 0, locationId: 0, completed: false };
}

export const CSODOTAMapLocationState: MessageFns<CSODOTAMapLocationState> = {
  encode(message: CSODOTAMapLocationState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.locationId !== 0) {
      writer.uint32(16).int32(message.locationId);
    }
    if (message.completed !== false) {
      writer.uint32(24).bool(message.completed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CSODOTAMapLocationState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSODOTAMapLocationState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.locationId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.completed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSODOTAMapLocationState {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      locationId: isSet(object.locationId) ? globalThis.Number(object.locationId) : 0,
      completed: isSet(object.completed) ? globalThis.Boolean(object.completed) : false,
    };
  },

  toJSON(message: CSODOTAMapLocationState): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.locationId !== 0) {
      obj.locationId = Math.round(message.locationId);
    }
    if (message.completed !== false) {
      obj.completed = message.completed;
    }
    return obj;
  },

  create(base?: DeepPartial<CSODOTAMapLocationState>): CSODOTAMapLocationState {
    return CSODOTAMapLocationState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSODOTAMapLocationState>): CSODOTAMapLocationState {
    const message = createBaseCSODOTAMapLocationState();
    message.accountId = object.accountId ?? 0;
    message.locationId = object.locationId ?? 0;
    message.completed = object.completed ?? false;
    return message;
  },
};

function createBaseCMsgLeagueAdminList(): CMsgLeagueAdminList {
  return { accountIds: [] };
}

export const CMsgLeagueAdminList: MessageFns<CMsgLeagueAdminList> = {
  encode(message: CMsgLeagueAdminList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.accountIds) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgLeagueAdminList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLeagueAdminList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.accountIds.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.accountIds.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLeagueAdminList {
    return {
      accountIds: globalThis.Array.isArray(object?.accountIds)
        ? object.accountIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgLeagueAdminList): unknown {
    const obj: any = {};
    if (message.accountIds?.length) {
      obj.accountIds = message.accountIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLeagueAdminList>): CMsgLeagueAdminList {
    return CMsgLeagueAdminList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLeagueAdminList>): CMsgLeagueAdminList {
    const message = createBaseCMsgLeagueAdminList();
    message.accountIds = object.accountIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgDOTAProfileCard(): CMsgDOTAProfileCard {
  return {
    accountId: 0,
    slots: [],
    badgePoints: 0,
    eventPoints: 0,
    eventId: 0,
    recentBattleCupVictory: undefined,
    rankTier: 0,
    leaderboardRank: 0,
    isPlusSubscriber: false,
    plusOriginalStartDate: 0,
    rankTierScore: 0,
    leaderboardRankCore: 0,
    title: 0,
    favoriteTeamPacked: "0",
    lifetimeGames: 0,
  };
}

export const CMsgDOTAProfileCard: MessageFns<CMsgDOTAProfileCard> = {
  encode(message: CMsgDOTAProfileCard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    for (const v of message.slots) {
      CMsgDOTAProfileCard_Slot.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.badgePoints !== 0) {
      writer.uint32(32).uint32(message.badgePoints);
    }
    if (message.eventPoints !== 0) {
      writer.uint32(40).uint32(message.eventPoints);
    }
    if (message.eventId !== 0) {
      writer.uint32(48).uint32(message.eventId);
    }
    if (message.recentBattleCupVictory !== undefined) {
      CMsgBattleCupVictory.encode(message.recentBattleCupVictory, writer.uint32(58).fork()).join();
    }
    if (message.rankTier !== 0) {
      writer.uint32(64).uint32(message.rankTier);
    }
    if (message.leaderboardRank !== 0) {
      writer.uint32(72).uint32(message.leaderboardRank);
    }
    if (message.isPlusSubscriber !== false) {
      writer.uint32(80).bool(message.isPlusSubscriber);
    }
    if (message.plusOriginalStartDate !== 0) {
      writer.uint32(88).uint32(message.plusOriginalStartDate);
    }
    if (message.rankTierScore !== 0) {
      writer.uint32(96).uint32(message.rankTierScore);
    }
    if (message.leaderboardRankCore !== 0) {
      writer.uint32(136).uint32(message.leaderboardRankCore);
    }
    if (message.title !== 0) {
      writer.uint32(184).uint32(message.title);
    }
    if (message.favoriteTeamPacked !== "0") {
      writer.uint32(192).uint64(message.favoriteTeamPacked);
    }
    if (message.lifetimeGames !== 0) {
      writer.uint32(200).uint32(message.lifetimeGames);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAProfileCard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAProfileCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.slots.push(CMsgDOTAProfileCard_Slot.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.badgePoints = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.eventPoints = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.recentBattleCupVictory = CMsgBattleCupVictory.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.rankTier = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.leaderboardRank = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isPlusSubscriber = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.plusOriginalStartDate = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.rankTierScore = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.leaderboardRankCore = reader.uint32();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.title = reader.uint32();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.favoriteTeamPacked = reader.uint64().toString();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.lifetimeGames = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAProfileCard {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      slots: globalThis.Array.isArray(object?.slots)
        ? object.slots.map((e: any) => CMsgDOTAProfileCard_Slot.fromJSON(e))
        : [],
      badgePoints: isSet(object.badgePoints) ? globalThis.Number(object.badgePoints) : 0,
      eventPoints: isSet(object.eventPoints) ? globalThis.Number(object.eventPoints) : 0,
      eventId: isSet(object.eventId) ? globalThis.Number(object.eventId) : 0,
      recentBattleCupVictory: isSet(object.recentBattleCupVictory)
        ? CMsgBattleCupVictory.fromJSON(object.recentBattleCupVictory)
        : undefined,
      rankTier: isSet(object.rankTier) ? globalThis.Number(object.rankTier) : 0,
      leaderboardRank: isSet(object.leaderboardRank) ? globalThis.Number(object.leaderboardRank) : 0,
      isPlusSubscriber: isSet(object.isPlusSubscriber) ? globalThis.Boolean(object.isPlusSubscriber) : false,
      plusOriginalStartDate: isSet(object.plusOriginalStartDate) ? globalThis.Number(object.plusOriginalStartDate) : 0,
      rankTierScore: isSet(object.rankTierScore) ? globalThis.Number(object.rankTierScore) : 0,
      leaderboardRankCore: isSet(object.leaderboardRankCore) ? globalThis.Number(object.leaderboardRankCore) : 0,
      title: isSet(object.title) ? globalThis.Number(object.title) : 0,
      favoriteTeamPacked: isSet(object.favoriteTeamPacked) ? globalThis.String(object.favoriteTeamPacked) : "0",
      lifetimeGames: isSet(object.lifetimeGames) ? globalThis.Number(object.lifetimeGames) : 0,
    };
  },

  toJSON(message: CMsgDOTAProfileCard): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.slots?.length) {
      obj.slots = message.slots.map((e) => CMsgDOTAProfileCard_Slot.toJSON(e));
    }
    if (message.badgePoints !== 0) {
      obj.badgePoints = Math.round(message.badgePoints);
    }
    if (message.eventPoints !== 0) {
      obj.eventPoints = Math.round(message.eventPoints);
    }
    if (message.eventId !== 0) {
      obj.eventId = Math.round(message.eventId);
    }
    if (message.recentBattleCupVictory !== undefined) {
      obj.recentBattleCupVictory = CMsgBattleCupVictory.toJSON(message.recentBattleCupVictory);
    }
    if (message.rankTier !== 0) {
      obj.rankTier = Math.round(message.rankTier);
    }
    if (message.leaderboardRank !== 0) {
      obj.leaderboardRank = Math.round(message.leaderboardRank);
    }
    if (message.isPlusSubscriber !== false) {
      obj.isPlusSubscriber = message.isPlusSubscriber;
    }
    if (message.plusOriginalStartDate !== 0) {
      obj.plusOriginalStartDate = Math.round(message.plusOriginalStartDate);
    }
    if (message.rankTierScore !== 0) {
      obj.rankTierScore = Math.round(message.rankTierScore);
    }
    if (message.leaderboardRankCore !== 0) {
      obj.leaderboardRankCore = Math.round(message.leaderboardRankCore);
    }
    if (message.title !== 0) {
      obj.title = Math.round(message.title);
    }
    if (message.favoriteTeamPacked !== "0") {
      obj.favoriteTeamPacked = message.favoriteTeamPacked;
    }
    if (message.lifetimeGames !== 0) {
      obj.lifetimeGames = Math.round(message.lifetimeGames);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAProfileCard>): CMsgDOTAProfileCard {
    return CMsgDOTAProfileCard.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAProfileCard>): CMsgDOTAProfileCard {
    const message = createBaseCMsgDOTAProfileCard();
    message.accountId = object.accountId ?? 0;
    message.slots = object.slots?.map((e) => CMsgDOTAProfileCard_Slot.fromPartial(e)) || [];
    message.badgePoints = object.badgePoints ?? 0;
    message.eventPoints = object.eventPoints ?? 0;
    message.eventId = object.eventId ?? 0;
    message.recentBattleCupVictory =
      (object.recentBattleCupVictory !== undefined && object.recentBattleCupVictory !== null)
        ? CMsgBattleCupVictory.fromPartial(object.recentBattleCupVictory)
        : undefined;
    message.rankTier = object.rankTier ?? 0;
    message.leaderboardRank = object.leaderboardRank ?? 0;
    message.isPlusSubscriber = object.isPlusSubscriber ?? false;
    message.plusOriginalStartDate = object.plusOriginalStartDate ?? 0;
    message.rankTierScore = object.rankTierScore ?? 0;
    message.leaderboardRankCore = object.leaderboardRankCore ?? 0;
    message.title = object.title ?? 0;
    message.favoriteTeamPacked = object.favoriteTeamPacked ?? "0";
    message.lifetimeGames = object.lifetimeGames ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAProfileCard_Slot(): CMsgDOTAProfileCard_Slot {
  return {
    slotId: 0,
    trophy: undefined,
    stat: undefined,
    item: undefined,
    hero: undefined,
    emoticon: undefined,
    team: undefined,
  };
}

export const CMsgDOTAProfileCard_Slot: MessageFns<CMsgDOTAProfileCard_Slot> = {
  encode(message: CMsgDOTAProfileCard_Slot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.slotId !== 0) {
      writer.uint32(8).uint32(message.slotId);
    }
    if (message.trophy !== undefined) {
      CMsgDOTAProfileCard_Slot_Trophy.encode(message.trophy, writer.uint32(18).fork()).join();
    }
    if (message.stat !== undefined) {
      CMsgDOTAProfileCard_Slot_Stat.encode(message.stat, writer.uint32(26).fork()).join();
    }
    if (message.item !== undefined) {
      CMsgDOTAProfileCard_Slot_Item.encode(message.item, writer.uint32(34).fork()).join();
    }
    if (message.hero !== undefined) {
      CMsgDOTAProfileCard_Slot_Hero.encode(message.hero, writer.uint32(42).fork()).join();
    }
    if (message.emoticon !== undefined) {
      CMsgDOTAProfileCard_Slot_Emoticon.encode(message.emoticon, writer.uint32(50).fork()).join();
    }
    if (message.team !== undefined) {
      CMsgDOTAProfileCard_Slot_Team.encode(message.team, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAProfileCard_Slot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAProfileCard_Slot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.slotId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trophy = CMsgDOTAProfileCard_Slot_Trophy.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stat = CMsgDOTAProfileCard_Slot_Stat.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.item = CMsgDOTAProfileCard_Slot_Item.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.hero = CMsgDOTAProfileCard_Slot_Hero.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.emoticon = CMsgDOTAProfileCard_Slot_Emoticon.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.team = CMsgDOTAProfileCard_Slot_Team.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAProfileCard_Slot {
    return {
      slotId: isSet(object.slotId) ? globalThis.Number(object.slotId) : 0,
      trophy: isSet(object.trophy) ? CMsgDOTAProfileCard_Slot_Trophy.fromJSON(object.trophy) : undefined,
      stat: isSet(object.stat) ? CMsgDOTAProfileCard_Slot_Stat.fromJSON(object.stat) : undefined,
      item: isSet(object.item) ? CMsgDOTAProfileCard_Slot_Item.fromJSON(object.item) : undefined,
      hero: isSet(object.hero) ? CMsgDOTAProfileCard_Slot_Hero.fromJSON(object.hero) : undefined,
      emoticon: isSet(object.emoticon) ? CMsgDOTAProfileCard_Slot_Emoticon.fromJSON(object.emoticon) : undefined,
      team: isSet(object.team) ? CMsgDOTAProfileCard_Slot_Team.fromJSON(object.team) : undefined,
    };
  },

  toJSON(message: CMsgDOTAProfileCard_Slot): unknown {
    const obj: any = {};
    if (message.slotId !== 0) {
      obj.slotId = Math.round(message.slotId);
    }
    if (message.trophy !== undefined) {
      obj.trophy = CMsgDOTAProfileCard_Slot_Trophy.toJSON(message.trophy);
    }
    if (message.stat !== undefined) {
      obj.stat = CMsgDOTAProfileCard_Slot_Stat.toJSON(message.stat);
    }
    if (message.item !== undefined) {
      obj.item = CMsgDOTAProfileCard_Slot_Item.toJSON(message.item);
    }
    if (message.hero !== undefined) {
      obj.hero = CMsgDOTAProfileCard_Slot_Hero.toJSON(message.hero);
    }
    if (message.emoticon !== undefined) {
      obj.emoticon = CMsgDOTAProfileCard_Slot_Emoticon.toJSON(message.emoticon);
    }
    if (message.team !== undefined) {
      obj.team = CMsgDOTAProfileCard_Slot_Team.toJSON(message.team);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAProfileCard_Slot>): CMsgDOTAProfileCard_Slot {
    return CMsgDOTAProfileCard_Slot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAProfileCard_Slot>): CMsgDOTAProfileCard_Slot {
    const message = createBaseCMsgDOTAProfileCard_Slot();
    message.slotId = object.slotId ?? 0;
    message.trophy = (object.trophy !== undefined && object.trophy !== null)
      ? CMsgDOTAProfileCard_Slot_Trophy.fromPartial(object.trophy)
      : undefined;
    message.stat = (object.stat !== undefined && object.stat !== null)
      ? CMsgDOTAProfileCard_Slot_Stat.fromPartial(object.stat)
      : undefined;
    message.item = (object.item !== undefined && object.item !== null)
      ? CMsgDOTAProfileCard_Slot_Item.fromPartial(object.item)
      : undefined;
    message.hero = (object.hero !== undefined && object.hero !== null)
      ? CMsgDOTAProfileCard_Slot_Hero.fromPartial(object.hero)
      : undefined;
    message.emoticon = (object.emoticon !== undefined && object.emoticon !== null)
      ? CMsgDOTAProfileCard_Slot_Emoticon.fromPartial(object.emoticon)
      : undefined;
    message.team = (object.team !== undefined && object.team !== null)
      ? CMsgDOTAProfileCard_Slot_Team.fromPartial(object.team)
      : undefined;
    return message;
  },
};

function createBaseCMsgDOTAProfileCard_Slot_Trophy(): CMsgDOTAProfileCard_Slot_Trophy {
  return { trophyId: 0, trophyScore: 0 };
}

export const CMsgDOTAProfileCard_Slot_Trophy: MessageFns<CMsgDOTAProfileCard_Slot_Trophy> = {
  encode(message: CMsgDOTAProfileCard_Slot_Trophy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trophyId !== 0) {
      writer.uint32(8).uint32(message.trophyId);
    }
    if (message.trophyScore !== 0) {
      writer.uint32(16).uint32(message.trophyScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAProfileCard_Slot_Trophy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAProfileCard_Slot_Trophy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.trophyId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.trophyScore = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAProfileCard_Slot_Trophy {
    return {
      trophyId: isSet(object.trophyId) ? globalThis.Number(object.trophyId) : 0,
      trophyScore: isSet(object.trophyScore) ? globalThis.Number(object.trophyScore) : 0,
    };
  },

  toJSON(message: CMsgDOTAProfileCard_Slot_Trophy): unknown {
    const obj: any = {};
    if (message.trophyId !== 0) {
      obj.trophyId = Math.round(message.trophyId);
    }
    if (message.trophyScore !== 0) {
      obj.trophyScore = Math.round(message.trophyScore);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAProfileCard_Slot_Trophy>): CMsgDOTAProfileCard_Slot_Trophy {
    return CMsgDOTAProfileCard_Slot_Trophy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAProfileCard_Slot_Trophy>): CMsgDOTAProfileCard_Slot_Trophy {
    const message = createBaseCMsgDOTAProfileCard_Slot_Trophy();
    message.trophyId = object.trophyId ?? 0;
    message.trophyScore = object.trophyScore ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAProfileCard_Slot_Stat(): CMsgDOTAProfileCard_Slot_Stat {
  return { statId: 3, statScore: 0 };
}

export const CMsgDOTAProfileCard_Slot_Stat: MessageFns<CMsgDOTAProfileCard_Slot_Stat> = {
  encode(message: CMsgDOTAProfileCard_Slot_Stat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.statId !== 3) {
      writer.uint32(8).int32(message.statId);
    }
    if (message.statScore !== 0) {
      writer.uint32(16).uint32(message.statScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAProfileCard_Slot_Stat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAProfileCard_Slot_Stat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.statId = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.statScore = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAProfileCard_Slot_Stat {
    return {
      statId: isSet(object.statId) ? cMsgDOTAProfileCard_EStatIDFromJSON(object.statId) : 3,
      statScore: isSet(object.statScore) ? globalThis.Number(object.statScore) : 0,
    };
  },

  toJSON(message: CMsgDOTAProfileCard_Slot_Stat): unknown {
    const obj: any = {};
    if (message.statId !== 3) {
      obj.statId = cMsgDOTAProfileCard_EStatIDToJSON(message.statId);
    }
    if (message.statScore !== 0) {
      obj.statScore = Math.round(message.statScore);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAProfileCard_Slot_Stat>): CMsgDOTAProfileCard_Slot_Stat {
    return CMsgDOTAProfileCard_Slot_Stat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAProfileCard_Slot_Stat>): CMsgDOTAProfileCard_Slot_Stat {
    const message = createBaseCMsgDOTAProfileCard_Slot_Stat();
    message.statId = object.statId ?? 3;
    message.statScore = object.statScore ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAProfileCard_Slot_Item(): CMsgDOTAProfileCard_Slot_Item {
  return { serializedItem: Buffer.alloc(0), itemId: "0" };
}

export const CMsgDOTAProfileCard_Slot_Item: MessageFns<CMsgDOTAProfileCard_Slot_Item> = {
  encode(message: CMsgDOTAProfileCard_Slot_Item, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serializedItem.length !== 0) {
      writer.uint32(10).bytes(message.serializedItem);
    }
    if (message.itemId !== "0") {
      writer.uint32(16).uint64(message.itemId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAProfileCard_Slot_Item {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAProfileCard_Slot_Item();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serializedItem = Buffer.from(reader.bytes());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.itemId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAProfileCard_Slot_Item {
    return {
      serializedItem: isSet(object.serializedItem)
        ? Buffer.from(bytesFromBase64(object.serializedItem))
        : Buffer.alloc(0),
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "0",
    };
  },

  toJSON(message: CMsgDOTAProfileCard_Slot_Item): unknown {
    const obj: any = {};
    if (message.serializedItem.length !== 0) {
      obj.serializedItem = base64FromBytes(message.serializedItem);
    }
    if (message.itemId !== "0") {
      obj.itemId = message.itemId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAProfileCard_Slot_Item>): CMsgDOTAProfileCard_Slot_Item {
    return CMsgDOTAProfileCard_Slot_Item.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAProfileCard_Slot_Item>): CMsgDOTAProfileCard_Slot_Item {
    const message = createBaseCMsgDOTAProfileCard_Slot_Item();
    message.serializedItem = object.serializedItem ?? Buffer.alloc(0);
    message.itemId = object.itemId ?? "0";
    return message;
  },
};

function createBaseCMsgDOTAProfileCard_Slot_Hero(): CMsgDOTAProfileCard_Slot_Hero {
  return { heroId: 0, heroWins: 0, heroLosses: 0 };
}

export const CMsgDOTAProfileCard_Slot_Hero: MessageFns<CMsgDOTAProfileCard_Slot_Hero> = {
  encode(message: CMsgDOTAProfileCard_Slot_Hero, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.heroId !== 0) {
      writer.uint32(8).uint32(message.heroId);
    }
    if (message.heroWins !== 0) {
      writer.uint32(16).uint32(message.heroWins);
    }
    if (message.heroLosses !== 0) {
      writer.uint32(24).uint32(message.heroLosses);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAProfileCard_Slot_Hero {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAProfileCard_Slot_Hero();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.heroWins = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.heroLosses = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAProfileCard_Slot_Hero {
    return {
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      heroWins: isSet(object.heroWins) ? globalThis.Number(object.heroWins) : 0,
      heroLosses: isSet(object.heroLosses) ? globalThis.Number(object.heroLosses) : 0,
    };
  },

  toJSON(message: CMsgDOTAProfileCard_Slot_Hero): unknown {
    const obj: any = {};
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.heroWins !== 0) {
      obj.heroWins = Math.round(message.heroWins);
    }
    if (message.heroLosses !== 0) {
      obj.heroLosses = Math.round(message.heroLosses);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAProfileCard_Slot_Hero>): CMsgDOTAProfileCard_Slot_Hero {
    return CMsgDOTAProfileCard_Slot_Hero.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAProfileCard_Slot_Hero>): CMsgDOTAProfileCard_Slot_Hero {
    const message = createBaseCMsgDOTAProfileCard_Slot_Hero();
    message.heroId = object.heroId ?? 0;
    message.heroWins = object.heroWins ?? 0;
    message.heroLosses = object.heroLosses ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAProfileCard_Slot_Emoticon(): CMsgDOTAProfileCard_Slot_Emoticon {
  return { emoticonId: 0 };
}

export const CMsgDOTAProfileCard_Slot_Emoticon: MessageFns<CMsgDOTAProfileCard_Slot_Emoticon> = {
  encode(message: CMsgDOTAProfileCard_Slot_Emoticon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.emoticonId !== 0) {
      writer.uint32(8).uint32(message.emoticonId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAProfileCard_Slot_Emoticon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAProfileCard_Slot_Emoticon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.emoticonId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAProfileCard_Slot_Emoticon {
    return { emoticonId: isSet(object.emoticonId) ? globalThis.Number(object.emoticonId) : 0 };
  },

  toJSON(message: CMsgDOTAProfileCard_Slot_Emoticon): unknown {
    const obj: any = {};
    if (message.emoticonId !== 0) {
      obj.emoticonId = Math.round(message.emoticonId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAProfileCard_Slot_Emoticon>): CMsgDOTAProfileCard_Slot_Emoticon {
    return CMsgDOTAProfileCard_Slot_Emoticon.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAProfileCard_Slot_Emoticon>): CMsgDOTAProfileCard_Slot_Emoticon {
    const message = createBaseCMsgDOTAProfileCard_Slot_Emoticon();
    message.emoticonId = object.emoticonId ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAProfileCard_Slot_Team(): CMsgDOTAProfileCard_Slot_Team {
  return { teamId: 0 };
}

export const CMsgDOTAProfileCard_Slot_Team: MessageFns<CMsgDOTAProfileCard_Slot_Team> = {
  encode(message: CMsgDOTAProfileCard_Slot_Team, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.teamId !== 0) {
      writer.uint32(8).uint32(message.teamId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAProfileCard_Slot_Team {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAProfileCard_Slot_Team();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAProfileCard_Slot_Team {
    return { teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0 };
  },

  toJSON(message: CMsgDOTAProfileCard_Slot_Team): unknown {
    const obj: any = {};
    if (message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAProfileCard_Slot_Team>): CMsgDOTAProfileCard_Slot_Team {
    return CMsgDOTAProfileCard_Slot_Team.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAProfileCard_Slot_Team>): CMsgDOTAProfileCard_Slot_Team {
    const message = createBaseCMsgDOTAProfileCard_Slot_Team();
    message.teamId = object.teamId ?? 0;
    return message;
  },
};

function createBaseCSODOTAPlayerChallenge(): CSODOTAPlayerChallenge {
  return {
    accountId: 0,
    eventId: 0,
    slotId: 0,
    intParam0: 0,
    intParam1: 0,
    createdTime: 0,
    completed: 0,
    sequenceId: 0,
    challengeTier: 0,
    flags: 0,
    attempts: 0,
    completeLimit: 0,
    questRank: 0,
    maxQuestRank: 0,
    instanceId: 0,
    heroId: 0,
    templateId: 0,
  };
}

export const CSODOTAPlayerChallenge: MessageFns<CSODOTAPlayerChallenge> = {
  encode(message: CSODOTAPlayerChallenge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.eventId !== 0) {
      writer.uint32(16).uint32(message.eventId);
    }
    if (message.slotId !== 0) {
      writer.uint32(24).uint32(message.slotId);
    }
    if (message.intParam0 !== 0) {
      writer.uint32(40).uint32(message.intParam0);
    }
    if (message.intParam1 !== 0) {
      writer.uint32(48).uint32(message.intParam1);
    }
    if (message.createdTime !== 0) {
      writer.uint32(56).uint32(message.createdTime);
    }
    if (message.completed !== 0) {
      writer.uint32(64).uint32(message.completed);
    }
    if (message.sequenceId !== 0) {
      writer.uint32(72).uint32(message.sequenceId);
    }
    if (message.challengeTier !== 0) {
      writer.uint32(80).uint32(message.challengeTier);
    }
    if (message.flags !== 0) {
      writer.uint32(88).uint32(message.flags);
    }
    if (message.attempts !== 0) {
      writer.uint32(96).uint32(message.attempts);
    }
    if (message.completeLimit !== 0) {
      writer.uint32(104).uint32(message.completeLimit);
    }
    if (message.questRank !== 0) {
      writer.uint32(112).uint32(message.questRank);
    }
    if (message.maxQuestRank !== 0) {
      writer.uint32(120).uint32(message.maxQuestRank);
    }
    if (message.instanceId !== 0) {
      writer.uint32(128).uint32(message.instanceId);
    }
    if (message.heroId !== 0) {
      writer.uint32(136).uint32(message.heroId);
    }
    if (message.templateId !== 0) {
      writer.uint32(144).uint32(message.templateId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CSODOTAPlayerChallenge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSODOTAPlayerChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.slotId = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.intParam0 = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.intParam1 = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.createdTime = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.completed = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.sequenceId = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.challengeTier = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.flags = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.attempts = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.completeLimit = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.questRank = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.maxQuestRank = reader.uint32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.instanceId = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.templateId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSODOTAPlayerChallenge {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      eventId: isSet(object.eventId) ? globalThis.Number(object.eventId) : 0,
      slotId: isSet(object.slotId) ? globalThis.Number(object.slotId) : 0,
      intParam0: isSet(object.intParam0) ? globalThis.Number(object.intParam0) : 0,
      intParam1: isSet(object.intParam1) ? globalThis.Number(object.intParam1) : 0,
      createdTime: isSet(object.createdTime) ? globalThis.Number(object.createdTime) : 0,
      completed: isSet(object.completed) ? globalThis.Number(object.completed) : 0,
      sequenceId: isSet(object.sequenceId) ? globalThis.Number(object.sequenceId) : 0,
      challengeTier: isSet(object.challengeTier) ? globalThis.Number(object.challengeTier) : 0,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
      attempts: isSet(object.attempts) ? globalThis.Number(object.attempts) : 0,
      completeLimit: isSet(object.completeLimit) ? globalThis.Number(object.completeLimit) : 0,
      questRank: isSet(object.questRank) ? globalThis.Number(object.questRank) : 0,
      maxQuestRank: isSet(object.maxQuestRank) ? globalThis.Number(object.maxQuestRank) : 0,
      instanceId: isSet(object.instanceId) ? globalThis.Number(object.instanceId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      templateId: isSet(object.templateId) ? globalThis.Number(object.templateId) : 0,
    };
  },

  toJSON(message: CSODOTAPlayerChallenge): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.eventId !== 0) {
      obj.eventId = Math.round(message.eventId);
    }
    if (message.slotId !== 0) {
      obj.slotId = Math.round(message.slotId);
    }
    if (message.intParam0 !== 0) {
      obj.intParam0 = Math.round(message.intParam0);
    }
    if (message.intParam1 !== 0) {
      obj.intParam1 = Math.round(message.intParam1);
    }
    if (message.createdTime !== 0) {
      obj.createdTime = Math.round(message.createdTime);
    }
    if (message.completed !== 0) {
      obj.completed = Math.round(message.completed);
    }
    if (message.sequenceId !== 0) {
      obj.sequenceId = Math.round(message.sequenceId);
    }
    if (message.challengeTier !== 0) {
      obj.challengeTier = Math.round(message.challengeTier);
    }
    if (message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    if (message.attempts !== 0) {
      obj.attempts = Math.round(message.attempts);
    }
    if (message.completeLimit !== 0) {
      obj.completeLimit = Math.round(message.completeLimit);
    }
    if (message.questRank !== 0) {
      obj.questRank = Math.round(message.questRank);
    }
    if (message.maxQuestRank !== 0) {
      obj.maxQuestRank = Math.round(message.maxQuestRank);
    }
    if (message.instanceId !== 0) {
      obj.instanceId = Math.round(message.instanceId);
    }
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.templateId !== 0) {
      obj.templateId = Math.round(message.templateId);
    }
    return obj;
  },

  create(base?: DeepPartial<CSODOTAPlayerChallenge>): CSODOTAPlayerChallenge {
    return CSODOTAPlayerChallenge.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSODOTAPlayerChallenge>): CSODOTAPlayerChallenge {
    const message = createBaseCSODOTAPlayerChallenge();
    message.accountId = object.accountId ?? 0;
    message.eventId = object.eventId ?? 0;
    message.slotId = object.slotId ?? 0;
    message.intParam0 = object.intParam0 ?? 0;
    message.intParam1 = object.intParam1 ?? 0;
    message.createdTime = object.createdTime ?? 0;
    message.completed = object.completed ?? 0;
    message.sequenceId = object.sequenceId ?? 0;
    message.challengeTier = object.challengeTier ?? 0;
    message.flags = object.flags ?? 0;
    message.attempts = object.attempts ?? 0;
    message.completeLimit = object.completeLimit ?? 0;
    message.questRank = object.questRank ?? 0;
    message.maxQuestRank = object.maxQuestRank ?? 0;
    message.instanceId = object.instanceId ?? 0;
    message.heroId = object.heroId ?? 0;
    message.templateId = object.templateId ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCRerollPlayerChallenge(): CMsgClientToGCRerollPlayerChallenge {
  return { eventId: 0, sequenceId: 0, heroId: 0 };
}

export const CMsgClientToGCRerollPlayerChallenge: MessageFns<CMsgClientToGCRerollPlayerChallenge> = {
  encode(message: CMsgClientToGCRerollPlayerChallenge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== 0) {
      writer.uint32(8).int32(message.eventId);
    }
    if (message.sequenceId !== 0) {
      writer.uint32(24).uint32(message.sequenceId);
    }
    if (message.heroId !== 0) {
      writer.uint32(32).uint32(message.heroId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCRerollPlayerChallenge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRerollPlayerChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sequenceId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRerollPlayerChallenge {
    return {
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      sequenceId: isSet(object.sequenceId) ? globalThis.Number(object.sequenceId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCRerollPlayerChallenge): unknown {
    const obj: any = {};
    if (message.eventId !== 0) {
      obj.eventId = eEventToJSON(message.eventId);
    }
    if (message.sequenceId !== 0) {
      obj.sequenceId = Math.round(message.sequenceId);
    }
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCRerollPlayerChallenge>): CMsgClientToGCRerollPlayerChallenge {
    return CMsgClientToGCRerollPlayerChallenge.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCRerollPlayerChallenge>): CMsgClientToGCRerollPlayerChallenge {
    const message = createBaseCMsgClientToGCRerollPlayerChallenge();
    message.eventId = object.eventId ?? 0;
    message.sequenceId = object.sequenceId ?? 0;
    message.heroId = object.heroId ?? 0;
    return message;
  },
};

function createBaseCMsgGCRerollPlayerChallengeResponse(): CMsgGCRerollPlayerChallengeResponse {
  return { result: 0 };
}

export const CMsgGCRerollPlayerChallengeResponse: MessageFns<CMsgGCRerollPlayerChallengeResponse> = {
  encode(message: CMsgGCRerollPlayerChallengeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCRerollPlayerChallengeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCRerollPlayerChallengeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCRerollPlayerChallengeResponse {
    return { result: isSet(object.result) ? cMsgGCRerollPlayerChallengeResponse_EResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgGCRerollPlayerChallengeResponse): unknown {
    const obj: any = {};
    if (message.result !== 0) {
      obj.result = cMsgGCRerollPlayerChallengeResponse_EResultToJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCRerollPlayerChallengeResponse>): CMsgGCRerollPlayerChallengeResponse {
    return CMsgGCRerollPlayerChallengeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCRerollPlayerChallengeResponse>): CMsgGCRerollPlayerChallengeResponse {
    const message = createBaseCMsgGCRerollPlayerChallengeResponse();
    message.result = object.result ?? 0;
    return message;
  },
};

function createBaseCMsgGCTopCustomGamesList(): CMsgGCTopCustomGamesList {
  return { topCustomGames: [], gameOfTheDay: "0" };
}

export const CMsgGCTopCustomGamesList: MessageFns<CMsgGCTopCustomGamesList> = {
  encode(message: CMsgGCTopCustomGamesList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.topCustomGames) {
      writer.uint64(v);
    }
    writer.join();
    if (message.gameOfTheDay !== "0") {
      writer.uint32(16).uint64(message.gameOfTheDay);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCTopCustomGamesList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCTopCustomGamesList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.topCustomGames.push(reader.uint64().toString());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.topCustomGames.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gameOfTheDay = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCTopCustomGamesList {
    return {
      topCustomGames: globalThis.Array.isArray(object?.topCustomGames)
        ? object.topCustomGames.map((e: any) => globalThis.String(e))
        : [],
      gameOfTheDay: isSet(object.gameOfTheDay) ? globalThis.String(object.gameOfTheDay) : "0",
    };
  },

  toJSON(message: CMsgGCTopCustomGamesList): unknown {
    const obj: any = {};
    if (message.topCustomGames?.length) {
      obj.topCustomGames = message.topCustomGames;
    }
    if (message.gameOfTheDay !== "0") {
      obj.gameOfTheDay = message.gameOfTheDay;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCTopCustomGamesList>): CMsgGCTopCustomGamesList {
    return CMsgGCTopCustomGamesList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCTopCustomGamesList>): CMsgGCTopCustomGamesList {
    const message = createBaseCMsgGCTopCustomGamesList();
    message.topCustomGames = object.topCustomGames?.map((e) => e) || [];
    message.gameOfTheDay = object.gameOfTheDay ?? "0";
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats(): CMsgDOTARealtimeGameStats {
  return { match: undefined, teams: [], buildings: [], graphData: undefined, deltaFrame: false };
}

export const CMsgDOTARealtimeGameStats: MessageFns<CMsgDOTARealtimeGameStats> = {
  encode(message: CMsgDOTARealtimeGameStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.match !== undefined) {
      CMsgDOTARealtimeGameStats_MatchDetails.encode(message.match, writer.uint32(10).fork()).join();
    }
    for (const v of message.teams) {
      CMsgDOTARealtimeGameStats_TeamDetails.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.buildings) {
      CMsgDOTARealtimeGameStats_BuildingDetails.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.graphData !== undefined) {
      CMsgDOTARealtimeGameStats_GraphData.encode(message.graphData, writer.uint32(34).fork()).join();
    }
    if (message.deltaFrame !== false) {
      writer.uint32(40).bool(message.deltaFrame);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.match = CMsgDOTARealtimeGameStats_MatchDetails.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.teams.push(CMsgDOTARealtimeGameStats_TeamDetails.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.buildings.push(CMsgDOTARealtimeGameStats_BuildingDetails.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.graphData = CMsgDOTARealtimeGameStats_GraphData.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.deltaFrame = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats {
    return {
      match: isSet(object.match) ? CMsgDOTARealtimeGameStats_MatchDetails.fromJSON(object.match) : undefined,
      teams: globalThis.Array.isArray(object?.teams)
        ? object.teams.map((e: any) => CMsgDOTARealtimeGameStats_TeamDetails.fromJSON(e))
        : [],
      buildings: globalThis.Array.isArray(object?.buildings)
        ? object.buildings.map((e: any) => CMsgDOTARealtimeGameStats_BuildingDetails.fromJSON(e))
        : [],
      graphData: isSet(object.graphData) ? CMsgDOTARealtimeGameStats_GraphData.fromJSON(object.graphData) : undefined,
      deltaFrame: isSet(object.deltaFrame) ? globalThis.Boolean(object.deltaFrame) : false,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats): unknown {
    const obj: any = {};
    if (message.match !== undefined) {
      obj.match = CMsgDOTARealtimeGameStats_MatchDetails.toJSON(message.match);
    }
    if (message.teams?.length) {
      obj.teams = message.teams.map((e) => CMsgDOTARealtimeGameStats_TeamDetails.toJSON(e));
    }
    if (message.buildings?.length) {
      obj.buildings = message.buildings.map((e) => CMsgDOTARealtimeGameStats_BuildingDetails.toJSON(e));
    }
    if (message.graphData !== undefined) {
      obj.graphData = CMsgDOTARealtimeGameStats_GraphData.toJSON(message.graphData);
    }
    if (message.deltaFrame !== false) {
      obj.deltaFrame = message.deltaFrame;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats>): CMsgDOTARealtimeGameStats {
    return CMsgDOTARealtimeGameStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStats>): CMsgDOTARealtimeGameStats {
    const message = createBaseCMsgDOTARealtimeGameStats();
    message.match = (object.match !== undefined && object.match !== null)
      ? CMsgDOTARealtimeGameStats_MatchDetails.fromPartial(object.match)
      : undefined;
    message.teams = object.teams?.map((e) => CMsgDOTARealtimeGameStats_TeamDetails.fromPartial(e)) || [];
    message.buildings = object.buildings?.map((e) => CMsgDOTARealtimeGameStats_BuildingDetails.fromPartial(e)) || [];
    message.graphData = (object.graphData !== undefined && object.graphData !== null)
      ? CMsgDOTARealtimeGameStats_GraphData.fromPartial(object.graphData)
      : undefined;
    message.deltaFrame = object.deltaFrame ?? false;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_TeamDetails(): CMsgDOTARealtimeGameStats_TeamDetails {
  return {
    teamNumber: 0,
    teamId: 0,
    teamName: "",
    teamLogo: "0",
    teamTag: "",
    score: 0,
    netWorth: 0,
    players: [],
    onlyTeam: false,
    cheers: 0,
    teamLogoUrl: "",
  };
}

export const CMsgDOTARealtimeGameStats_TeamDetails: MessageFns<CMsgDOTARealtimeGameStats_TeamDetails> = {
  encode(message: CMsgDOTARealtimeGameStats_TeamDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.teamNumber !== 0) {
      writer.uint32(8).uint32(message.teamNumber);
    }
    if (message.teamId !== 0) {
      writer.uint32(16).uint32(message.teamId);
    }
    if (message.teamName !== "") {
      writer.uint32(26).string(message.teamName);
    }
    if (message.teamLogo !== "0") {
      writer.uint32(33).fixed64(message.teamLogo);
    }
    if (message.teamTag !== "") {
      writer.uint32(82).string(message.teamTag);
    }
    if (message.score !== 0) {
      writer.uint32(40).uint32(message.score);
    }
    if (message.netWorth !== 0) {
      writer.uint32(72).uint32(message.netWorth);
    }
    for (const v of message.players) {
      CMsgDOTARealtimeGameStats_PlayerDetails.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.onlyTeam !== false) {
      writer.uint32(56).bool(message.onlyTeam);
    }
    if (message.cheers !== 0) {
      writer.uint32(64).uint32(message.cheers);
    }
    if (message.teamLogoUrl !== "") {
      writer.uint32(90).string(message.teamLogoUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_TeamDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_TeamDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.teamNumber = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.teamName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.teamLogo = reader.fixed64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.teamTag = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.score = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.netWorth = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.players.push(CMsgDOTARealtimeGameStats_PlayerDetails.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.onlyTeam = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.cheers = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.teamLogoUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_TeamDetails {
    return {
      teamNumber: isSet(object.teamNumber) ? globalThis.Number(object.teamNumber) : 0,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      teamName: isSet(object.teamName) ? globalThis.String(object.teamName) : "",
      teamLogo: isSet(object.teamLogo) ? globalThis.String(object.teamLogo) : "0",
      teamTag: isSet(object.teamTag) ? globalThis.String(object.teamTag) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgDOTARealtimeGameStats_PlayerDetails.fromJSON(e))
        : [],
      onlyTeam: isSet(object.onlyTeam) ? globalThis.Boolean(object.onlyTeam) : false,
      cheers: isSet(object.cheers) ? globalThis.Number(object.cheers) : 0,
      teamLogoUrl: isSet(object.teamLogoUrl) ? globalThis.String(object.teamLogoUrl) : "",
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_TeamDetails): unknown {
    const obj: any = {};
    if (message.teamNumber !== 0) {
      obj.teamNumber = Math.round(message.teamNumber);
    }
    if (message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.teamName !== "") {
      obj.teamName = message.teamName;
    }
    if (message.teamLogo !== "0") {
      obj.teamLogo = message.teamLogo;
    }
    if (message.teamTag !== "") {
      obj.teamTag = message.teamTag;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.netWorth !== 0) {
      obj.netWorth = Math.round(message.netWorth);
    }
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgDOTARealtimeGameStats_PlayerDetails.toJSON(e));
    }
    if (message.onlyTeam !== false) {
      obj.onlyTeam = message.onlyTeam;
    }
    if (message.cheers !== 0) {
      obj.cheers = Math.round(message.cheers);
    }
    if (message.teamLogoUrl !== "") {
      obj.teamLogoUrl = message.teamLogoUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_TeamDetails>): CMsgDOTARealtimeGameStats_TeamDetails {
    return CMsgDOTARealtimeGameStats_TeamDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStats_TeamDetails>): CMsgDOTARealtimeGameStats_TeamDetails {
    const message = createBaseCMsgDOTARealtimeGameStats_TeamDetails();
    message.teamNumber = object.teamNumber ?? 0;
    message.teamId = object.teamId ?? 0;
    message.teamName = object.teamName ?? "";
    message.teamLogo = object.teamLogo ?? "0";
    message.teamTag = object.teamTag ?? "";
    message.score = object.score ?? 0;
    message.netWorth = object.netWorth ?? 0;
    message.players = object.players?.map((e) => CMsgDOTARealtimeGameStats_PlayerDetails.fromPartial(e)) || [];
    message.onlyTeam = object.onlyTeam ?? false;
    message.cheers = object.cheers ?? 0;
    message.teamLogoUrl = object.teamLogoUrl ?? "";
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_ItemDetails(): CMsgDOTARealtimeGameStats_ItemDetails {
  return { itemAbilityId: -1, name: "", time: 0, sold: false, stackcount: 0 };
}

export const CMsgDOTARealtimeGameStats_ItemDetails: MessageFns<CMsgDOTARealtimeGameStats_ItemDetails> = {
  encode(message: CMsgDOTARealtimeGameStats_ItemDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.itemAbilityId !== -1) {
      writer.uint32(8).int32(message.itemAbilityId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.time !== 0) {
      writer.uint32(24).int32(message.time);
    }
    if (message.sold !== false) {
      writer.uint32(32).bool(message.sold);
    }
    if (message.stackcount !== 0) {
      writer.uint32(40).uint32(message.stackcount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_ItemDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_ItemDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.itemAbilityId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.time = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sold = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.stackcount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_ItemDetails {
    return {
      itemAbilityId: isSet(object.itemAbilityId) ? globalThis.Number(object.itemAbilityId) : -1,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      time: isSet(object.time) ? globalThis.Number(object.time) : 0,
      sold: isSet(object.sold) ? globalThis.Boolean(object.sold) : false,
      stackcount: isSet(object.stackcount) ? globalThis.Number(object.stackcount) : 0,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_ItemDetails): unknown {
    const obj: any = {};
    if (message.itemAbilityId !== -1) {
      obj.itemAbilityId = Math.round(message.itemAbilityId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.time !== 0) {
      obj.time = Math.round(message.time);
    }
    if (message.sold !== false) {
      obj.sold = message.sold;
    }
    if (message.stackcount !== 0) {
      obj.stackcount = Math.round(message.stackcount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_ItemDetails>): CMsgDOTARealtimeGameStats_ItemDetails {
    return CMsgDOTARealtimeGameStats_ItemDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStats_ItemDetails>): CMsgDOTARealtimeGameStats_ItemDetails {
    const message = createBaseCMsgDOTARealtimeGameStats_ItemDetails();
    message.itemAbilityId = object.itemAbilityId ?? -1;
    message.name = object.name ?? "";
    message.time = object.time ?? 0;
    message.sold = object.sold ?? false;
    message.stackcount = object.stackcount ?? 0;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_AbilityDetails(): CMsgDOTARealtimeGameStats_AbilityDetails {
  return { id: -1, name: "", level: 0, cooldown: 0, cooldownMax: 0 };
}

export const CMsgDOTARealtimeGameStats_AbilityDetails: MessageFns<CMsgDOTARealtimeGameStats_AbilityDetails> = {
  encode(message: CMsgDOTARealtimeGameStats_AbilityDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== -1) {
      writer.uint32(8).int32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.level !== 0) {
      writer.uint32(24).uint32(message.level);
    }
    if (message.cooldown !== 0) {
      writer.uint32(37).float(message.cooldown);
    }
    if (message.cooldownMax !== 0) {
      writer.uint32(45).float(message.cooldownMax);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_AbilityDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_AbilityDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.level = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.cooldown = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.cooldownMax = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_AbilityDetails {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : -1,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      cooldown: isSet(object.cooldown) ? globalThis.Number(object.cooldown) : 0,
      cooldownMax: isSet(object.cooldownMax) ? globalThis.Number(object.cooldownMax) : 0,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_AbilityDetails): unknown {
    const obj: any = {};
    if (message.id !== -1) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.cooldown !== 0) {
      obj.cooldown = message.cooldown;
    }
    if (message.cooldownMax !== 0) {
      obj.cooldownMax = message.cooldownMax;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_AbilityDetails>): CMsgDOTARealtimeGameStats_AbilityDetails {
    return CMsgDOTARealtimeGameStats_AbilityDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStats_AbilityDetails>): CMsgDOTARealtimeGameStats_AbilityDetails {
    const message = createBaseCMsgDOTARealtimeGameStats_AbilityDetails();
    message.id = object.id ?? -1;
    message.name = object.name ?? "";
    message.level = object.level ?? 0;
    message.cooldown = object.cooldown ?? 0;
    message.cooldownMax = object.cooldownMax ?? 0;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_HeroToHeroStats(): CMsgDOTARealtimeGameStats_HeroToHeroStats {
  return { victimid: -1, kills: 0, assists: 0 };
}

export const CMsgDOTARealtimeGameStats_HeroToHeroStats: MessageFns<CMsgDOTARealtimeGameStats_HeroToHeroStats> = {
  encode(message: CMsgDOTARealtimeGameStats_HeroToHeroStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.victimid !== -1) {
      writer.uint32(8).int32(message.victimid);
    }
    if (message.kills !== 0) {
      writer.uint32(16).uint32(message.kills);
    }
    if (message.assists !== 0) {
      writer.uint32(24).uint32(message.assists);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_HeroToHeroStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_HeroToHeroStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.victimid = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.assists = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_HeroToHeroStats {
    return {
      victimid: isSet(object.victimid) ? globalThis.Number(object.victimid) : -1,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      assists: isSet(object.assists) ? globalThis.Number(object.assists) : 0,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_HeroToHeroStats): unknown {
    const obj: any = {};
    if (message.victimid !== -1) {
      obj.victimid = Math.round(message.victimid);
    }
    if (message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.assists !== 0) {
      obj.assists = Math.round(message.assists);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_HeroToHeroStats>): CMsgDOTARealtimeGameStats_HeroToHeroStats {
    return CMsgDOTARealtimeGameStats_HeroToHeroStats.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTARealtimeGameStats_HeroToHeroStats>,
  ): CMsgDOTARealtimeGameStats_HeroToHeroStats {
    const message = createBaseCMsgDOTARealtimeGameStats_HeroToHeroStats();
    message.victimid = object.victimid ?? -1;
    message.kills = object.kills ?? 0;
    message.assists = object.assists ?? 0;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_AbilityList(): CMsgDOTARealtimeGameStats_AbilityList {
  return { id: [] };
}

export const CMsgDOTARealtimeGameStats_AbilityList: MessageFns<CMsgDOTARealtimeGameStats_AbilityList> = {
  encode(message: CMsgDOTARealtimeGameStats_AbilityList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.id) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_AbilityList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_AbilityList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.id.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.id.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_AbilityList {
    return { id: globalThis.Array.isArray(object?.id) ? object.id.map((e: any) => globalThis.Number(e)) : [] };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_AbilityList): unknown {
    const obj: any = {};
    if (message.id?.length) {
      obj.id = message.id.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_AbilityList>): CMsgDOTARealtimeGameStats_AbilityList {
    return CMsgDOTARealtimeGameStats_AbilityList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStats_AbilityList>): CMsgDOTARealtimeGameStats_AbilityList {
    const message = createBaseCMsgDOTARealtimeGameStats_AbilityList();
    message.id = object.id?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_PlayerDetails(): CMsgDOTARealtimeGameStats_PlayerDetails {
  return {
    accountid: 0,
    playerid: -1,
    name: "",
    team: 0,
    heroid: 0,
    healthpoints: 0,
    maxhealthpoints: 0,
    healthregenrate: 0,
    manapoints: 0,
    maxmanapoints: 0,
    manaregenrate: 0,
    baseStrength: 0,
    baseAgility: 0,
    baseIntelligence: 0,
    baseArmor: 0,
    baseMovespeed: 0,
    baseDamage: 0,
    strength: 0,
    agility: 0,
    intelligence: 0,
    armor: 0,
    movespeed: 0,
    damage: 0,
    heroDamage: 0,
    towerDamage: 0,
    abilities: [],
    level: 0,
    killCount: 0,
    deathCount: 0,
    assistsCount: 0,
    deniesCount: 0,
    lhCount: 0,
    heroHealing: 0,
    goldPerMin: 0,
    xpPerMin: 0,
    netGold: 0,
    gold: 0,
    x: 0,
    y: 0,
    respawnTime: 0,
    ultimateCooldown: 0,
    hasBuyback: false,
    items: [],
    stashitems: [],
    itemshoppinglist: [],
    levelpoints: [],
    heroToHeroStats: [],
    hasUltimate: false,
    hasUltimateMana: false,
  };
}

export const CMsgDOTARealtimeGameStats_PlayerDetails: MessageFns<CMsgDOTARealtimeGameStats_PlayerDetails> = {
  encode(message: CMsgDOTARealtimeGameStats_PlayerDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountid !== 0) {
      writer.uint32(8).uint32(message.accountid);
    }
    if (message.playerid !== -1) {
      writer.uint32(16).int32(message.playerid);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.team !== 0) {
      writer.uint32(32).uint32(message.team);
    }
    if (message.heroid !== 0) {
      writer.uint32(40).uint32(message.heroid);
    }
    if (message.healthpoints !== 0) {
      writer.uint32(48).uint32(message.healthpoints);
    }
    if (message.maxhealthpoints !== 0) {
      writer.uint32(56).uint32(message.maxhealthpoints);
    }
    if (message.healthregenrate !== 0) {
      writer.uint32(69).float(message.healthregenrate);
    }
    if (message.manapoints !== 0) {
      writer.uint32(72).uint32(message.manapoints);
    }
    if (message.maxmanapoints !== 0) {
      writer.uint32(80).uint32(message.maxmanapoints);
    }
    if (message.manaregenrate !== 0) {
      writer.uint32(93).float(message.manaregenrate);
    }
    if (message.baseStrength !== 0) {
      writer.uint32(96).uint32(message.baseStrength);
    }
    if (message.baseAgility !== 0) {
      writer.uint32(104).uint32(message.baseAgility);
    }
    if (message.baseIntelligence !== 0) {
      writer.uint32(112).uint32(message.baseIntelligence);
    }
    if (message.baseArmor !== 0) {
      writer.uint32(120).int32(message.baseArmor);
    }
    if (message.baseMovespeed !== 0) {
      writer.uint32(128).uint32(message.baseMovespeed);
    }
    if (message.baseDamage !== 0) {
      writer.uint32(136).uint32(message.baseDamage);
    }
    if (message.strength !== 0) {
      writer.uint32(144).uint32(message.strength);
    }
    if (message.agility !== 0) {
      writer.uint32(152).uint32(message.agility);
    }
    if (message.intelligence !== 0) {
      writer.uint32(160).uint32(message.intelligence);
    }
    if (message.armor !== 0) {
      writer.uint32(168).int32(message.armor);
    }
    if (message.movespeed !== 0) {
      writer.uint32(176).uint32(message.movespeed);
    }
    if (message.damage !== 0) {
      writer.uint32(184).uint32(message.damage);
    }
    if (message.heroDamage !== 0) {
      writer.uint32(192).uint32(message.heroDamage);
    }
    if (message.towerDamage !== 0) {
      writer.uint32(200).uint32(message.towerDamage);
    }
    for (const v of message.abilities) {
      CMsgDOTARealtimeGameStats_AbilityDetails.encode(v!, writer.uint32(210).fork()).join();
    }
    if (message.level !== 0) {
      writer.uint32(216).uint32(message.level);
    }
    if (message.killCount !== 0) {
      writer.uint32(224).uint32(message.killCount);
    }
    if (message.deathCount !== 0) {
      writer.uint32(232).uint32(message.deathCount);
    }
    if (message.assistsCount !== 0) {
      writer.uint32(240).uint32(message.assistsCount);
    }
    if (message.deniesCount !== 0) {
      writer.uint32(248).uint32(message.deniesCount);
    }
    if (message.lhCount !== 0) {
      writer.uint32(256).uint32(message.lhCount);
    }
    if (message.heroHealing !== 0) {
      writer.uint32(264).uint32(message.heroHealing);
    }
    if (message.goldPerMin !== 0) {
      writer.uint32(272).uint32(message.goldPerMin);
    }
    if (message.xpPerMin !== 0) {
      writer.uint32(280).uint32(message.xpPerMin);
    }
    if (message.netGold !== 0) {
      writer.uint32(288).uint32(message.netGold);
    }
    if (message.gold !== 0) {
      writer.uint32(296).uint32(message.gold);
    }
    if (message.x !== 0) {
      writer.uint32(309).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(317).float(message.y);
    }
    if (message.respawnTime !== 0) {
      writer.uint32(320).int32(message.respawnTime);
    }
    if (message.ultimateCooldown !== 0) {
      writer.uint32(328).uint32(message.ultimateCooldown);
    }
    if (message.hasBuyback !== false) {
      writer.uint32(336).bool(message.hasBuyback);
    }
    for (const v of message.items) {
      CMsgDOTARealtimeGameStats_ItemDetails.encode(v!, writer.uint32(346).fork()).join();
    }
    for (const v of message.stashitems) {
      CMsgDOTARealtimeGameStats_ItemDetails.encode(v!, writer.uint32(354).fork()).join();
    }
    for (const v of message.itemshoppinglist) {
      CMsgDOTARealtimeGameStats_ItemDetails.encode(v!, writer.uint32(362).fork()).join();
    }
    for (const v of message.levelpoints) {
      CMsgDOTARealtimeGameStats_AbilityList.encode(v!, writer.uint32(370).fork()).join();
    }
    for (const v of message.heroToHeroStats) {
      CMsgDOTARealtimeGameStats_HeroToHeroStats.encode(v!, writer.uint32(378).fork()).join();
    }
    if (message.hasUltimate !== false) {
      writer.uint32(384).bool(message.hasUltimate);
    }
    if (message.hasUltimateMana !== false) {
      writer.uint32(392).bool(message.hasUltimateMana);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_PlayerDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_PlayerDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountid = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.playerid = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.team = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.heroid = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.healthpoints = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.maxhealthpoints = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.healthregenrate = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.manapoints = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.maxmanapoints = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.manaregenrate = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.baseStrength = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.baseAgility = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.baseIntelligence = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.baseArmor = reader.int32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.baseMovespeed = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.baseDamage = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.strength = reader.uint32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.agility = reader.uint32();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.intelligence = reader.uint32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.armor = reader.int32();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.movespeed = reader.uint32();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.damage = reader.uint32();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.heroDamage = reader.uint32();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.towerDamage = reader.uint32();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.abilities.push(CMsgDOTARealtimeGameStats_AbilityDetails.decode(reader, reader.uint32()));
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.level = reader.uint32();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.killCount = reader.uint32();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.deathCount = reader.uint32();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.assistsCount = reader.uint32();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.deniesCount = reader.uint32();
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.lhCount = reader.uint32();
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.heroHealing = reader.uint32();
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.goldPerMin = reader.uint32();
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.xpPerMin = reader.uint32();
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }

          message.netGold = reader.uint32();
          continue;
        }
        case 37: {
          if (tag !== 296) {
            break;
          }

          message.gold = reader.uint32();
          continue;
        }
        case 38: {
          if (tag !== 309) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 39: {
          if (tag !== 317) {
            break;
          }

          message.y = reader.float();
          continue;
        }
        case 40: {
          if (tag !== 320) {
            break;
          }

          message.respawnTime = reader.int32();
          continue;
        }
        case 41: {
          if (tag !== 328) {
            break;
          }

          message.ultimateCooldown = reader.uint32();
          continue;
        }
        case 42: {
          if (tag !== 336) {
            break;
          }

          message.hasBuyback = reader.bool();
          continue;
        }
        case 43: {
          if (tag !== 346) {
            break;
          }

          message.items.push(CMsgDOTARealtimeGameStats_ItemDetails.decode(reader, reader.uint32()));
          continue;
        }
        case 44: {
          if (tag !== 354) {
            break;
          }

          message.stashitems.push(CMsgDOTARealtimeGameStats_ItemDetails.decode(reader, reader.uint32()));
          continue;
        }
        case 45: {
          if (tag !== 362) {
            break;
          }

          message.itemshoppinglist.push(CMsgDOTARealtimeGameStats_ItemDetails.decode(reader, reader.uint32()));
          continue;
        }
        case 46: {
          if (tag !== 370) {
            break;
          }

          message.levelpoints.push(CMsgDOTARealtimeGameStats_AbilityList.decode(reader, reader.uint32()));
          continue;
        }
        case 47: {
          if (tag !== 378) {
            break;
          }

          message.heroToHeroStats.push(CMsgDOTARealtimeGameStats_HeroToHeroStats.decode(reader, reader.uint32()));
          continue;
        }
        case 48: {
          if (tag !== 384) {
            break;
          }

          message.hasUltimate = reader.bool();
          continue;
        }
        case 49: {
          if (tag !== 392) {
            break;
          }

          message.hasUltimateMana = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_PlayerDetails {
    return {
      accountid: isSet(object.accountid) ? globalThis.Number(object.accountid) : 0,
      playerid: isSet(object.playerid) ? globalThis.Number(object.playerid) : -1,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
      heroid: isSet(object.heroid) ? globalThis.Number(object.heroid) : 0,
      healthpoints: isSet(object.healthpoints) ? globalThis.Number(object.healthpoints) : 0,
      maxhealthpoints: isSet(object.maxhealthpoints) ? globalThis.Number(object.maxhealthpoints) : 0,
      healthregenrate: isSet(object.healthregenrate) ? globalThis.Number(object.healthregenrate) : 0,
      manapoints: isSet(object.manapoints) ? globalThis.Number(object.manapoints) : 0,
      maxmanapoints: isSet(object.maxmanapoints) ? globalThis.Number(object.maxmanapoints) : 0,
      manaregenrate: isSet(object.manaregenrate) ? globalThis.Number(object.manaregenrate) : 0,
      baseStrength: isSet(object.baseStrength) ? globalThis.Number(object.baseStrength) : 0,
      baseAgility: isSet(object.baseAgility) ? globalThis.Number(object.baseAgility) : 0,
      baseIntelligence: isSet(object.baseIntelligence) ? globalThis.Number(object.baseIntelligence) : 0,
      baseArmor: isSet(object.baseArmor) ? globalThis.Number(object.baseArmor) : 0,
      baseMovespeed: isSet(object.baseMovespeed) ? globalThis.Number(object.baseMovespeed) : 0,
      baseDamage: isSet(object.baseDamage) ? globalThis.Number(object.baseDamage) : 0,
      strength: isSet(object.strength) ? globalThis.Number(object.strength) : 0,
      agility: isSet(object.agility) ? globalThis.Number(object.agility) : 0,
      intelligence: isSet(object.intelligence) ? globalThis.Number(object.intelligence) : 0,
      armor: isSet(object.armor) ? globalThis.Number(object.armor) : 0,
      movespeed: isSet(object.movespeed) ? globalThis.Number(object.movespeed) : 0,
      damage: isSet(object.damage) ? globalThis.Number(object.damage) : 0,
      heroDamage: isSet(object.heroDamage) ? globalThis.Number(object.heroDamage) : 0,
      towerDamage: isSet(object.towerDamage) ? globalThis.Number(object.towerDamage) : 0,
      abilities: globalThis.Array.isArray(object?.abilities)
        ? object.abilities.map((e: any) => CMsgDOTARealtimeGameStats_AbilityDetails.fromJSON(e))
        : [],
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      killCount: isSet(object.killCount) ? globalThis.Number(object.killCount) : 0,
      deathCount: isSet(object.deathCount) ? globalThis.Number(object.deathCount) : 0,
      assistsCount: isSet(object.assistsCount) ? globalThis.Number(object.assistsCount) : 0,
      deniesCount: isSet(object.deniesCount) ? globalThis.Number(object.deniesCount) : 0,
      lhCount: isSet(object.lhCount) ? globalThis.Number(object.lhCount) : 0,
      heroHealing: isSet(object.heroHealing) ? globalThis.Number(object.heroHealing) : 0,
      goldPerMin: isSet(object.goldPerMin) ? globalThis.Number(object.goldPerMin) : 0,
      xpPerMin: isSet(object.xpPerMin) ? globalThis.Number(object.xpPerMin) : 0,
      netGold: isSet(object.netGold) ? globalThis.Number(object.netGold) : 0,
      gold: isSet(object.gold) ? globalThis.Number(object.gold) : 0,
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      respawnTime: isSet(object.respawnTime) ? globalThis.Number(object.respawnTime) : 0,
      ultimateCooldown: isSet(object.ultimateCooldown) ? globalThis.Number(object.ultimateCooldown) : 0,
      hasBuyback: isSet(object.hasBuyback) ? globalThis.Boolean(object.hasBuyback) : false,
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => CMsgDOTARealtimeGameStats_ItemDetails.fromJSON(e))
        : [],
      stashitems: globalThis.Array.isArray(object?.stashitems)
        ? object.stashitems.map((e: any) => CMsgDOTARealtimeGameStats_ItemDetails.fromJSON(e))
        : [],
      itemshoppinglist: globalThis.Array.isArray(object?.itemshoppinglist)
        ? object.itemshoppinglist.map((e: any) => CMsgDOTARealtimeGameStats_ItemDetails.fromJSON(e))
        : [],
      levelpoints: globalThis.Array.isArray(object?.levelpoints)
        ? object.levelpoints.map((e: any) => CMsgDOTARealtimeGameStats_AbilityList.fromJSON(e))
        : [],
      heroToHeroStats: globalThis.Array.isArray(object?.heroToHeroStats)
        ? object.heroToHeroStats.map((e: any) => CMsgDOTARealtimeGameStats_HeroToHeroStats.fromJSON(e))
        : [],
      hasUltimate: isSet(object.hasUltimate) ? globalThis.Boolean(object.hasUltimate) : false,
      hasUltimateMana: isSet(object.hasUltimateMana) ? globalThis.Boolean(object.hasUltimateMana) : false,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_PlayerDetails): unknown {
    const obj: any = {};
    if (message.accountid !== 0) {
      obj.accountid = Math.round(message.accountid);
    }
    if (message.playerid !== -1) {
      obj.playerid = Math.round(message.playerid);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    if (message.heroid !== 0) {
      obj.heroid = Math.round(message.heroid);
    }
    if (message.healthpoints !== 0) {
      obj.healthpoints = Math.round(message.healthpoints);
    }
    if (message.maxhealthpoints !== 0) {
      obj.maxhealthpoints = Math.round(message.maxhealthpoints);
    }
    if (message.healthregenrate !== 0) {
      obj.healthregenrate = message.healthregenrate;
    }
    if (message.manapoints !== 0) {
      obj.manapoints = Math.round(message.manapoints);
    }
    if (message.maxmanapoints !== 0) {
      obj.maxmanapoints = Math.round(message.maxmanapoints);
    }
    if (message.manaregenrate !== 0) {
      obj.manaregenrate = message.manaregenrate;
    }
    if (message.baseStrength !== 0) {
      obj.baseStrength = Math.round(message.baseStrength);
    }
    if (message.baseAgility !== 0) {
      obj.baseAgility = Math.round(message.baseAgility);
    }
    if (message.baseIntelligence !== 0) {
      obj.baseIntelligence = Math.round(message.baseIntelligence);
    }
    if (message.baseArmor !== 0) {
      obj.baseArmor = Math.round(message.baseArmor);
    }
    if (message.baseMovespeed !== 0) {
      obj.baseMovespeed = Math.round(message.baseMovespeed);
    }
    if (message.baseDamage !== 0) {
      obj.baseDamage = Math.round(message.baseDamage);
    }
    if (message.strength !== 0) {
      obj.strength = Math.round(message.strength);
    }
    if (message.agility !== 0) {
      obj.agility = Math.round(message.agility);
    }
    if (message.intelligence !== 0) {
      obj.intelligence = Math.round(message.intelligence);
    }
    if (message.armor !== 0) {
      obj.armor = Math.round(message.armor);
    }
    if (message.movespeed !== 0) {
      obj.movespeed = Math.round(message.movespeed);
    }
    if (message.damage !== 0) {
      obj.damage = Math.round(message.damage);
    }
    if (message.heroDamage !== 0) {
      obj.heroDamage = Math.round(message.heroDamage);
    }
    if (message.towerDamage !== 0) {
      obj.towerDamage = Math.round(message.towerDamage);
    }
    if (message.abilities?.length) {
      obj.abilities = message.abilities.map((e) => CMsgDOTARealtimeGameStats_AbilityDetails.toJSON(e));
    }
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.killCount !== 0) {
      obj.killCount = Math.round(message.killCount);
    }
    if (message.deathCount !== 0) {
      obj.deathCount = Math.round(message.deathCount);
    }
    if (message.assistsCount !== 0) {
      obj.assistsCount = Math.round(message.assistsCount);
    }
    if (message.deniesCount !== 0) {
      obj.deniesCount = Math.round(message.deniesCount);
    }
    if (message.lhCount !== 0) {
      obj.lhCount = Math.round(message.lhCount);
    }
    if (message.heroHealing !== 0) {
      obj.heroHealing = Math.round(message.heroHealing);
    }
    if (message.goldPerMin !== 0) {
      obj.goldPerMin = Math.round(message.goldPerMin);
    }
    if (message.xpPerMin !== 0) {
      obj.xpPerMin = Math.round(message.xpPerMin);
    }
    if (message.netGold !== 0) {
      obj.netGold = Math.round(message.netGold);
    }
    if (message.gold !== 0) {
      obj.gold = Math.round(message.gold);
    }
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.respawnTime !== 0) {
      obj.respawnTime = Math.round(message.respawnTime);
    }
    if (message.ultimateCooldown !== 0) {
      obj.ultimateCooldown = Math.round(message.ultimateCooldown);
    }
    if (message.hasBuyback !== false) {
      obj.hasBuyback = message.hasBuyback;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => CMsgDOTARealtimeGameStats_ItemDetails.toJSON(e));
    }
    if (message.stashitems?.length) {
      obj.stashitems = message.stashitems.map((e) => CMsgDOTARealtimeGameStats_ItemDetails.toJSON(e));
    }
    if (message.itemshoppinglist?.length) {
      obj.itemshoppinglist = message.itemshoppinglist.map((e) => CMsgDOTARealtimeGameStats_ItemDetails.toJSON(e));
    }
    if (message.levelpoints?.length) {
      obj.levelpoints = message.levelpoints.map((e) => CMsgDOTARealtimeGameStats_AbilityList.toJSON(e));
    }
    if (message.heroToHeroStats?.length) {
      obj.heroToHeroStats = message.heroToHeroStats.map((e) => CMsgDOTARealtimeGameStats_HeroToHeroStats.toJSON(e));
    }
    if (message.hasUltimate !== false) {
      obj.hasUltimate = message.hasUltimate;
    }
    if (message.hasUltimateMana !== false) {
      obj.hasUltimateMana = message.hasUltimateMana;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_PlayerDetails>): CMsgDOTARealtimeGameStats_PlayerDetails {
    return CMsgDOTARealtimeGameStats_PlayerDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStats_PlayerDetails>): CMsgDOTARealtimeGameStats_PlayerDetails {
    const message = createBaseCMsgDOTARealtimeGameStats_PlayerDetails();
    message.accountid = object.accountid ?? 0;
    message.playerid = object.playerid ?? -1;
    message.name = object.name ?? "";
    message.team = object.team ?? 0;
    message.heroid = object.heroid ?? 0;
    message.healthpoints = object.healthpoints ?? 0;
    message.maxhealthpoints = object.maxhealthpoints ?? 0;
    message.healthregenrate = object.healthregenrate ?? 0;
    message.manapoints = object.manapoints ?? 0;
    message.maxmanapoints = object.maxmanapoints ?? 0;
    message.manaregenrate = object.manaregenrate ?? 0;
    message.baseStrength = object.baseStrength ?? 0;
    message.baseAgility = object.baseAgility ?? 0;
    message.baseIntelligence = object.baseIntelligence ?? 0;
    message.baseArmor = object.baseArmor ?? 0;
    message.baseMovespeed = object.baseMovespeed ?? 0;
    message.baseDamage = object.baseDamage ?? 0;
    message.strength = object.strength ?? 0;
    message.agility = object.agility ?? 0;
    message.intelligence = object.intelligence ?? 0;
    message.armor = object.armor ?? 0;
    message.movespeed = object.movespeed ?? 0;
    message.damage = object.damage ?? 0;
    message.heroDamage = object.heroDamage ?? 0;
    message.towerDamage = object.towerDamage ?? 0;
    message.abilities = object.abilities?.map((e) => CMsgDOTARealtimeGameStats_AbilityDetails.fromPartial(e)) || [];
    message.level = object.level ?? 0;
    message.killCount = object.killCount ?? 0;
    message.deathCount = object.deathCount ?? 0;
    message.assistsCount = object.assistsCount ?? 0;
    message.deniesCount = object.deniesCount ?? 0;
    message.lhCount = object.lhCount ?? 0;
    message.heroHealing = object.heroHealing ?? 0;
    message.goldPerMin = object.goldPerMin ?? 0;
    message.xpPerMin = object.xpPerMin ?? 0;
    message.netGold = object.netGold ?? 0;
    message.gold = object.gold ?? 0;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.respawnTime = object.respawnTime ?? 0;
    message.ultimateCooldown = object.ultimateCooldown ?? 0;
    message.hasBuyback = object.hasBuyback ?? false;
    message.items = object.items?.map((e) => CMsgDOTARealtimeGameStats_ItemDetails.fromPartial(e)) || [];
    message.stashitems = object.stashitems?.map((e) => CMsgDOTARealtimeGameStats_ItemDetails.fromPartial(e)) || [];
    message.itemshoppinglist =
      object.itemshoppinglist?.map((e) => CMsgDOTARealtimeGameStats_ItemDetails.fromPartial(e)) || [];
    message.levelpoints = object.levelpoints?.map((e) => CMsgDOTARealtimeGameStats_AbilityList.fromPartial(e)) || [];
    message.heroToHeroStats =
      object.heroToHeroStats?.map((e) => CMsgDOTARealtimeGameStats_HeroToHeroStats.fromPartial(e)) || [];
    message.hasUltimate = object.hasUltimate ?? false;
    message.hasUltimateMana = object.hasUltimateMana ?? false;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_BuildingDetails(): CMsgDOTARealtimeGameStats_BuildingDetails {
  return { team: 0, heading: 0, lane: 0, tier: 0, type: 0, x: 0, y: 0, destroyed: false };
}

export const CMsgDOTARealtimeGameStats_BuildingDetails: MessageFns<CMsgDOTARealtimeGameStats_BuildingDetails> = {
  encode(message: CMsgDOTARealtimeGameStats_BuildingDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.team !== 0) {
      writer.uint32(16).uint32(message.team);
    }
    if (message.heading !== 0) {
      writer.uint32(29).float(message.heading);
    }
    if (message.lane !== 0) {
      writer.uint32(32).uint32(message.lane);
    }
    if (message.tier !== 0) {
      writer.uint32(40).uint32(message.tier);
    }
    if (message.type !== 0) {
      writer.uint32(48).uint32(message.type);
    }
    if (message.x !== 0) {
      writer.uint32(61).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(69).float(message.y);
    }
    if (message.destroyed !== false) {
      writer.uint32(72).bool(message.destroyed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_BuildingDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_BuildingDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.team = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.heading = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lane = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.tier = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.type = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.y = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.destroyed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_BuildingDetails {
    return {
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
      heading: isSet(object.heading) ? globalThis.Number(object.heading) : 0,
      lane: isSet(object.lane) ? globalThis.Number(object.lane) : 0,
      tier: isSet(object.tier) ? globalThis.Number(object.tier) : 0,
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      destroyed: isSet(object.destroyed) ? globalThis.Boolean(object.destroyed) : false,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_BuildingDetails): unknown {
    const obj: any = {};
    if (message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    if (message.heading !== 0) {
      obj.heading = message.heading;
    }
    if (message.lane !== 0) {
      obj.lane = Math.round(message.lane);
    }
    if (message.tier !== 0) {
      obj.tier = Math.round(message.tier);
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.destroyed !== false) {
      obj.destroyed = message.destroyed;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_BuildingDetails>): CMsgDOTARealtimeGameStats_BuildingDetails {
    return CMsgDOTARealtimeGameStats_BuildingDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTARealtimeGameStats_BuildingDetails>,
  ): CMsgDOTARealtimeGameStats_BuildingDetails {
    const message = createBaseCMsgDOTARealtimeGameStats_BuildingDetails();
    message.team = object.team ?? 0;
    message.heading = object.heading ?? 0;
    message.lane = object.lane ?? 0;
    message.tier = object.tier ?? 0;
    message.type = object.type ?? 0;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.destroyed = object.destroyed ?? false;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_KillDetails(): CMsgDOTARealtimeGameStats_KillDetails {
  return { playerId: -1, deathTime: 0, killerPlayerId: -1 };
}

export const CMsgDOTARealtimeGameStats_KillDetails: MessageFns<CMsgDOTARealtimeGameStats_KillDetails> = {
  encode(message: CMsgDOTARealtimeGameStats_KillDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.deathTime !== 0) {
      writer.uint32(16).int32(message.deathTime);
    }
    if (message.killerPlayerId !== -1) {
      writer.uint32(24).int32(message.killerPlayerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_KillDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_KillDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.deathTime = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.killerPlayerId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_KillDetails {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      deathTime: isSet(object.deathTime) ? globalThis.Number(object.deathTime) : 0,
      killerPlayerId: isSet(object.killerPlayerId) ? globalThis.Number(object.killerPlayerId) : -1,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_KillDetails): unknown {
    const obj: any = {};
    if (message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.deathTime !== 0) {
      obj.deathTime = Math.round(message.deathTime);
    }
    if (message.killerPlayerId !== -1) {
      obj.killerPlayerId = Math.round(message.killerPlayerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_KillDetails>): CMsgDOTARealtimeGameStats_KillDetails {
    return CMsgDOTARealtimeGameStats_KillDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStats_KillDetails>): CMsgDOTARealtimeGameStats_KillDetails {
    const message = createBaseCMsgDOTARealtimeGameStats_KillDetails();
    message.playerId = object.playerId ?? -1;
    message.deathTime = object.deathTime ?? 0;
    message.killerPlayerId = object.killerPlayerId ?? -1;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_BroadcasterDetails(): CMsgDOTARealtimeGameStats_BroadcasterDetails {
  return { playerId: -1 };
}

export const CMsgDOTARealtimeGameStats_BroadcasterDetails: MessageFns<CMsgDOTARealtimeGameStats_BroadcasterDetails> = {
  encode(
    message: CMsgDOTARealtimeGameStats_BroadcasterDetails,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_BroadcasterDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_BroadcasterDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_BroadcasterDetails {
    return { playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1 };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_BroadcasterDetails): unknown {
    const obj: any = {};
    if (message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTARealtimeGameStats_BroadcasterDetails>,
  ): CMsgDOTARealtimeGameStats_BroadcasterDetails {
    return CMsgDOTARealtimeGameStats_BroadcasterDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTARealtimeGameStats_BroadcasterDetails>,
  ): CMsgDOTARealtimeGameStats_BroadcasterDetails {
    const message = createBaseCMsgDOTARealtimeGameStats_BroadcasterDetails();
    message.playerId = object.playerId ?? -1;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_PickBanDetails(): CMsgDOTARealtimeGameStats_PickBanDetails {
  return { hero: 0, team: 0 };
}

export const CMsgDOTARealtimeGameStats_PickBanDetails: MessageFns<CMsgDOTARealtimeGameStats_PickBanDetails> = {
  encode(message: CMsgDOTARealtimeGameStats_PickBanDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hero !== 0) {
      writer.uint32(8).uint32(message.hero);
    }
    if (message.team !== 0) {
      writer.uint32(16).uint32(message.team);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_PickBanDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_PickBanDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hero = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.team = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_PickBanDetails {
    return {
      hero: isSet(object.hero) ? globalThis.Number(object.hero) : 0,
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_PickBanDetails): unknown {
    const obj: any = {};
    if (message.hero !== 0) {
      obj.hero = Math.round(message.hero);
    }
    if (message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_PickBanDetails>): CMsgDOTARealtimeGameStats_PickBanDetails {
    return CMsgDOTARealtimeGameStats_PickBanDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStats_PickBanDetails>): CMsgDOTARealtimeGameStats_PickBanDetails {
    const message = createBaseCMsgDOTARealtimeGameStats_PickBanDetails();
    message.hero = object.hero ?? 0;
    message.team = object.team ?? 0;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_MatchDetails(): CMsgDOTARealtimeGameStats_MatchDetails {
  return {
    serverSteamId: "0",
    matchId: "0",
    timestamp: 0,
    timeOfDay: 0,
    isNightstalkerNight: false,
    gameTime: 0,
    gameState: 0,
    teamidRadiant: 0,
    teamidDire: 0,
    picks: [],
    bans: [],
    kills: [],
    broadcasters: [],
    gameMode: 0,
    leagueId: 0,
    leagueNodeId: 0,
    singleTeam: false,
    cheersPeak: 0,
    lobbyType: 0,
    startTimestamp: 0,
  };
}

export const CMsgDOTARealtimeGameStats_MatchDetails: MessageFns<CMsgDOTARealtimeGameStats_MatchDetails> = {
  encode(message: CMsgDOTARealtimeGameStats_MatchDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serverSteamId !== "0") {
      writer.uint32(9).fixed64(message.serverSteamId);
    }
    if (message.matchId !== "0") {
      writer.uint32(16).uint64(message.matchId);
    }
    if (message.timestamp !== 0) {
      writer.uint32(24).uint32(message.timestamp);
    }
    if (message.timeOfDay !== 0) {
      writer.uint32(37).float(message.timeOfDay);
    }
    if (message.isNightstalkerNight !== false) {
      writer.uint32(40).bool(message.isNightstalkerNight);
    }
    if (message.gameTime !== 0) {
      writer.uint32(48).int32(message.gameTime);
    }
    if (message.gameState !== 0) {
      writer.uint32(152).uint32(message.gameState);
    }
    if (message.teamidRadiant !== 0) {
      writer.uint32(64).uint32(message.teamidRadiant);
    }
    if (message.teamidDire !== 0) {
      writer.uint32(72).uint32(message.teamidDire);
    }
    for (const v of message.picks) {
      CMsgDOTARealtimeGameStats_PickBanDetails.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.bans) {
      CMsgDOTARealtimeGameStats_PickBanDetails.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.kills) {
      CMsgDOTARealtimeGameStats_KillDetails.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.broadcasters) {
      CMsgDOTARealtimeGameStats_BroadcasterDetails.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.gameMode !== 0) {
      writer.uint32(112).uint32(message.gameMode);
    }
    if (message.leagueId !== 0) {
      writer.uint32(120).uint32(message.leagueId);
    }
    if (message.leagueNodeId !== 0) {
      writer.uint32(144).uint32(message.leagueNodeId);
    }
    if (message.singleTeam !== false) {
      writer.uint32(128).bool(message.singleTeam);
    }
    if (message.cheersPeak !== 0) {
      writer.uint32(136).uint32(message.cheersPeak);
    }
    if (message.lobbyType !== 0) {
      writer.uint32(160).uint32(message.lobbyType);
    }
    if (message.startTimestamp !== 0) {
      writer.uint32(168).uint32(message.startTimestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_MatchDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_MatchDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.serverSteamId = reader.fixed64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.matchId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.timeOfDay = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isNightstalkerNight = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.gameTime = reader.int32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.gameState = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.teamidRadiant = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.teamidDire = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.picks.push(CMsgDOTARealtimeGameStats_PickBanDetails.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.bans.push(CMsgDOTARealtimeGameStats_PickBanDetails.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.kills.push(CMsgDOTARealtimeGameStats_KillDetails.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.broadcasters.push(CMsgDOTARealtimeGameStats_BroadcasterDetails.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.gameMode = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.leagueNodeId = reader.uint32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.singleTeam = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.cheersPeak = reader.uint32();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.lobbyType = reader.uint32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.startTimestamp = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_MatchDetails {
    return {
      serverSteamId: isSet(object.serverSteamId) ? globalThis.String(object.serverSteamId) : "0",
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      timeOfDay: isSet(object.timeOfDay) ? globalThis.Number(object.timeOfDay) : 0,
      isNightstalkerNight: isSet(object.isNightstalkerNight) ? globalThis.Boolean(object.isNightstalkerNight) : false,
      gameTime: isSet(object.gameTime) ? globalThis.Number(object.gameTime) : 0,
      gameState: isSet(object.gameState) ? globalThis.Number(object.gameState) : 0,
      teamidRadiant: isSet(object.teamidRadiant) ? globalThis.Number(object.teamidRadiant) : 0,
      teamidDire: isSet(object.teamidDire) ? globalThis.Number(object.teamidDire) : 0,
      picks: globalThis.Array.isArray(object?.picks)
        ? object.picks.map((e: any) => CMsgDOTARealtimeGameStats_PickBanDetails.fromJSON(e))
        : [],
      bans: globalThis.Array.isArray(object?.bans)
        ? object.bans.map((e: any) => CMsgDOTARealtimeGameStats_PickBanDetails.fromJSON(e))
        : [],
      kills: globalThis.Array.isArray(object?.kills)
        ? object.kills.map((e: any) => CMsgDOTARealtimeGameStats_KillDetails.fromJSON(e))
        : [],
      broadcasters: globalThis.Array.isArray(object?.broadcasters)
        ? object.broadcasters.map((e: any) => CMsgDOTARealtimeGameStats_BroadcasterDetails.fromJSON(e))
        : [],
      gameMode: isSet(object.gameMode) ? globalThis.Number(object.gameMode) : 0,
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      leagueNodeId: isSet(object.leagueNodeId) ? globalThis.Number(object.leagueNodeId) : 0,
      singleTeam: isSet(object.singleTeam) ? globalThis.Boolean(object.singleTeam) : false,
      cheersPeak: isSet(object.cheersPeak) ? globalThis.Number(object.cheersPeak) : 0,
      lobbyType: isSet(object.lobbyType) ? globalThis.Number(object.lobbyType) : 0,
      startTimestamp: isSet(object.startTimestamp) ? globalThis.Number(object.startTimestamp) : 0,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_MatchDetails): unknown {
    const obj: any = {};
    if (message.serverSteamId !== "0") {
      obj.serverSteamId = message.serverSteamId;
    }
    if (message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.timeOfDay !== 0) {
      obj.timeOfDay = message.timeOfDay;
    }
    if (message.isNightstalkerNight !== false) {
      obj.isNightstalkerNight = message.isNightstalkerNight;
    }
    if (message.gameTime !== 0) {
      obj.gameTime = Math.round(message.gameTime);
    }
    if (message.gameState !== 0) {
      obj.gameState = Math.round(message.gameState);
    }
    if (message.teamidRadiant !== 0) {
      obj.teamidRadiant = Math.round(message.teamidRadiant);
    }
    if (message.teamidDire !== 0) {
      obj.teamidDire = Math.round(message.teamidDire);
    }
    if (message.picks?.length) {
      obj.picks = message.picks.map((e) => CMsgDOTARealtimeGameStats_PickBanDetails.toJSON(e));
    }
    if (message.bans?.length) {
      obj.bans = message.bans.map((e) => CMsgDOTARealtimeGameStats_PickBanDetails.toJSON(e));
    }
    if (message.kills?.length) {
      obj.kills = message.kills.map((e) => CMsgDOTARealtimeGameStats_KillDetails.toJSON(e));
    }
    if (message.broadcasters?.length) {
      obj.broadcasters = message.broadcasters.map((e) => CMsgDOTARealtimeGameStats_BroadcasterDetails.toJSON(e));
    }
    if (message.gameMode !== 0) {
      obj.gameMode = Math.round(message.gameMode);
    }
    if (message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.leagueNodeId !== 0) {
      obj.leagueNodeId = Math.round(message.leagueNodeId);
    }
    if (message.singleTeam !== false) {
      obj.singleTeam = message.singleTeam;
    }
    if (message.cheersPeak !== 0) {
      obj.cheersPeak = Math.round(message.cheersPeak);
    }
    if (message.lobbyType !== 0) {
      obj.lobbyType = Math.round(message.lobbyType);
    }
    if (message.startTimestamp !== 0) {
      obj.startTimestamp = Math.round(message.startTimestamp);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_MatchDetails>): CMsgDOTARealtimeGameStats_MatchDetails {
    return CMsgDOTARealtimeGameStats_MatchDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStats_MatchDetails>): CMsgDOTARealtimeGameStats_MatchDetails {
    const message = createBaseCMsgDOTARealtimeGameStats_MatchDetails();
    message.serverSteamId = object.serverSteamId ?? "0";
    message.matchId = object.matchId ?? "0";
    message.timestamp = object.timestamp ?? 0;
    message.timeOfDay = object.timeOfDay ?? 0;
    message.isNightstalkerNight = object.isNightstalkerNight ?? false;
    message.gameTime = object.gameTime ?? 0;
    message.gameState = object.gameState ?? 0;
    message.teamidRadiant = object.teamidRadiant ?? 0;
    message.teamidDire = object.teamidDire ?? 0;
    message.picks = object.picks?.map((e) => CMsgDOTARealtimeGameStats_PickBanDetails.fromPartial(e)) || [];
    message.bans = object.bans?.map((e) => CMsgDOTARealtimeGameStats_PickBanDetails.fromPartial(e)) || [];
    message.kills = object.kills?.map((e) => CMsgDOTARealtimeGameStats_KillDetails.fromPartial(e)) || [];
    message.broadcasters =
      object.broadcasters?.map((e) => CMsgDOTARealtimeGameStats_BroadcasterDetails.fromPartial(e)) || [];
    message.gameMode = object.gameMode ?? 0;
    message.leagueId = object.leagueId ?? 0;
    message.leagueNodeId = object.leagueNodeId ?? 0;
    message.singleTeam = object.singleTeam ?? false;
    message.cheersPeak = object.cheersPeak ?? 0;
    message.lobbyType = object.lobbyType ?? 0;
    message.startTimestamp = object.startTimestamp ?? 0;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_GraphData(): CMsgDOTARealtimeGameStats_GraphData {
  return { graphGold: [], graphXp: [], graphKill: [], graphTower: [], graphRax: [], teamLocStats: [] };
}

export const CMsgDOTARealtimeGameStats_GraphData: MessageFns<CMsgDOTARealtimeGameStats_GraphData> = {
  encode(message: CMsgDOTARealtimeGameStats_GraphData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.graphGold) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(18).fork();
    for (const v of message.graphXp) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(26).fork();
    for (const v of message.graphKill) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(34).fork();
    for (const v of message.graphTower) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(42).fork();
    for (const v of message.graphRax) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.teamLocStats) {
      CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_GraphData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_GraphData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.graphGold.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.graphGold.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag === 16) {
            message.graphXp.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.graphXp.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag === 24) {
            message.graphKill.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.graphKill.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag === 32) {
            message.graphTower.push(reader.int32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.graphTower.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag === 40) {
            message.graphRax.push(reader.int32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.graphRax.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.teamLocStats.push(
            CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_GraphData {
    return {
      graphGold: globalThis.Array.isArray(object?.graphGold)
        ? object.graphGold.map((e: any) => globalThis.Number(e))
        : [],
      graphXp: globalThis.Array.isArray(object?.graphXp) ? object.graphXp.map((e: any) => globalThis.Number(e)) : [],
      graphKill: globalThis.Array.isArray(object?.graphKill)
        ? object.graphKill.map((e: any) => globalThis.Number(e))
        : [],
      graphTower: globalThis.Array.isArray(object?.graphTower)
        ? object.graphTower.map((e: any) => globalThis.Number(e))
        : [],
      graphRax: globalThis.Array.isArray(object?.graphRax) ? object.graphRax.map((e: any) => globalThis.Number(e)) : [],
      teamLocStats: globalThis.Array.isArray(object?.teamLocStats)
        ? object.teamLocStats.map((e: any) => CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_GraphData): unknown {
    const obj: any = {};
    if (message.graphGold?.length) {
      obj.graphGold = message.graphGold.map((e) => Math.round(e));
    }
    if (message.graphXp?.length) {
      obj.graphXp = message.graphXp.map((e) => Math.round(e));
    }
    if (message.graphKill?.length) {
      obj.graphKill = message.graphKill.map((e) => Math.round(e));
    }
    if (message.graphTower?.length) {
      obj.graphTower = message.graphTower.map((e) => Math.round(e));
    }
    if (message.graphRax?.length) {
      obj.graphRax = message.graphRax.map((e) => Math.round(e));
    }
    if (message.teamLocStats?.length) {
      obj.teamLocStats = message.teamLocStats.map((e) =>
        CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_GraphData>): CMsgDOTARealtimeGameStats_GraphData {
    return CMsgDOTARealtimeGameStats_GraphData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStats_GraphData>): CMsgDOTARealtimeGameStats_GraphData {
    const message = createBaseCMsgDOTARealtimeGameStats_GraphData();
    message.graphGold = object.graphGold?.map((e) => e) || [];
    message.graphXp = object.graphXp?.map((e) => e) || [];
    message.graphKill = object.graphKill?.map((e) => e) || [];
    message.graphTower = object.graphTower?.map((e) => e) || [];
    message.graphRax = object.graphRax?.map((e) => e) || [];
    message.teamLocStats =
      object.teamLocStats?.map((e) => CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_GraphData_LocationStats(): CMsgDOTARealtimeGameStats_GraphData_LocationStats {
  return { stats: [] };
}

export const CMsgDOTARealtimeGameStats_GraphData_LocationStats: MessageFns<
  CMsgDOTARealtimeGameStats_GraphData_LocationStats
> = {
  encode(
    message: CMsgDOTARealtimeGameStats_GraphData_LocationStats,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.stats) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_GraphData_LocationStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_GraphData_LocationStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.stats.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.stats.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_GraphData_LocationStats {
    return { stats: globalThis.Array.isArray(object?.stats) ? object.stats.map((e: any) => globalThis.Number(e)) : [] };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_GraphData_LocationStats): unknown {
    const obj: any = {};
    if (message.stats?.length) {
      obj.stats = message.stats.map((e) => Math.round(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTARealtimeGameStats_GraphData_LocationStats>,
  ): CMsgDOTARealtimeGameStats_GraphData_LocationStats {
    return CMsgDOTARealtimeGameStats_GraphData_LocationStats.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTARealtimeGameStats_GraphData_LocationStats>,
  ): CMsgDOTARealtimeGameStats_GraphData_LocationStats {
    const message = createBaseCMsgDOTARealtimeGameStats_GraphData_LocationStats();
    message.stats = object.stats?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_GraphData_TeamLocationStats(): CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
  return { locStats: [] };
}

export const CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats: MessageFns<
  CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats
> = {
  encode(
    message: CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.locStats) {
      CMsgDOTARealtimeGameStats_GraphData_LocationStats.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_GraphData_TeamLocationStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.locStats.push(CMsgDOTARealtimeGameStats_GraphData_LocationStats.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
    return {
      locStats: globalThis.Array.isArray(object?.locStats)
        ? object.locStats.map((e: any) => CMsgDOTARealtimeGameStats_GraphData_LocationStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats): unknown {
    const obj: any = {};
    if (message.locStats?.length) {
      obj.locStats = message.locStats.map((e) => CMsgDOTARealtimeGameStats_GraphData_LocationStats.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats>,
  ): CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
    return CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats>,
  ): CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
    const message = createBaseCMsgDOTARealtimeGameStats_GraphData_TeamLocationStats();
    message.locStats = object.locStats?.map((e) => CMsgDOTARealtimeGameStats_GraphData_LocationStats.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStatsTerse(): CMsgDOTARealtimeGameStatsTerse {
  return { match: undefined, teams: [], buildings: [], graphData: undefined, deltaFrame: false };
}

export const CMsgDOTARealtimeGameStatsTerse: MessageFns<CMsgDOTARealtimeGameStatsTerse> = {
  encode(message: CMsgDOTARealtimeGameStatsTerse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.match !== undefined) {
      CMsgDOTARealtimeGameStatsTerse_MatchDetails.encode(message.match, writer.uint32(10).fork()).join();
    }
    for (const v of message.teams) {
      CMsgDOTARealtimeGameStatsTerse_TeamDetails.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.buildings) {
      CMsgDOTARealtimeGameStatsTerse_BuildingDetails.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.graphData !== undefined) {
      CMsgDOTARealtimeGameStatsTerse_GraphData.encode(message.graphData, writer.uint32(34).fork()).join();
    }
    if (message.deltaFrame !== false) {
      writer.uint32(40).bool(message.deltaFrame);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStatsTerse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStatsTerse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.match = CMsgDOTARealtimeGameStatsTerse_MatchDetails.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.teams.push(CMsgDOTARealtimeGameStatsTerse_TeamDetails.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.buildings.push(CMsgDOTARealtimeGameStatsTerse_BuildingDetails.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.graphData = CMsgDOTARealtimeGameStatsTerse_GraphData.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.deltaFrame = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStatsTerse {
    return {
      match: isSet(object.match) ? CMsgDOTARealtimeGameStatsTerse_MatchDetails.fromJSON(object.match) : undefined,
      teams: globalThis.Array.isArray(object?.teams)
        ? object.teams.map((e: any) => CMsgDOTARealtimeGameStatsTerse_TeamDetails.fromJSON(e))
        : [],
      buildings: globalThis.Array.isArray(object?.buildings)
        ? object.buildings.map((e: any) => CMsgDOTARealtimeGameStatsTerse_BuildingDetails.fromJSON(e))
        : [],
      graphData: isSet(object.graphData)
        ? CMsgDOTARealtimeGameStatsTerse_GraphData.fromJSON(object.graphData)
        : undefined,
      deltaFrame: isSet(object.deltaFrame) ? globalThis.Boolean(object.deltaFrame) : false,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStatsTerse): unknown {
    const obj: any = {};
    if (message.match !== undefined) {
      obj.match = CMsgDOTARealtimeGameStatsTerse_MatchDetails.toJSON(message.match);
    }
    if (message.teams?.length) {
      obj.teams = message.teams.map((e) => CMsgDOTARealtimeGameStatsTerse_TeamDetails.toJSON(e));
    }
    if (message.buildings?.length) {
      obj.buildings = message.buildings.map((e) => CMsgDOTARealtimeGameStatsTerse_BuildingDetails.toJSON(e));
    }
    if (message.graphData !== undefined) {
      obj.graphData = CMsgDOTARealtimeGameStatsTerse_GraphData.toJSON(message.graphData);
    }
    if (message.deltaFrame !== false) {
      obj.deltaFrame = message.deltaFrame;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStatsTerse>): CMsgDOTARealtimeGameStatsTerse {
    return CMsgDOTARealtimeGameStatsTerse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStatsTerse>): CMsgDOTARealtimeGameStatsTerse {
    const message = createBaseCMsgDOTARealtimeGameStatsTerse();
    message.match = (object.match !== undefined && object.match !== null)
      ? CMsgDOTARealtimeGameStatsTerse_MatchDetails.fromPartial(object.match)
      : undefined;
    message.teams = object.teams?.map((e) => CMsgDOTARealtimeGameStatsTerse_TeamDetails.fromPartial(e)) || [];
    message.buildings = object.buildings?.map((e) => CMsgDOTARealtimeGameStatsTerse_BuildingDetails.fromPartial(e)) ||
      [];
    message.graphData = (object.graphData !== undefined && object.graphData !== null)
      ? CMsgDOTARealtimeGameStatsTerse_GraphData.fromPartial(object.graphData)
      : undefined;
    message.deltaFrame = object.deltaFrame ?? false;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStatsTerse_TeamDetails(): CMsgDOTARealtimeGameStatsTerse_TeamDetails {
  return {
    teamNumber: 0,
    teamId: 0,
    teamName: "",
    teamTag: "",
    teamLogo: "0",
    score: 0,
    netWorth: 0,
    teamLogoUrl: "",
    players: [],
  };
}

export const CMsgDOTARealtimeGameStatsTerse_TeamDetails: MessageFns<CMsgDOTARealtimeGameStatsTerse_TeamDetails> = {
  encode(message: CMsgDOTARealtimeGameStatsTerse_TeamDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.teamNumber !== 0) {
      writer.uint32(8).uint32(message.teamNumber);
    }
    if (message.teamId !== 0) {
      writer.uint32(16).uint32(message.teamId);
    }
    if (message.teamName !== "") {
      writer.uint32(26).string(message.teamName);
    }
    if (message.teamTag !== "") {
      writer.uint32(66).string(message.teamTag);
    }
    if (message.teamLogo !== "0") {
      writer.uint32(33).fixed64(message.teamLogo);
    }
    if (message.score !== 0) {
      writer.uint32(40).uint32(message.score);
    }
    if (message.netWorth !== 0) {
      writer.uint32(56).uint32(message.netWorth);
    }
    if (message.teamLogoUrl !== "") {
      writer.uint32(74).string(message.teamLogoUrl);
    }
    for (const v of message.players) {
      CMsgDOTARealtimeGameStatsTerse_PlayerDetails.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStatsTerse_TeamDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_TeamDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.teamNumber = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.teamName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.teamTag = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.teamLogo = reader.fixed64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.score = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.netWorth = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.teamLogoUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.players.push(CMsgDOTARealtimeGameStatsTerse_PlayerDetails.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStatsTerse_TeamDetails {
    return {
      teamNumber: isSet(object.teamNumber) ? globalThis.Number(object.teamNumber) : 0,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      teamName: isSet(object.teamName) ? globalThis.String(object.teamName) : "",
      teamTag: isSet(object.teamTag) ? globalThis.String(object.teamTag) : "",
      teamLogo: isSet(object.teamLogo) ? globalThis.String(object.teamLogo) : "0",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      teamLogoUrl: isSet(object.teamLogoUrl) ? globalThis.String(object.teamLogoUrl) : "",
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgDOTARealtimeGameStatsTerse_PlayerDetails.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStatsTerse_TeamDetails): unknown {
    const obj: any = {};
    if (message.teamNumber !== 0) {
      obj.teamNumber = Math.round(message.teamNumber);
    }
    if (message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.teamName !== "") {
      obj.teamName = message.teamName;
    }
    if (message.teamTag !== "") {
      obj.teamTag = message.teamTag;
    }
    if (message.teamLogo !== "0") {
      obj.teamLogo = message.teamLogo;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.netWorth !== 0) {
      obj.netWorth = Math.round(message.netWorth);
    }
    if (message.teamLogoUrl !== "") {
      obj.teamLogoUrl = message.teamLogoUrl;
    }
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgDOTARealtimeGameStatsTerse_PlayerDetails.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStatsTerse_TeamDetails>): CMsgDOTARealtimeGameStatsTerse_TeamDetails {
    return CMsgDOTARealtimeGameStatsTerse_TeamDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTARealtimeGameStatsTerse_TeamDetails>,
  ): CMsgDOTARealtimeGameStatsTerse_TeamDetails {
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_TeamDetails();
    message.teamNumber = object.teamNumber ?? 0;
    message.teamId = object.teamId ?? 0;
    message.teamName = object.teamName ?? "";
    message.teamTag = object.teamTag ?? "";
    message.teamLogo = object.teamLogo ?? "0";
    message.score = object.score ?? 0;
    message.netWorth = object.netWorth ?? 0;
    message.teamLogoUrl = object.teamLogoUrl ?? "";
    message.players = object.players?.map((e) => CMsgDOTARealtimeGameStatsTerse_PlayerDetails.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStatsTerse_PlayerDetails(): CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
  return {
    accountid: 0,
    playerid: -1,
    name: "",
    team: 0,
    heroid: 0,
    level: 0,
    killCount: 0,
    deathCount: 0,
    assistsCount: 0,
    deniesCount: 0,
    lhCount: 0,
    gold: 0,
    x: 0,
    y: 0,
    netWorth: 0,
    abilities: [],
    items: [],
  };
}

export const CMsgDOTARealtimeGameStatsTerse_PlayerDetails: MessageFns<CMsgDOTARealtimeGameStatsTerse_PlayerDetails> = {
  encode(
    message: CMsgDOTARealtimeGameStatsTerse_PlayerDetails,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountid !== 0) {
      writer.uint32(8).uint32(message.accountid);
    }
    if (message.playerid !== -1) {
      writer.uint32(16).int32(message.playerid);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.team !== 0) {
      writer.uint32(32).uint32(message.team);
    }
    if (message.heroid !== 0) {
      writer.uint32(40).uint32(message.heroid);
    }
    if (message.level !== 0) {
      writer.uint32(48).uint32(message.level);
    }
    if (message.killCount !== 0) {
      writer.uint32(56).uint32(message.killCount);
    }
    if (message.deathCount !== 0) {
      writer.uint32(64).uint32(message.deathCount);
    }
    if (message.assistsCount !== 0) {
      writer.uint32(72).uint32(message.assistsCount);
    }
    if (message.deniesCount !== 0) {
      writer.uint32(80).uint32(message.deniesCount);
    }
    if (message.lhCount !== 0) {
      writer.uint32(88).uint32(message.lhCount);
    }
    if (message.gold !== 0) {
      writer.uint32(96).uint32(message.gold);
    }
    if (message.x !== 0) {
      writer.uint32(109).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(117).float(message.y);
    }
    if (message.netWorth !== 0) {
      writer.uint32(120).uint32(message.netWorth);
    }
    writer.uint32(130).fork();
    for (const v of message.abilities) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(138).fork();
    for (const v of message.items) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_PlayerDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountid = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.playerid = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.team = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.heroid = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.level = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.killCount = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.deathCount = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.assistsCount = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.deniesCount = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.lhCount = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.gold = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 109) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 14: {
          if (tag !== 117) {
            break;
          }

          message.y = reader.float();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.netWorth = reader.uint32();
          continue;
        }
        case 16: {
          if (tag === 128) {
            message.abilities.push(reader.int32());

            continue;
          }

          if (tag === 130) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.abilities.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 17: {
          if (tag === 136) {
            message.items.push(reader.int32());

            continue;
          }

          if (tag === 138) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.items.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
    return {
      accountid: isSet(object.accountid) ? globalThis.Number(object.accountid) : 0,
      playerid: isSet(object.playerid) ? globalThis.Number(object.playerid) : -1,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
      heroid: isSet(object.heroid) ? globalThis.Number(object.heroid) : 0,
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      killCount: isSet(object.killCount) ? globalThis.Number(object.killCount) : 0,
      deathCount: isSet(object.deathCount) ? globalThis.Number(object.deathCount) : 0,
      assistsCount: isSet(object.assistsCount) ? globalThis.Number(object.assistsCount) : 0,
      deniesCount: isSet(object.deniesCount) ? globalThis.Number(object.deniesCount) : 0,
      lhCount: isSet(object.lhCount) ? globalThis.Number(object.lhCount) : 0,
      gold: isSet(object.gold) ? globalThis.Number(object.gold) : 0,
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      abilities: globalThis.Array.isArray(object?.abilities)
        ? object.abilities.map((e: any) => globalThis.Number(e))
        : [],
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStatsTerse_PlayerDetails): unknown {
    const obj: any = {};
    if (message.accountid !== 0) {
      obj.accountid = Math.round(message.accountid);
    }
    if (message.playerid !== -1) {
      obj.playerid = Math.round(message.playerid);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    if (message.heroid !== 0) {
      obj.heroid = Math.round(message.heroid);
    }
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.killCount !== 0) {
      obj.killCount = Math.round(message.killCount);
    }
    if (message.deathCount !== 0) {
      obj.deathCount = Math.round(message.deathCount);
    }
    if (message.assistsCount !== 0) {
      obj.assistsCount = Math.round(message.assistsCount);
    }
    if (message.deniesCount !== 0) {
      obj.deniesCount = Math.round(message.deniesCount);
    }
    if (message.lhCount !== 0) {
      obj.lhCount = Math.round(message.lhCount);
    }
    if (message.gold !== 0) {
      obj.gold = Math.round(message.gold);
    }
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.netWorth !== 0) {
      obj.netWorth = Math.round(message.netWorth);
    }
    if (message.abilities?.length) {
      obj.abilities = message.abilities.map((e) => Math.round(e));
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => Math.round(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTARealtimeGameStatsTerse_PlayerDetails>,
  ): CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
    return CMsgDOTARealtimeGameStatsTerse_PlayerDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTARealtimeGameStatsTerse_PlayerDetails>,
  ): CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_PlayerDetails();
    message.accountid = object.accountid ?? 0;
    message.playerid = object.playerid ?? -1;
    message.name = object.name ?? "";
    message.team = object.team ?? 0;
    message.heroid = object.heroid ?? 0;
    message.level = object.level ?? 0;
    message.killCount = object.killCount ?? 0;
    message.deathCount = object.deathCount ?? 0;
    message.assistsCount = object.assistsCount ?? 0;
    message.deniesCount = object.deniesCount ?? 0;
    message.lhCount = object.lhCount ?? 0;
    message.gold = object.gold ?? 0;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.netWorth = object.netWorth ?? 0;
    message.abilities = object.abilities?.map((e) => e) || [];
    message.items = object.items?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStatsTerse_BuildingDetails(): CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
  return { team: 0, heading: 0, type: 0, lane: 0, tier: 0, x: 0, y: 0, destroyed: false };
}

export const CMsgDOTARealtimeGameStatsTerse_BuildingDetails: MessageFns<
  CMsgDOTARealtimeGameStatsTerse_BuildingDetails
> = {
  encode(
    message: CMsgDOTARealtimeGameStatsTerse_BuildingDetails,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.team !== 0) {
      writer.uint32(8).uint32(message.team);
    }
    if (message.heading !== 0) {
      writer.uint32(21).float(message.heading);
    }
    if (message.type !== 0) {
      writer.uint32(24).uint32(message.type);
    }
    if (message.lane !== 0) {
      writer.uint32(32).uint32(message.lane);
    }
    if (message.tier !== 0) {
      writer.uint32(40).uint32(message.tier);
    }
    if (message.x !== 0) {
      writer.uint32(53).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(61).float(message.y);
    }
    if (message.destroyed !== false) {
      writer.uint32(64).bool(message.destroyed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_BuildingDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.team = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.heading = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lane = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.tier = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.y = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.destroyed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
    return {
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
      heading: isSet(object.heading) ? globalThis.Number(object.heading) : 0,
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      lane: isSet(object.lane) ? globalThis.Number(object.lane) : 0,
      tier: isSet(object.tier) ? globalThis.Number(object.tier) : 0,
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      destroyed: isSet(object.destroyed) ? globalThis.Boolean(object.destroyed) : false,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStatsTerse_BuildingDetails): unknown {
    const obj: any = {};
    if (message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    if (message.heading !== 0) {
      obj.heading = message.heading;
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.lane !== 0) {
      obj.lane = Math.round(message.lane);
    }
    if (message.tier !== 0) {
      obj.tier = Math.round(message.tier);
    }
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.destroyed !== false) {
      obj.destroyed = message.destroyed;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTARealtimeGameStatsTerse_BuildingDetails>,
  ): CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
    return CMsgDOTARealtimeGameStatsTerse_BuildingDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTARealtimeGameStatsTerse_BuildingDetails>,
  ): CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_BuildingDetails();
    message.team = object.team ?? 0;
    message.heading = object.heading ?? 0;
    message.type = object.type ?? 0;
    message.lane = object.lane ?? 0;
    message.tier = object.tier ?? 0;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.destroyed = object.destroyed ?? false;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStatsTerse_PickBanDetails(): CMsgDOTARealtimeGameStatsTerse_PickBanDetails {
  return { hero: 0, team: 0 };
}

export const CMsgDOTARealtimeGameStatsTerse_PickBanDetails: MessageFns<CMsgDOTARealtimeGameStatsTerse_PickBanDetails> =
  {
    encode(
      message: CMsgDOTARealtimeGameStatsTerse_PickBanDetails,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.hero !== 0) {
        writer.uint32(8).uint32(message.hero);
      }
      if (message.team !== 0) {
        writer.uint32(16).uint32(message.team);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStatsTerse_PickBanDetails {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCMsgDOTARealtimeGameStatsTerse_PickBanDetails();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.hero = reader.uint32();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.team = reader.uint32();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CMsgDOTARealtimeGameStatsTerse_PickBanDetails {
      return {
        hero: isSet(object.hero) ? globalThis.Number(object.hero) : 0,
        team: isSet(object.team) ? globalThis.Number(object.team) : 0,
      };
    },

    toJSON(message: CMsgDOTARealtimeGameStatsTerse_PickBanDetails): unknown {
      const obj: any = {};
      if (message.hero !== 0) {
        obj.hero = Math.round(message.hero);
      }
      if (message.team !== 0) {
        obj.team = Math.round(message.team);
      }
      return obj;
    },

    create(
      base?: DeepPartial<CMsgDOTARealtimeGameStatsTerse_PickBanDetails>,
    ): CMsgDOTARealtimeGameStatsTerse_PickBanDetails {
      return CMsgDOTARealtimeGameStatsTerse_PickBanDetails.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<CMsgDOTARealtimeGameStatsTerse_PickBanDetails>,
    ): CMsgDOTARealtimeGameStatsTerse_PickBanDetails {
      const message = createBaseCMsgDOTARealtimeGameStatsTerse_PickBanDetails();
      message.hero = object.hero ?? 0;
      message.team = object.team ?? 0;
      return message;
    },
  };

function createBaseCMsgDOTARealtimeGameStatsTerse_MatchDetails(): CMsgDOTARealtimeGameStatsTerse_MatchDetails {
  return {
    serverSteamId: "0",
    matchId: "0",
    timestamp: 0,
    gameTime: 0,
    steamBroadcasterAccountIds: [],
    gameMode: 0,
    leagueId: 0,
    leagueNodeId: 0,
    gameState: 0,
    picks: [],
    bans: [],
    lobbyType: 0,
    startTimestamp: 0,
  };
}

export const CMsgDOTARealtimeGameStatsTerse_MatchDetails: MessageFns<CMsgDOTARealtimeGameStatsTerse_MatchDetails> = {
  encode(
    message: CMsgDOTARealtimeGameStatsTerse_MatchDetails,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.serverSteamId !== "0") {
      writer.uint32(9).fixed64(message.serverSteamId);
    }
    if (message.matchId !== "0") {
      writer.uint32(16).uint64(message.matchId);
    }
    if (message.timestamp !== 0) {
      writer.uint32(24).uint32(message.timestamp);
    }
    if (message.gameTime !== 0) {
      writer.uint32(32).int32(message.gameTime);
    }
    writer.uint32(50).fork();
    for (const v of message.steamBroadcasterAccountIds) {
      writer.uint32(v);
    }
    writer.join();
    if (message.gameMode !== 0) {
      writer.uint32(56).uint32(message.gameMode);
    }
    if (message.leagueId !== 0) {
      writer.uint32(64).uint32(message.leagueId);
    }
    if (message.leagueNodeId !== 0) {
      writer.uint32(72).uint32(message.leagueNodeId);
    }
    if (message.gameState !== 0) {
      writer.uint32(80).uint32(message.gameState);
    }
    for (const v of message.picks) {
      CMsgDOTARealtimeGameStatsTerse_PickBanDetails.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.bans) {
      CMsgDOTARealtimeGameStatsTerse_PickBanDetails.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.lobbyType !== 0) {
      writer.uint32(104).uint32(message.lobbyType);
    }
    if (message.startTimestamp !== 0) {
      writer.uint32(112).uint32(message.startTimestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStatsTerse_MatchDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_MatchDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.serverSteamId = reader.fixed64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.matchId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gameTime = reader.int32();
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.steamBroadcasterAccountIds.push(reader.uint32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.steamBroadcasterAccountIds.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.gameMode = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.leagueNodeId = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.gameState = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.picks.push(CMsgDOTARealtimeGameStatsTerse_PickBanDetails.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.bans.push(CMsgDOTARealtimeGameStatsTerse_PickBanDetails.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.lobbyType = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.startTimestamp = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStatsTerse_MatchDetails {
    return {
      serverSteamId: isSet(object.serverSteamId) ? globalThis.String(object.serverSteamId) : "0",
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      gameTime: isSet(object.gameTime) ? globalThis.Number(object.gameTime) : 0,
      steamBroadcasterAccountIds: globalThis.Array.isArray(object?.steamBroadcasterAccountIds)
        ? object.steamBroadcasterAccountIds.map((e: any) => globalThis.Number(e))
        : [],
      gameMode: isSet(object.gameMode) ? globalThis.Number(object.gameMode) : 0,
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      leagueNodeId: isSet(object.leagueNodeId) ? globalThis.Number(object.leagueNodeId) : 0,
      gameState: isSet(object.gameState) ? globalThis.Number(object.gameState) : 0,
      picks: globalThis.Array.isArray(object?.picks)
        ? object.picks.map((e: any) => CMsgDOTARealtimeGameStatsTerse_PickBanDetails.fromJSON(e))
        : [],
      bans: globalThis.Array.isArray(object?.bans)
        ? object.bans.map((e: any) => CMsgDOTARealtimeGameStatsTerse_PickBanDetails.fromJSON(e))
        : [],
      lobbyType: isSet(object.lobbyType) ? globalThis.Number(object.lobbyType) : 0,
      startTimestamp: isSet(object.startTimestamp) ? globalThis.Number(object.startTimestamp) : 0,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStatsTerse_MatchDetails): unknown {
    const obj: any = {};
    if (message.serverSteamId !== "0") {
      obj.serverSteamId = message.serverSteamId;
    }
    if (message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.gameTime !== 0) {
      obj.gameTime = Math.round(message.gameTime);
    }
    if (message.steamBroadcasterAccountIds?.length) {
      obj.steamBroadcasterAccountIds = message.steamBroadcasterAccountIds.map((e) => Math.round(e));
    }
    if (message.gameMode !== 0) {
      obj.gameMode = Math.round(message.gameMode);
    }
    if (message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.leagueNodeId !== 0) {
      obj.leagueNodeId = Math.round(message.leagueNodeId);
    }
    if (message.gameState !== 0) {
      obj.gameState = Math.round(message.gameState);
    }
    if (message.picks?.length) {
      obj.picks = message.picks.map((e) => CMsgDOTARealtimeGameStatsTerse_PickBanDetails.toJSON(e));
    }
    if (message.bans?.length) {
      obj.bans = message.bans.map((e) => CMsgDOTARealtimeGameStatsTerse_PickBanDetails.toJSON(e));
    }
    if (message.lobbyType !== 0) {
      obj.lobbyType = Math.round(message.lobbyType);
    }
    if (message.startTimestamp !== 0) {
      obj.startTimestamp = Math.round(message.startTimestamp);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStatsTerse_MatchDetails>): CMsgDOTARealtimeGameStatsTerse_MatchDetails {
    return CMsgDOTARealtimeGameStatsTerse_MatchDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTARealtimeGameStatsTerse_MatchDetails>,
  ): CMsgDOTARealtimeGameStatsTerse_MatchDetails {
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_MatchDetails();
    message.serverSteamId = object.serverSteamId ?? "0";
    message.matchId = object.matchId ?? "0";
    message.timestamp = object.timestamp ?? 0;
    message.gameTime = object.gameTime ?? 0;
    message.steamBroadcasterAccountIds = object.steamBroadcasterAccountIds?.map((e) => e) || [];
    message.gameMode = object.gameMode ?? 0;
    message.leagueId = object.leagueId ?? 0;
    message.leagueNodeId = object.leagueNodeId ?? 0;
    message.gameState = object.gameState ?? 0;
    message.picks = object.picks?.map((e) => CMsgDOTARealtimeGameStatsTerse_PickBanDetails.fromPartial(e)) || [];
    message.bans = object.bans?.map((e) => CMsgDOTARealtimeGameStatsTerse_PickBanDetails.fromPartial(e)) || [];
    message.lobbyType = object.lobbyType ?? 0;
    message.startTimestamp = object.startTimestamp ?? 0;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStatsTerse_GraphData(): CMsgDOTARealtimeGameStatsTerse_GraphData {
  return { graphGold: [] };
}

export const CMsgDOTARealtimeGameStatsTerse_GraphData: MessageFns<CMsgDOTARealtimeGameStatsTerse_GraphData> = {
  encode(message: CMsgDOTARealtimeGameStatsTerse_GraphData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.graphGold) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTARealtimeGameStatsTerse_GraphData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_GraphData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.graphGold.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.graphGold.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStatsTerse_GraphData {
    return {
      graphGold: globalThis.Array.isArray(object?.graphGold)
        ? object.graphGold.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStatsTerse_GraphData): unknown {
    const obj: any = {};
    if (message.graphGold?.length) {
      obj.graphGold = message.graphGold.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStatsTerse_GraphData>): CMsgDOTARealtimeGameStatsTerse_GraphData {
    return CMsgDOTARealtimeGameStatsTerse_GraphData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStatsTerse_GraphData>): CMsgDOTARealtimeGameStatsTerse_GraphData {
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_GraphData();
    message.graphGold = object.graphGold?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgDOTABroadcastTimelineEvent(): CMsgDOTABroadcastTimelineEvent {
  return { event: 1, timestamp: 0, data: 0, stringData: "" };
}

export const CMsgDOTABroadcastTimelineEvent: MessageFns<CMsgDOTABroadcastTimelineEvent> = {
  encode(message: CMsgDOTABroadcastTimelineEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== 1) {
      writer.uint32(8).int32(message.event);
    }
    if (message.timestamp !== 0) {
      writer.uint32(21).fixed32(message.timestamp);
    }
    if (message.data !== 0) {
      writer.uint32(24).uint32(message.data);
    }
    if (message.stringData !== "") {
      writer.uint32(34).string(message.stringData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTABroadcastTimelineEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTABroadcastTimelineEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.event = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.timestamp = reader.fixed32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.data = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stringData = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTABroadcastTimelineEvent {
    return {
      event: isSet(object.event) ? eBroadcastTimelineEventFromJSON(object.event) : 1,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      data: isSet(object.data) ? globalThis.Number(object.data) : 0,
      stringData: isSet(object.stringData) ? globalThis.String(object.stringData) : "",
    };
  },

  toJSON(message: CMsgDOTABroadcastTimelineEvent): unknown {
    const obj: any = {};
    if (message.event !== 1) {
      obj.event = eBroadcastTimelineEventToJSON(message.event);
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.data !== 0) {
      obj.data = Math.round(message.data);
    }
    if (message.stringData !== "") {
      obj.stringData = message.stringData;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTABroadcastTimelineEvent>): CMsgDOTABroadcastTimelineEvent {
    return CMsgDOTABroadcastTimelineEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTABroadcastTimelineEvent>): CMsgDOTABroadcastTimelineEvent {
    const message = createBaseCMsgDOTABroadcastTimelineEvent();
    message.event = object.event ?? 1;
    message.timestamp = object.timestamp ?? 0;
    message.data = object.data ?? 0;
    message.stringData = object.stringData ?? "";
    return message;
  },
};

function createBaseCMsgGCToClientMatchGroupsVersion(): CMsgGCToClientMatchGroupsVersion {
  return { matchgroupsVersion: 0 };
}

export const CMsgGCToClientMatchGroupsVersion: MessageFns<CMsgGCToClientMatchGroupsVersion> = {
  encode(message: CMsgGCToClientMatchGroupsVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matchgroupsVersion !== 0) {
      writer.uint32(8).uint32(message.matchgroupsVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToClientMatchGroupsVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientMatchGroupsVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.matchgroupsVersion = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientMatchGroupsVersion {
    return { matchgroupsVersion: isSet(object.matchgroupsVersion) ? globalThis.Number(object.matchgroupsVersion) : 0 };
  },

  toJSON(message: CMsgGCToClientMatchGroupsVersion): unknown {
    const obj: any = {};
    if (message.matchgroupsVersion !== 0) {
      obj.matchgroupsVersion = Math.round(message.matchgroupsVersion);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToClientMatchGroupsVersion>): CMsgGCToClientMatchGroupsVersion {
    return CMsgGCToClientMatchGroupsVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToClientMatchGroupsVersion>): CMsgGCToClientMatchGroupsVersion {
    const message = createBaseCMsgGCToClientMatchGroupsVersion();
    message.matchgroupsVersion = object.matchgroupsVersion ?? 0;
    return message;
  },
};

function createBaseCMsgDOTASDOHeroStatsHistory(): CMsgDOTASDOHeroStatsHistory {
  return {
    matchId: "0",
    gameMode: 0,
    lobbyType: 0,
    startTime: 0,
    won: false,
    gpm: 0,
    xpm: 0,
    kills: 0,
    deaths: 0,
    assists: 0,
  };
}

export const CMsgDOTASDOHeroStatsHistory: MessageFns<CMsgDOTASDOHeroStatsHistory> = {
  encode(message: CMsgDOTASDOHeroStatsHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.gameMode !== 0) {
      writer.uint32(16).uint32(message.gameMode);
    }
    if (message.lobbyType !== 0) {
      writer.uint32(24).uint32(message.lobbyType);
    }
    if (message.startTime !== 0) {
      writer.uint32(32).uint32(message.startTime);
    }
    if (message.won !== false) {
      writer.uint32(40).bool(message.won);
    }
    if (message.gpm !== 0) {
      writer.uint32(48).uint32(message.gpm);
    }
    if (message.xpm !== 0) {
      writer.uint32(56).uint32(message.xpm);
    }
    if (message.kills !== 0) {
      writer.uint32(64).uint32(message.kills);
    }
    if (message.deaths !== 0) {
      writer.uint32(72).uint32(message.deaths);
    }
    if (message.assists !== 0) {
      writer.uint32(80).uint32(message.assists);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTASDOHeroStatsHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASDOHeroStatsHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.matchId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gameMode = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lobbyType = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.startTime = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.won = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.gpm = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.xpm = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.assists = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASDOHeroStatsHistory {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      gameMode: isSet(object.gameMode) ? globalThis.Number(object.gameMode) : 0,
      lobbyType: isSet(object.lobbyType) ? globalThis.Number(object.lobbyType) : 0,
      startTime: isSet(object.startTime) ? globalThis.Number(object.startTime) : 0,
      won: isSet(object.won) ? globalThis.Boolean(object.won) : false,
      gpm: isSet(object.gpm) ? globalThis.Number(object.gpm) : 0,
      xpm: isSet(object.xpm) ? globalThis.Number(object.xpm) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      assists: isSet(object.assists) ? globalThis.Number(object.assists) : 0,
    };
  },

  toJSON(message: CMsgDOTASDOHeroStatsHistory): unknown {
    const obj: any = {};
    if (message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.gameMode !== 0) {
      obj.gameMode = Math.round(message.gameMode);
    }
    if (message.lobbyType !== 0) {
      obj.lobbyType = Math.round(message.lobbyType);
    }
    if (message.startTime !== 0) {
      obj.startTime = Math.round(message.startTime);
    }
    if (message.won !== false) {
      obj.won = message.won;
    }
    if (message.gpm !== 0) {
      obj.gpm = Math.round(message.gpm);
    }
    if (message.xpm !== 0) {
      obj.xpm = Math.round(message.xpm);
    }
    if (message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.assists !== 0) {
      obj.assists = Math.round(message.assists);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTASDOHeroStatsHistory>): CMsgDOTASDOHeroStatsHistory {
    return CMsgDOTASDOHeroStatsHistory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTASDOHeroStatsHistory>): CMsgDOTASDOHeroStatsHistory {
    const message = createBaseCMsgDOTASDOHeroStatsHistory();
    message.matchId = object.matchId ?? "0";
    message.gameMode = object.gameMode ?? 0;
    message.lobbyType = object.lobbyType ?? 0;
    message.startTime = object.startTime ?? 0;
    message.won = object.won ?? false;
    message.gpm = object.gpm ?? 0;
    message.xpm = object.xpm ?? 0;
    message.kills = object.kills ?? 0;
    message.deaths = object.deaths ?? 0;
    message.assists = object.assists ?? 0;
    return message;
  },
};

function createBaseCMsgPredictionChoice(): CMsgPredictionChoice {
  return { value: 0, name: "", minRawValue: 0, maxRawValue: 0 };
}

export const CMsgPredictionChoice: MessageFns<CMsgPredictionChoice> = {
  encode(message: CMsgPredictionChoice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).uint32(message.value);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.minRawValue !== 0) {
      writer.uint32(24).uint32(message.minRawValue);
    }
    if (message.maxRawValue !== 0) {
      writer.uint32(32).uint32(message.maxRawValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgPredictionChoice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPredictionChoice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.minRawValue = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxRawValue = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPredictionChoice {
    return {
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      minRawValue: isSet(object.minRawValue) ? globalThis.Number(object.minRawValue) : 0,
      maxRawValue: isSet(object.maxRawValue) ? globalThis.Number(object.maxRawValue) : 0,
    };
  },

  toJSON(message: CMsgPredictionChoice): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.minRawValue !== 0) {
      obj.minRawValue = Math.round(message.minRawValue);
    }
    if (message.maxRawValue !== 0) {
      obj.maxRawValue = Math.round(message.maxRawValue);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPredictionChoice>): CMsgPredictionChoice {
    return CMsgPredictionChoice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPredictionChoice>): CMsgPredictionChoice {
    const message = createBaseCMsgPredictionChoice();
    message.value = object.value ?? 0;
    message.name = object.name ?? "";
    message.minRawValue = object.minRawValue ?? 0;
    message.maxRawValue = object.maxRawValue ?? 0;
    return message;
  },
};

function createBaseCMsgInGamePrediction(): CMsgInGamePrediction {
  return {
    id: 0,
    name: "",
    type: 0,
    group: 0,
    question: "",
    choices: [],
    requiredHeroes: [],
    queryName: "",
    queryValues: [],
    answerResolutionType: 0,
    pointsToGrant: 0,
    rewardAction: 0,
    debugForceSelection: 0,
    rawValueType: 0,
  };
}

export const CMsgInGamePrediction: MessageFns<CMsgInGamePrediction> = {
  encode(message: CMsgInGamePrediction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.group !== 0) {
      writer.uint32(32).int32(message.group);
    }
    if (message.question !== "") {
      writer.uint32(42).string(message.question);
    }
    for (const v of message.choices) {
      CMsgPredictionChoice.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.requiredHeroes) {
      writer.uint32(58).string(v!);
    }
    if (message.queryName !== "") {
      writer.uint32(66).string(message.queryName);
    }
    for (const v of message.queryValues) {
      CMsgInGamePrediction_QueryKeyValues.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.answerResolutionType !== 0) {
      writer.uint32(80).int32(message.answerResolutionType);
    }
    if (message.pointsToGrant !== 0) {
      writer.uint32(88).uint32(message.pointsToGrant);
    }
    if (message.rewardAction !== 0) {
      writer.uint32(96).uint32(message.rewardAction);
    }
    if (message.debugForceSelection !== 0) {
      writer.uint32(104).uint32(message.debugForceSelection);
    }
    if (message.rawValueType !== 0) {
      writer.uint32(112).int32(message.rawValueType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgInGamePrediction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgInGamePrediction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.group = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.question = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.choices.push(CMsgPredictionChoice.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.requiredHeroes.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.queryName = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.queryValues.push(CMsgInGamePrediction_QueryKeyValues.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.answerResolutionType = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.pointsToGrant = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.rewardAction = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.debugForceSelection = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.rawValueType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgInGamePrediction {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? cMsgInGamePrediction_EPredictionTypeFromJSON(object.type) : 0,
      group: isSet(object.group) ? cMsgInGamePrediction_ERandomSelectionGroupTFromJSON(object.group) : 0,
      question: isSet(object.question) ? globalThis.String(object.question) : "",
      choices: globalThis.Array.isArray(object?.choices)
        ? object.choices.map((e: any) => CMsgPredictionChoice.fromJSON(e))
        : [],
      requiredHeroes: globalThis.Array.isArray(object?.requiredHeroes)
        ? object.requiredHeroes.map((e: any) => globalThis.String(e))
        : [],
      queryName: isSet(object.queryName) ? globalThis.String(object.queryName) : "",
      queryValues: globalThis.Array.isArray(object?.queryValues)
        ? object.queryValues.map((e: any) => CMsgInGamePrediction_QueryKeyValues.fromJSON(e))
        : [],
      answerResolutionType: isSet(object.answerResolutionType)
        ? cMsgInGamePrediction_EResolutionTypeTFromJSON(object.answerResolutionType)
        : 0,
      pointsToGrant: isSet(object.pointsToGrant) ? globalThis.Number(object.pointsToGrant) : 0,
      rewardAction: isSet(object.rewardAction) ? globalThis.Number(object.rewardAction) : 0,
      debugForceSelection: isSet(object.debugForceSelection) ? globalThis.Number(object.debugForceSelection) : 0,
      rawValueType: isSet(object.rawValueType) ? cMsgInGamePrediction_ERawValueTypeTFromJSON(object.rawValueType) : 0,
    };
  },

  toJSON(message: CMsgInGamePrediction): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = cMsgInGamePrediction_EPredictionTypeToJSON(message.type);
    }
    if (message.group !== 0) {
      obj.group = cMsgInGamePrediction_ERandomSelectionGroupTToJSON(message.group);
    }
    if (message.question !== "") {
      obj.question = message.question;
    }
    if (message.choices?.length) {
      obj.choices = message.choices.map((e) => CMsgPredictionChoice.toJSON(e));
    }
    if (message.requiredHeroes?.length) {
      obj.requiredHeroes = message.requiredHeroes;
    }
    if (message.queryName !== "") {
      obj.queryName = message.queryName;
    }
    if (message.queryValues?.length) {
      obj.queryValues = message.queryValues.map((e) => CMsgInGamePrediction_QueryKeyValues.toJSON(e));
    }
    if (message.answerResolutionType !== 0) {
      obj.answerResolutionType = cMsgInGamePrediction_EResolutionTypeTToJSON(message.answerResolutionType);
    }
    if (message.pointsToGrant !== 0) {
      obj.pointsToGrant = Math.round(message.pointsToGrant);
    }
    if (message.rewardAction !== 0) {
      obj.rewardAction = Math.round(message.rewardAction);
    }
    if (message.debugForceSelection !== 0) {
      obj.debugForceSelection = Math.round(message.debugForceSelection);
    }
    if (message.rawValueType !== 0) {
      obj.rawValueType = cMsgInGamePrediction_ERawValueTypeTToJSON(message.rawValueType);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgInGamePrediction>): CMsgInGamePrediction {
    return CMsgInGamePrediction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgInGamePrediction>): CMsgInGamePrediction {
    const message = createBaseCMsgInGamePrediction();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.group = object.group ?? 0;
    message.question = object.question ?? "";
    message.choices = object.choices?.map((e) => CMsgPredictionChoice.fromPartial(e)) || [];
    message.requiredHeroes = object.requiredHeroes?.map((e) => e) || [];
    message.queryName = object.queryName ?? "";
    message.queryValues = object.queryValues?.map((e) => CMsgInGamePrediction_QueryKeyValues.fromPartial(e)) || [];
    message.answerResolutionType = object.answerResolutionType ?? 0;
    message.pointsToGrant = object.pointsToGrant ?? 0;
    message.rewardAction = object.rewardAction ?? 0;
    message.debugForceSelection = object.debugForceSelection ?? 0;
    message.rawValueType = object.rawValueType ?? 0;
    return message;
  },
};

function createBaseCMsgInGamePrediction_QueryKeyValues(): CMsgInGamePrediction_QueryKeyValues {
  return { name: "", value: "" };
}

export const CMsgInGamePrediction_QueryKeyValues: MessageFns<CMsgInGamePrediction_QueryKeyValues> = {
  encode(message: CMsgInGamePrediction_QueryKeyValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgInGamePrediction_QueryKeyValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgInGamePrediction_QueryKeyValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgInGamePrediction_QueryKeyValues {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CMsgInGamePrediction_QueryKeyValues): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgInGamePrediction_QueryKeyValues>): CMsgInGamePrediction_QueryKeyValues {
    return CMsgInGamePrediction_QueryKeyValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgInGamePrediction_QueryKeyValues>): CMsgInGamePrediction_QueryKeyValues {
    const message = createBaseCMsgInGamePrediction_QueryKeyValues();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCMsgDOTASeasonPredictions(): CMsgDOTASeasonPredictions {
  return {
    predictions: [],
    inGamePredictions: [],
    inGamePredictionCountPerGame: 0,
    inGamePredictionVotingPeriodMinutes: 0,
  };
}

export const CMsgDOTASeasonPredictions: MessageFns<CMsgDOTASeasonPredictions> = {
  encode(message: CMsgDOTASeasonPredictions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.predictions) {
      CMsgDOTASeasonPredictions_Prediction.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.inGamePredictions) {
      CMsgInGamePrediction.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.inGamePredictionCountPerGame !== 0) {
      writer.uint32(24).uint32(message.inGamePredictionCountPerGame);
    }
    if (message.inGamePredictionVotingPeriodMinutes !== 0) {
      writer.uint32(32).uint32(message.inGamePredictionVotingPeriodMinutes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTASeasonPredictions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASeasonPredictions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.predictions.push(CMsgDOTASeasonPredictions_Prediction.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inGamePredictions.push(CMsgInGamePrediction.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.inGamePredictionCountPerGame = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.inGamePredictionVotingPeriodMinutes = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASeasonPredictions {
    return {
      predictions: globalThis.Array.isArray(object?.predictions)
        ? object.predictions.map((e: any) => CMsgDOTASeasonPredictions_Prediction.fromJSON(e))
        : [],
      inGamePredictions: globalThis.Array.isArray(object?.inGamePredictions)
        ? object.inGamePredictions.map((e: any) => CMsgInGamePrediction.fromJSON(e))
        : [],
      inGamePredictionCountPerGame: isSet(object.inGamePredictionCountPerGame)
        ? globalThis.Number(object.inGamePredictionCountPerGame)
        : 0,
      inGamePredictionVotingPeriodMinutes: isSet(object.inGamePredictionVotingPeriodMinutes)
        ? globalThis.Number(object.inGamePredictionVotingPeriodMinutes)
        : 0,
    };
  },

  toJSON(message: CMsgDOTASeasonPredictions): unknown {
    const obj: any = {};
    if (message.predictions?.length) {
      obj.predictions = message.predictions.map((e) => CMsgDOTASeasonPredictions_Prediction.toJSON(e));
    }
    if (message.inGamePredictions?.length) {
      obj.inGamePredictions = message.inGamePredictions.map((e) => CMsgInGamePrediction.toJSON(e));
    }
    if (message.inGamePredictionCountPerGame !== 0) {
      obj.inGamePredictionCountPerGame = Math.round(message.inGamePredictionCountPerGame);
    }
    if (message.inGamePredictionVotingPeriodMinutes !== 0) {
      obj.inGamePredictionVotingPeriodMinutes = Math.round(message.inGamePredictionVotingPeriodMinutes);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTASeasonPredictions>): CMsgDOTASeasonPredictions {
    return CMsgDOTASeasonPredictions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTASeasonPredictions>): CMsgDOTASeasonPredictions {
    const message = createBaseCMsgDOTASeasonPredictions();
    message.predictions = object.predictions?.map((e) => CMsgDOTASeasonPredictions_Prediction.fromPartial(e)) || [];
    message.inGamePredictions = object.inGamePredictions?.map((e) => CMsgInGamePrediction.fromPartial(e)) || [];
    message.inGamePredictionCountPerGame = object.inGamePredictionCountPerGame ?? 0;
    message.inGamePredictionVotingPeriodMinutes = object.inGamePredictionVotingPeriodMinutes ?? 0;
    return message;
  },
};

function createBaseCMsgDOTASeasonPredictions_Prediction(): CMsgDOTASeasonPredictions_Prediction {
  return {
    type: 0,
    question: "",
    choices: [],
    selectionId: 0,
    startDate: 0,
    lockDate: 0,
    reward: 0,
    answerType: 0,
    answerId: 0,
    answers: [],
    queryName: "",
    lockOnSelectionId: 0,
    lockOnSelectionValue: 0,
    lockOnSelectionSet: false,
    useAnswerValueRanges: false,
    region: 0,
    phases: [],
    rewardEvent: 0,
  };
}

export const CMsgDOTASeasonPredictions_Prediction: MessageFns<CMsgDOTASeasonPredictions_Prediction> = {
  encode(message: CMsgDOTASeasonPredictions_Prediction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.question !== "") {
      writer.uint32(18).string(message.question);
    }
    for (const v of message.choices) {
      CMsgPredictionChoice.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.selectionId !== 0) {
      writer.uint32(32).uint32(message.selectionId);
    }
    if (message.startDate !== 0) {
      writer.uint32(40).uint32(message.startDate);
    }
    if (message.lockDate !== 0) {
      writer.uint32(48).uint32(message.lockDate);
    }
    if (message.reward !== 0) {
      writer.uint32(56).uint32(message.reward);
    }
    if (message.answerType !== 0) {
      writer.uint32(64).int32(message.answerType);
    }
    if (message.answerId !== 0) {
      writer.uint32(72).uint32(message.answerId);
    }
    for (const v of message.answers) {
      CMsgDOTASeasonPredictions_Prediction_Answers.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.queryName !== "") {
      writer.uint32(90).string(message.queryName);
    }
    if (message.lockOnSelectionId !== 0) {
      writer.uint32(104).uint32(message.lockOnSelectionId);
    }
    if (message.lockOnSelectionValue !== 0) {
      writer.uint32(112).uint32(message.lockOnSelectionValue);
    }
    if (message.lockOnSelectionSet !== false) {
      writer.uint32(120).bool(message.lockOnSelectionSet);
    }
    if (message.useAnswerValueRanges !== false) {
      writer.uint32(128).bool(message.useAnswerValueRanges);
    }
    if (message.region !== 0) {
      writer.uint32(136).int32(message.region);
    }
    writer.uint32(146).fork();
    for (const v of message.phases) {
      writer.int32(v);
    }
    writer.join();
    if (message.rewardEvent !== 0) {
      writer.uint32(152).int32(message.rewardEvent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTASeasonPredictions_Prediction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASeasonPredictions_Prediction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.question = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.choices.push(CMsgPredictionChoice.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.selectionId = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.startDate = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.lockDate = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.reward = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.answerType = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.answerId = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.answers.push(CMsgDOTASeasonPredictions_Prediction_Answers.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.queryName = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.lockOnSelectionId = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.lockOnSelectionValue = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.lockOnSelectionSet = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.useAnswerValueRanges = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.region = reader.int32() as any;
          continue;
        }
        case 18: {
          if (tag === 144) {
            message.phases.push(reader.int32() as any);

            continue;
          }

          if (tag === 146) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.phases.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.rewardEvent = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASeasonPredictions_Prediction {
    return {
      type: isSet(object.type) ? cMsgDOTASeasonPredictions_Prediction_EPredictionTypeFromJSON(object.type) : 0,
      question: isSet(object.question) ? globalThis.String(object.question) : "",
      choices: globalThis.Array.isArray(object?.choices)
        ? object.choices.map((e: any) => CMsgPredictionChoice.fromJSON(e))
        : [],
      selectionId: isSet(object.selectionId) ? globalThis.Number(object.selectionId) : 0,
      startDate: isSet(object.startDate) ? globalThis.Number(object.startDate) : 0,
      lockDate: isSet(object.lockDate) ? globalThis.Number(object.lockDate) : 0,
      reward: isSet(object.reward) ? globalThis.Number(object.reward) : 0,
      answerType: isSet(object.answerType)
        ? cMsgDOTASeasonPredictions_Prediction_EAnswerTypeFromJSON(object.answerType)
        : 0,
      answerId: isSet(object.answerId) ? globalThis.Number(object.answerId) : 0,
      answers: globalThis.Array.isArray(object?.answers)
        ? object.answers.map((e: any) => CMsgDOTASeasonPredictions_Prediction_Answers.fromJSON(e))
        : [],
      queryName: isSet(object.queryName) ? globalThis.String(object.queryName) : "",
      lockOnSelectionId: isSet(object.lockOnSelectionId) ? globalThis.Number(object.lockOnSelectionId) : 0,
      lockOnSelectionValue: isSet(object.lockOnSelectionValue) ? globalThis.Number(object.lockOnSelectionValue) : 0,
      lockOnSelectionSet: isSet(object.lockOnSelectionSet) ? globalThis.Boolean(object.lockOnSelectionSet) : false,
      useAnswerValueRanges: isSet(object.useAnswerValueRanges)
        ? globalThis.Boolean(object.useAnswerValueRanges)
        : false,
      region: isSet(object.region) ? eLeagueRegionFromJSON(object.region) : 0,
      phases: globalThis.Array.isArray(object?.phases) ? object.phases.map((e: any) => eLeaguePhaseFromJSON(e)) : [],
      rewardEvent: isSet(object.rewardEvent) ? eEventFromJSON(object.rewardEvent) : 0,
    };
  },

  toJSON(message: CMsgDOTASeasonPredictions_Prediction): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = cMsgDOTASeasonPredictions_Prediction_EPredictionTypeToJSON(message.type);
    }
    if (message.question !== "") {
      obj.question = message.question;
    }
    if (message.choices?.length) {
      obj.choices = message.choices.map((e) => CMsgPredictionChoice.toJSON(e));
    }
    if (message.selectionId !== 0) {
      obj.selectionId = Math.round(message.selectionId);
    }
    if (message.startDate !== 0) {
      obj.startDate = Math.round(message.startDate);
    }
    if (message.lockDate !== 0) {
      obj.lockDate = Math.round(message.lockDate);
    }
    if (message.reward !== 0) {
      obj.reward = Math.round(message.reward);
    }
    if (message.answerType !== 0) {
      obj.answerType = cMsgDOTASeasonPredictions_Prediction_EAnswerTypeToJSON(message.answerType);
    }
    if (message.answerId !== 0) {
      obj.answerId = Math.round(message.answerId);
    }
    if (message.answers?.length) {
      obj.answers = message.answers.map((e) => CMsgDOTASeasonPredictions_Prediction_Answers.toJSON(e));
    }
    if (message.queryName !== "") {
      obj.queryName = message.queryName;
    }
    if (message.lockOnSelectionId !== 0) {
      obj.lockOnSelectionId = Math.round(message.lockOnSelectionId);
    }
    if (message.lockOnSelectionValue !== 0) {
      obj.lockOnSelectionValue = Math.round(message.lockOnSelectionValue);
    }
    if (message.lockOnSelectionSet !== false) {
      obj.lockOnSelectionSet = message.lockOnSelectionSet;
    }
    if (message.useAnswerValueRanges !== false) {
      obj.useAnswerValueRanges = message.useAnswerValueRanges;
    }
    if (message.region !== 0) {
      obj.region = eLeagueRegionToJSON(message.region);
    }
    if (message.phases?.length) {
      obj.phases = message.phases.map((e) => eLeaguePhaseToJSON(e));
    }
    if (message.rewardEvent !== 0) {
      obj.rewardEvent = eEventToJSON(message.rewardEvent);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTASeasonPredictions_Prediction>): CMsgDOTASeasonPredictions_Prediction {
    return CMsgDOTASeasonPredictions_Prediction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTASeasonPredictions_Prediction>): CMsgDOTASeasonPredictions_Prediction {
    const message = createBaseCMsgDOTASeasonPredictions_Prediction();
    message.type = object.type ?? 0;
    message.question = object.question ?? "";
    message.choices = object.choices?.map((e) => CMsgPredictionChoice.fromPartial(e)) || [];
    message.selectionId = object.selectionId ?? 0;
    message.startDate = object.startDate ?? 0;
    message.lockDate = object.lockDate ?? 0;
    message.reward = object.reward ?? 0;
    message.answerType = object.answerType ?? 0;
    message.answerId = object.answerId ?? 0;
    message.answers = object.answers?.map((e) => CMsgDOTASeasonPredictions_Prediction_Answers.fromPartial(e)) || [];
    message.queryName = object.queryName ?? "";
    message.lockOnSelectionId = object.lockOnSelectionId ?? 0;
    message.lockOnSelectionValue = object.lockOnSelectionValue ?? 0;
    message.lockOnSelectionSet = object.lockOnSelectionSet ?? false;
    message.useAnswerValueRanges = object.useAnswerValueRanges ?? false;
    message.region = object.region ?? 0;
    message.phases = object.phases?.map((e) => e) || [];
    message.rewardEvent = object.rewardEvent ?? 0;
    return message;
  },
};

function createBaseCMsgDOTASeasonPredictions_Prediction_Answers(): CMsgDOTASeasonPredictions_Prediction_Answers {
  return { answerId: 0 };
}

export const CMsgDOTASeasonPredictions_Prediction_Answers: MessageFns<CMsgDOTASeasonPredictions_Prediction_Answers> = {
  encode(
    message: CMsgDOTASeasonPredictions_Prediction_Answers,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.answerId !== 0) {
      writer.uint32(8).uint32(message.answerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTASeasonPredictions_Prediction_Answers {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASeasonPredictions_Prediction_Answers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.answerId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASeasonPredictions_Prediction_Answers {
    return { answerId: isSet(object.answerId) ? globalThis.Number(object.answerId) : 0 };
  },

  toJSON(message: CMsgDOTASeasonPredictions_Prediction_Answers): unknown {
    const obj: any = {};
    if (message.answerId !== 0) {
      obj.answerId = Math.round(message.answerId);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTASeasonPredictions_Prediction_Answers>,
  ): CMsgDOTASeasonPredictions_Prediction_Answers {
    return CMsgDOTASeasonPredictions_Prediction_Answers.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTASeasonPredictions_Prediction_Answers>,
  ): CMsgDOTASeasonPredictions_Prediction_Answers {
    const message = createBaseCMsgDOTASeasonPredictions_Prediction_Answers();
    message.answerId = object.answerId ?? 0;
    return message;
  },
};

function createBaseCMsgAvailablePredictions(): CMsgAvailablePredictions {
  return { matchPredictions: [] };
}

export const CMsgAvailablePredictions: MessageFns<CMsgAvailablePredictions> = {
  encode(message: CMsgAvailablePredictions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matchPredictions) {
      CMsgAvailablePredictions_MatchPrediction.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgAvailablePredictions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAvailablePredictions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matchPredictions.push(CMsgAvailablePredictions_MatchPrediction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAvailablePredictions {
    return {
      matchPredictions: globalThis.Array.isArray(object?.matchPredictions)
        ? object.matchPredictions.map((e: any) => CMsgAvailablePredictions_MatchPrediction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgAvailablePredictions): unknown {
    const obj: any = {};
    if (message.matchPredictions?.length) {
      obj.matchPredictions = message.matchPredictions.map((e) => CMsgAvailablePredictions_MatchPrediction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAvailablePredictions>): CMsgAvailablePredictions {
    return CMsgAvailablePredictions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAvailablePredictions>): CMsgAvailablePredictions {
    const message = createBaseCMsgAvailablePredictions();
    message.matchPredictions =
      object.matchPredictions?.map((e) => CMsgAvailablePredictions_MatchPrediction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgAvailablePredictions_MatchPrediction(): CMsgAvailablePredictions_MatchPrediction {
  return { matchId: "0", predictions: [] };
}

export const CMsgAvailablePredictions_MatchPrediction: MessageFns<CMsgAvailablePredictions_MatchPrediction> = {
  encode(message: CMsgAvailablePredictions_MatchPrediction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    for (const v of message.predictions) {
      CMsgInGamePrediction.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgAvailablePredictions_MatchPrediction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAvailablePredictions_MatchPrediction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.matchId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.predictions.push(CMsgInGamePrediction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAvailablePredictions_MatchPrediction {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      predictions: globalThis.Array.isArray(object?.predictions)
        ? object.predictions.map((e: any) => CMsgInGamePrediction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgAvailablePredictions_MatchPrediction): unknown {
    const obj: any = {};
    if (message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.predictions?.length) {
      obj.predictions = message.predictions.map((e) => CMsgInGamePrediction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAvailablePredictions_MatchPrediction>): CMsgAvailablePredictions_MatchPrediction {
    return CMsgAvailablePredictions_MatchPrediction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAvailablePredictions_MatchPrediction>): CMsgAvailablePredictions_MatchPrediction {
    const message = createBaseCMsgAvailablePredictions_MatchPrediction();
    message.matchId = object.matchId ?? "0";
    message.predictions = object.predictions?.map((e) => CMsgInGamePrediction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgLeagueWatchedGames(): CMsgLeagueWatchedGames {
  return { leagues: [] };
}

export const CMsgLeagueWatchedGames: MessageFns<CMsgLeagueWatchedGames> = {
  encode(message: CMsgLeagueWatchedGames, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.leagues) {
      CMsgLeagueWatchedGames_League.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgLeagueWatchedGames {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLeagueWatchedGames();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leagues.push(CMsgLeagueWatchedGames_League.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLeagueWatchedGames {
    return {
      leagues: globalThis.Array.isArray(object?.leagues)
        ? object.leagues.map((e: any) => CMsgLeagueWatchedGames_League.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgLeagueWatchedGames): unknown {
    const obj: any = {};
    if (message.leagues?.length) {
      obj.leagues = message.leagues.map((e) => CMsgLeagueWatchedGames_League.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLeagueWatchedGames>): CMsgLeagueWatchedGames {
    return CMsgLeagueWatchedGames.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLeagueWatchedGames>): CMsgLeagueWatchedGames {
    const message = createBaseCMsgLeagueWatchedGames();
    message.leagues = object.leagues?.map((e) => CMsgLeagueWatchedGames_League.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgLeagueWatchedGames_Series(): CMsgLeagueWatchedGames_Series {
  return { nodeId: 0, game: [] };
}

export const CMsgLeagueWatchedGames_Series: MessageFns<CMsgLeagueWatchedGames_Series> = {
  encode(message: CMsgLeagueWatchedGames_Series, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== 0) {
      writer.uint32(8).uint32(message.nodeId);
    }
    writer.uint32(18).fork();
    for (const v of message.game) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgLeagueWatchedGames_Series {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLeagueWatchedGames_Series();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nodeId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.game.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.game.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLeagueWatchedGames_Series {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0,
      game: globalThis.Array.isArray(object?.game) ? object.game.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CMsgLeagueWatchedGames_Series): unknown {
    const obj: any = {};
    if (message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    if (message.game?.length) {
      obj.game = message.game.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLeagueWatchedGames_Series>): CMsgLeagueWatchedGames_Series {
    return CMsgLeagueWatchedGames_Series.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLeagueWatchedGames_Series>): CMsgLeagueWatchedGames_Series {
    const message = createBaseCMsgLeagueWatchedGames_Series();
    message.nodeId = object.nodeId ?? 0;
    message.game = object.game?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgLeagueWatchedGames_League(): CMsgLeagueWatchedGames_League {
  return { leagueId: 0, series: [] };
}

export const CMsgLeagueWatchedGames_League: MessageFns<CMsgLeagueWatchedGames_League> = {
  encode(message: CMsgLeagueWatchedGames_League, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leagueId !== 0) {
      writer.uint32(8).uint32(message.leagueId);
    }
    for (const v of message.series) {
      CMsgLeagueWatchedGames_Series.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgLeagueWatchedGames_League {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLeagueWatchedGames_League();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.series.push(CMsgLeagueWatchedGames_Series.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLeagueWatchedGames_League {
    return {
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      series: globalThis.Array.isArray(object?.series)
        ? object.series.map((e: any) => CMsgLeagueWatchedGames_Series.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgLeagueWatchedGames_League): unknown {
    const obj: any = {};
    if (message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.series?.length) {
      obj.series = message.series.map((e) => CMsgLeagueWatchedGames_Series.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLeagueWatchedGames_League>): CMsgLeagueWatchedGames_League {
    return CMsgLeagueWatchedGames_League.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLeagueWatchedGames_League>): CMsgLeagueWatchedGames_League {
    const message = createBaseCMsgLeagueWatchedGames_League();
    message.leagueId = object.leagueId ?? 0;
    message.series = object.series?.map((e) => CMsgLeagueWatchedGames_Series.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTAMatch(): CMsgDOTAMatch {
  return {
    duration: 0,
    starttime: 0,
    players: [],
    matchId: "0",
    towerStatus: [],
    barracksStatus: [],
    cluster: 0,
    firstBloodTime: 0,
    replaySalt: 0,
    serverIp: 0,
    serverPort: 0,
    lobbyType: 0,
    humanPlayers: 0,
    averageSkill: 0,
    gameBalance: 0,
    radiantTeamId: 0,
    direTeamId: 0,
    leagueid: 0,
    radiantTeamName: "",
    direTeamName: "",
    radiantTeamLogo: "0",
    direTeamLogo: "0",
    radiantTeamLogoUrl: "",
    direTeamLogoUrl: "",
    radiantTeamComplete: 0,
    direTeamComplete: 0,
    positiveVotes: 0,
    negativeVotes: 0,
    gameMode: 0,
    picksBans: [],
    matchSeqNum: "0",
    replayState: 0,
    radiantGuildId: 0,
    direGuildId: 0,
    radiantTeamTag: "",
    direTeamTag: "",
    seriesId: 0,
    seriesType: 0,
    broadcasterChannels: [],
    engine: 0,
    customGameData: undefined,
    matchFlags: 0,
    privateMetadataKey: 0,
    radiantTeamScore: 0,
    direTeamScore: 0,
    matchOutcome: 0,
    tournamentId: 0,
    tournamentRound: 0,
    preGameDuration: 0,
    coaches: [],
  };
}

export const CMsgDOTAMatch: MessageFns<CMsgDOTAMatch> = {
  encode(message: CMsgDOTAMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.duration !== 0) {
      writer.uint32(24).uint32(message.duration);
    }
    if (message.starttime !== 0) {
      writer.uint32(37).fixed32(message.starttime);
    }
    for (const v of message.players) {
      CMsgDOTAMatch_Player.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.matchId !== "0") {
      writer.uint32(48).uint64(message.matchId);
    }
    writer.uint32(66).fork();
    for (const v of message.towerStatus) {
      writer.uint32(v);
    }
    writer.join();
    writer.uint32(74).fork();
    for (const v of message.barracksStatus) {
      writer.uint32(v);
    }
    writer.join();
    if (message.cluster !== 0) {
      writer.uint32(80).uint32(message.cluster);
    }
    if (message.firstBloodTime !== 0) {
      writer.uint32(96).uint32(message.firstBloodTime);
    }
    if (message.replaySalt !== 0) {
      writer.uint32(109).fixed32(message.replaySalt);
    }
    if (message.serverIp !== 0) {
      writer.uint32(117).fixed32(message.serverIp);
    }
    if (message.serverPort !== 0) {
      writer.uint32(120).uint32(message.serverPort);
    }
    if (message.lobbyType !== 0) {
      writer.uint32(128).uint32(message.lobbyType);
    }
    if (message.humanPlayers !== 0) {
      writer.uint32(136).uint32(message.humanPlayers);
    }
    if (message.averageSkill !== 0) {
      writer.uint32(144).uint32(message.averageSkill);
    }
    if (message.gameBalance !== 0) {
      writer.uint32(157).float(message.gameBalance);
    }
    if (message.radiantTeamId !== 0) {
      writer.uint32(160).uint32(message.radiantTeamId);
    }
    if (message.direTeamId !== 0) {
      writer.uint32(168).uint32(message.direTeamId);
    }
    if (message.leagueid !== 0) {
      writer.uint32(176).uint32(message.leagueid);
    }
    if (message.radiantTeamName !== "") {
      writer.uint32(186).string(message.radiantTeamName);
    }
    if (message.direTeamName !== "") {
      writer.uint32(194).string(message.direTeamName);
    }
    if (message.radiantTeamLogo !== "0") {
      writer.uint32(200).uint64(message.radiantTeamLogo);
    }
    if (message.direTeamLogo !== "0") {
      writer.uint32(208).uint64(message.direTeamLogo);
    }
    if (message.radiantTeamLogoUrl !== "") {
      writer.uint32(434).string(message.radiantTeamLogoUrl);
    }
    if (message.direTeamLogoUrl !== "") {
      writer.uint32(442).string(message.direTeamLogoUrl);
    }
    if (message.radiantTeamComplete !== 0) {
      writer.uint32(216).uint32(message.radiantTeamComplete);
    }
    if (message.direTeamComplete !== 0) {
      writer.uint32(224).uint32(message.direTeamComplete);
    }
    if (message.positiveVotes !== 0) {
      writer.uint32(232).uint32(message.positiveVotes);
    }
    if (message.negativeVotes !== 0) {
      writer.uint32(240).uint32(message.negativeVotes);
    }
    if (message.gameMode !== 0) {
      writer.uint32(248).int32(message.gameMode);
    }
    for (const v of message.picksBans) {
      CMatchHeroSelectEvent.encode(v!, writer.uint32(258).fork()).join();
    }
    if (message.matchSeqNum !== "0") {
      writer.uint32(264).uint64(message.matchSeqNum);
    }
    if (message.replayState !== 0) {
      writer.uint32(272).int32(message.replayState);
    }
    if (message.radiantGuildId !== 0) {
      writer.uint32(280).uint32(message.radiantGuildId);
    }
    if (message.direGuildId !== 0) {
      writer.uint32(288).uint32(message.direGuildId);
    }
    if (message.radiantTeamTag !== "") {
      writer.uint32(298).string(message.radiantTeamTag);
    }
    if (message.direTeamTag !== "") {
      writer.uint32(306).string(message.direTeamTag);
    }
    if (message.seriesId !== 0) {
      writer.uint32(312).uint32(message.seriesId);
    }
    if (message.seriesType !== 0) {
      writer.uint32(320).uint32(message.seriesType);
    }
    for (const v of message.broadcasterChannels) {
      CMsgDOTAMatch_BroadcasterChannel.encode(v!, writer.uint32(346).fork()).join();
    }
    if (message.engine !== 0) {
      writer.uint32(352).uint32(message.engine);
    }
    if (message.customGameData !== undefined) {
      CMsgDOTAMatch_CustomGameData.encode(message.customGameData, writer.uint32(362).fork()).join();
    }
    if (message.matchFlags !== 0) {
      writer.uint32(368).uint32(message.matchFlags);
    }
    if (message.privateMetadataKey !== 0) {
      writer.uint32(381).fixed32(message.privateMetadataKey);
    }
    if (message.radiantTeamScore !== 0) {
      writer.uint32(384).uint32(message.radiantTeamScore);
    }
    if (message.direTeamScore !== 0) {
      writer.uint32(392).uint32(message.direTeamScore);
    }
    if (message.matchOutcome !== 0) {
      writer.uint32(400).int32(message.matchOutcome);
    }
    if (message.tournamentId !== 0) {
      writer.uint32(408).uint32(message.tournamentId);
    }
    if (message.tournamentRound !== 0) {
      writer.uint32(416).uint32(message.tournamentRound);
    }
    if (message.preGameDuration !== 0) {
      writer.uint32(424).uint32(message.preGameDuration);
    }
    for (const v of message.coaches) {
      CMsgDOTAMatch_Coach.encode(v!, writer.uint32(458).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.duration = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.starttime = reader.fixed32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.players.push(CMsgDOTAMatch_Player.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.matchId = reader.uint64().toString();
          continue;
        }
        case 8: {
          if (tag === 64) {
            message.towerStatus.push(reader.uint32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.towerStatus.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 9: {
          if (tag === 72) {
            message.barracksStatus.push(reader.uint32());

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.barracksStatus.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.cluster = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.firstBloodTime = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 109) {
            break;
          }

          message.replaySalt = reader.fixed32();
          continue;
        }
        case 14: {
          if (tag !== 117) {
            break;
          }

          message.serverIp = reader.fixed32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.serverPort = reader.uint32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.lobbyType = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.humanPlayers = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.averageSkill = reader.uint32();
          continue;
        }
        case 19: {
          if (tag !== 157) {
            break;
          }

          message.gameBalance = reader.float();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.radiantTeamId = reader.uint32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.direTeamId = reader.uint32();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.leagueid = reader.uint32();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.radiantTeamName = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.direTeamName = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.radiantTeamLogo = reader.uint64().toString();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.direTeamLogo = reader.uint64().toString();
          continue;
        }
        case 54: {
          if (tag !== 434) {
            break;
          }

          message.radiantTeamLogoUrl = reader.string();
          continue;
        }
        case 55: {
          if (tag !== 442) {
            break;
          }

          message.direTeamLogoUrl = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.radiantTeamComplete = reader.uint32();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.direTeamComplete = reader.uint32();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.positiveVotes = reader.uint32();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.negativeVotes = reader.uint32();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.gameMode = reader.int32() as any;
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.picksBans.push(CMatchHeroSelectEvent.decode(reader, reader.uint32()));
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.matchSeqNum = reader.uint64().toString();
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.replayState = reader.int32() as any;
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.radiantGuildId = reader.uint32();
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }

          message.direGuildId = reader.uint32();
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.radiantTeamTag = reader.string();
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.direTeamTag = reader.string();
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }

          message.seriesId = reader.uint32();
          continue;
        }
        case 40: {
          if (tag !== 320) {
            break;
          }

          message.seriesType = reader.uint32();
          continue;
        }
        case 43: {
          if (tag !== 346) {
            break;
          }

          message.broadcasterChannels.push(CMsgDOTAMatch_BroadcasterChannel.decode(reader, reader.uint32()));
          continue;
        }
        case 44: {
          if (tag !== 352) {
            break;
          }

          message.engine = reader.uint32();
          continue;
        }
        case 45: {
          if (tag !== 362) {
            break;
          }

          message.customGameData = CMsgDOTAMatch_CustomGameData.decode(reader, reader.uint32());
          continue;
        }
        case 46: {
          if (tag !== 368) {
            break;
          }

          message.matchFlags = reader.uint32();
          continue;
        }
        case 47: {
          if (tag !== 381) {
            break;
          }

          message.privateMetadataKey = reader.fixed32();
          continue;
        }
        case 48: {
          if (tag !== 384) {
            break;
          }

          message.radiantTeamScore = reader.uint32();
          continue;
        }
        case 49: {
          if (tag !== 392) {
            break;
          }

          message.direTeamScore = reader.uint32();
          continue;
        }
        case 50: {
          if (tag !== 400) {
            break;
          }

          message.matchOutcome = reader.int32() as any;
          continue;
        }
        case 51: {
          if (tag !== 408) {
            break;
          }

          message.tournamentId = reader.uint32();
          continue;
        }
        case 52: {
          if (tag !== 416) {
            break;
          }

          message.tournamentRound = reader.uint32();
          continue;
        }
        case 53: {
          if (tag !== 424) {
            break;
          }

          message.preGameDuration = reader.uint32();
          continue;
        }
        case 57: {
          if (tag !== 458) {
            break;
          }

          message.coaches.push(CMsgDOTAMatch_Coach.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatch {
    return {
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      starttime: isSet(object.starttime) ? globalThis.Number(object.starttime) : 0,
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgDOTAMatch_Player.fromJSON(e))
        : [],
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      towerStatus: globalThis.Array.isArray(object?.towerStatus)
        ? object.towerStatus.map((e: any) => globalThis.Number(e))
        : [],
      barracksStatus: globalThis.Array.isArray(object?.barracksStatus)
        ? object.barracksStatus.map((e: any) => globalThis.Number(e))
        : [],
      cluster: isSet(object.cluster) ? globalThis.Number(object.cluster) : 0,
      firstBloodTime: isSet(object.firstBloodTime) ? globalThis.Number(object.firstBloodTime) : 0,
      replaySalt: isSet(object.replaySalt) ? globalThis.Number(object.replaySalt) : 0,
      serverIp: isSet(object.serverIp) ? globalThis.Number(object.serverIp) : 0,
      serverPort: isSet(object.serverPort) ? globalThis.Number(object.serverPort) : 0,
      lobbyType: isSet(object.lobbyType) ? globalThis.Number(object.lobbyType) : 0,
      humanPlayers: isSet(object.humanPlayers) ? globalThis.Number(object.humanPlayers) : 0,
      averageSkill: isSet(object.averageSkill) ? globalThis.Number(object.averageSkill) : 0,
      gameBalance: isSet(object.gameBalance) ? globalThis.Number(object.gameBalance) : 0,
      radiantTeamId: isSet(object.radiantTeamId) ? globalThis.Number(object.radiantTeamId) : 0,
      direTeamId: isSet(object.direTeamId) ? globalThis.Number(object.direTeamId) : 0,
      leagueid: isSet(object.leagueid) ? globalThis.Number(object.leagueid) : 0,
      radiantTeamName: isSet(object.radiantTeamName) ? globalThis.String(object.radiantTeamName) : "",
      direTeamName: isSet(object.direTeamName) ? globalThis.String(object.direTeamName) : "",
      radiantTeamLogo: isSet(object.radiantTeamLogo) ? globalThis.String(object.radiantTeamLogo) : "0",
      direTeamLogo: isSet(object.direTeamLogo) ? globalThis.String(object.direTeamLogo) : "0",
      radiantTeamLogoUrl: isSet(object.radiantTeamLogoUrl) ? globalThis.String(object.radiantTeamLogoUrl) : "",
      direTeamLogoUrl: isSet(object.direTeamLogoUrl) ? globalThis.String(object.direTeamLogoUrl) : "",
      radiantTeamComplete: isSet(object.radiantTeamComplete) ? globalThis.Number(object.radiantTeamComplete) : 0,
      direTeamComplete: isSet(object.direTeamComplete) ? globalThis.Number(object.direTeamComplete) : 0,
      positiveVotes: isSet(object.positiveVotes) ? globalThis.Number(object.positiveVotes) : 0,
      negativeVotes: isSet(object.negativeVotes) ? globalThis.Number(object.negativeVotes) : 0,
      gameMode: isSet(object.gameMode) ? dOTAGameModeFromJSON(object.gameMode) : 0,
      picksBans: globalThis.Array.isArray(object?.picksBans)
        ? object.picksBans.map((e: any) => CMatchHeroSelectEvent.fromJSON(e))
        : [],
      matchSeqNum: isSet(object.matchSeqNum) ? globalThis.String(object.matchSeqNum) : "0",
      replayState: isSet(object.replayState) ? cMsgDOTAMatch_ReplayStateFromJSON(object.replayState) : 0,
      radiantGuildId: isSet(object.radiantGuildId) ? globalThis.Number(object.radiantGuildId) : 0,
      direGuildId: isSet(object.direGuildId) ? globalThis.Number(object.direGuildId) : 0,
      radiantTeamTag: isSet(object.radiantTeamTag) ? globalThis.String(object.radiantTeamTag) : "",
      direTeamTag: isSet(object.direTeamTag) ? globalThis.String(object.direTeamTag) : "",
      seriesId: isSet(object.seriesId) ? globalThis.Number(object.seriesId) : 0,
      seriesType: isSet(object.seriesType) ? globalThis.Number(object.seriesType) : 0,
      broadcasterChannels: globalThis.Array.isArray(object?.broadcasterChannels)
        ? object.broadcasterChannels.map((e: any) => CMsgDOTAMatch_BroadcasterChannel.fromJSON(e))
        : [],
      engine: isSet(object.engine) ? globalThis.Number(object.engine) : 0,
      customGameData: isSet(object.customGameData)
        ? CMsgDOTAMatch_CustomGameData.fromJSON(object.customGameData)
        : undefined,
      matchFlags: isSet(object.matchFlags) ? globalThis.Number(object.matchFlags) : 0,
      privateMetadataKey: isSet(object.privateMetadataKey) ? globalThis.Number(object.privateMetadataKey) : 0,
      radiantTeamScore: isSet(object.radiantTeamScore) ? globalThis.Number(object.radiantTeamScore) : 0,
      direTeamScore: isSet(object.direTeamScore) ? globalThis.Number(object.direTeamScore) : 0,
      matchOutcome: isSet(object.matchOutcome) ? eMatchOutcomeFromJSON(object.matchOutcome) : 0,
      tournamentId: isSet(object.tournamentId) ? globalThis.Number(object.tournamentId) : 0,
      tournamentRound: isSet(object.tournamentRound) ? globalThis.Number(object.tournamentRound) : 0,
      preGameDuration: isSet(object.preGameDuration) ? globalThis.Number(object.preGameDuration) : 0,
      coaches: globalThis.Array.isArray(object?.coaches)
        ? object.coaches.map((e: any) => CMsgDOTAMatch_Coach.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTAMatch): unknown {
    const obj: any = {};
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.starttime !== 0) {
      obj.starttime = Math.round(message.starttime);
    }
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgDOTAMatch_Player.toJSON(e));
    }
    if (message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.towerStatus?.length) {
      obj.towerStatus = message.towerStatus.map((e) => Math.round(e));
    }
    if (message.barracksStatus?.length) {
      obj.barracksStatus = message.barracksStatus.map((e) => Math.round(e));
    }
    if (message.cluster !== 0) {
      obj.cluster = Math.round(message.cluster);
    }
    if (message.firstBloodTime !== 0) {
      obj.firstBloodTime = Math.round(message.firstBloodTime);
    }
    if (message.replaySalt !== 0) {
      obj.replaySalt = Math.round(message.replaySalt);
    }
    if (message.serverIp !== 0) {
      obj.serverIp = Math.round(message.serverIp);
    }
    if (message.serverPort !== 0) {
      obj.serverPort = Math.round(message.serverPort);
    }
    if (message.lobbyType !== 0) {
      obj.lobbyType = Math.round(message.lobbyType);
    }
    if (message.humanPlayers !== 0) {
      obj.humanPlayers = Math.round(message.humanPlayers);
    }
    if (message.averageSkill !== 0) {
      obj.averageSkill = Math.round(message.averageSkill);
    }
    if (message.gameBalance !== 0) {
      obj.gameBalance = message.gameBalance;
    }
    if (message.radiantTeamId !== 0) {
      obj.radiantTeamId = Math.round(message.radiantTeamId);
    }
    if (message.direTeamId !== 0) {
      obj.direTeamId = Math.round(message.direTeamId);
    }
    if (message.leagueid !== 0) {
      obj.leagueid = Math.round(message.leagueid);
    }
    if (message.radiantTeamName !== "") {
      obj.radiantTeamName = message.radiantTeamName;
    }
    if (message.direTeamName !== "") {
      obj.direTeamName = message.direTeamName;
    }
    if (message.radiantTeamLogo !== "0") {
      obj.radiantTeamLogo = message.radiantTeamLogo;
    }
    if (message.direTeamLogo !== "0") {
      obj.direTeamLogo = message.direTeamLogo;
    }
    if (message.radiantTeamLogoUrl !== "") {
      obj.radiantTeamLogoUrl = message.radiantTeamLogoUrl;
    }
    if (message.direTeamLogoUrl !== "") {
      obj.direTeamLogoUrl = message.direTeamLogoUrl;
    }
    if (message.radiantTeamComplete !== 0) {
      obj.radiantTeamComplete = Math.round(message.radiantTeamComplete);
    }
    if (message.direTeamComplete !== 0) {
      obj.direTeamComplete = Math.round(message.direTeamComplete);
    }
    if (message.positiveVotes !== 0) {
      obj.positiveVotes = Math.round(message.positiveVotes);
    }
    if (message.negativeVotes !== 0) {
      obj.negativeVotes = Math.round(message.negativeVotes);
    }
    if (message.gameMode !== 0) {
      obj.gameMode = dOTAGameModeToJSON(message.gameMode);
    }
    if (message.picksBans?.length) {
      obj.picksBans = message.picksBans.map((e) => CMatchHeroSelectEvent.toJSON(e));
    }
    if (message.matchSeqNum !== "0") {
      obj.matchSeqNum = message.matchSeqNum;
    }
    if (message.replayState !== 0) {
      obj.replayState = cMsgDOTAMatch_ReplayStateToJSON(message.replayState);
    }
    if (message.radiantGuildId !== 0) {
      obj.radiantGuildId = Math.round(message.radiantGuildId);
    }
    if (message.direGuildId !== 0) {
      obj.direGuildId = Math.round(message.direGuildId);
    }
    if (message.radiantTeamTag !== "") {
      obj.radiantTeamTag = message.radiantTeamTag;
    }
    if (message.direTeamTag !== "") {
      obj.direTeamTag = message.direTeamTag;
    }
    if (message.seriesId !== 0) {
      obj.seriesId = Math.round(message.seriesId);
    }
    if (message.seriesType !== 0) {
      obj.seriesType = Math.round(message.seriesType);
    }
    if (message.broadcasterChannels?.length) {
      obj.broadcasterChannels = message.broadcasterChannels.map((e) => CMsgDOTAMatch_BroadcasterChannel.toJSON(e));
    }
    if (message.engine !== 0) {
      obj.engine = Math.round(message.engine);
    }
    if (message.customGameData !== undefined) {
      obj.customGameData = CMsgDOTAMatch_CustomGameData.toJSON(message.customGameData);
    }
    if (message.matchFlags !== 0) {
      obj.matchFlags = Math.round(message.matchFlags);
    }
    if (message.privateMetadataKey !== 0) {
      obj.privateMetadataKey = Math.round(message.privateMetadataKey);
    }
    if (message.radiantTeamScore !== 0) {
      obj.radiantTeamScore = Math.round(message.radiantTeamScore);
    }
    if (message.direTeamScore !== 0) {
      obj.direTeamScore = Math.round(message.direTeamScore);
    }
    if (message.matchOutcome !== 0) {
      obj.matchOutcome = eMatchOutcomeToJSON(message.matchOutcome);
    }
    if (message.tournamentId !== 0) {
      obj.tournamentId = Math.round(message.tournamentId);
    }
    if (message.tournamentRound !== 0) {
      obj.tournamentRound = Math.round(message.tournamentRound);
    }
    if (message.preGameDuration !== 0) {
      obj.preGameDuration = Math.round(message.preGameDuration);
    }
    if (message.coaches?.length) {
      obj.coaches = message.coaches.map((e) => CMsgDOTAMatch_Coach.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatch>): CMsgDOTAMatch {
    return CMsgDOTAMatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatch>): CMsgDOTAMatch {
    const message = createBaseCMsgDOTAMatch();
    message.duration = object.duration ?? 0;
    message.starttime = object.starttime ?? 0;
    message.players = object.players?.map((e) => CMsgDOTAMatch_Player.fromPartial(e)) || [];
    message.matchId = object.matchId ?? "0";
    message.towerStatus = object.towerStatus?.map((e) => e) || [];
    message.barracksStatus = object.barracksStatus?.map((e) => e) || [];
    message.cluster = object.cluster ?? 0;
    message.firstBloodTime = object.firstBloodTime ?? 0;
    message.replaySalt = object.replaySalt ?? 0;
    message.serverIp = object.serverIp ?? 0;
    message.serverPort = object.serverPort ?? 0;
    message.lobbyType = object.lobbyType ?? 0;
    message.humanPlayers = object.humanPlayers ?? 0;
    message.averageSkill = object.averageSkill ?? 0;
    message.gameBalance = object.gameBalance ?? 0;
    message.radiantTeamId = object.radiantTeamId ?? 0;
    message.direTeamId = object.direTeamId ?? 0;
    message.leagueid = object.leagueid ?? 0;
    message.radiantTeamName = object.radiantTeamName ?? "";
    message.direTeamName = object.direTeamName ?? "";
    message.radiantTeamLogo = object.radiantTeamLogo ?? "0";
    message.direTeamLogo = object.direTeamLogo ?? "0";
    message.radiantTeamLogoUrl = object.radiantTeamLogoUrl ?? "";
    message.direTeamLogoUrl = object.direTeamLogoUrl ?? "";
    message.radiantTeamComplete = object.radiantTeamComplete ?? 0;
    message.direTeamComplete = object.direTeamComplete ?? 0;
    message.positiveVotes = object.positiveVotes ?? 0;
    message.negativeVotes = object.negativeVotes ?? 0;
    message.gameMode = object.gameMode ?? 0;
    message.picksBans = object.picksBans?.map((e) => CMatchHeroSelectEvent.fromPartial(e)) || [];
    message.matchSeqNum = object.matchSeqNum ?? "0";
    message.replayState = object.replayState ?? 0;
    message.radiantGuildId = object.radiantGuildId ?? 0;
    message.direGuildId = object.direGuildId ?? 0;
    message.radiantTeamTag = object.radiantTeamTag ?? "";
    message.direTeamTag = object.direTeamTag ?? "";
    message.seriesId = object.seriesId ?? 0;
    message.seriesType = object.seriesType ?? 0;
    message.broadcasterChannels =
      object.broadcasterChannels?.map((e) => CMsgDOTAMatch_BroadcasterChannel.fromPartial(e)) || [];
    message.engine = object.engine ?? 0;
    message.customGameData = (object.customGameData !== undefined && object.customGameData !== null)
      ? CMsgDOTAMatch_CustomGameData.fromPartial(object.customGameData)
      : undefined;
    message.matchFlags = object.matchFlags ?? 0;
    message.privateMetadataKey = object.privateMetadataKey ?? 0;
    message.radiantTeamScore = object.radiantTeamScore ?? 0;
    message.direTeamScore = object.direTeamScore ?? 0;
    message.matchOutcome = object.matchOutcome ?? 0;
    message.tournamentId = object.tournamentId ?? 0;
    message.tournamentRound = object.tournamentRound ?? 0;
    message.preGameDuration = object.preGameDuration ?? 0;
    message.coaches = object.coaches?.map((e) => CMsgDOTAMatch_Coach.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTAMatch_Player(): CMsgDOTAMatch_Player {
  return {
    accountId: 0,
    playerSlot: 0,
    heroId: 0,
    item0: -1,
    item1: -1,
    item2: -1,
    item3: -1,
    item4: -1,
    item5: -1,
    item6: -1,
    item7: -1,
    item8: -1,
    item9: -1,
    expectedTeamContribution: 0,
    scaledMetric: 0,
    previousRank: 0,
    rankChange: 0,
    mmrType: 0,
    kills: 0,
    deaths: 0,
    assists: 0,
    leaverStatus: 0,
    gold: 0,
    lastHits: 0,
    denies: 0,
    goldPerMin: 0,
    xpPerMin: 0,
    goldSpent: 0,
    heroDamage: 0,
    towerDamage: 0,
    heroHealing: 0,
    level: 0,
    timeLastSeen: 0,
    playerName: "",
    supportAbilityValue: 0,
    feedingDetected: false,
    searchRank: 0,
    searchRankUncertainty: 0,
    rankUncertaintyChange: 0,
    heroPlayCount: 0,
    partyId: "0",
    scaledHeroDamage: 0,
    scaledTowerDamage: 0,
    scaledHeroHealing: 0,
    scaledKills: 0,
    scaledDeaths: 0,
    scaledAssists: 0,
    claimedFarmGold: 0,
    supportGold: 0,
    claimedDenies: 0,
    claimedMisses: 0,
    misses: 0,
    abilityUpgrades: [],
    additionalUnitsInventory: [],
    permanentBuffs: [],
    proName: "",
    realName: "",
    customGameData: undefined,
    activePlusSubscription: false,
    netWorth: 0,
    botDifficulty: 0,
    heroPickOrder: 0,
    heroWasRandomed: false,
    heroWasDotaPlusSuggestion: false,
    heroDamageReceived: [],
    heroDamageDealt: [],
    secondsDead: 0,
    goldLostToDeath: 0,
    laneSelectionFlags: 0,
    bountyRunes: 0,
    outpostsCaptured: 0,
    teamNumber: 0,
    teamSlot: 0,
  };
}

export const CMsgDOTAMatch_Player: MessageFns<CMsgDOTAMatch_Player> = {
  encode(message: CMsgDOTAMatch_Player, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.playerSlot !== 0) {
      writer.uint32(16).uint32(message.playerSlot);
    }
    if (message.heroId !== 0) {
      writer.uint32(24).uint32(message.heroId);
    }
    if (message.item0 !== -1) {
      writer.uint32(32).int32(message.item0);
    }
    if (message.item1 !== -1) {
      writer.uint32(40).int32(message.item1);
    }
    if (message.item2 !== -1) {
      writer.uint32(48).int32(message.item2);
    }
    if (message.item3 !== -1) {
      writer.uint32(56).int32(message.item3);
    }
    if (message.item4 !== -1) {
      writer.uint32(64).int32(message.item4);
    }
    if (message.item5 !== -1) {
      writer.uint32(72).int32(message.item5);
    }
    if (message.item6 !== -1) {
      writer.uint32(472).int32(message.item6);
    }
    if (message.item7 !== -1) {
      writer.uint32(480).int32(message.item7);
    }
    if (message.item8 !== -1) {
      writer.uint32(488).int32(message.item8);
    }
    if (message.item9 !== -1) {
      writer.uint32(608).int32(message.item9);
    }
    if (message.expectedTeamContribution !== 0) {
      writer.uint32(85).float(message.expectedTeamContribution);
    }
    if (message.scaledMetric !== 0) {
      writer.uint32(93).float(message.scaledMetric);
    }
    if (message.previousRank !== 0) {
      writer.uint32(96).uint32(message.previousRank);
    }
    if (message.rankChange !== 0) {
      writer.uint32(104).sint32(message.rankChange);
    }
    if (message.mmrType !== 0) {
      writer.uint32(592).uint32(message.mmrType);
    }
    if (message.kills !== 0) {
      writer.uint32(112).uint32(message.kills);
    }
    if (message.deaths !== 0) {
      writer.uint32(120).uint32(message.deaths);
    }
    if (message.assists !== 0) {
      writer.uint32(128).uint32(message.assists);
    }
    if (message.leaverStatus !== 0) {
      writer.uint32(136).uint32(message.leaverStatus);
    }
    if (message.gold !== 0) {
      writer.uint32(144).uint32(message.gold);
    }
    if (message.lastHits !== 0) {
      writer.uint32(152).uint32(message.lastHits);
    }
    if (message.denies !== 0) {
      writer.uint32(160).uint32(message.denies);
    }
    if (message.goldPerMin !== 0) {
      writer.uint32(168).uint32(message.goldPerMin);
    }
    if (message.xpPerMin !== 0) {
      writer.uint32(176).uint32(message.xpPerMin);
    }
    if (message.goldSpent !== 0) {
      writer.uint32(184).uint32(message.goldSpent);
    }
    if (message.heroDamage !== 0) {
      writer.uint32(192).uint32(message.heroDamage);
    }
    if (message.towerDamage !== 0) {
      writer.uint32(200).uint32(message.towerDamage);
    }
    if (message.heroHealing !== 0) {
      writer.uint32(208).uint32(message.heroHealing);
    }
    if (message.level !== 0) {
      writer.uint32(216).uint32(message.level);
    }
    if (message.timeLastSeen !== 0) {
      writer.uint32(224).uint32(message.timeLastSeen);
    }
    if (message.playerName !== "") {
      writer.uint32(234).string(message.playerName);
    }
    if (message.supportAbilityValue !== 0) {
      writer.uint32(240).uint32(message.supportAbilityValue);
    }
    if (message.feedingDetected !== false) {
      writer.uint32(256).bool(message.feedingDetected);
    }
    if (message.searchRank !== 0) {
      writer.uint32(272).uint32(message.searchRank);
    }
    if (message.searchRankUncertainty !== 0) {
      writer.uint32(280).uint32(message.searchRankUncertainty);
    }
    if (message.rankUncertaintyChange !== 0) {
      writer.uint32(288).int32(message.rankUncertaintyChange);
    }
    if (message.heroPlayCount !== 0) {
      writer.uint32(296).uint32(message.heroPlayCount);
    }
    if (message.partyId !== "0") {
      writer.uint32(305).fixed64(message.partyId);
    }
    if (message.scaledHeroDamage !== 0) {
      writer.uint32(432).uint32(message.scaledHeroDamage);
    }
    if (message.scaledTowerDamage !== 0) {
      writer.uint32(440).uint32(message.scaledTowerDamage);
    }
    if (message.scaledHeroHealing !== 0) {
      writer.uint32(448).uint32(message.scaledHeroHealing);
    }
    if (message.scaledKills !== 0) {
      writer.uint32(317).float(message.scaledKills);
    }
    if (message.scaledDeaths !== 0) {
      writer.uint32(325).float(message.scaledDeaths);
    }
    if (message.scaledAssists !== 0) {
      writer.uint32(333).float(message.scaledAssists);
    }
    if (message.claimedFarmGold !== 0) {
      writer.uint32(336).uint32(message.claimedFarmGold);
    }
    if (message.supportGold !== 0) {
      writer.uint32(344).uint32(message.supportGold);
    }
    if (message.claimedDenies !== 0) {
      writer.uint32(352).uint32(message.claimedDenies);
    }
    if (message.claimedMisses !== 0) {
      writer.uint32(360).uint32(message.claimedMisses);
    }
    if (message.misses !== 0) {
      writer.uint32(368).uint32(message.misses);
    }
    for (const v of message.abilityUpgrades) {
      CMatchPlayerAbilityUpgrade.encode(v!, writer.uint32(378).fork()).join();
    }
    for (const v of message.additionalUnitsInventory) {
      CMatchAdditionalUnitInventory.encode(v!, writer.uint32(386).fork()).join();
    }
    for (const v of message.permanentBuffs) {
      CMatchPlayerPermanentBuff.encode(v!, writer.uint32(458).fork()).join();
    }
    if (message.proName !== "") {
      writer.uint32(578).string(message.proName);
    }
    if (message.realName !== "") {
      writer.uint32(586).string(message.realName);
    }
    if (message.customGameData !== undefined) {
      CMsgDOTAMatch_Player_CustomGameData.encode(message.customGameData, writer.uint32(402).fork()).join();
    }
    if (message.activePlusSubscription !== false) {
      writer.uint32(408).bool(message.activePlusSubscription);
    }
    if (message.netWorth !== 0) {
      writer.uint32(416).uint32(message.netWorth);
    }
    if (message.botDifficulty !== 0) {
      writer.uint32(464).uint32(message.botDifficulty);
    }
    if (message.heroPickOrder !== 0) {
      writer.uint32(504).uint32(message.heroPickOrder);
    }
    if (message.heroWasRandomed !== false) {
      writer.uint32(512).bool(message.heroWasRandomed);
    }
    if (message.heroWasDotaPlusSuggestion !== false) {
      writer.uint32(552).bool(message.heroWasDotaPlusSuggestion);
    }
    for (const v of message.heroDamageReceived) {
      CMsgDOTAMatch_Player_HeroDamageReceived.encode(v!, writer.uint32(538).fork()).join();
    }
    for (const v of message.heroDamageDealt) {
      CMsgDOTAMatch_Player_HeroDamageReceived.encode(v!, writer.uint32(634).fork()).join();
    }
    if (message.secondsDead !== 0) {
      writer.uint32(560).uint32(message.secondsDead);
    }
    if (message.goldLostToDeath !== 0) {
      writer.uint32(568).uint32(message.goldLostToDeath);
    }
    if (message.laneSelectionFlags !== 0) {
      writer.uint32(600).uint32(message.laneSelectionFlags);
    }
    if (message.bountyRunes !== 0) {
      writer.uint32(616).uint32(message.bountyRunes);
    }
    if (message.outpostsCaptured !== 0) {
      writer.uint32(624).uint32(message.outpostsCaptured);
    }
    if (message.teamNumber !== 0) {
      writer.uint32(640).int32(message.teamNumber);
    }
    if (message.teamSlot !== 0) {
      writer.uint32(648).uint32(message.teamSlot);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAMatch_Player {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatch_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.playerSlot = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.item0 = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.item1 = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.item2 = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.item3 = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.item4 = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.item5 = reader.int32();
          continue;
        }
        case 59: {
          if (tag !== 472) {
            break;
          }

          message.item6 = reader.int32();
          continue;
        }
        case 60: {
          if (tag !== 480) {
            break;
          }

          message.item7 = reader.int32();
          continue;
        }
        case 61: {
          if (tag !== 488) {
            break;
          }

          message.item8 = reader.int32();
          continue;
        }
        case 76: {
          if (tag !== 608) {
            break;
          }

          message.item9 = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.expectedTeamContribution = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.scaledMetric = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.previousRank = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.rankChange = reader.sint32();
          continue;
        }
        case 74: {
          if (tag !== 592) {
            break;
          }

          message.mmrType = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.assists = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.leaverStatus = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.gold = reader.uint32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.lastHits = reader.uint32();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.denies = reader.uint32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.goldPerMin = reader.uint32();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.xpPerMin = reader.uint32();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.goldSpent = reader.uint32();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.heroDamage = reader.uint32();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.towerDamage = reader.uint32();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.heroHealing = reader.uint32();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.level = reader.uint32();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.timeLastSeen = reader.uint32();
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.playerName = reader.string();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.supportAbilityValue = reader.uint32();
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.feedingDetected = reader.bool();
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.searchRank = reader.uint32();
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.searchRankUncertainty = reader.uint32();
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }

          message.rankUncertaintyChange = reader.int32();
          continue;
        }
        case 37: {
          if (tag !== 296) {
            break;
          }

          message.heroPlayCount = reader.uint32();
          continue;
        }
        case 38: {
          if (tag !== 305) {
            break;
          }

          message.partyId = reader.fixed64().toString();
          continue;
        }
        case 54: {
          if (tag !== 432) {
            break;
          }

          message.scaledHeroDamage = reader.uint32();
          continue;
        }
        case 55: {
          if (tag !== 440) {
            break;
          }

          message.scaledTowerDamage = reader.uint32();
          continue;
        }
        case 56: {
          if (tag !== 448) {
            break;
          }

          message.scaledHeroHealing = reader.uint32();
          continue;
        }
        case 39: {
          if (tag !== 317) {
            break;
          }

          message.scaledKills = reader.float();
          continue;
        }
        case 40: {
          if (tag !== 325) {
            break;
          }

          message.scaledDeaths = reader.float();
          continue;
        }
        case 41: {
          if (tag !== 333) {
            break;
          }

          message.scaledAssists = reader.float();
          continue;
        }
        case 42: {
          if (tag !== 336) {
            break;
          }

          message.claimedFarmGold = reader.uint32();
          continue;
        }
        case 43: {
          if (tag !== 344) {
            break;
          }

          message.supportGold = reader.uint32();
          continue;
        }
        case 44: {
          if (tag !== 352) {
            break;
          }

          message.claimedDenies = reader.uint32();
          continue;
        }
        case 45: {
          if (tag !== 360) {
            break;
          }

          message.claimedMisses = reader.uint32();
          continue;
        }
        case 46: {
          if (tag !== 368) {
            break;
          }

          message.misses = reader.uint32();
          continue;
        }
        case 47: {
          if (tag !== 378) {
            break;
          }

          message.abilityUpgrades.push(CMatchPlayerAbilityUpgrade.decode(reader, reader.uint32()));
          continue;
        }
        case 48: {
          if (tag !== 386) {
            break;
          }

          message.additionalUnitsInventory.push(CMatchAdditionalUnitInventory.decode(reader, reader.uint32()));
          continue;
        }
        case 57: {
          if (tag !== 458) {
            break;
          }

          message.permanentBuffs.push(CMatchPlayerPermanentBuff.decode(reader, reader.uint32()));
          continue;
        }
        case 72: {
          if (tag !== 578) {
            break;
          }

          message.proName = reader.string();
          continue;
        }
        case 73: {
          if (tag !== 586) {
            break;
          }

          message.realName = reader.string();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.customGameData = CMsgDOTAMatch_Player_CustomGameData.decode(reader, reader.uint32());
          continue;
        }
        case 51: {
          if (tag !== 408) {
            break;
          }

          message.activePlusSubscription = reader.bool();
          continue;
        }
        case 52: {
          if (tag !== 416) {
            break;
          }

          message.netWorth = reader.uint32();
          continue;
        }
        case 58: {
          if (tag !== 464) {
            break;
          }

          message.botDifficulty = reader.uint32();
          continue;
        }
        case 63: {
          if (tag !== 504) {
            break;
          }

          message.heroPickOrder = reader.uint32();
          continue;
        }
        case 64: {
          if (tag !== 512) {
            break;
          }

          message.heroWasRandomed = reader.bool();
          continue;
        }
        case 69: {
          if (tag !== 552) {
            break;
          }

          message.heroWasDotaPlusSuggestion = reader.bool();
          continue;
        }
        case 67: {
          if (tag !== 538) {
            break;
          }

          message.heroDamageReceived.push(CMsgDOTAMatch_Player_HeroDamageReceived.decode(reader, reader.uint32()));
          continue;
        }
        case 79: {
          if (tag !== 634) {
            break;
          }

          message.heroDamageDealt.push(CMsgDOTAMatch_Player_HeroDamageReceived.decode(reader, reader.uint32()));
          continue;
        }
        case 70: {
          if (tag !== 560) {
            break;
          }

          message.secondsDead = reader.uint32();
          continue;
        }
        case 71: {
          if (tag !== 568) {
            break;
          }

          message.goldLostToDeath = reader.uint32();
          continue;
        }
        case 75: {
          if (tag !== 600) {
            break;
          }

          message.laneSelectionFlags = reader.uint32();
          continue;
        }
        case 77: {
          if (tag !== 616) {
            break;
          }

          message.bountyRunes = reader.uint32();
          continue;
        }
        case 78: {
          if (tag !== 624) {
            break;
          }

          message.outpostsCaptured = reader.uint32();
          continue;
        }
        case 80: {
          if (tag !== 640) {
            break;
          }

          message.teamNumber = reader.int32() as any;
          continue;
        }
        case 81: {
          if (tag !== 648) {
            break;
          }

          message.teamSlot = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatch_Player {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      playerSlot: isSet(object.playerSlot) ? globalThis.Number(object.playerSlot) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      item0: isSet(object.item0) ? globalThis.Number(object.item0) : -1,
      item1: isSet(object.item1) ? globalThis.Number(object.item1) : -1,
      item2: isSet(object.item2) ? globalThis.Number(object.item2) : -1,
      item3: isSet(object.item3) ? globalThis.Number(object.item3) : -1,
      item4: isSet(object.item4) ? globalThis.Number(object.item4) : -1,
      item5: isSet(object.item5) ? globalThis.Number(object.item5) : -1,
      item6: isSet(object.item6) ? globalThis.Number(object.item6) : -1,
      item7: isSet(object.item7) ? globalThis.Number(object.item7) : -1,
      item8: isSet(object.item8) ? globalThis.Number(object.item8) : -1,
      item9: isSet(object.item9) ? globalThis.Number(object.item9) : -1,
      expectedTeamContribution: isSet(object.expectedTeamContribution)
        ? globalThis.Number(object.expectedTeamContribution)
        : 0,
      scaledMetric: isSet(object.scaledMetric) ? globalThis.Number(object.scaledMetric) : 0,
      previousRank: isSet(object.previousRank) ? globalThis.Number(object.previousRank) : 0,
      rankChange: isSet(object.rankChange) ? globalThis.Number(object.rankChange) : 0,
      mmrType: isSet(object.mmrType) ? globalThis.Number(object.mmrType) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      assists: isSet(object.assists) ? globalThis.Number(object.assists) : 0,
      leaverStatus: isSet(object.leaverStatus) ? globalThis.Number(object.leaverStatus) : 0,
      gold: isSet(object.gold) ? globalThis.Number(object.gold) : 0,
      lastHits: isSet(object.lastHits) ? globalThis.Number(object.lastHits) : 0,
      denies: isSet(object.denies) ? globalThis.Number(object.denies) : 0,
      goldPerMin: isSet(object.goldPerMin) ? globalThis.Number(object.goldPerMin) : 0,
      xpPerMin: isSet(object.xpPerMin) ? globalThis.Number(object.xpPerMin) : 0,
      goldSpent: isSet(object.goldSpent) ? globalThis.Number(object.goldSpent) : 0,
      heroDamage: isSet(object.heroDamage) ? globalThis.Number(object.heroDamage) : 0,
      towerDamage: isSet(object.towerDamage) ? globalThis.Number(object.towerDamage) : 0,
      heroHealing: isSet(object.heroHealing) ? globalThis.Number(object.heroHealing) : 0,
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      timeLastSeen: isSet(object.timeLastSeen) ? globalThis.Number(object.timeLastSeen) : 0,
      playerName: isSet(object.playerName) ? globalThis.String(object.playerName) : "",
      supportAbilityValue: isSet(object.supportAbilityValue) ? globalThis.Number(object.supportAbilityValue) : 0,
      feedingDetected: isSet(object.feedingDetected) ? globalThis.Boolean(object.feedingDetected) : false,
      searchRank: isSet(object.searchRank) ? globalThis.Number(object.searchRank) : 0,
      searchRankUncertainty: isSet(object.searchRankUncertainty) ? globalThis.Number(object.searchRankUncertainty) : 0,
      rankUncertaintyChange: isSet(object.rankUncertaintyChange) ? globalThis.Number(object.rankUncertaintyChange) : 0,
      heroPlayCount: isSet(object.heroPlayCount) ? globalThis.Number(object.heroPlayCount) : 0,
      partyId: isSet(object.partyId) ? globalThis.String(object.partyId) : "0",
      scaledHeroDamage: isSet(object.scaledHeroDamage) ? globalThis.Number(object.scaledHeroDamage) : 0,
      scaledTowerDamage: isSet(object.scaledTowerDamage) ? globalThis.Number(object.scaledTowerDamage) : 0,
      scaledHeroHealing: isSet(object.scaledHeroHealing) ? globalThis.Number(object.scaledHeroHealing) : 0,
      scaledKills: isSet(object.scaledKills) ? globalThis.Number(object.scaledKills) : 0,
      scaledDeaths: isSet(object.scaledDeaths) ? globalThis.Number(object.scaledDeaths) : 0,
      scaledAssists: isSet(object.scaledAssists) ? globalThis.Number(object.scaledAssists) : 0,
      claimedFarmGold: isSet(object.claimedFarmGold) ? globalThis.Number(object.claimedFarmGold) : 0,
      supportGold: isSet(object.supportGold) ? globalThis.Number(object.supportGold) : 0,
      claimedDenies: isSet(object.claimedDenies) ? globalThis.Number(object.claimedDenies) : 0,
      claimedMisses: isSet(object.claimedMisses) ? globalThis.Number(object.claimedMisses) : 0,
      misses: isSet(object.misses) ? globalThis.Number(object.misses) : 0,
      abilityUpgrades: globalThis.Array.isArray(object?.abilityUpgrades)
        ? object.abilityUpgrades.map((e: any) => CMatchPlayerAbilityUpgrade.fromJSON(e))
        : [],
      additionalUnitsInventory: globalThis.Array.isArray(object?.additionalUnitsInventory)
        ? object.additionalUnitsInventory.map((e: any) => CMatchAdditionalUnitInventory.fromJSON(e))
        : [],
      permanentBuffs: globalThis.Array.isArray(object?.permanentBuffs)
        ? object.permanentBuffs.map((e: any) => CMatchPlayerPermanentBuff.fromJSON(e))
        : [],
      proName: isSet(object.proName) ? globalThis.String(object.proName) : "",
      realName: isSet(object.realName) ? globalThis.String(object.realName) : "",
      customGameData: isSet(object.customGameData)
        ? CMsgDOTAMatch_Player_CustomGameData.fromJSON(object.customGameData)
        : undefined,
      activePlusSubscription: isSet(object.activePlusSubscription)
        ? globalThis.Boolean(object.activePlusSubscription)
        : false,
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      botDifficulty: isSet(object.botDifficulty) ? globalThis.Number(object.botDifficulty) : 0,
      heroPickOrder: isSet(object.heroPickOrder) ? globalThis.Number(object.heroPickOrder) : 0,
      heroWasRandomed: isSet(object.heroWasRandomed) ? globalThis.Boolean(object.heroWasRandomed) : false,
      heroWasDotaPlusSuggestion: isSet(object.heroWasDotaPlusSuggestion)
        ? globalThis.Boolean(object.heroWasDotaPlusSuggestion)
        : false,
      heroDamageReceived: globalThis.Array.isArray(object?.heroDamageReceived)
        ? object.heroDamageReceived.map((e: any) => CMsgDOTAMatch_Player_HeroDamageReceived.fromJSON(e))
        : [],
      heroDamageDealt: globalThis.Array.isArray(object?.heroDamageDealt)
        ? object.heroDamageDealt.map((e: any) => CMsgDOTAMatch_Player_HeroDamageReceived.fromJSON(e))
        : [],
      secondsDead: isSet(object.secondsDead) ? globalThis.Number(object.secondsDead) : 0,
      goldLostToDeath: isSet(object.goldLostToDeath) ? globalThis.Number(object.goldLostToDeath) : 0,
      laneSelectionFlags: isSet(object.laneSelectionFlags) ? globalThis.Number(object.laneSelectionFlags) : 0,
      bountyRunes: isSet(object.bountyRunes) ? globalThis.Number(object.bountyRunes) : 0,
      outpostsCaptured: isSet(object.outpostsCaptured) ? globalThis.Number(object.outpostsCaptured) : 0,
      teamNumber: isSet(object.teamNumber) ? dotaGcTeamFromJSON(object.teamNumber) : 0,
      teamSlot: isSet(object.teamSlot) ? globalThis.Number(object.teamSlot) : 0,
    };
  },

  toJSON(message: CMsgDOTAMatch_Player): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.playerSlot !== 0) {
      obj.playerSlot = Math.round(message.playerSlot);
    }
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.item0 !== -1) {
      obj.item0 = Math.round(message.item0);
    }
    if (message.item1 !== -1) {
      obj.item1 = Math.round(message.item1);
    }
    if (message.item2 !== -1) {
      obj.item2 = Math.round(message.item2);
    }
    if (message.item3 !== -1) {
      obj.item3 = Math.round(message.item3);
    }
    if (message.item4 !== -1) {
      obj.item4 = Math.round(message.item4);
    }
    if (message.item5 !== -1) {
      obj.item5 = Math.round(message.item5);
    }
    if (message.item6 !== -1) {
      obj.item6 = Math.round(message.item6);
    }
    if (message.item7 !== -1) {
      obj.item7 = Math.round(message.item7);
    }
    if (message.item8 !== -1) {
      obj.item8 = Math.round(message.item8);
    }
    if (message.item9 !== -1) {
      obj.item9 = Math.round(message.item9);
    }
    if (message.expectedTeamContribution !== 0) {
      obj.expectedTeamContribution = message.expectedTeamContribution;
    }
    if (message.scaledMetric !== 0) {
      obj.scaledMetric = message.scaledMetric;
    }
    if (message.previousRank !== 0) {
      obj.previousRank = Math.round(message.previousRank);
    }
    if (message.rankChange !== 0) {
      obj.rankChange = Math.round(message.rankChange);
    }
    if (message.mmrType !== 0) {
      obj.mmrType = Math.round(message.mmrType);
    }
    if (message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.assists !== 0) {
      obj.assists = Math.round(message.assists);
    }
    if (message.leaverStatus !== 0) {
      obj.leaverStatus = Math.round(message.leaverStatus);
    }
    if (message.gold !== 0) {
      obj.gold = Math.round(message.gold);
    }
    if (message.lastHits !== 0) {
      obj.lastHits = Math.round(message.lastHits);
    }
    if (message.denies !== 0) {
      obj.denies = Math.round(message.denies);
    }
    if (message.goldPerMin !== 0) {
      obj.goldPerMin = Math.round(message.goldPerMin);
    }
    if (message.xpPerMin !== 0) {
      obj.xpPerMin = Math.round(message.xpPerMin);
    }
    if (message.goldSpent !== 0) {
      obj.goldSpent = Math.round(message.goldSpent);
    }
    if (message.heroDamage !== 0) {
      obj.heroDamage = Math.round(message.heroDamage);
    }
    if (message.towerDamage !== 0) {
      obj.towerDamage = Math.round(message.towerDamage);
    }
    if (message.heroHealing !== 0) {
      obj.heroHealing = Math.round(message.heroHealing);
    }
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.timeLastSeen !== 0) {
      obj.timeLastSeen = Math.round(message.timeLastSeen);
    }
    if (message.playerName !== "") {
      obj.playerName = message.playerName;
    }
    if (message.supportAbilityValue !== 0) {
      obj.supportAbilityValue = Math.round(message.supportAbilityValue);
    }
    if (message.feedingDetected !== false) {
      obj.feedingDetected = message.feedingDetected;
    }
    if (message.searchRank !== 0) {
      obj.searchRank = Math.round(message.searchRank);
    }
    if (message.searchRankUncertainty !== 0) {
      obj.searchRankUncertainty = Math.round(message.searchRankUncertainty);
    }
    if (message.rankUncertaintyChange !== 0) {
      obj.rankUncertaintyChange = Math.round(message.rankUncertaintyChange);
    }
    if (message.heroPlayCount !== 0) {
      obj.heroPlayCount = Math.round(message.heroPlayCount);
    }
    if (message.partyId !== "0") {
      obj.partyId = message.partyId;
    }
    if (message.scaledHeroDamage !== 0) {
      obj.scaledHeroDamage = Math.round(message.scaledHeroDamage);
    }
    if (message.scaledTowerDamage !== 0) {
      obj.scaledTowerDamage = Math.round(message.scaledTowerDamage);
    }
    if (message.scaledHeroHealing !== 0) {
      obj.scaledHeroHealing = Math.round(message.scaledHeroHealing);
    }
    if (message.scaledKills !== 0) {
      obj.scaledKills = message.scaledKills;
    }
    if (message.scaledDeaths !== 0) {
      obj.scaledDeaths = message.scaledDeaths;
    }
    if (message.scaledAssists !== 0) {
      obj.scaledAssists = message.scaledAssists;
    }
    if (message.claimedFarmGold !== 0) {
      obj.claimedFarmGold = Math.round(message.claimedFarmGold);
    }
    if (message.supportGold !== 0) {
      obj.supportGold = Math.round(message.supportGold);
    }
    if (message.claimedDenies !== 0) {
      obj.claimedDenies = Math.round(message.claimedDenies);
    }
    if (message.claimedMisses !== 0) {
      obj.claimedMisses = Math.round(message.claimedMisses);
    }
    if (message.misses !== 0) {
      obj.misses = Math.round(message.misses);
    }
    if (message.abilityUpgrades?.length) {
      obj.abilityUpgrades = message.abilityUpgrades.map((e) => CMatchPlayerAbilityUpgrade.toJSON(e));
    }
    if (message.additionalUnitsInventory?.length) {
      obj.additionalUnitsInventory = message.additionalUnitsInventory.map((e) =>
        CMatchAdditionalUnitInventory.toJSON(e)
      );
    }
    if (message.permanentBuffs?.length) {
      obj.permanentBuffs = message.permanentBuffs.map((e) => CMatchPlayerPermanentBuff.toJSON(e));
    }
    if (message.proName !== "") {
      obj.proName = message.proName;
    }
    if (message.realName !== "") {
      obj.realName = message.realName;
    }
    if (message.customGameData !== undefined) {
      obj.customGameData = CMsgDOTAMatch_Player_CustomGameData.toJSON(message.customGameData);
    }
    if (message.activePlusSubscription !== false) {
      obj.activePlusSubscription = message.activePlusSubscription;
    }
    if (message.netWorth !== 0) {
      obj.netWorth = Math.round(message.netWorth);
    }
    if (message.botDifficulty !== 0) {
      obj.botDifficulty = Math.round(message.botDifficulty);
    }
    if (message.heroPickOrder !== 0) {
      obj.heroPickOrder = Math.round(message.heroPickOrder);
    }
    if (message.heroWasRandomed !== false) {
      obj.heroWasRandomed = message.heroWasRandomed;
    }
    if (message.heroWasDotaPlusSuggestion !== false) {
      obj.heroWasDotaPlusSuggestion = message.heroWasDotaPlusSuggestion;
    }
    if (message.heroDamageReceived?.length) {
      obj.heroDamageReceived = message.heroDamageReceived.map((e) => CMsgDOTAMatch_Player_HeroDamageReceived.toJSON(e));
    }
    if (message.heroDamageDealt?.length) {
      obj.heroDamageDealt = message.heroDamageDealt.map((e) => CMsgDOTAMatch_Player_HeroDamageReceived.toJSON(e));
    }
    if (message.secondsDead !== 0) {
      obj.secondsDead = Math.round(message.secondsDead);
    }
    if (message.goldLostToDeath !== 0) {
      obj.goldLostToDeath = Math.round(message.goldLostToDeath);
    }
    if (message.laneSelectionFlags !== 0) {
      obj.laneSelectionFlags = Math.round(message.laneSelectionFlags);
    }
    if (message.bountyRunes !== 0) {
      obj.bountyRunes = Math.round(message.bountyRunes);
    }
    if (message.outpostsCaptured !== 0) {
      obj.outpostsCaptured = Math.round(message.outpostsCaptured);
    }
    if (message.teamNumber !== 0) {
      obj.teamNumber = dotaGcTeamToJSON(message.teamNumber);
    }
    if (message.teamSlot !== 0) {
      obj.teamSlot = Math.round(message.teamSlot);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatch_Player>): CMsgDOTAMatch_Player {
    return CMsgDOTAMatch_Player.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatch_Player>): CMsgDOTAMatch_Player {
    const message = createBaseCMsgDOTAMatch_Player();
    message.accountId = object.accountId ?? 0;
    message.playerSlot = object.playerSlot ?? 0;
    message.heroId = object.heroId ?? 0;
    message.item0 = object.item0 ?? -1;
    message.item1 = object.item1 ?? -1;
    message.item2 = object.item2 ?? -1;
    message.item3 = object.item3 ?? -1;
    message.item4 = object.item4 ?? -1;
    message.item5 = object.item5 ?? -1;
    message.item6 = object.item6 ?? -1;
    message.item7 = object.item7 ?? -1;
    message.item8 = object.item8 ?? -1;
    message.item9 = object.item9 ?? -1;
    message.expectedTeamContribution = object.expectedTeamContribution ?? 0;
    message.scaledMetric = object.scaledMetric ?? 0;
    message.previousRank = object.previousRank ?? 0;
    message.rankChange = object.rankChange ?? 0;
    message.mmrType = object.mmrType ?? 0;
    message.kills = object.kills ?? 0;
    message.deaths = object.deaths ?? 0;
    message.assists = object.assists ?? 0;
    message.leaverStatus = object.leaverStatus ?? 0;
    message.gold = object.gold ?? 0;
    message.lastHits = object.lastHits ?? 0;
    message.denies = object.denies ?? 0;
    message.goldPerMin = object.goldPerMin ?? 0;
    message.xpPerMin = object.xpPerMin ?? 0;
    message.goldSpent = object.goldSpent ?? 0;
    message.heroDamage = object.heroDamage ?? 0;
    message.towerDamage = object.towerDamage ?? 0;
    message.heroHealing = object.heroHealing ?? 0;
    message.level = object.level ?? 0;
    message.timeLastSeen = object.timeLastSeen ?? 0;
    message.playerName = object.playerName ?? "";
    message.supportAbilityValue = object.supportAbilityValue ?? 0;
    message.feedingDetected = object.feedingDetected ?? false;
    message.searchRank = object.searchRank ?? 0;
    message.searchRankUncertainty = object.searchRankUncertainty ?? 0;
    message.rankUncertaintyChange = object.rankUncertaintyChange ?? 0;
    message.heroPlayCount = object.heroPlayCount ?? 0;
    message.partyId = object.partyId ?? "0";
    message.scaledHeroDamage = object.scaledHeroDamage ?? 0;
    message.scaledTowerDamage = object.scaledTowerDamage ?? 0;
    message.scaledHeroHealing = object.scaledHeroHealing ?? 0;
    message.scaledKills = object.scaledKills ?? 0;
    message.scaledDeaths = object.scaledDeaths ?? 0;
    message.scaledAssists = object.scaledAssists ?? 0;
    message.claimedFarmGold = object.claimedFarmGold ?? 0;
    message.supportGold = object.supportGold ?? 0;
    message.claimedDenies = object.claimedDenies ?? 0;
    message.claimedMisses = object.claimedMisses ?? 0;
    message.misses = object.misses ?? 0;
    message.abilityUpgrades = object.abilityUpgrades?.map((e) => CMatchPlayerAbilityUpgrade.fromPartial(e)) || [];
    message.additionalUnitsInventory =
      object.additionalUnitsInventory?.map((e) => CMatchAdditionalUnitInventory.fromPartial(e)) || [];
    message.permanentBuffs = object.permanentBuffs?.map((e) => CMatchPlayerPermanentBuff.fromPartial(e)) || [];
    message.proName = object.proName ?? "";
    message.realName = object.realName ?? "";
    message.customGameData = (object.customGameData !== undefined && object.customGameData !== null)
      ? CMsgDOTAMatch_Player_CustomGameData.fromPartial(object.customGameData)
      : undefined;
    message.activePlusSubscription = object.activePlusSubscription ?? false;
    message.netWorth = object.netWorth ?? 0;
    message.botDifficulty = object.botDifficulty ?? 0;
    message.heroPickOrder = object.heroPickOrder ?? 0;
    message.heroWasRandomed = object.heroWasRandomed ?? false;
    message.heroWasDotaPlusSuggestion = object.heroWasDotaPlusSuggestion ?? false;
    message.heroDamageReceived =
      object.heroDamageReceived?.map((e) => CMsgDOTAMatch_Player_HeroDamageReceived.fromPartial(e)) || [];
    message.heroDamageDealt =
      object.heroDamageDealt?.map((e) => CMsgDOTAMatch_Player_HeroDamageReceived.fromPartial(e)) || [];
    message.secondsDead = object.secondsDead ?? 0;
    message.goldLostToDeath = object.goldLostToDeath ?? 0;
    message.laneSelectionFlags = object.laneSelectionFlags ?? 0;
    message.bountyRunes = object.bountyRunes ?? 0;
    message.outpostsCaptured = object.outpostsCaptured ?? 0;
    message.teamNumber = object.teamNumber ?? 0;
    message.teamSlot = object.teamSlot ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAMatch_Player_CustomGameData(): CMsgDOTAMatch_Player_CustomGameData {
  return { dotaTeam: 0, winner: false };
}

export const CMsgDOTAMatch_Player_CustomGameData: MessageFns<CMsgDOTAMatch_Player_CustomGameData> = {
  encode(message: CMsgDOTAMatch_Player_CustomGameData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dotaTeam !== 0) {
      writer.uint32(8).uint32(message.dotaTeam);
    }
    if (message.winner !== false) {
      writer.uint32(16).bool(message.winner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAMatch_Player_CustomGameData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatch_Player_CustomGameData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.dotaTeam = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.winner = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatch_Player_CustomGameData {
    return {
      dotaTeam: isSet(object.dotaTeam) ? globalThis.Number(object.dotaTeam) : 0,
      winner: isSet(object.winner) ? globalThis.Boolean(object.winner) : false,
    };
  },

  toJSON(message: CMsgDOTAMatch_Player_CustomGameData): unknown {
    const obj: any = {};
    if (message.dotaTeam !== 0) {
      obj.dotaTeam = Math.round(message.dotaTeam);
    }
    if (message.winner !== false) {
      obj.winner = message.winner;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatch_Player_CustomGameData>): CMsgDOTAMatch_Player_CustomGameData {
    return CMsgDOTAMatch_Player_CustomGameData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatch_Player_CustomGameData>): CMsgDOTAMatch_Player_CustomGameData {
    const message = createBaseCMsgDOTAMatch_Player_CustomGameData();
    message.dotaTeam = object.dotaTeam ?? 0;
    message.winner = object.winner ?? false;
    return message;
  },
};

function createBaseCMsgDOTAMatch_Player_HeroDamageReceived(): CMsgDOTAMatch_Player_HeroDamageReceived {
  return { preReduction: 0, postReduction: 0, damageType: 0 };
}

export const CMsgDOTAMatch_Player_HeroDamageReceived: MessageFns<CMsgDOTAMatch_Player_HeroDamageReceived> = {
  encode(message: CMsgDOTAMatch_Player_HeroDamageReceived, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.preReduction !== 0) {
      writer.uint32(8).uint32(message.preReduction);
    }
    if (message.postReduction !== 0) {
      writer.uint32(16).uint32(message.postReduction);
    }
    if (message.damageType !== 0) {
      writer.uint32(24).int32(message.damageType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAMatch_Player_HeroDamageReceived {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatch_Player_HeroDamageReceived();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.preReduction = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.postReduction = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.damageType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatch_Player_HeroDamageReceived {
    return {
      preReduction: isSet(object.preReduction) ? globalThis.Number(object.preReduction) : 0,
      postReduction: isSet(object.postReduction) ? globalThis.Number(object.postReduction) : 0,
      damageType: isSet(object.damageType) ? cMsgDOTAMatch_Player_HeroDamageTypeFromJSON(object.damageType) : 0,
    };
  },

  toJSON(message: CMsgDOTAMatch_Player_HeroDamageReceived): unknown {
    const obj: any = {};
    if (message.preReduction !== 0) {
      obj.preReduction = Math.round(message.preReduction);
    }
    if (message.postReduction !== 0) {
      obj.postReduction = Math.round(message.postReduction);
    }
    if (message.damageType !== 0) {
      obj.damageType = cMsgDOTAMatch_Player_HeroDamageTypeToJSON(message.damageType);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatch_Player_HeroDamageReceived>): CMsgDOTAMatch_Player_HeroDamageReceived {
    return CMsgDOTAMatch_Player_HeroDamageReceived.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatch_Player_HeroDamageReceived>): CMsgDOTAMatch_Player_HeroDamageReceived {
    const message = createBaseCMsgDOTAMatch_Player_HeroDamageReceived();
    message.preReduction = object.preReduction ?? 0;
    message.postReduction = object.postReduction ?? 0;
    message.damageType = object.damageType ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAMatch_BroadcasterInfo(): CMsgDOTAMatch_BroadcasterInfo {
  return { accountId: 0, name: "" };
}

export const CMsgDOTAMatch_BroadcasterInfo: MessageFns<CMsgDOTAMatch_BroadcasterInfo> = {
  encode(message: CMsgDOTAMatch_BroadcasterInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAMatch_BroadcasterInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatch_BroadcasterInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatch_BroadcasterInfo {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: CMsgDOTAMatch_BroadcasterInfo): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatch_BroadcasterInfo>): CMsgDOTAMatch_BroadcasterInfo {
    return CMsgDOTAMatch_BroadcasterInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatch_BroadcasterInfo>): CMsgDOTAMatch_BroadcasterInfo {
    const message = createBaseCMsgDOTAMatch_BroadcasterInfo();
    message.accountId = object.accountId ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCMsgDOTAMatch_BroadcasterChannel(): CMsgDOTAMatch_BroadcasterChannel {
  return { countryCode: "", description: "", broadcasterInfos: [], languageCode: "" };
}

export const CMsgDOTAMatch_BroadcasterChannel: MessageFns<CMsgDOTAMatch_BroadcasterChannel> = {
  encode(message: CMsgDOTAMatch_BroadcasterChannel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.countryCode !== "") {
      writer.uint32(10).string(message.countryCode);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.broadcasterInfos) {
      CMsgDOTAMatch_BroadcasterInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(34).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAMatch_BroadcasterChannel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatch_BroadcasterChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.broadcasterInfos.push(CMsgDOTAMatch_BroadcasterInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatch_BroadcasterChannel {
    return {
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      broadcasterInfos: globalThis.Array.isArray(object?.broadcasterInfos)
        ? object.broadcasterInfos.map((e: any) => CMsgDOTAMatch_BroadcasterInfo.fromJSON(e))
        : [],
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: CMsgDOTAMatch_BroadcasterChannel): unknown {
    const obj: any = {};
    if (message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.broadcasterInfos?.length) {
      obj.broadcasterInfos = message.broadcasterInfos.map((e) => CMsgDOTAMatch_BroadcasterInfo.toJSON(e));
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatch_BroadcasterChannel>): CMsgDOTAMatch_BroadcasterChannel {
    return CMsgDOTAMatch_BroadcasterChannel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatch_BroadcasterChannel>): CMsgDOTAMatch_BroadcasterChannel {
    const message = createBaseCMsgDOTAMatch_BroadcasterChannel();
    message.countryCode = object.countryCode ?? "";
    message.description = object.description ?? "";
    message.broadcasterInfos = object.broadcasterInfos?.map((e) => CMsgDOTAMatch_BroadcasterInfo.fromPartial(e)) || [];
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseCMsgDOTAMatch_Coach(): CMsgDOTAMatch_Coach {
  return { accountId: 0, coachName: "", coachRating: 0, coachTeam: 0, coachPartyId: "0", isPrivateCoach: false };
}

export const CMsgDOTAMatch_Coach: MessageFns<CMsgDOTAMatch_Coach> = {
  encode(message: CMsgDOTAMatch_Coach, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.coachName !== "") {
      writer.uint32(18).string(message.coachName);
    }
    if (message.coachRating !== 0) {
      writer.uint32(24).uint32(message.coachRating);
    }
    if (message.coachTeam !== 0) {
      writer.uint32(32).uint32(message.coachTeam);
    }
    if (message.coachPartyId !== "0") {
      writer.uint32(40).uint64(message.coachPartyId);
    }
    if (message.isPrivateCoach !== false) {
      writer.uint32(48).bool(message.isPrivateCoach);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAMatch_Coach {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatch_Coach();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.coachName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.coachRating = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.coachTeam = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.coachPartyId = reader.uint64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isPrivateCoach = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatch_Coach {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      coachName: isSet(object.coachName) ? globalThis.String(object.coachName) : "",
      coachRating: isSet(object.coachRating) ? globalThis.Number(object.coachRating) : 0,
      coachTeam: isSet(object.coachTeam) ? globalThis.Number(object.coachTeam) : 0,
      coachPartyId: isSet(object.coachPartyId) ? globalThis.String(object.coachPartyId) : "0",
      isPrivateCoach: isSet(object.isPrivateCoach) ? globalThis.Boolean(object.isPrivateCoach) : false,
    };
  },

  toJSON(message: CMsgDOTAMatch_Coach): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.coachName !== "") {
      obj.coachName = message.coachName;
    }
    if (message.coachRating !== 0) {
      obj.coachRating = Math.round(message.coachRating);
    }
    if (message.coachTeam !== 0) {
      obj.coachTeam = Math.round(message.coachTeam);
    }
    if (message.coachPartyId !== "0") {
      obj.coachPartyId = message.coachPartyId;
    }
    if (message.isPrivateCoach !== false) {
      obj.isPrivateCoach = message.isPrivateCoach;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatch_Coach>): CMsgDOTAMatch_Coach {
    return CMsgDOTAMatch_Coach.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatch_Coach>): CMsgDOTAMatch_Coach {
    const message = createBaseCMsgDOTAMatch_Coach();
    message.accountId = object.accountId ?? 0;
    message.coachName = object.coachName ?? "";
    message.coachRating = object.coachRating ?? 0;
    message.coachTeam = object.coachTeam ?? 0;
    message.coachPartyId = object.coachPartyId ?? "0";
    message.isPrivateCoach = object.isPrivateCoach ?? false;
    return message;
  },
};

function createBaseCMsgDOTAMatch_CustomGameData(): CMsgDOTAMatch_CustomGameData {
  return { customGameId: "0", mapName: "" };
}

export const CMsgDOTAMatch_CustomGameData: MessageFns<CMsgDOTAMatch_CustomGameData> = {
  encode(message: CMsgDOTAMatch_CustomGameData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customGameId !== "0") {
      writer.uint32(8).uint64(message.customGameId);
    }
    if (message.mapName !== "") {
      writer.uint32(18).string(message.mapName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAMatch_CustomGameData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatch_CustomGameData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.customGameId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mapName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatch_CustomGameData {
    return {
      customGameId: isSet(object.customGameId) ? globalThis.String(object.customGameId) : "0",
      mapName: isSet(object.mapName) ? globalThis.String(object.mapName) : "",
    };
  },

  toJSON(message: CMsgDOTAMatch_CustomGameData): unknown {
    const obj: any = {};
    if (message.customGameId !== "0") {
      obj.customGameId = message.customGameId;
    }
    if (message.mapName !== "") {
      obj.mapName = message.mapName;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatch_CustomGameData>): CMsgDOTAMatch_CustomGameData {
    return CMsgDOTAMatch_CustomGameData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatch_CustomGameData>): CMsgDOTAMatch_CustomGameData {
    const message = createBaseCMsgDOTAMatch_CustomGameData();
    message.customGameId = object.customGameId ?? "0";
    message.mapName = object.mapName ?? "";
    return message;
  },
};

function createBaseCMsgPlayerCard(): CMsgPlayerCard {
  return { accountId: 0, statModifier: [] };
}

export const CMsgPlayerCard: MessageFns<CMsgPlayerCard> = {
  encode(message: CMsgPlayerCard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    for (const v of message.statModifier) {
      CMsgPlayerCard_StatModifier.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgPlayerCard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.statModifier.push(CMsgPlayerCard_StatModifier.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPlayerCard {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      statModifier: globalThis.Array.isArray(object?.statModifier)
        ? object.statModifier.map((e: any) => CMsgPlayerCard_StatModifier.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgPlayerCard): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.statModifier?.length) {
      obj.statModifier = message.statModifier.map((e) => CMsgPlayerCard_StatModifier.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPlayerCard>): CMsgPlayerCard {
    return CMsgPlayerCard.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPlayerCard>): CMsgPlayerCard {
    const message = createBaseCMsgPlayerCard();
    message.accountId = object.accountId ?? 0;
    message.statModifier = object.statModifier?.map((e) => CMsgPlayerCard_StatModifier.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgPlayerCard_StatModifier(): CMsgPlayerCard_StatModifier {
  return { stat: 0, value: 0 };
}

export const CMsgPlayerCard_StatModifier: MessageFns<CMsgPlayerCard_StatModifier> = {
  encode(message: CMsgPlayerCard_StatModifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stat !== 0) {
      writer.uint32(8).uint32(message.stat);
    }
    if (message.value !== 0) {
      writer.uint32(16).uint32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgPlayerCard_StatModifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerCard_StatModifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.stat = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPlayerCard_StatModifier {
    return {
      stat: isSet(object.stat) ? globalThis.Number(object.stat) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: CMsgPlayerCard_StatModifier): unknown {
    const obj: any = {};
    if (message.stat !== 0) {
      obj.stat = Math.round(message.stat);
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPlayerCard_StatModifier>): CMsgPlayerCard_StatModifier {
    return CMsgPlayerCard_StatModifier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPlayerCard_StatModifier>): CMsgPlayerCard_StatModifier {
    const message = createBaseCMsgPlayerCard_StatModifier();
    message.stat = object.stat ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAFantasyPlayerStats(): CMsgDOTAFantasyPlayerStats {
  return {
    playerAccountId: 0,
    matchId: "0",
    matchCompleted: false,
    teamId: 0,
    leagueId: 0,
    delay: 0,
    seriesId: 0,
    seriesType: 0,
    kills: 0,
    deaths: 0,
    cs: 0,
    gpm: 0,
    towerKills: 0,
    roshanKills: 0,
    teamfightParticipation: 0,
    wardsPlaced: 0,
    campsStacked: 0,
    runesGrabbed: 0,
    firstBlood: 0,
    stuns: 0,
  };
}

export const CMsgDOTAFantasyPlayerStats: MessageFns<CMsgDOTAFantasyPlayerStats> = {
  encode(message: CMsgDOTAFantasyPlayerStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerAccountId !== 0) {
      writer.uint32(8).uint32(message.playerAccountId);
    }
    if (message.matchId !== "0") {
      writer.uint32(16).uint64(message.matchId);
    }
    if (message.matchCompleted !== false) {
      writer.uint32(24).bool(message.matchCompleted);
    }
    if (message.teamId !== 0) {
      writer.uint32(32).uint32(message.teamId);
    }
    if (message.leagueId !== 0) {
      writer.uint32(40).uint32(message.leagueId);
    }
    if (message.delay !== 0) {
      writer.uint32(48).uint32(message.delay);
    }
    if (message.seriesId !== 0) {
      writer.uint32(56).uint32(message.seriesId);
    }
    if (message.seriesType !== 0) {
      writer.uint32(64).uint32(message.seriesType);
    }
    if (message.kills !== 0) {
      writer.uint32(80).uint32(message.kills);
    }
    if (message.deaths !== 0) {
      writer.uint32(88).uint32(message.deaths);
    }
    if (message.cs !== 0) {
      writer.uint32(96).uint32(message.cs);
    }
    if (message.gpm !== 0) {
      writer.uint32(109).float(message.gpm);
    }
    if (message.towerKills !== 0) {
      writer.uint32(112).uint32(message.towerKills);
    }
    if (message.roshanKills !== 0) {
      writer.uint32(120).uint32(message.roshanKills);
    }
    if (message.teamfightParticipation !== 0) {
      writer.uint32(133).float(message.teamfightParticipation);
    }
    if (message.wardsPlaced !== 0) {
      writer.uint32(136).uint32(message.wardsPlaced);
    }
    if (message.campsStacked !== 0) {
      writer.uint32(144).uint32(message.campsStacked);
    }
    if (message.runesGrabbed !== 0) {
      writer.uint32(152).uint32(message.runesGrabbed);
    }
    if (message.firstBlood !== 0) {
      writer.uint32(160).uint32(message.firstBlood);
    }
    if (message.stuns !== 0) {
      writer.uint32(173).float(message.stuns);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAFantasyPlayerStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAFantasyPlayerStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.playerAccountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.matchId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.matchCompleted = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.delay = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.seriesId = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.seriesType = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.cs = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 109) {
            break;
          }

          message.gpm = reader.float();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.towerKills = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.roshanKills = reader.uint32();
          continue;
        }
        case 16: {
          if (tag !== 133) {
            break;
          }

          message.teamfightParticipation = reader.float();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.wardsPlaced = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.campsStacked = reader.uint32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.runesGrabbed = reader.uint32();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.firstBlood = reader.uint32();
          continue;
        }
        case 21: {
          if (tag !== 173) {
            break;
          }

          message.stuns = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAFantasyPlayerStats {
    return {
      playerAccountId: isSet(object.playerAccountId) ? globalThis.Number(object.playerAccountId) : 0,
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      matchCompleted: isSet(object.matchCompleted) ? globalThis.Boolean(object.matchCompleted) : false,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      delay: isSet(object.delay) ? globalThis.Number(object.delay) : 0,
      seriesId: isSet(object.seriesId) ? globalThis.Number(object.seriesId) : 0,
      seriesType: isSet(object.seriesType) ? globalThis.Number(object.seriesType) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      cs: isSet(object.cs) ? globalThis.Number(object.cs) : 0,
      gpm: isSet(object.gpm) ? globalThis.Number(object.gpm) : 0,
      towerKills: isSet(object.towerKills) ? globalThis.Number(object.towerKills) : 0,
      roshanKills: isSet(object.roshanKills) ? globalThis.Number(object.roshanKills) : 0,
      teamfightParticipation: isSet(object.teamfightParticipation)
        ? globalThis.Number(object.teamfightParticipation)
        : 0,
      wardsPlaced: isSet(object.wardsPlaced) ? globalThis.Number(object.wardsPlaced) : 0,
      campsStacked: isSet(object.campsStacked) ? globalThis.Number(object.campsStacked) : 0,
      runesGrabbed: isSet(object.runesGrabbed) ? globalThis.Number(object.runesGrabbed) : 0,
      firstBlood: isSet(object.firstBlood) ? globalThis.Number(object.firstBlood) : 0,
      stuns: isSet(object.stuns) ? globalThis.Number(object.stuns) : 0,
    };
  },

  toJSON(message: CMsgDOTAFantasyPlayerStats): unknown {
    const obj: any = {};
    if (message.playerAccountId !== 0) {
      obj.playerAccountId = Math.round(message.playerAccountId);
    }
    if (message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.matchCompleted !== false) {
      obj.matchCompleted = message.matchCompleted;
    }
    if (message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.delay !== 0) {
      obj.delay = Math.round(message.delay);
    }
    if (message.seriesId !== 0) {
      obj.seriesId = Math.round(message.seriesId);
    }
    if (message.seriesType !== 0) {
      obj.seriesType = Math.round(message.seriesType);
    }
    if (message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.cs !== 0) {
      obj.cs = Math.round(message.cs);
    }
    if (message.gpm !== 0) {
      obj.gpm = message.gpm;
    }
    if (message.towerKills !== 0) {
      obj.towerKills = Math.round(message.towerKills);
    }
    if (message.roshanKills !== 0) {
      obj.roshanKills = Math.round(message.roshanKills);
    }
    if (message.teamfightParticipation !== 0) {
      obj.teamfightParticipation = message.teamfightParticipation;
    }
    if (message.wardsPlaced !== 0) {
      obj.wardsPlaced = Math.round(message.wardsPlaced);
    }
    if (message.campsStacked !== 0) {
      obj.campsStacked = Math.round(message.campsStacked);
    }
    if (message.runesGrabbed !== 0) {
      obj.runesGrabbed = Math.round(message.runesGrabbed);
    }
    if (message.firstBlood !== 0) {
      obj.firstBlood = Math.round(message.firstBlood);
    }
    if (message.stuns !== 0) {
      obj.stuns = message.stuns;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAFantasyPlayerStats>): CMsgDOTAFantasyPlayerStats {
    return CMsgDOTAFantasyPlayerStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAFantasyPlayerStats>): CMsgDOTAFantasyPlayerStats {
    const message = createBaseCMsgDOTAFantasyPlayerStats();
    message.playerAccountId = object.playerAccountId ?? 0;
    message.matchId = object.matchId ?? "0";
    message.matchCompleted = object.matchCompleted ?? false;
    message.teamId = object.teamId ?? 0;
    message.leagueId = object.leagueId ?? 0;
    message.delay = object.delay ?? 0;
    message.seriesId = object.seriesId ?? 0;
    message.seriesType = object.seriesType ?? 0;
    message.kills = object.kills ?? 0;
    message.deaths = object.deaths ?? 0;
    message.cs = object.cs ?? 0;
    message.gpm = object.gpm ?? 0;
    message.towerKills = object.towerKills ?? 0;
    message.roshanKills = object.roshanKills ?? 0;
    message.teamfightParticipation = object.teamfightParticipation ?? 0;
    message.wardsPlaced = object.wardsPlaced ?? 0;
    message.campsStacked = object.campsStacked ?? 0;
    message.runesGrabbed = object.runesGrabbed ?? 0;
    message.firstBlood = object.firstBlood ?? 0;
    message.stuns = object.stuns ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAFantasyPlayerMatchStats(): CMsgDOTAFantasyPlayerMatchStats {
  return { matches: [] };
}

export const CMsgDOTAFantasyPlayerMatchStats: MessageFns<CMsgDOTAFantasyPlayerMatchStats> = {
  encode(message: CMsgDOTAFantasyPlayerMatchStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matches) {
      CMsgDOTAFantasyPlayerStats.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAFantasyPlayerMatchStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAFantasyPlayerMatchStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matches.push(CMsgDOTAFantasyPlayerStats.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAFantasyPlayerMatchStats {
    return {
      matches: globalThis.Array.isArray(object?.matches)
        ? object.matches.map((e: any) => CMsgDOTAFantasyPlayerStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTAFantasyPlayerMatchStats): unknown {
    const obj: any = {};
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => CMsgDOTAFantasyPlayerStats.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAFantasyPlayerMatchStats>): CMsgDOTAFantasyPlayerMatchStats {
    return CMsgDOTAFantasyPlayerMatchStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAFantasyPlayerMatchStats>): CMsgDOTAFantasyPlayerMatchStats {
    const message = createBaseCMsgDOTAFantasyPlayerMatchStats();
    message.matches = object.matches?.map((e) => CMsgDOTAFantasyPlayerStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTABotDebugInfo(): CMsgDOTABotDebugInfo {
  return {
    bots: [],
    desirePushLaneTop: 0,
    desirePushLaneMid: 0,
    desirePushLaneBot: 0,
    desireDefendLaneTop: 0,
    desireDefendLaneMid: 0,
    desireDefendLaneBot: 0,
    desireFarmLaneTop: 0,
    desireFarmLaneMid: 0,
    desireFarmLaneBot: 0,
    desireFarmRoshan: 0,
    executionTime: 0,
    runeStatus: [],
  };
}

export const CMsgDOTABotDebugInfo: MessageFns<CMsgDOTABotDebugInfo> = {
  encode(message: CMsgDOTABotDebugInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.bots) {
      CMsgDOTABotDebugInfo_Bot.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.desirePushLaneTop !== 0) {
      writer.uint32(21).float(message.desirePushLaneTop);
    }
    if (message.desirePushLaneMid !== 0) {
      writer.uint32(29).float(message.desirePushLaneMid);
    }
    if (message.desirePushLaneBot !== 0) {
      writer.uint32(37).float(message.desirePushLaneBot);
    }
    if (message.desireDefendLaneTop !== 0) {
      writer.uint32(45).float(message.desireDefendLaneTop);
    }
    if (message.desireDefendLaneMid !== 0) {
      writer.uint32(53).float(message.desireDefendLaneMid);
    }
    if (message.desireDefendLaneBot !== 0) {
      writer.uint32(61).float(message.desireDefendLaneBot);
    }
    if (message.desireFarmLaneTop !== 0) {
      writer.uint32(69).float(message.desireFarmLaneTop);
    }
    if (message.desireFarmLaneMid !== 0) {
      writer.uint32(77).float(message.desireFarmLaneMid);
    }
    if (message.desireFarmLaneBot !== 0) {
      writer.uint32(85).float(message.desireFarmLaneBot);
    }
    if (message.desireFarmRoshan !== 0) {
      writer.uint32(93).float(message.desireFarmRoshan);
    }
    if (message.executionTime !== 0) {
      writer.uint32(101).float(message.executionTime);
    }
    writer.uint32(106).fork();
    for (const v of message.runeStatus) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTABotDebugInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTABotDebugInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bots.push(CMsgDOTABotDebugInfo_Bot.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.desirePushLaneTop = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.desirePushLaneMid = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.desirePushLaneBot = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.desireDefendLaneTop = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.desireDefendLaneMid = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.desireDefendLaneBot = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.desireFarmLaneTop = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.desireFarmLaneMid = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.desireFarmLaneBot = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.desireFarmRoshan = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 101) {
            break;
          }

          message.executionTime = reader.float();
          continue;
        }
        case 13: {
          if (tag === 104) {
            message.runeStatus.push(reader.uint32());

            continue;
          }

          if (tag === 106) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.runeStatus.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTABotDebugInfo {
    return {
      bots: globalThis.Array.isArray(object?.bots)
        ? object.bots.map((e: any) => CMsgDOTABotDebugInfo_Bot.fromJSON(e))
        : [],
      desirePushLaneTop: isSet(object.desirePushLaneTop) ? globalThis.Number(object.desirePushLaneTop) : 0,
      desirePushLaneMid: isSet(object.desirePushLaneMid) ? globalThis.Number(object.desirePushLaneMid) : 0,
      desirePushLaneBot: isSet(object.desirePushLaneBot) ? globalThis.Number(object.desirePushLaneBot) : 0,
      desireDefendLaneTop: isSet(object.desireDefendLaneTop) ? globalThis.Number(object.desireDefendLaneTop) : 0,
      desireDefendLaneMid: isSet(object.desireDefendLaneMid) ? globalThis.Number(object.desireDefendLaneMid) : 0,
      desireDefendLaneBot: isSet(object.desireDefendLaneBot) ? globalThis.Number(object.desireDefendLaneBot) : 0,
      desireFarmLaneTop: isSet(object.desireFarmLaneTop) ? globalThis.Number(object.desireFarmLaneTop) : 0,
      desireFarmLaneMid: isSet(object.desireFarmLaneMid) ? globalThis.Number(object.desireFarmLaneMid) : 0,
      desireFarmLaneBot: isSet(object.desireFarmLaneBot) ? globalThis.Number(object.desireFarmLaneBot) : 0,
      desireFarmRoshan: isSet(object.desireFarmRoshan) ? globalThis.Number(object.desireFarmRoshan) : 0,
      executionTime: isSet(object.executionTime) ? globalThis.Number(object.executionTime) : 0,
      runeStatus: globalThis.Array.isArray(object?.runeStatus)
        ? object.runeStatus.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTABotDebugInfo): unknown {
    const obj: any = {};
    if (message.bots?.length) {
      obj.bots = message.bots.map((e) => CMsgDOTABotDebugInfo_Bot.toJSON(e));
    }
    if (message.desirePushLaneTop !== 0) {
      obj.desirePushLaneTop = message.desirePushLaneTop;
    }
    if (message.desirePushLaneMid !== 0) {
      obj.desirePushLaneMid = message.desirePushLaneMid;
    }
    if (message.desirePushLaneBot !== 0) {
      obj.desirePushLaneBot = message.desirePushLaneBot;
    }
    if (message.desireDefendLaneTop !== 0) {
      obj.desireDefendLaneTop = message.desireDefendLaneTop;
    }
    if (message.desireDefendLaneMid !== 0) {
      obj.desireDefendLaneMid = message.desireDefendLaneMid;
    }
    if (message.desireDefendLaneBot !== 0) {
      obj.desireDefendLaneBot = message.desireDefendLaneBot;
    }
    if (message.desireFarmLaneTop !== 0) {
      obj.desireFarmLaneTop = message.desireFarmLaneTop;
    }
    if (message.desireFarmLaneMid !== 0) {
      obj.desireFarmLaneMid = message.desireFarmLaneMid;
    }
    if (message.desireFarmLaneBot !== 0) {
      obj.desireFarmLaneBot = message.desireFarmLaneBot;
    }
    if (message.desireFarmRoshan !== 0) {
      obj.desireFarmRoshan = message.desireFarmRoshan;
    }
    if (message.executionTime !== 0) {
      obj.executionTime = message.executionTime;
    }
    if (message.runeStatus?.length) {
      obj.runeStatus = message.runeStatus.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTABotDebugInfo>): CMsgDOTABotDebugInfo {
    return CMsgDOTABotDebugInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTABotDebugInfo>): CMsgDOTABotDebugInfo {
    const message = createBaseCMsgDOTABotDebugInfo();
    message.bots = object.bots?.map((e) => CMsgDOTABotDebugInfo_Bot.fromPartial(e)) || [];
    message.desirePushLaneTop = object.desirePushLaneTop ?? 0;
    message.desirePushLaneMid = object.desirePushLaneMid ?? 0;
    message.desirePushLaneBot = object.desirePushLaneBot ?? 0;
    message.desireDefendLaneTop = object.desireDefendLaneTop ?? 0;
    message.desireDefendLaneMid = object.desireDefendLaneMid ?? 0;
    message.desireDefendLaneBot = object.desireDefendLaneBot ?? 0;
    message.desireFarmLaneTop = object.desireFarmLaneTop ?? 0;
    message.desireFarmLaneMid = object.desireFarmLaneMid ?? 0;
    message.desireFarmLaneBot = object.desireFarmLaneBot ?? 0;
    message.desireFarmRoshan = object.desireFarmRoshan ?? 0;
    message.executionTime = object.executionTime ?? 0;
    message.runeStatus = object.runeStatus?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgDOTABotDebugInfo_Bot(): CMsgDOTABotDebugInfo_Bot {
  return {
    playerOwnerId: -1,
    heroId: 0,
    difficulty: 0,
    powerCurrent: 0,
    powerMax: 0,
    moveTargetX: 0,
    moveTargetY: 0,
    moveTargetZ: 0,
    activeModeId: 0,
    executionTime: 0,
    modes: [],
    action: undefined,
  };
}

export const CMsgDOTABotDebugInfo_Bot: MessageFns<CMsgDOTABotDebugInfo_Bot> = {
  encode(message: CMsgDOTABotDebugInfo_Bot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerOwnerId !== -1) {
      writer.uint32(8).int32(message.playerOwnerId);
    }
    if (message.heroId !== 0) {
      writer.uint32(16).uint32(message.heroId);
    }
    if (message.difficulty !== 0) {
      writer.uint32(24).uint32(message.difficulty);
    }
    if (message.powerCurrent !== 0) {
      writer.uint32(32).uint32(message.powerCurrent);
    }
    if (message.powerMax !== 0) {
      writer.uint32(40).uint32(message.powerMax);
    }
    if (message.moveTargetX !== 0) {
      writer.uint32(48).uint32(message.moveTargetX);
    }
    if (message.moveTargetY !== 0) {
      writer.uint32(56).uint32(message.moveTargetY);
    }
    if (message.moveTargetZ !== 0) {
      writer.uint32(64).uint32(message.moveTargetZ);
    }
    if (message.activeModeId !== 0) {
      writer.uint32(72).uint32(message.activeModeId);
    }
    if (message.executionTime !== 0) {
      writer.uint32(85).float(message.executionTime);
    }
    for (const v of message.modes) {
      CMsgDOTABotDebugInfo_Bot_Mode.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.action !== undefined) {
      CMsgDOTABotDebugInfo_Bot_Action.encode(message.action, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTABotDebugInfo_Bot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTABotDebugInfo_Bot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.playerOwnerId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.difficulty = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.powerCurrent = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.powerMax = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.moveTargetX = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.moveTargetY = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.moveTargetZ = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.activeModeId = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.executionTime = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.modes.push(CMsgDOTABotDebugInfo_Bot_Mode.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.action = CMsgDOTABotDebugInfo_Bot_Action.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTABotDebugInfo_Bot {
    return {
      playerOwnerId: isSet(object.playerOwnerId) ? globalThis.Number(object.playerOwnerId) : -1,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      difficulty: isSet(object.difficulty) ? globalThis.Number(object.difficulty) : 0,
      powerCurrent: isSet(object.powerCurrent) ? globalThis.Number(object.powerCurrent) : 0,
      powerMax: isSet(object.powerMax) ? globalThis.Number(object.powerMax) : 0,
      moveTargetX: isSet(object.moveTargetX) ? globalThis.Number(object.moveTargetX) : 0,
      moveTargetY: isSet(object.moveTargetY) ? globalThis.Number(object.moveTargetY) : 0,
      moveTargetZ: isSet(object.moveTargetZ) ? globalThis.Number(object.moveTargetZ) : 0,
      activeModeId: isSet(object.activeModeId) ? globalThis.Number(object.activeModeId) : 0,
      executionTime: isSet(object.executionTime) ? globalThis.Number(object.executionTime) : 0,
      modes: globalThis.Array.isArray(object?.modes)
        ? object.modes.map((e: any) => CMsgDOTABotDebugInfo_Bot_Mode.fromJSON(e))
        : [],
      action: isSet(object.action) ? CMsgDOTABotDebugInfo_Bot_Action.fromJSON(object.action) : undefined,
    };
  },

  toJSON(message: CMsgDOTABotDebugInfo_Bot): unknown {
    const obj: any = {};
    if (message.playerOwnerId !== -1) {
      obj.playerOwnerId = Math.round(message.playerOwnerId);
    }
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.difficulty !== 0) {
      obj.difficulty = Math.round(message.difficulty);
    }
    if (message.powerCurrent !== 0) {
      obj.powerCurrent = Math.round(message.powerCurrent);
    }
    if (message.powerMax !== 0) {
      obj.powerMax = Math.round(message.powerMax);
    }
    if (message.moveTargetX !== 0) {
      obj.moveTargetX = Math.round(message.moveTargetX);
    }
    if (message.moveTargetY !== 0) {
      obj.moveTargetY = Math.round(message.moveTargetY);
    }
    if (message.moveTargetZ !== 0) {
      obj.moveTargetZ = Math.round(message.moveTargetZ);
    }
    if (message.activeModeId !== 0) {
      obj.activeModeId = Math.round(message.activeModeId);
    }
    if (message.executionTime !== 0) {
      obj.executionTime = message.executionTime;
    }
    if (message.modes?.length) {
      obj.modes = message.modes.map((e) => CMsgDOTABotDebugInfo_Bot_Mode.toJSON(e));
    }
    if (message.action !== undefined) {
      obj.action = CMsgDOTABotDebugInfo_Bot_Action.toJSON(message.action);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTABotDebugInfo_Bot>): CMsgDOTABotDebugInfo_Bot {
    return CMsgDOTABotDebugInfo_Bot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTABotDebugInfo_Bot>): CMsgDOTABotDebugInfo_Bot {
    const message = createBaseCMsgDOTABotDebugInfo_Bot();
    message.playerOwnerId = object.playerOwnerId ?? -1;
    message.heroId = object.heroId ?? 0;
    message.difficulty = object.difficulty ?? 0;
    message.powerCurrent = object.powerCurrent ?? 0;
    message.powerMax = object.powerMax ?? 0;
    message.moveTargetX = object.moveTargetX ?? 0;
    message.moveTargetY = object.moveTargetY ?? 0;
    message.moveTargetZ = object.moveTargetZ ?? 0;
    message.activeModeId = object.activeModeId ?? 0;
    message.executionTime = object.executionTime ?? 0;
    message.modes = object.modes?.map((e) => CMsgDOTABotDebugInfo_Bot_Mode.fromPartial(e)) || [];
    message.action = (object.action !== undefined && object.action !== null)
      ? CMsgDOTABotDebugInfo_Bot_Action.fromPartial(object.action)
      : undefined;
    return message;
  },
};

function createBaseCMsgDOTABotDebugInfo_Bot_Mode(): CMsgDOTABotDebugInfo_Bot_Mode {
  return { modeId: 0, desire: 0, targetEntity: -1, targetX: 0, targetY: 0, targetZ: 0 };
}

export const CMsgDOTABotDebugInfo_Bot_Mode: MessageFns<CMsgDOTABotDebugInfo_Bot_Mode> = {
  encode(message: CMsgDOTABotDebugInfo_Bot_Mode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.modeId !== 0) {
      writer.uint32(8).uint32(message.modeId);
    }
    if (message.desire !== 0) {
      writer.uint32(21).float(message.desire);
    }
    if (message.targetEntity !== -1) {
      writer.uint32(24).int32(message.targetEntity);
    }
    if (message.targetX !== 0) {
      writer.uint32(32).uint32(message.targetX);
    }
    if (message.targetY !== 0) {
      writer.uint32(40).uint32(message.targetY);
    }
    if (message.targetZ !== 0) {
      writer.uint32(48).uint32(message.targetZ);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTABotDebugInfo_Bot_Mode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTABotDebugInfo_Bot_Mode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.modeId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.desire = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.targetEntity = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.targetX = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.targetY = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.targetZ = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTABotDebugInfo_Bot_Mode {
    return {
      modeId: isSet(object.modeId) ? globalThis.Number(object.modeId) : 0,
      desire: isSet(object.desire) ? globalThis.Number(object.desire) : 0,
      targetEntity: isSet(object.targetEntity) ? globalThis.Number(object.targetEntity) : -1,
      targetX: isSet(object.targetX) ? globalThis.Number(object.targetX) : 0,
      targetY: isSet(object.targetY) ? globalThis.Number(object.targetY) : 0,
      targetZ: isSet(object.targetZ) ? globalThis.Number(object.targetZ) : 0,
    };
  },

  toJSON(message: CMsgDOTABotDebugInfo_Bot_Mode): unknown {
    const obj: any = {};
    if (message.modeId !== 0) {
      obj.modeId = Math.round(message.modeId);
    }
    if (message.desire !== 0) {
      obj.desire = message.desire;
    }
    if (message.targetEntity !== -1) {
      obj.targetEntity = Math.round(message.targetEntity);
    }
    if (message.targetX !== 0) {
      obj.targetX = Math.round(message.targetX);
    }
    if (message.targetY !== 0) {
      obj.targetY = Math.round(message.targetY);
    }
    if (message.targetZ !== 0) {
      obj.targetZ = Math.round(message.targetZ);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTABotDebugInfo_Bot_Mode>): CMsgDOTABotDebugInfo_Bot_Mode {
    return CMsgDOTABotDebugInfo_Bot_Mode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTABotDebugInfo_Bot_Mode>): CMsgDOTABotDebugInfo_Bot_Mode {
    const message = createBaseCMsgDOTABotDebugInfo_Bot_Mode();
    message.modeId = object.modeId ?? 0;
    message.desire = object.desire ?? 0;
    message.targetEntity = object.targetEntity ?? -1;
    message.targetX = object.targetX ?? 0;
    message.targetY = object.targetY ?? 0;
    message.targetZ = object.targetZ ?? 0;
    return message;
  },
};

function createBaseCMsgDOTABotDebugInfo_Bot_Action(): CMsgDOTABotDebugInfo_Bot_Action {
  return { actionId: 0, actionTarget: "" };
}

export const CMsgDOTABotDebugInfo_Bot_Action: MessageFns<CMsgDOTABotDebugInfo_Bot_Action> = {
  encode(message: CMsgDOTABotDebugInfo_Bot_Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actionId !== 0) {
      writer.uint32(8).uint32(message.actionId);
    }
    if (message.actionTarget !== "") {
      writer.uint32(18).string(message.actionTarget);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTABotDebugInfo_Bot_Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTABotDebugInfo_Bot_Action();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.actionId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.actionTarget = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTABotDebugInfo_Bot_Action {
    return {
      actionId: isSet(object.actionId) ? globalThis.Number(object.actionId) : 0,
      actionTarget: isSet(object.actionTarget) ? globalThis.String(object.actionTarget) : "",
    };
  },

  toJSON(message: CMsgDOTABotDebugInfo_Bot_Action): unknown {
    const obj: any = {};
    if (message.actionId !== 0) {
      obj.actionId = Math.round(message.actionId);
    }
    if (message.actionTarget !== "") {
      obj.actionTarget = message.actionTarget;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTABotDebugInfo_Bot_Action>): CMsgDOTABotDebugInfo_Bot_Action {
    return CMsgDOTABotDebugInfo_Bot_Action.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTABotDebugInfo_Bot_Action>): CMsgDOTABotDebugInfo_Bot_Action {
    const message = createBaseCMsgDOTABotDebugInfo_Bot_Action();
    message.actionId = object.actionId ?? 0;
    message.actionTarget = object.actionTarget ?? "";
    return message;
  },
};

function createBaseCMsgSuccessfulHero(): CMsgSuccessfulHero {
  return { heroId: 0, winPercent: 0, longestStreak: 0 };
}

export const CMsgSuccessfulHero: MessageFns<CMsgSuccessfulHero> = {
  encode(message: CMsgSuccessfulHero, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.heroId !== 0) {
      writer.uint32(8).uint32(message.heroId);
    }
    if (message.winPercent !== 0) {
      writer.uint32(21).float(message.winPercent);
    }
    if (message.longestStreak !== 0) {
      writer.uint32(24).uint32(message.longestStreak);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSuccessfulHero {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSuccessfulHero();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.winPercent = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.longestStreak = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSuccessfulHero {
    return {
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      winPercent: isSet(object.winPercent) ? globalThis.Number(object.winPercent) : 0,
      longestStreak: isSet(object.longestStreak) ? globalThis.Number(object.longestStreak) : 0,
    };
  },

  toJSON(message: CMsgSuccessfulHero): unknown {
    const obj: any = {};
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.winPercent !== 0) {
      obj.winPercent = message.winPercent;
    }
    if (message.longestStreak !== 0) {
      obj.longestStreak = Math.round(message.longestStreak);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSuccessfulHero>): CMsgSuccessfulHero {
    return CMsgSuccessfulHero.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSuccessfulHero>): CMsgSuccessfulHero {
    const message = createBaseCMsgSuccessfulHero();
    message.heroId = object.heroId ?? 0;
    message.winPercent = object.winPercent ?? 0;
    message.longestStreak = object.longestStreak ?? 0;
    return message;
  },
};

function createBaseCMsgRecentMatchInfo(): CMsgRecentMatchInfo {
  return {
    matchId: "0",
    gameMode: 0,
    kills: 0,
    deaths: 0,
    assists: 0,
    duration: 0,
    playerSlot: 0,
    matchOutcome: 0,
    timestamp: 0,
    lobbyType: 0,
    teamNumber: 0,
  };
}

export const CMsgRecentMatchInfo: MessageFns<CMsgRecentMatchInfo> = {
  encode(message: CMsgRecentMatchInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.gameMode !== 0) {
      writer.uint32(16).int32(message.gameMode);
    }
    if (message.kills !== 0) {
      writer.uint32(24).uint32(message.kills);
    }
    if (message.deaths !== 0) {
      writer.uint32(32).uint32(message.deaths);
    }
    if (message.assists !== 0) {
      writer.uint32(40).uint32(message.assists);
    }
    if (message.duration !== 0) {
      writer.uint32(48).uint32(message.duration);
    }
    if (message.playerSlot !== 0) {
      writer.uint32(56).uint32(message.playerSlot);
    }
    if (message.matchOutcome !== 0) {
      writer.uint32(64).int32(message.matchOutcome);
    }
    if (message.timestamp !== 0) {
      writer.uint32(72).uint32(message.timestamp);
    }
    if (message.lobbyType !== 0) {
      writer.uint32(80).uint32(message.lobbyType);
    }
    if (message.teamNumber !== 0) {
      writer.uint32(88).uint32(message.teamNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgRecentMatchInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgRecentMatchInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.matchId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gameMode = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.assists = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.duration = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.playerSlot = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.matchOutcome = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.lobbyType = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.teamNumber = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgRecentMatchInfo {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      gameMode: isSet(object.gameMode) ? dOTAGameModeFromJSON(object.gameMode) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      assists: isSet(object.assists) ? globalThis.Number(object.assists) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      playerSlot: isSet(object.playerSlot) ? globalThis.Number(object.playerSlot) : 0,
      matchOutcome: isSet(object.matchOutcome) ? eMatchOutcomeFromJSON(object.matchOutcome) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      lobbyType: isSet(object.lobbyType) ? globalThis.Number(object.lobbyType) : 0,
      teamNumber: isSet(object.teamNumber) ? globalThis.Number(object.teamNumber) : 0,
    };
  },

  toJSON(message: CMsgRecentMatchInfo): unknown {
    const obj: any = {};
    if (message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.gameMode !== 0) {
      obj.gameMode = dOTAGameModeToJSON(message.gameMode);
    }
    if (message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.assists !== 0) {
      obj.assists = Math.round(message.assists);
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.playerSlot !== 0) {
      obj.playerSlot = Math.round(message.playerSlot);
    }
    if (message.matchOutcome !== 0) {
      obj.matchOutcome = eMatchOutcomeToJSON(message.matchOutcome);
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.lobbyType !== 0) {
      obj.lobbyType = Math.round(message.lobbyType);
    }
    if (message.teamNumber !== 0) {
      obj.teamNumber = Math.round(message.teamNumber);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgRecentMatchInfo>): CMsgRecentMatchInfo {
    return CMsgRecentMatchInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgRecentMatchInfo>): CMsgRecentMatchInfo {
    const message = createBaseCMsgRecentMatchInfo();
    message.matchId = object.matchId ?? "0";
    message.gameMode = object.gameMode ?? 0;
    message.kills = object.kills ?? 0;
    message.deaths = object.deaths ?? 0;
    message.assists = object.assists ?? 0;
    message.duration = object.duration ?? 0;
    message.playerSlot = object.playerSlot ?? 0;
    message.matchOutcome = object.matchOutcome ?? 0;
    message.timestamp = object.timestamp ?? 0;
    message.lobbyType = object.lobbyType ?? 0;
    message.teamNumber = object.teamNumber ?? 0;
    return message;
  },
};

function createBaseCMsgMatchTips(): CMsgMatchTips {
  return { tips: [] };
}

export const CMsgMatchTips: MessageFns<CMsgMatchTips> = {
  encode(message: CMsgMatchTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tips) {
      CMsgMatchTips_SingleTip.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgMatchTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgMatchTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tips.push(CMsgMatchTips_SingleTip.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgMatchTips {
    return {
      tips: globalThis.Array.isArray(object?.tips)
        ? object.tips.map((e: any) => CMsgMatchTips_SingleTip.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgMatchTips): unknown {
    const obj: any = {};
    if (message.tips?.length) {
      obj.tips = message.tips.map((e) => CMsgMatchTips_SingleTip.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgMatchTips>): CMsgMatchTips {
    return CMsgMatchTips.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgMatchTips>): CMsgMatchTips {
    const message = createBaseCMsgMatchTips();
    message.tips = object.tips?.map((e) => CMsgMatchTips_SingleTip.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgMatchTips_SingleTip(): CMsgMatchTips_SingleTip {
  return { sourceAccountId: 0, targetAccountId: 0, tipAmount: 0, eventId: 0 };
}

export const CMsgMatchTips_SingleTip: MessageFns<CMsgMatchTips_SingleTip> = {
  encode(message: CMsgMatchTips_SingleTip, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceAccountId !== 0) {
      writer.uint32(8).uint32(message.sourceAccountId);
    }
    if (message.targetAccountId !== 0) {
      writer.uint32(16).uint32(message.targetAccountId);
    }
    if (message.tipAmount !== 0) {
      writer.uint32(24).uint32(message.tipAmount);
    }
    if (message.eventId !== 0) {
      writer.uint32(32).int32(message.eventId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgMatchTips_SingleTip {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgMatchTips_SingleTip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sourceAccountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.targetAccountId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.tipAmount = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgMatchTips_SingleTip {
    return {
      sourceAccountId: isSet(object.sourceAccountId) ? globalThis.Number(object.sourceAccountId) : 0,
      targetAccountId: isSet(object.targetAccountId) ? globalThis.Number(object.targetAccountId) : 0,
      tipAmount: isSet(object.tipAmount) ? globalThis.Number(object.tipAmount) : 0,
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
    };
  },

  toJSON(message: CMsgMatchTips_SingleTip): unknown {
    const obj: any = {};
    if (message.sourceAccountId !== 0) {
      obj.sourceAccountId = Math.round(message.sourceAccountId);
    }
    if (message.targetAccountId !== 0) {
      obj.targetAccountId = Math.round(message.targetAccountId);
    }
    if (message.tipAmount !== 0) {
      obj.tipAmount = Math.round(message.tipAmount);
    }
    if (message.eventId !== 0) {
      obj.eventId = eEventToJSON(message.eventId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgMatchTips_SingleTip>): CMsgMatchTips_SingleTip {
    return CMsgMatchTips_SingleTip.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgMatchTips_SingleTip>): CMsgMatchTips_SingleTip {
    const message = createBaseCMsgMatchTips_SingleTip();
    message.sourceAccountId = object.sourceAccountId ?? 0;
    message.targetAccountId = object.targetAccountId ?? 0;
    message.tipAmount = object.tipAmount ?? 0;
    message.eventId = object.eventId ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAMatchMinimal(): CMsgDOTAMatchMinimal {
  return {
    matchId: "0",
    startTime: 0,
    duration: 0,
    gameMode: 0,
    players: [],
    tourney: undefined,
    matchOutcome: 0,
    radiantScore: 0,
    direScore: 0,
    lobbyType: 0,
  };
}

export const CMsgDOTAMatchMinimal: MessageFns<CMsgDOTAMatchMinimal> = {
  encode(message: CMsgDOTAMatchMinimal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.startTime !== 0) {
      writer.uint32(21).fixed32(message.startTime);
    }
    if (message.duration !== 0) {
      writer.uint32(24).uint32(message.duration);
    }
    if (message.gameMode !== 0) {
      writer.uint32(32).int32(message.gameMode);
    }
    for (const v of message.players) {
      CMsgDOTAMatchMinimal_Player.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.tourney !== undefined) {
      CMsgDOTAMatchMinimal_Tourney.encode(message.tourney, writer.uint32(58).fork()).join();
    }
    if (message.matchOutcome !== 0) {
      writer.uint32(64).int32(message.matchOutcome);
    }
    if (message.radiantScore !== 0) {
      writer.uint32(72).uint32(message.radiantScore);
    }
    if (message.direScore !== 0) {
      writer.uint32(80).uint32(message.direScore);
    }
    if (message.lobbyType !== 0) {
      writer.uint32(88).uint32(message.lobbyType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAMatchMinimal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatchMinimal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.matchId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.startTime = reader.fixed32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.duration = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gameMode = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.players.push(CMsgDOTAMatchMinimal_Player.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tourney = CMsgDOTAMatchMinimal_Tourney.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.matchOutcome = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.radiantScore = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.direScore = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.lobbyType = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatchMinimal {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      startTime: isSet(object.startTime) ? globalThis.Number(object.startTime) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      gameMode: isSet(object.gameMode) ? dOTAGameModeFromJSON(object.gameMode) : 0,
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgDOTAMatchMinimal_Player.fromJSON(e))
        : [],
      tourney: isSet(object.tourney) ? CMsgDOTAMatchMinimal_Tourney.fromJSON(object.tourney) : undefined,
      matchOutcome: isSet(object.matchOutcome) ? eMatchOutcomeFromJSON(object.matchOutcome) : 0,
      radiantScore: isSet(object.radiantScore) ? globalThis.Number(object.radiantScore) : 0,
      direScore: isSet(object.direScore) ? globalThis.Number(object.direScore) : 0,
      lobbyType: isSet(object.lobbyType) ? globalThis.Number(object.lobbyType) : 0,
    };
  },

  toJSON(message: CMsgDOTAMatchMinimal): unknown {
    const obj: any = {};
    if (message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.startTime !== 0) {
      obj.startTime = Math.round(message.startTime);
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.gameMode !== 0) {
      obj.gameMode = dOTAGameModeToJSON(message.gameMode);
    }
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgDOTAMatchMinimal_Player.toJSON(e));
    }
    if (message.tourney !== undefined) {
      obj.tourney = CMsgDOTAMatchMinimal_Tourney.toJSON(message.tourney);
    }
    if (message.matchOutcome !== 0) {
      obj.matchOutcome = eMatchOutcomeToJSON(message.matchOutcome);
    }
    if (message.radiantScore !== 0) {
      obj.radiantScore = Math.round(message.radiantScore);
    }
    if (message.direScore !== 0) {
      obj.direScore = Math.round(message.direScore);
    }
    if (message.lobbyType !== 0) {
      obj.lobbyType = Math.round(message.lobbyType);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatchMinimal>): CMsgDOTAMatchMinimal {
    return CMsgDOTAMatchMinimal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatchMinimal>): CMsgDOTAMatchMinimal {
    const message = createBaseCMsgDOTAMatchMinimal();
    message.matchId = object.matchId ?? "0";
    message.startTime = object.startTime ?? 0;
    message.duration = object.duration ?? 0;
    message.gameMode = object.gameMode ?? 0;
    message.players = object.players?.map((e) => CMsgDOTAMatchMinimal_Player.fromPartial(e)) || [];
    message.tourney = (object.tourney !== undefined && object.tourney !== null)
      ? CMsgDOTAMatchMinimal_Tourney.fromPartial(object.tourney)
      : undefined;
    message.matchOutcome = object.matchOutcome ?? 0;
    message.radiantScore = object.radiantScore ?? 0;
    message.direScore = object.direScore ?? 0;
    message.lobbyType = object.lobbyType ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAMatchMinimal_Player(): CMsgDOTAMatchMinimal_Player {
  return {
    accountId: 0,
    heroId: 0,
    kills: 0,
    deaths: 0,
    assists: 0,
    items: [],
    playerSlot: 0,
    proName: "",
    level: 0,
    teamNumber: 0,
  };
}

export const CMsgDOTAMatchMinimal_Player: MessageFns<CMsgDOTAMatchMinimal_Player> = {
  encode(message: CMsgDOTAMatchMinimal_Player, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.heroId !== 0) {
      writer.uint32(16).uint32(message.heroId);
    }
    if (message.kills !== 0) {
      writer.uint32(24).uint32(message.kills);
    }
    if (message.deaths !== 0) {
      writer.uint32(32).uint32(message.deaths);
    }
    if (message.assists !== 0) {
      writer.uint32(40).uint32(message.assists);
    }
    writer.uint32(50).fork();
    for (const v of message.items) {
      writer.int32(v);
    }
    writer.join();
    if (message.playerSlot !== 0) {
      writer.uint32(56).uint32(message.playerSlot);
    }
    if (message.proName !== "") {
      writer.uint32(66).string(message.proName);
    }
    if (message.level !== 0) {
      writer.uint32(72).uint32(message.level);
    }
    if (message.teamNumber !== 0) {
      writer.uint32(80).int32(message.teamNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAMatchMinimal_Player {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatchMinimal_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.assists = reader.uint32();
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.items.push(reader.int32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.items.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.playerSlot = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.proName = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.level = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.teamNumber = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatchMinimal_Player {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      assists: isSet(object.assists) ? globalThis.Number(object.assists) : 0,
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => globalThis.Number(e)) : [],
      playerSlot: isSet(object.playerSlot) ? globalThis.Number(object.playerSlot) : 0,
      proName: isSet(object.proName) ? globalThis.String(object.proName) : "",
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      teamNumber: isSet(object.teamNumber) ? dotaGcTeamFromJSON(object.teamNumber) : 0,
    };
  },

  toJSON(message: CMsgDOTAMatchMinimal_Player): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.assists !== 0) {
      obj.assists = Math.round(message.assists);
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => Math.round(e));
    }
    if (message.playerSlot !== 0) {
      obj.playerSlot = Math.round(message.playerSlot);
    }
    if (message.proName !== "") {
      obj.proName = message.proName;
    }
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.teamNumber !== 0) {
      obj.teamNumber = dotaGcTeamToJSON(message.teamNumber);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatchMinimal_Player>): CMsgDOTAMatchMinimal_Player {
    return CMsgDOTAMatchMinimal_Player.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatchMinimal_Player>): CMsgDOTAMatchMinimal_Player {
    const message = createBaseCMsgDOTAMatchMinimal_Player();
    message.accountId = object.accountId ?? 0;
    message.heroId = object.heroId ?? 0;
    message.kills = object.kills ?? 0;
    message.deaths = object.deaths ?? 0;
    message.assists = object.assists ?? 0;
    message.items = object.items?.map((e) => e) || [];
    message.playerSlot = object.playerSlot ?? 0;
    message.proName = object.proName ?? "";
    message.level = object.level ?? 0;
    message.teamNumber = object.teamNumber ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAMatchMinimal_Tourney(): CMsgDOTAMatchMinimal_Tourney {
  return {
    leagueId: 0,
    seriesType: 0,
    seriesGame: 0,
    weekendTourneyTournamentId: 0,
    weekendTourneySeasonTrophyId: 0,
    weekendTourneyDivision: 0,
    weekendTourneySkillLevel: 0,
    radiantTeamId: 0,
    radiantTeamName: "",
    radiantTeamLogo: "0",
    radiantTeamLogoUrl: "",
    direTeamId: 0,
    direTeamName: "",
    direTeamLogo: "0",
    direTeamLogoUrl: "",
  };
}

export const CMsgDOTAMatchMinimal_Tourney: MessageFns<CMsgDOTAMatchMinimal_Tourney> = {
  encode(message: CMsgDOTAMatchMinimal_Tourney, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leagueId !== 0) {
      writer.uint32(8).uint32(message.leagueId);
    }
    if (message.seriesType !== 0) {
      writer.uint32(64).uint32(message.seriesType);
    }
    if (message.seriesGame !== 0) {
      writer.uint32(72).uint32(message.seriesGame);
    }
    if (message.weekendTourneyTournamentId !== 0) {
      writer.uint32(80).uint32(message.weekendTourneyTournamentId);
    }
    if (message.weekendTourneySeasonTrophyId !== 0) {
      writer.uint32(88).uint32(message.weekendTourneySeasonTrophyId);
    }
    if (message.weekendTourneyDivision !== 0) {
      writer.uint32(96).uint32(message.weekendTourneyDivision);
    }
    if (message.weekendTourneySkillLevel !== 0) {
      writer.uint32(104).uint32(message.weekendTourneySkillLevel);
    }
    if (message.radiantTeamId !== 0) {
      writer.uint32(16).uint32(message.radiantTeamId);
    }
    if (message.radiantTeamName !== "") {
      writer.uint32(26).string(message.radiantTeamName);
    }
    if (message.radiantTeamLogo !== "0") {
      writer.uint32(33).fixed64(message.radiantTeamLogo);
    }
    if (message.radiantTeamLogoUrl !== "") {
      writer.uint32(114).string(message.radiantTeamLogoUrl);
    }
    if (message.direTeamId !== 0) {
      writer.uint32(40).uint32(message.direTeamId);
    }
    if (message.direTeamName !== "") {
      writer.uint32(50).string(message.direTeamName);
    }
    if (message.direTeamLogo !== "0") {
      writer.uint32(57).fixed64(message.direTeamLogo);
    }
    if (message.direTeamLogoUrl !== "") {
      writer.uint32(122).string(message.direTeamLogoUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTAMatchMinimal_Tourney {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatchMinimal_Tourney();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.seriesType = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.seriesGame = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.weekendTourneyTournamentId = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.weekendTourneySeasonTrophyId = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.weekendTourneyDivision = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.weekendTourneySkillLevel = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.radiantTeamId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.radiantTeamName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.radiantTeamLogo = reader.fixed64().toString();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.radiantTeamLogoUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.direTeamId = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.direTeamName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.direTeamLogo = reader.fixed64().toString();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.direTeamLogoUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatchMinimal_Tourney {
    return {
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      seriesType: isSet(object.seriesType) ? globalThis.Number(object.seriesType) : 0,
      seriesGame: isSet(object.seriesGame) ? globalThis.Number(object.seriesGame) : 0,
      weekendTourneyTournamentId: isSet(object.weekendTourneyTournamentId)
        ? globalThis.Number(object.weekendTourneyTournamentId)
        : 0,
      weekendTourneySeasonTrophyId: isSet(object.weekendTourneySeasonTrophyId)
        ? globalThis.Number(object.weekendTourneySeasonTrophyId)
        : 0,
      weekendTourneyDivision: isSet(object.weekendTourneyDivision)
        ? globalThis.Number(object.weekendTourneyDivision)
        : 0,
      weekendTourneySkillLevel: isSet(object.weekendTourneySkillLevel)
        ? globalThis.Number(object.weekendTourneySkillLevel)
        : 0,
      radiantTeamId: isSet(object.radiantTeamId) ? globalThis.Number(object.radiantTeamId) : 0,
      radiantTeamName: isSet(object.radiantTeamName) ? globalThis.String(object.radiantTeamName) : "",
      radiantTeamLogo: isSet(object.radiantTeamLogo) ? globalThis.String(object.radiantTeamLogo) : "0",
      radiantTeamLogoUrl: isSet(object.radiantTeamLogoUrl) ? globalThis.String(object.radiantTeamLogoUrl) : "",
      direTeamId: isSet(object.direTeamId) ? globalThis.Number(object.direTeamId) : 0,
      direTeamName: isSet(object.direTeamName) ? globalThis.String(object.direTeamName) : "",
      direTeamLogo: isSet(object.direTeamLogo) ? globalThis.String(object.direTeamLogo) : "0",
      direTeamLogoUrl: isSet(object.direTeamLogoUrl) ? globalThis.String(object.direTeamLogoUrl) : "",
    };
  },

  toJSON(message: CMsgDOTAMatchMinimal_Tourney): unknown {
    const obj: any = {};
    if (message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.seriesType !== 0) {
      obj.seriesType = Math.round(message.seriesType);
    }
    if (message.seriesGame !== 0) {
      obj.seriesGame = Math.round(message.seriesGame);
    }
    if (message.weekendTourneyTournamentId !== 0) {
      obj.weekendTourneyTournamentId = Math.round(message.weekendTourneyTournamentId);
    }
    if (message.weekendTourneySeasonTrophyId !== 0) {
      obj.weekendTourneySeasonTrophyId = Math.round(message.weekendTourneySeasonTrophyId);
    }
    if (message.weekendTourneyDivision !== 0) {
      obj.weekendTourneyDivision = Math.round(message.weekendTourneyDivision);
    }
    if (message.weekendTourneySkillLevel !== 0) {
      obj.weekendTourneySkillLevel = Math.round(message.weekendTourneySkillLevel);
    }
    if (message.radiantTeamId !== 0) {
      obj.radiantTeamId = Math.round(message.radiantTeamId);
    }
    if (message.radiantTeamName !== "") {
      obj.radiantTeamName = message.radiantTeamName;
    }
    if (message.radiantTeamLogo !== "0") {
      obj.radiantTeamLogo = message.radiantTeamLogo;
    }
    if (message.radiantTeamLogoUrl !== "") {
      obj.radiantTeamLogoUrl = message.radiantTeamLogoUrl;
    }
    if (message.direTeamId !== 0) {
      obj.direTeamId = Math.round(message.direTeamId);
    }
    if (message.direTeamName !== "") {
      obj.direTeamName = message.direTeamName;
    }
    if (message.direTeamLogo !== "0") {
      obj.direTeamLogo = message.direTeamLogo;
    }
    if (message.direTeamLogoUrl !== "") {
      obj.direTeamLogoUrl = message.direTeamLogoUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatchMinimal_Tourney>): CMsgDOTAMatchMinimal_Tourney {
    return CMsgDOTAMatchMinimal_Tourney.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatchMinimal_Tourney>): CMsgDOTAMatchMinimal_Tourney {
    const message = createBaseCMsgDOTAMatchMinimal_Tourney();
    message.leagueId = object.leagueId ?? 0;
    message.seriesType = object.seriesType ?? 0;
    message.seriesGame = object.seriesGame ?? 0;
    message.weekendTourneyTournamentId = object.weekendTourneyTournamentId ?? 0;
    message.weekendTourneySeasonTrophyId = object.weekendTourneySeasonTrophyId ?? 0;
    message.weekendTourneyDivision = object.weekendTourneyDivision ?? 0;
    message.weekendTourneySkillLevel = object.weekendTourneySkillLevel ?? 0;
    message.radiantTeamId = object.radiantTeamId ?? 0;
    message.radiantTeamName = object.radiantTeamName ?? "";
    message.radiantTeamLogo = object.radiantTeamLogo ?? "0";
    message.radiantTeamLogoUrl = object.radiantTeamLogoUrl ?? "";
    message.direTeamId = object.direTeamId ?? 0;
    message.direTeamName = object.direTeamName ?? "";
    message.direTeamLogo = object.direTeamLogo ?? "0";
    message.direTeamLogoUrl = object.direTeamLogoUrl ?? "";
    return message;
  },
};

function createBaseCMsgConsumableUsage(): CMsgConsumableUsage {
  return { itemDef: 0, quantityChange: 0 };
}

export const CMsgConsumableUsage: MessageFns<CMsgConsumableUsage> = {
  encode(message: CMsgConsumableUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.itemDef !== 0) {
      writer.uint32(8).uint32(message.itemDef);
    }
    if (message.quantityChange !== 0) {
      writer.uint32(16).int32(message.quantityChange);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgConsumableUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgConsumableUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.itemDef = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantityChange = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgConsumableUsage {
    return {
      itemDef: isSet(object.itemDef) ? globalThis.Number(object.itemDef) : 0,
      quantityChange: isSet(object.quantityChange) ? globalThis.Number(object.quantityChange) : 0,
    };
  },

  toJSON(message: CMsgConsumableUsage): unknown {
    const obj: any = {};
    if (message.itemDef !== 0) {
      obj.itemDef = Math.round(message.itemDef);
    }
    if (message.quantityChange !== 0) {
      obj.quantityChange = Math.round(message.quantityChange);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgConsumableUsage>): CMsgConsumableUsage {
    return CMsgConsumableUsage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgConsumableUsage>): CMsgConsumableUsage {
    const message = createBaseCMsgConsumableUsage();
    message.itemDef = object.itemDef ?? 0;
    message.quantityChange = object.quantityChange ?? 0;
    return message;
  },
};

function createBaseCMsgMatchConsumableUsage(): CMsgMatchConsumableUsage {
  return { playerConsumablesUsed: [] };
}

export const CMsgMatchConsumableUsage: MessageFns<CMsgMatchConsumableUsage> = {
  encode(message: CMsgMatchConsumableUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.playerConsumablesUsed) {
      CMsgMatchConsumableUsage_PlayerUsage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgMatchConsumableUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgMatchConsumableUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerConsumablesUsed.push(CMsgMatchConsumableUsage_PlayerUsage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgMatchConsumableUsage {
    return {
      playerConsumablesUsed: globalThis.Array.isArray(object?.playerConsumablesUsed)
        ? object.playerConsumablesUsed.map((e: any) => CMsgMatchConsumableUsage_PlayerUsage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgMatchConsumableUsage): unknown {
    const obj: any = {};
    if (message.playerConsumablesUsed?.length) {
      obj.playerConsumablesUsed = message.playerConsumablesUsed.map((e) =>
        CMsgMatchConsumableUsage_PlayerUsage.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgMatchConsumableUsage>): CMsgMatchConsumableUsage {
    return CMsgMatchConsumableUsage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgMatchConsumableUsage>): CMsgMatchConsumableUsage {
    const message = createBaseCMsgMatchConsumableUsage();
    message.playerConsumablesUsed =
      object.playerConsumablesUsed?.map((e) => CMsgMatchConsumableUsage_PlayerUsage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgMatchConsumableUsage_PlayerUsage(): CMsgMatchConsumableUsage_PlayerUsage {
  return { accountId: 0, consumablesUsed: [] };
}

export const CMsgMatchConsumableUsage_PlayerUsage: MessageFns<CMsgMatchConsumableUsage_PlayerUsage> = {
  encode(message: CMsgMatchConsumableUsage_PlayerUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    for (const v of message.consumablesUsed) {
      CMsgConsumableUsage.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgMatchConsumableUsage_PlayerUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgMatchConsumableUsage_PlayerUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.consumablesUsed.push(CMsgConsumableUsage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgMatchConsumableUsage_PlayerUsage {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      consumablesUsed: globalThis.Array.isArray(object?.consumablesUsed)
        ? object.consumablesUsed.map((e: any) => CMsgConsumableUsage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgMatchConsumableUsage_PlayerUsage): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.consumablesUsed?.length) {
      obj.consumablesUsed = message.consumablesUsed.map((e) => CMsgConsumableUsage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgMatchConsumableUsage_PlayerUsage>): CMsgMatchConsumableUsage_PlayerUsage {
    return CMsgMatchConsumableUsage_PlayerUsage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgMatchConsumableUsage_PlayerUsage>): CMsgMatchConsumableUsage_PlayerUsage {
    const message = createBaseCMsgMatchConsumableUsage_PlayerUsage();
    message.accountId = object.accountId ?? 0;
    message.consumablesUsed = object.consumablesUsed?.map((e) => CMsgConsumableUsage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgMatchEventActionGrants(): CMsgMatchEventActionGrants {
  return { playerGrants: [] };
}

export const CMsgMatchEventActionGrants: MessageFns<CMsgMatchEventActionGrants> = {
  encode(message: CMsgMatchEventActionGrants, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.playerGrants) {
      CMsgMatchEventActionGrants_PlayerGrants.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgMatchEventActionGrants {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgMatchEventActionGrants();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerGrants.push(CMsgMatchEventActionGrants_PlayerGrants.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgMatchEventActionGrants {
    return {
      playerGrants: globalThis.Array.isArray(object?.playerGrants)
        ? object.playerGrants.map((e: any) => CMsgMatchEventActionGrants_PlayerGrants.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgMatchEventActionGrants): unknown {
    const obj: any = {};
    if (message.playerGrants?.length) {
      obj.playerGrants = message.playerGrants.map((e) => CMsgMatchEventActionGrants_PlayerGrants.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgMatchEventActionGrants>): CMsgMatchEventActionGrants {
    return CMsgMatchEventActionGrants.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgMatchEventActionGrants>): CMsgMatchEventActionGrants {
    const message = createBaseCMsgMatchEventActionGrants();
    message.playerGrants = object.playerGrants?.map((e) => CMsgMatchEventActionGrants_PlayerGrants.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseCMsgMatchEventActionGrants_PlayerGrants(): CMsgMatchEventActionGrants_PlayerGrants {
  return { accountId: 0, actionsGranted: [] };
}

export const CMsgMatchEventActionGrants_PlayerGrants: MessageFns<CMsgMatchEventActionGrants_PlayerGrants> = {
  encode(message: CMsgMatchEventActionGrants_PlayerGrants, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    for (const v of message.actionsGranted) {
      CMsgPendingEventAward.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgMatchEventActionGrants_PlayerGrants {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgMatchEventActionGrants_PlayerGrants();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.actionsGranted.push(CMsgPendingEventAward.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgMatchEventActionGrants_PlayerGrants {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      actionsGranted: globalThis.Array.isArray(object?.actionsGranted)
        ? object.actionsGranted.map((e: any) => CMsgPendingEventAward.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgMatchEventActionGrants_PlayerGrants): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.actionsGranted?.length) {
      obj.actionsGranted = message.actionsGranted.map((e) => CMsgPendingEventAward.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgMatchEventActionGrants_PlayerGrants>): CMsgMatchEventActionGrants_PlayerGrants {
    return CMsgMatchEventActionGrants_PlayerGrants.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgMatchEventActionGrants_PlayerGrants>): CMsgMatchEventActionGrants_PlayerGrants {
    const message = createBaseCMsgMatchEventActionGrants_PlayerGrants();
    message.accountId = object.accountId ?? 0;
    message.actionsGranted = object.actionsGranted?.map((e) => CMsgPendingEventAward.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgCustomGameWhitelist(): CMsgCustomGameWhitelist {
  return { version: 0, customGamesWhitelist: [], disableWhitelist: false };
}

export const CMsgCustomGameWhitelist: MessageFns<CMsgCustomGameWhitelist> = {
  encode(message: CMsgCustomGameWhitelist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    writer.uint32(18).fork();
    for (const v of message.customGamesWhitelist) {
      writer.uint64(v);
    }
    writer.join();
    if (message.disableWhitelist !== false) {
      writer.uint32(24).bool(message.disableWhitelist);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgCustomGameWhitelist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgCustomGameWhitelist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.customGamesWhitelist.push(reader.uint64().toString());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.customGamesWhitelist.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.disableWhitelist = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgCustomGameWhitelist {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      customGamesWhitelist: globalThis.Array.isArray(object?.customGamesWhitelist)
        ? object.customGamesWhitelist.map((e: any) => globalThis.String(e))
        : [],
      disableWhitelist: isSet(object.disableWhitelist) ? globalThis.Boolean(object.disableWhitelist) : false,
    };
  },

  toJSON(message: CMsgCustomGameWhitelist): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.customGamesWhitelist?.length) {
      obj.customGamesWhitelist = message.customGamesWhitelist;
    }
    if (message.disableWhitelist !== false) {
      obj.disableWhitelist = message.disableWhitelist;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgCustomGameWhitelist>): CMsgCustomGameWhitelist {
    return CMsgCustomGameWhitelist.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgCustomGameWhitelist>): CMsgCustomGameWhitelist {
    const message = createBaseCMsgCustomGameWhitelist();
    message.version = object.version ?? 0;
    message.customGamesWhitelist = object.customGamesWhitelist?.map((e) => e) || [];
    message.disableWhitelist = object.disableWhitelist ?? false;
    return message;
  },
};

function createBaseCMsgCustomGameWhitelistForEdit(): CMsgCustomGameWhitelistForEdit {
  return { whitelistEntries: [] };
}

export const CMsgCustomGameWhitelistForEdit: MessageFns<CMsgCustomGameWhitelistForEdit> = {
  encode(message: CMsgCustomGameWhitelistForEdit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.whitelistEntries) {
      CMsgCustomGameWhitelistForEdit_WhitelistEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgCustomGameWhitelistForEdit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgCustomGameWhitelistForEdit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.whitelistEntries.push(CMsgCustomGameWhitelistForEdit_WhitelistEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgCustomGameWhitelistForEdit {
    return {
      whitelistEntries: globalThis.Array.isArray(object?.whitelistEntries)
        ? object.whitelistEntries.map((e: any) => CMsgCustomGameWhitelistForEdit_WhitelistEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgCustomGameWhitelistForEdit): unknown {
    const obj: any = {};
    if (message.whitelistEntries?.length) {
      obj.whitelistEntries = message.whitelistEntries.map((e) =>
        CMsgCustomGameWhitelistForEdit_WhitelistEntry.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgCustomGameWhitelistForEdit>): CMsgCustomGameWhitelistForEdit {
    return CMsgCustomGameWhitelistForEdit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgCustomGameWhitelistForEdit>): CMsgCustomGameWhitelistForEdit {
    const message = createBaseCMsgCustomGameWhitelistForEdit();
    message.whitelistEntries =
      object.whitelistEntries?.map((e) => CMsgCustomGameWhitelistForEdit_WhitelistEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgCustomGameWhitelistForEdit_WhitelistEntry(): CMsgCustomGameWhitelistForEdit_WhitelistEntry {
  return { customGameId: "0", whitelistState: 0 };
}

export const CMsgCustomGameWhitelistForEdit_WhitelistEntry: MessageFns<CMsgCustomGameWhitelistForEdit_WhitelistEntry> =
  {
    encode(
      message: CMsgCustomGameWhitelistForEdit_WhitelistEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.customGameId !== "0") {
        writer.uint32(8).uint64(message.customGameId);
      }
      if (message.whitelistState !== 0) {
        writer.uint32(16).int32(message.whitelistState);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): CMsgCustomGameWhitelistForEdit_WhitelistEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCMsgCustomGameWhitelistForEdit_WhitelistEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.customGameId = reader.uint64().toString();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.whitelistState = reader.int32() as any;
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CMsgCustomGameWhitelistForEdit_WhitelistEntry {
      return {
        customGameId: isSet(object.customGameId) ? globalThis.String(object.customGameId) : "0",
        whitelistState: isSet(object.whitelistState) ? eCustomGameWhitelistStateFromJSON(object.whitelistState) : 0,
      };
    },

    toJSON(message: CMsgCustomGameWhitelistForEdit_WhitelistEntry): unknown {
      const obj: any = {};
      if (message.customGameId !== "0") {
        obj.customGameId = message.customGameId;
      }
      if (message.whitelistState !== 0) {
        obj.whitelistState = eCustomGameWhitelistStateToJSON(message.whitelistState);
      }
      return obj;
    },

    create(
      base?: DeepPartial<CMsgCustomGameWhitelistForEdit_WhitelistEntry>,
    ): CMsgCustomGameWhitelistForEdit_WhitelistEntry {
      return CMsgCustomGameWhitelistForEdit_WhitelistEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<CMsgCustomGameWhitelistForEdit_WhitelistEntry>,
    ): CMsgCustomGameWhitelistForEdit_WhitelistEntry {
      const message = createBaseCMsgCustomGameWhitelistForEdit_WhitelistEntry();
      message.customGameId = object.customGameId ?? "0";
      message.whitelistState = object.whitelistState ?? 0;
      return message;
    },
  };

function createBaseCMsgPlayerRecentMatchInfo(): CMsgPlayerRecentMatchInfo {
  return { matchId: "0", timestamp: 0, duration: 0, win: false, heroId: 0, kills: 0, deaths: 0, assists: 0 };
}

export const CMsgPlayerRecentMatchInfo: MessageFns<CMsgPlayerRecentMatchInfo> = {
  encode(message: CMsgPlayerRecentMatchInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.timestamp !== 0) {
      writer.uint32(16).uint32(message.timestamp);
    }
    if (message.duration !== 0) {
      writer.uint32(24).uint32(message.duration);
    }
    if (message.win !== false) {
      writer.uint32(32).bool(message.win);
    }
    if (message.heroId !== 0) {
      writer.uint32(40).uint32(message.heroId);
    }
    if (message.kills !== 0) {
      writer.uint32(48).uint32(message.kills);
    }
    if (message.deaths !== 0) {
      writer.uint32(56).uint32(message.deaths);
    }
    if (message.assists !== 0) {
      writer.uint32(64).uint32(message.assists);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgPlayerRecentMatchInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerRecentMatchInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.matchId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.duration = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.win = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.assists = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPlayerRecentMatchInfo {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      win: isSet(object.win) ? globalThis.Boolean(object.win) : false,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      assists: isSet(object.assists) ? globalThis.Number(object.assists) : 0,
    };
  },

  toJSON(message: CMsgPlayerRecentMatchInfo): unknown {
    const obj: any = {};
    if (message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.win !== false) {
      obj.win = message.win;
    }
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.assists !== 0) {
      obj.assists = Math.round(message.assists);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPlayerRecentMatchInfo>): CMsgPlayerRecentMatchInfo {
    return CMsgPlayerRecentMatchInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPlayerRecentMatchInfo>): CMsgPlayerRecentMatchInfo {
    const message = createBaseCMsgPlayerRecentMatchInfo();
    message.matchId = object.matchId ?? "0";
    message.timestamp = object.timestamp ?? 0;
    message.duration = object.duration ?? 0;
    message.win = object.win ?? false;
    message.heroId = object.heroId ?? 0;
    message.kills = object.kills ?? 0;
    message.deaths = object.deaths ?? 0;
    message.assists = object.assists ?? 0;
    return message;
  },
};

function createBaseCMsgPlayerMatchRecord(): CMsgPlayerMatchRecord {
  return { wins: 0, losses: 0 };
}

export const CMsgPlayerMatchRecord: MessageFns<CMsgPlayerMatchRecord> = {
  encode(message: CMsgPlayerMatchRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.wins !== 0) {
      writer.uint32(8).uint32(message.wins);
    }
    if (message.losses !== 0) {
      writer.uint32(16).uint32(message.losses);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgPlayerMatchRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerMatchRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.wins = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.losses = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPlayerMatchRecord {
    return {
      wins: isSet(object.wins) ? globalThis.Number(object.wins) : 0,
      losses: isSet(object.losses) ? globalThis.Number(object.losses) : 0,
    };
  },

  toJSON(message: CMsgPlayerMatchRecord): unknown {
    const obj: any = {};
    if (message.wins !== 0) {
      obj.wins = Math.round(message.wins);
    }
    if (message.losses !== 0) {
      obj.losses = Math.round(message.losses);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPlayerMatchRecord>): CMsgPlayerMatchRecord {
    return CMsgPlayerMatchRecord.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPlayerMatchRecord>): CMsgPlayerMatchRecord {
    const message = createBaseCMsgPlayerMatchRecord();
    message.wins = object.wins ?? 0;
    message.losses = object.losses ?? 0;
    return message;
  },
};

function createBaseCMsgPlayerRecentMatchOutcomes(): CMsgPlayerRecentMatchOutcomes {
  return { outcomes: 0, matchCount: 0 };
}

export const CMsgPlayerRecentMatchOutcomes: MessageFns<CMsgPlayerRecentMatchOutcomes> = {
  encode(message: CMsgPlayerRecentMatchOutcomes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outcomes !== 0) {
      writer.uint32(8).uint32(message.outcomes);
    }
    if (message.matchCount !== 0) {
      writer.uint32(16).uint32(message.matchCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgPlayerRecentMatchOutcomes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerRecentMatchOutcomes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.outcomes = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.matchCount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPlayerRecentMatchOutcomes {
    return {
      outcomes: isSet(object.outcomes) ? globalThis.Number(object.outcomes) : 0,
      matchCount: isSet(object.matchCount) ? globalThis.Number(object.matchCount) : 0,
    };
  },

  toJSON(message: CMsgPlayerRecentMatchOutcomes): unknown {
    const obj: any = {};
    if (message.outcomes !== 0) {
      obj.outcomes = Math.round(message.outcomes);
    }
    if (message.matchCount !== 0) {
      obj.matchCount = Math.round(message.matchCount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPlayerRecentMatchOutcomes>): CMsgPlayerRecentMatchOutcomes {
    return CMsgPlayerRecentMatchOutcomes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPlayerRecentMatchOutcomes>): CMsgPlayerRecentMatchOutcomes {
    const message = createBaseCMsgPlayerRecentMatchOutcomes();
    message.outcomes = object.outcomes ?? 0;
    message.matchCount = object.matchCount ?? 0;
    return message;
  },
};

function createBaseCMsgPlayerRecentCommends(): CMsgPlayerRecentCommends {
  return { commends: 0, matchCount: 0 };
}

export const CMsgPlayerRecentCommends: MessageFns<CMsgPlayerRecentCommends> = {
  encode(message: CMsgPlayerRecentCommends, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commends !== 0) {
      writer.uint32(8).uint32(message.commends);
    }
    if (message.matchCount !== 0) {
      writer.uint32(16).uint32(message.matchCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgPlayerRecentCommends {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerRecentCommends();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.commends = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.matchCount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPlayerRecentCommends {
    return {
      commends: isSet(object.commends) ? globalThis.Number(object.commends) : 0,
      matchCount: isSet(object.matchCount) ? globalThis.Number(object.matchCount) : 0,
    };
  },

  toJSON(message: CMsgPlayerRecentCommends): unknown {
    const obj: any = {};
    if (message.commends !== 0) {
      obj.commends = Math.round(message.commends);
    }
    if (message.matchCount !== 0) {
      obj.matchCount = Math.round(message.matchCount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPlayerRecentCommends>): CMsgPlayerRecentCommends {
    return CMsgPlayerRecentCommends.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPlayerRecentCommends>): CMsgPlayerRecentCommends {
    const message = createBaseCMsgPlayerRecentCommends();
    message.commends = object.commends ?? 0;
    message.matchCount = object.matchCount ?? 0;
    return message;
  },
};

function createBaseCMsgPlayerRecentAccomplishments(): CMsgPlayerRecentAccomplishments {
  return {
    recentOutcomes: undefined,
    totalRecord: undefined,
    predictionStreak: 0,
    plusPredictionStreak: 0,
    recentCommends: undefined,
    firstMatchTimestamp: 0,
    lastMatch: undefined,
    recentMvps: undefined,
  };
}

export const CMsgPlayerRecentAccomplishments: MessageFns<CMsgPlayerRecentAccomplishments> = {
  encode(message: CMsgPlayerRecentAccomplishments, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recentOutcomes !== undefined) {
      CMsgPlayerRecentMatchOutcomes.encode(message.recentOutcomes, writer.uint32(10).fork()).join();
    }
    if (message.totalRecord !== undefined) {
      CMsgPlayerMatchRecord.encode(message.totalRecord, writer.uint32(18).fork()).join();
    }
    if (message.predictionStreak !== 0) {
      writer.uint32(24).uint32(message.predictionStreak);
    }
    if (message.plusPredictionStreak !== 0) {
      writer.uint32(32).uint32(message.plusPredictionStreak);
    }
    if (message.recentCommends !== undefined) {
      CMsgPlayerRecentCommends.encode(message.recentCommends, writer.uint32(42).fork()).join();
    }
    if (message.firstMatchTimestamp !== 0) {
      writer.uint32(48).uint32(message.firstMatchTimestamp);
    }
    if (message.lastMatch !== undefined) {
      CMsgPlayerRecentMatchInfo.encode(message.lastMatch, writer.uint32(58).fork()).join();
    }
    if (message.recentMvps !== undefined) {
      CMsgPlayerRecentMatchOutcomes.encode(message.recentMvps, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgPlayerRecentAccomplishments {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerRecentAccomplishments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recentOutcomes = CMsgPlayerRecentMatchOutcomes.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.totalRecord = CMsgPlayerMatchRecord.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.predictionStreak = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.plusPredictionStreak = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.recentCommends = CMsgPlayerRecentCommends.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.firstMatchTimestamp = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.lastMatch = CMsgPlayerRecentMatchInfo.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.recentMvps = CMsgPlayerRecentMatchOutcomes.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPlayerRecentAccomplishments {
    return {
      recentOutcomes: isSet(object.recentOutcomes)
        ? CMsgPlayerRecentMatchOutcomes.fromJSON(object.recentOutcomes)
        : undefined,
      totalRecord: isSet(object.totalRecord) ? CMsgPlayerMatchRecord.fromJSON(object.totalRecord) : undefined,
      predictionStreak: isSet(object.predictionStreak) ? globalThis.Number(object.predictionStreak) : 0,
      plusPredictionStreak: isSet(object.plusPredictionStreak) ? globalThis.Number(object.plusPredictionStreak) : 0,
      recentCommends: isSet(object.recentCommends)
        ? CMsgPlayerRecentCommends.fromJSON(object.recentCommends)
        : undefined,
      firstMatchTimestamp: isSet(object.firstMatchTimestamp) ? globalThis.Number(object.firstMatchTimestamp) : 0,
      lastMatch: isSet(object.lastMatch) ? CMsgPlayerRecentMatchInfo.fromJSON(object.lastMatch) : undefined,
      recentMvps: isSet(object.recentMvps) ? CMsgPlayerRecentMatchOutcomes.fromJSON(object.recentMvps) : undefined,
    };
  },

  toJSON(message: CMsgPlayerRecentAccomplishments): unknown {
    const obj: any = {};
    if (message.recentOutcomes !== undefined) {
      obj.recentOutcomes = CMsgPlayerRecentMatchOutcomes.toJSON(message.recentOutcomes);
    }
    if (message.totalRecord !== undefined) {
      obj.totalRecord = CMsgPlayerMatchRecord.toJSON(message.totalRecord);
    }
    if (message.predictionStreak !== 0) {
      obj.predictionStreak = Math.round(message.predictionStreak);
    }
    if (message.plusPredictionStreak !== 0) {
      obj.plusPredictionStreak = Math.round(message.plusPredictionStreak);
    }
    if (message.recentCommends !== undefined) {
      obj.recentCommends = CMsgPlayerRecentCommends.toJSON(message.recentCommends);
    }
    if (message.firstMatchTimestamp !== 0) {
      obj.firstMatchTimestamp = Math.round(message.firstMatchTimestamp);
    }
    if (message.lastMatch !== undefined) {
      obj.lastMatch = CMsgPlayerRecentMatchInfo.toJSON(message.lastMatch);
    }
    if (message.recentMvps !== undefined) {
      obj.recentMvps = CMsgPlayerRecentMatchOutcomes.toJSON(message.recentMvps);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPlayerRecentAccomplishments>): CMsgPlayerRecentAccomplishments {
    return CMsgPlayerRecentAccomplishments.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPlayerRecentAccomplishments>): CMsgPlayerRecentAccomplishments {
    const message = createBaseCMsgPlayerRecentAccomplishments();
    message.recentOutcomes = (object.recentOutcomes !== undefined && object.recentOutcomes !== null)
      ? CMsgPlayerRecentMatchOutcomes.fromPartial(object.recentOutcomes)
      : undefined;
    message.totalRecord = (object.totalRecord !== undefined && object.totalRecord !== null)
      ? CMsgPlayerMatchRecord.fromPartial(object.totalRecord)
      : undefined;
    message.predictionStreak = object.predictionStreak ?? 0;
    message.plusPredictionStreak = object.plusPredictionStreak ?? 0;
    message.recentCommends = (object.recentCommends !== undefined && object.recentCommends !== null)
      ? CMsgPlayerRecentCommends.fromPartial(object.recentCommends)
      : undefined;
    message.firstMatchTimestamp = object.firstMatchTimestamp ?? 0;
    message.lastMatch = (object.lastMatch !== undefined && object.lastMatch !== null)
      ? CMsgPlayerRecentMatchInfo.fromPartial(object.lastMatch)
      : undefined;
    message.recentMvps = (object.recentMvps !== undefined && object.recentMvps !== null)
      ? CMsgPlayerRecentMatchOutcomes.fromPartial(object.recentMvps)
      : undefined;
    return message;
  },
};

function createBaseCMsgPlayerHeroRecentAccomplishments(): CMsgPlayerHeroRecentAccomplishments {
  return { recentOutcomes: undefined, totalRecord: undefined, lastMatch: undefined };
}

export const CMsgPlayerHeroRecentAccomplishments: MessageFns<CMsgPlayerHeroRecentAccomplishments> = {
  encode(message: CMsgPlayerHeroRecentAccomplishments, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recentOutcomes !== undefined) {
      CMsgPlayerRecentMatchOutcomes.encode(message.recentOutcomes, writer.uint32(10).fork()).join();
    }
    if (message.totalRecord !== undefined) {
      CMsgPlayerMatchRecord.encode(message.totalRecord, writer.uint32(18).fork()).join();
    }
    if (message.lastMatch !== undefined) {
      CMsgPlayerRecentMatchInfo.encode(message.lastMatch, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgPlayerHeroRecentAccomplishments {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerHeroRecentAccomplishments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recentOutcomes = CMsgPlayerRecentMatchOutcomes.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.totalRecord = CMsgPlayerMatchRecord.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastMatch = CMsgPlayerRecentMatchInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPlayerHeroRecentAccomplishments {
    return {
      recentOutcomes: isSet(object.recentOutcomes)
        ? CMsgPlayerRecentMatchOutcomes.fromJSON(object.recentOutcomes)
        : undefined,
      totalRecord: isSet(object.totalRecord) ? CMsgPlayerMatchRecord.fromJSON(object.totalRecord) : undefined,
      lastMatch: isSet(object.lastMatch) ? CMsgPlayerRecentMatchInfo.fromJSON(object.lastMatch) : undefined,
    };
  },

  toJSON(message: CMsgPlayerHeroRecentAccomplishments): unknown {
    const obj: any = {};
    if (message.recentOutcomes !== undefined) {
      obj.recentOutcomes = CMsgPlayerRecentMatchOutcomes.toJSON(message.recentOutcomes);
    }
    if (message.totalRecord !== undefined) {
      obj.totalRecord = CMsgPlayerMatchRecord.toJSON(message.totalRecord);
    }
    if (message.lastMatch !== undefined) {
      obj.lastMatch = CMsgPlayerRecentMatchInfo.toJSON(message.lastMatch);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPlayerHeroRecentAccomplishments>): CMsgPlayerHeroRecentAccomplishments {
    return CMsgPlayerHeroRecentAccomplishments.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPlayerHeroRecentAccomplishments>): CMsgPlayerHeroRecentAccomplishments {
    const message = createBaseCMsgPlayerHeroRecentAccomplishments();
    message.recentOutcomes = (object.recentOutcomes !== undefined && object.recentOutcomes !== null)
      ? CMsgPlayerRecentMatchOutcomes.fromPartial(object.recentOutcomes)
      : undefined;
    message.totalRecord = (object.totalRecord !== undefined && object.totalRecord !== null)
      ? CMsgPlayerMatchRecord.fromPartial(object.totalRecord)
      : undefined;
    message.lastMatch = (object.lastMatch !== undefined && object.lastMatch !== null)
      ? CMsgPlayerRecentMatchInfo.fromPartial(object.lastMatch)
      : undefined;
    return message;
  },
};

function createBaseCMsgRecentAccomplishments(): CMsgRecentAccomplishments {
  return { playerAccomplishments: undefined, heroAccomplishments: undefined };
}

export const CMsgRecentAccomplishments: MessageFns<CMsgRecentAccomplishments> = {
  encode(message: CMsgRecentAccomplishments, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerAccomplishments !== undefined) {
      CMsgPlayerRecentAccomplishments.encode(message.playerAccomplishments, writer.uint32(10).fork()).join();
    }
    if (message.heroAccomplishments !== undefined) {
      CMsgPlayerHeroRecentAccomplishments.encode(message.heroAccomplishments, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgRecentAccomplishments {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgRecentAccomplishments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerAccomplishments = CMsgPlayerRecentAccomplishments.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.heroAccomplishments = CMsgPlayerHeroRecentAccomplishments.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgRecentAccomplishments {
    return {
      playerAccomplishments: isSet(object.playerAccomplishments)
        ? CMsgPlayerRecentAccomplishments.fromJSON(object.playerAccomplishments)
        : undefined,
      heroAccomplishments: isSet(object.heroAccomplishments)
        ? CMsgPlayerHeroRecentAccomplishments.fromJSON(object.heroAccomplishments)
        : undefined,
    };
  },

  toJSON(message: CMsgRecentAccomplishments): unknown {
    const obj: any = {};
    if (message.playerAccomplishments !== undefined) {
      obj.playerAccomplishments = CMsgPlayerRecentAccomplishments.toJSON(message.playerAccomplishments);
    }
    if (message.heroAccomplishments !== undefined) {
      obj.heroAccomplishments = CMsgPlayerHeroRecentAccomplishments.toJSON(message.heroAccomplishments);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgRecentAccomplishments>): CMsgRecentAccomplishments {
    return CMsgRecentAccomplishments.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgRecentAccomplishments>): CMsgRecentAccomplishments {
    const message = createBaseCMsgRecentAccomplishments();
    message.playerAccomplishments =
      (object.playerAccomplishments !== undefined && object.playerAccomplishments !== null)
        ? CMsgPlayerRecentAccomplishments.fromPartial(object.playerAccomplishments)
        : undefined;
    message.heroAccomplishments = (object.heroAccomplishments !== undefined && object.heroAccomplishments !== null)
      ? CMsgPlayerHeroRecentAccomplishments.fromPartial(object.heroAccomplishments)
      : undefined;
    return message;
  },
};

function createBaseCMsgServerToGCRequestPlayerRecentAccomplishments(): CMsgServerToGCRequestPlayerRecentAccomplishments {
  return { accountId: 0, heroId: 0 };
}

export const CMsgServerToGCRequestPlayerRecentAccomplishments: MessageFns<
  CMsgServerToGCRequestPlayerRecentAccomplishments
> = {
  encode(
    message: CMsgServerToGCRequestPlayerRecentAccomplishments,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.heroId !== 0) {
      writer.uint32(16).uint32(message.heroId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgServerToGCRequestPlayerRecentAccomplishments {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCRequestPlayerRecentAccomplishments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCRequestPlayerRecentAccomplishments {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
    };
  },

  toJSON(message: CMsgServerToGCRequestPlayerRecentAccomplishments): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCRequestPlayerRecentAccomplishments>,
  ): CMsgServerToGCRequestPlayerRecentAccomplishments {
    return CMsgServerToGCRequestPlayerRecentAccomplishments.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCRequestPlayerRecentAccomplishments>,
  ): CMsgServerToGCRequestPlayerRecentAccomplishments {
    const message = createBaseCMsgServerToGCRequestPlayerRecentAccomplishments();
    message.accountId = object.accountId ?? 0;
    message.heroId = object.heroId ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCRequestPlayerRecentAccomplishmentsResponse(): CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
  return { result: 0, playerAccomplishments: undefined };
}

export const CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse: MessageFns<
  CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse
> = {
  encode(
    message: CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.playerAccomplishments !== undefined) {
      CMsgRecentAccomplishments.encode(message.playerAccomplishments, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCRequestPlayerRecentAccomplishmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playerAccomplishments = CMsgRecentAccomplishments.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    return {
      result: isSet(object.result)
        ? cMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponseFromJSON(object.result)
        : 0,
      playerAccomplishments: isSet(object.playerAccomplishments)
        ? CMsgRecentAccomplishments.fromJSON(object.playerAccomplishments)
        : undefined,
    };
  },

  toJSON(message: CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse): unknown {
    const obj: any = {};
    if (message.result !== 0) {
      obj.result = cMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponseToJSON(message.result);
    }
    if (message.playerAccomplishments !== undefined) {
      obj.playerAccomplishments = CMsgRecentAccomplishments.toJSON(message.playerAccomplishments);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse>,
  ): CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    return CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse>,
  ): CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    const message = createBaseCMsgServerToGCRequestPlayerRecentAccomplishmentsResponse();
    message.result = object.result ?? 0;
    message.playerAccomplishments =
      (object.playerAccomplishments !== undefined && object.playerAccomplishments !== null)
        ? CMsgRecentAccomplishments.fromPartial(object.playerAccomplishments)
        : undefined;
    return message;
  },
};

function createBaseCMsgArcanaVoteMatchVotes(): CMsgArcanaVoteMatchVotes {
  return { matchId: 0, heroId: 0, voteCount: 0 };
}

export const CMsgArcanaVoteMatchVotes: MessageFns<CMsgArcanaVoteMatchVotes> = {
  encode(message: CMsgArcanaVoteMatchVotes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matchId !== 0) {
      writer.uint32(8).uint32(message.matchId);
    }
    if (message.heroId !== 0) {
      writer.uint32(16).uint32(message.heroId);
    }
    if (message.voteCount !== 0) {
      writer.uint32(24).uint32(message.voteCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgArcanaVoteMatchVotes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgArcanaVoteMatchVotes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.matchId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.voteCount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgArcanaVoteMatchVotes {
    return {
      matchId: isSet(object.matchId) ? globalThis.Number(object.matchId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      voteCount: isSet(object.voteCount) ? globalThis.Number(object.voteCount) : 0,
    };
  },

  toJSON(message: CMsgArcanaVoteMatchVotes): unknown {
    const obj: any = {};
    if (message.matchId !== 0) {
      obj.matchId = Math.round(message.matchId);
    }
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.voteCount !== 0) {
      obj.voteCount = Math.round(message.voteCount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgArcanaVoteMatchVotes>): CMsgArcanaVoteMatchVotes {
    return CMsgArcanaVoteMatchVotes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgArcanaVoteMatchVotes>): CMsgArcanaVoteMatchVotes {
    const message = createBaseCMsgArcanaVoteMatchVotes();
    message.matchId = object.matchId ?? 0;
    message.heroId = object.heroId ?? 0;
    message.voteCount = object.voteCount ?? 0;
    return message;
  },
};

function createBaseCMsgGCtoGCAssociatedExploiterAccountInfo(): CMsgGCtoGCAssociatedExploiterAccountInfo {
  return { accountId: 0, numMatchesToSearch: 0, minSharedMatchCount: 0, numAdditionalPlayers: 0 };
}

export const CMsgGCtoGCAssociatedExploiterAccountInfo: MessageFns<CMsgGCtoGCAssociatedExploiterAccountInfo> = {
  encode(message: CMsgGCtoGCAssociatedExploiterAccountInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.numMatchesToSearch !== 0) {
      writer.uint32(16).uint32(message.numMatchesToSearch);
    }
    if (message.minSharedMatchCount !== 0) {
      writer.uint32(24).uint32(message.minSharedMatchCount);
    }
    if (message.numAdditionalPlayers !== 0) {
      writer.uint32(32).uint32(message.numAdditionalPlayers);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCtoGCAssociatedExploiterAccountInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCtoGCAssociatedExploiterAccountInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.numMatchesToSearch = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.minSharedMatchCount = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.numAdditionalPlayers = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCtoGCAssociatedExploiterAccountInfo {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      numMatchesToSearch: isSet(object.numMatchesToSearch) ? globalThis.Number(object.numMatchesToSearch) : 0,
      minSharedMatchCount: isSet(object.minSharedMatchCount) ? globalThis.Number(object.minSharedMatchCount) : 0,
      numAdditionalPlayers: isSet(object.numAdditionalPlayers) ? globalThis.Number(object.numAdditionalPlayers) : 0,
    };
  },

  toJSON(message: CMsgGCtoGCAssociatedExploiterAccountInfo): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.numMatchesToSearch !== 0) {
      obj.numMatchesToSearch = Math.round(message.numMatchesToSearch);
    }
    if (message.minSharedMatchCount !== 0) {
      obj.minSharedMatchCount = Math.round(message.minSharedMatchCount);
    }
    if (message.numAdditionalPlayers !== 0) {
      obj.numAdditionalPlayers = Math.round(message.numAdditionalPlayers);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCtoGCAssociatedExploiterAccountInfo>): CMsgGCtoGCAssociatedExploiterAccountInfo {
    return CMsgGCtoGCAssociatedExploiterAccountInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCtoGCAssociatedExploiterAccountInfo>): CMsgGCtoGCAssociatedExploiterAccountInfo {
    const message = createBaseCMsgGCtoGCAssociatedExploiterAccountInfo();
    message.accountId = object.accountId ?? 0;
    message.numMatchesToSearch = object.numMatchesToSearch ?? 0;
    message.minSharedMatchCount = object.minSharedMatchCount ?? 0;
    message.numAdditionalPlayers = object.numAdditionalPlayers ?? 0;
    return message;
  },
};

function createBaseCMsgGCtoGCAssociatedExploiterAccountInfoResponse(): CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
  return { accounts: [] };
}

export const CMsgGCtoGCAssociatedExploiterAccountInfoResponse: MessageFns<
  CMsgGCtoGCAssociatedExploiterAccountInfoResponse
> = {
  encode(
    message: CMsgGCtoGCAssociatedExploiterAccountInfoResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.accounts) {
      CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCtoGCAssociatedExploiterAccountInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accounts.push(
            CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    return {
      accounts: globalThis.Array.isArray(object?.accounts)
        ? object.accounts.map((e: any) => CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCtoGCAssociatedExploiterAccountInfoResponse): unknown {
    const obj: any = {};
    if (message.accounts?.length) {
      obj.accounts = message.accounts.map((e) => CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgGCtoGCAssociatedExploiterAccountInfoResponse>,
  ): CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    return CMsgGCtoGCAssociatedExploiterAccountInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGCtoGCAssociatedExploiterAccountInfoResponse>,
  ): CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    const message = createBaseCMsgGCtoGCAssociatedExploiterAccountInfoResponse();
    message.accounts =
      object.accounts?.map((e) => CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account(): CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account {
  return {
    accountId: 0,
    numCommonMatches: 0,
    earliestCommonMatch: 0,
    latestCommonMatch: 0,
    generation: 0,
    persona: "",
    alreadyBanned: false,
  };
}

export const CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account: MessageFns<
  CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account
> = {
  encode(
    message: CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.numCommonMatches !== 0) {
      writer.uint32(16).uint32(message.numCommonMatches);
    }
    if (message.earliestCommonMatch !== 0) {
      writer.uint32(24).uint32(message.earliestCommonMatch);
    }
    if (message.latestCommonMatch !== 0) {
      writer.uint32(32).uint32(message.latestCommonMatch);
    }
    if (message.generation !== 0) {
      writer.uint32(40).uint32(message.generation);
    }
    if (message.persona !== "") {
      writer.uint32(50).string(message.persona);
    }
    if (message.alreadyBanned !== false) {
      writer.uint32(56).bool(message.alreadyBanned);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.numCommonMatches = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.earliestCommonMatch = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.latestCommonMatch = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.generation = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.persona = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.alreadyBanned = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      numCommonMatches: isSet(object.numCommonMatches) ? globalThis.Number(object.numCommonMatches) : 0,
      earliestCommonMatch: isSet(object.earliestCommonMatch) ? globalThis.Number(object.earliestCommonMatch) : 0,
      latestCommonMatch: isSet(object.latestCommonMatch) ? globalThis.Number(object.latestCommonMatch) : 0,
      generation: isSet(object.generation) ? globalThis.Number(object.generation) : 0,
      persona: isSet(object.persona) ? globalThis.String(object.persona) : "",
      alreadyBanned: isSet(object.alreadyBanned) ? globalThis.Boolean(object.alreadyBanned) : false,
    };
  },

  toJSON(message: CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.numCommonMatches !== 0) {
      obj.numCommonMatches = Math.round(message.numCommonMatches);
    }
    if (message.earliestCommonMatch !== 0) {
      obj.earliestCommonMatch = Math.round(message.earliestCommonMatch);
    }
    if (message.latestCommonMatch !== 0) {
      obj.latestCommonMatch = Math.round(message.latestCommonMatch);
    }
    if (message.generation !== 0) {
      obj.generation = Math.round(message.generation);
    }
    if (message.persona !== "") {
      obj.persona = message.persona;
    }
    if (message.alreadyBanned !== false) {
      obj.alreadyBanned = message.alreadyBanned;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account>,
  ): CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account {
    return CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account>,
  ): CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account {
    const message = createBaseCMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account();
    message.accountId = object.accountId ?? 0;
    message.numCommonMatches = object.numCommonMatches ?? 0;
    message.earliestCommonMatch = object.earliestCommonMatch ?? 0;
    message.latestCommonMatch = object.latestCommonMatch ?? 0;
    message.generation = object.generation ?? 0;
    message.persona = object.persona ?? "";
    message.alreadyBanned = object.alreadyBanned ?? false;
    return message;
  },
};

function createBaseCMsgPullTabsData(): CMsgPullTabsData {
  return { slots: [], jackpots: [], lastBoard: 0 };
}

export const CMsgPullTabsData: MessageFns<CMsgPullTabsData> = {
  encode(message: CMsgPullTabsData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.slots) {
      CMsgPullTabsData_Slot.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.jackpots) {
      CMsgPullTabsData_Jackpot.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.lastBoard !== 0) {
      writer.uint32(24).uint32(message.lastBoard);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgPullTabsData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPullTabsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.slots.push(CMsgPullTabsData_Slot.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.jackpots.push(CMsgPullTabsData_Jackpot.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lastBoard = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPullTabsData {
    return {
      slots: globalThis.Array.isArray(object?.slots)
        ? object.slots.map((e: any) => CMsgPullTabsData_Slot.fromJSON(e))
        : [],
      jackpots: globalThis.Array.isArray(object?.jackpots)
        ? object.jackpots.map((e: any) => CMsgPullTabsData_Jackpot.fromJSON(e))
        : [],
      lastBoard: isSet(object.lastBoard) ? globalThis.Number(object.lastBoard) : 0,
    };
  },

  toJSON(message: CMsgPullTabsData): unknown {
    const obj: any = {};
    if (message.slots?.length) {
      obj.slots = message.slots.map((e) => CMsgPullTabsData_Slot.toJSON(e));
    }
    if (message.jackpots?.length) {
      obj.jackpots = message.jackpots.map((e) => CMsgPullTabsData_Jackpot.toJSON(e));
    }
    if (message.lastBoard !== 0) {
      obj.lastBoard = Math.round(message.lastBoard);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPullTabsData>): CMsgPullTabsData {
    return CMsgPullTabsData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPullTabsData>): CMsgPullTabsData {
    const message = createBaseCMsgPullTabsData();
    message.slots = object.slots?.map((e) => CMsgPullTabsData_Slot.fromPartial(e)) || [];
    message.jackpots = object.jackpots?.map((e) => CMsgPullTabsData_Jackpot.fromPartial(e)) || [];
    message.lastBoard = object.lastBoard ?? 0;
    return message;
  },
};

function createBaseCMsgPullTabsData_Slot(): CMsgPullTabsData_Slot {
  return { eventId: 0, boardId: 0, heroId: 0, actionId: 0, redeemed: false };
}

export const CMsgPullTabsData_Slot: MessageFns<CMsgPullTabsData_Slot> = {
  encode(message: CMsgPullTabsData_Slot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    if (message.boardId !== 0) {
      writer.uint32(16).uint32(message.boardId);
    }
    if (message.heroId !== 0) {
      writer.uint32(24).uint32(message.heroId);
    }
    if (message.actionId !== 0) {
      writer.uint32(32).uint32(message.actionId);
    }
    if (message.redeemed !== false) {
      writer.uint32(40).bool(message.redeemed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgPullTabsData_Slot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPullTabsData_Slot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.boardId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.actionId = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.redeemed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPullTabsData_Slot {
    return {
      eventId: isSet(object.eventId) ? globalThis.Number(object.eventId) : 0,
      boardId: isSet(object.boardId) ? globalThis.Number(object.boardId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      actionId: isSet(object.actionId) ? globalThis.Number(object.actionId) : 0,
      redeemed: isSet(object.redeemed) ? globalThis.Boolean(object.redeemed) : false,
    };
  },

  toJSON(message: CMsgPullTabsData_Slot): unknown {
    const obj: any = {};
    if (message.eventId !== 0) {
      obj.eventId = Math.round(message.eventId);
    }
    if (message.boardId !== 0) {
      obj.boardId = Math.round(message.boardId);
    }
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.actionId !== 0) {
      obj.actionId = Math.round(message.actionId);
    }
    if (message.redeemed !== false) {
      obj.redeemed = message.redeemed;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPullTabsData_Slot>): CMsgPullTabsData_Slot {
    return CMsgPullTabsData_Slot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPullTabsData_Slot>): CMsgPullTabsData_Slot {
    const message = createBaseCMsgPullTabsData_Slot();
    message.eventId = object.eventId ?? 0;
    message.boardId = object.boardId ?? 0;
    message.heroId = object.heroId ?? 0;
    message.actionId = object.actionId ?? 0;
    message.redeemed = object.redeemed ?? false;
    return message;
  },
};

function createBaseCMsgPullTabsData_Jackpot(): CMsgPullTabsData_Jackpot {
  return { boardId: 0, actionId: 0, heroId: 0 };
}

export const CMsgPullTabsData_Jackpot: MessageFns<CMsgPullTabsData_Jackpot> = {
  encode(message: CMsgPullTabsData_Jackpot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.boardId !== 0) {
      writer.uint32(8).uint32(message.boardId);
    }
    if (message.actionId !== 0) {
      writer.uint32(16).uint32(message.actionId);
    }
    if (message.heroId !== 0) {
      writer.uint32(24).uint32(message.heroId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgPullTabsData_Jackpot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPullTabsData_Jackpot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.boardId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.actionId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPullTabsData_Jackpot {
    return {
      boardId: isSet(object.boardId) ? globalThis.Number(object.boardId) : 0,
      actionId: isSet(object.actionId) ? globalThis.Number(object.actionId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
    };
  },

  toJSON(message: CMsgPullTabsData_Jackpot): unknown {
    const obj: any = {};
    if (message.boardId !== 0) {
      obj.boardId = Math.round(message.boardId);
    }
    if (message.actionId !== 0) {
      obj.actionId = Math.round(message.actionId);
    }
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPullTabsData_Jackpot>): CMsgPullTabsData_Jackpot {
    return CMsgPullTabsData_Jackpot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPullTabsData_Jackpot>): CMsgPullTabsData_Jackpot {
    const message = createBaseCMsgPullTabsData_Jackpot();
    message.boardId = object.boardId ?? 0;
    message.actionId = object.actionId ?? 0;
    message.heroId = object.heroId ?? 0;
    return message;
  },
};

function createBaseCMsgUnderDraftData(): CMsgUnderDraftData {
  return { benchSlots: [], shopSlots: [], gold: 0, totalGold: 0, notRestorable: false };
}

export const CMsgUnderDraftData: MessageFns<CMsgUnderDraftData> = {
  encode(message: CMsgUnderDraftData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.benchSlots) {
      CMsgUnderDraftData_BenchSlot.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.shopSlots) {
      CMsgUnderDraftData_ShopSlot.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.gold !== 0) {
      writer.uint32(24).uint32(message.gold);
    }
    if (message.totalGold !== 0) {
      writer.uint32(32).uint32(message.totalGold);
    }
    if (message.notRestorable !== false) {
      writer.uint32(40).bool(message.notRestorable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgUnderDraftData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgUnderDraftData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.benchSlots.push(CMsgUnderDraftData_BenchSlot.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.shopSlots.push(CMsgUnderDraftData_ShopSlot.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.gold = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalGold = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.notRestorable = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgUnderDraftData {
    return {
      benchSlots: globalThis.Array.isArray(object?.benchSlots)
        ? object.benchSlots.map((e: any) => CMsgUnderDraftData_BenchSlot.fromJSON(e))
        : [],
      shopSlots: globalThis.Array.isArray(object?.shopSlots)
        ? object.shopSlots.map((e: any) => CMsgUnderDraftData_ShopSlot.fromJSON(e))
        : [],
      gold: isSet(object.gold) ? globalThis.Number(object.gold) : 0,
      totalGold: isSet(object.totalGold) ? globalThis.Number(object.totalGold) : 0,
      notRestorable: isSet(object.notRestorable) ? globalThis.Boolean(object.notRestorable) : false,
    };
  },

  toJSON(message: CMsgUnderDraftData): unknown {
    const obj: any = {};
    if (message.benchSlots?.length) {
      obj.benchSlots = message.benchSlots.map((e) => CMsgUnderDraftData_BenchSlot.toJSON(e));
    }
    if (message.shopSlots?.length) {
      obj.shopSlots = message.shopSlots.map((e) => CMsgUnderDraftData_ShopSlot.toJSON(e));
    }
    if (message.gold !== 0) {
      obj.gold = Math.round(message.gold);
    }
    if (message.totalGold !== 0) {
      obj.totalGold = Math.round(message.totalGold);
    }
    if (message.notRestorable !== false) {
      obj.notRestorable = message.notRestorable;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgUnderDraftData>): CMsgUnderDraftData {
    return CMsgUnderDraftData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgUnderDraftData>): CMsgUnderDraftData {
    const message = createBaseCMsgUnderDraftData();
    message.benchSlots = object.benchSlots?.map((e) => CMsgUnderDraftData_BenchSlot.fromPartial(e)) || [];
    message.shopSlots = object.shopSlots?.map((e) => CMsgUnderDraftData_ShopSlot.fromPartial(e)) || [];
    message.gold = object.gold ?? 0;
    message.totalGold = object.totalGold ?? 0;
    message.notRestorable = object.notRestorable ?? false;
    return message;
  },
};

function createBaseCMsgUnderDraftData_BenchSlot(): CMsgUnderDraftData_BenchSlot {
  return { slotId: 0, heroId: 0, stars: 0 };
}

export const CMsgUnderDraftData_BenchSlot: MessageFns<CMsgUnderDraftData_BenchSlot> = {
  encode(message: CMsgUnderDraftData_BenchSlot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.slotId !== 0) {
      writer.uint32(8).uint32(message.slotId);
    }
    if (message.heroId !== 0) {
      writer.uint32(16).uint32(message.heroId);
    }
    if (message.stars !== 0) {
      writer.uint32(24).uint32(message.stars);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgUnderDraftData_BenchSlot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgUnderDraftData_BenchSlot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.slotId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.stars = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgUnderDraftData_BenchSlot {
    return {
      slotId: isSet(object.slotId) ? globalThis.Number(object.slotId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      stars: isSet(object.stars) ? globalThis.Number(object.stars) : 0,
    };
  },

  toJSON(message: CMsgUnderDraftData_BenchSlot): unknown {
    const obj: any = {};
    if (message.slotId !== 0) {
      obj.slotId = Math.round(message.slotId);
    }
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.stars !== 0) {
      obj.stars = Math.round(message.stars);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgUnderDraftData_BenchSlot>): CMsgUnderDraftData_BenchSlot {
    return CMsgUnderDraftData_BenchSlot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgUnderDraftData_BenchSlot>): CMsgUnderDraftData_BenchSlot {
    const message = createBaseCMsgUnderDraftData_BenchSlot();
    message.slotId = object.slotId ?? 0;
    message.heroId = object.heroId ?? 0;
    message.stars = object.stars ?? 0;
    return message;
  },
};

function createBaseCMsgUnderDraftData_ShopSlot(): CMsgUnderDraftData_ShopSlot {
  return { slotId: 0, heroId: 0, isSpecialReward: false };
}

export const CMsgUnderDraftData_ShopSlot: MessageFns<CMsgUnderDraftData_ShopSlot> = {
  encode(message: CMsgUnderDraftData_ShopSlot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.slotId !== 0) {
      writer.uint32(8).uint32(message.slotId);
    }
    if (message.heroId !== 0) {
      writer.uint32(16).uint32(message.heroId);
    }
    if (message.isSpecialReward !== false) {
      writer.uint32(24).bool(message.isSpecialReward);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgUnderDraftData_ShopSlot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgUnderDraftData_ShopSlot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.slotId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isSpecialReward = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgUnderDraftData_ShopSlot {
    return {
      slotId: isSet(object.slotId) ? globalThis.Number(object.slotId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      isSpecialReward: isSet(object.isSpecialReward) ? globalThis.Boolean(object.isSpecialReward) : false,
    };
  },

  toJSON(message: CMsgUnderDraftData_ShopSlot): unknown {
    const obj: any = {};
    if (message.slotId !== 0) {
      obj.slotId = Math.round(message.slotId);
    }
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.isSpecialReward !== false) {
      obj.isSpecialReward = message.isSpecialReward;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgUnderDraftData_ShopSlot>): CMsgUnderDraftData_ShopSlot {
    return CMsgUnderDraftData_ShopSlot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgUnderDraftData_ShopSlot>): CMsgUnderDraftData_ShopSlot {
    const message = createBaseCMsgUnderDraftData_ShopSlot();
    message.slotId = object.slotId ?? 0;
    message.heroId = object.heroId ?? 0;
    message.isSpecialReward = object.isSpecialReward ?? false;
    return message;
  },
};

function createBaseCMsgPlayerTitleData(): CMsgPlayerTitleData {
  return { title: [], eventId: [], active: 0 };
}

export const CMsgPlayerTitleData: MessageFns<CMsgPlayerTitleData> = {
  encode(message: CMsgPlayerTitleData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.title) {
      writer.uint32(v);
    }
    writer.join();
    writer.uint32(18).fork();
    for (const v of message.eventId) {
      writer.uint32(v);
    }
    writer.join();
    if (message.active !== 0) {
      writer.uint32(24).uint32(message.active);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgPlayerTitleData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerTitleData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.title.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.title.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag === 16) {
            message.eventId.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.eventId.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.active = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPlayerTitleData {
    return {
      title: globalThis.Array.isArray(object?.title) ? object.title.map((e: any) => globalThis.Number(e)) : [],
      eventId: globalThis.Array.isArray(object?.eventId) ? object.eventId.map((e: any) => globalThis.Number(e)) : [],
      active: isSet(object.active) ? globalThis.Number(object.active) : 0,
    };
  },

  toJSON(message: CMsgPlayerTitleData): unknown {
    const obj: any = {};
    if (message.title?.length) {
      obj.title = message.title.map((e) => Math.round(e));
    }
    if (message.eventId?.length) {
      obj.eventId = message.eventId.map((e) => Math.round(e));
    }
    if (message.active !== 0) {
      obj.active = Math.round(message.active);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPlayerTitleData>): CMsgPlayerTitleData {
    return CMsgPlayerTitleData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPlayerTitleData>): CMsgPlayerTitleData {
    const message = createBaseCMsgPlayerTitleData();
    message.title = object.title?.map((e) => e) || [];
    message.eventId = object.eventId?.map((e) => e) || [];
    message.active = object.active ?? 0;
    return message;
  },
};

function createBaseCMsgDOTATriviaQuestion(): CMsgDOTATriviaQuestion {
  return { questionId: 0, category: 0, timestamp: 0, questionValue: "", answerValues: [], correctAnswerIndex: 0 };
}

export const CMsgDOTATriviaQuestion: MessageFns<CMsgDOTATriviaQuestion> = {
  encode(message: CMsgDOTATriviaQuestion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.questionId !== 0) {
      writer.uint32(8).uint32(message.questionId);
    }
    if (message.category !== 0) {
      writer.uint32(16).int32(message.category);
    }
    if (message.timestamp !== 0) {
      writer.uint32(24).uint32(message.timestamp);
    }
    if (message.questionValue !== "") {
      writer.uint32(34).string(message.questionValue);
    }
    for (const v of message.answerValues) {
      writer.uint32(42).string(v!);
    }
    if (message.correctAnswerIndex !== 0) {
      writer.uint32(48).uint32(message.correctAnswerIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTATriviaQuestion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTATriviaQuestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.questionId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.questionValue = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.answerValues.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.correctAnswerIndex = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTATriviaQuestion {
    return {
      questionId: isSet(object.questionId) ? globalThis.Number(object.questionId) : 0,
      category: isSet(object.category) ? eDOTATriviaQuestionCategoryFromJSON(object.category) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      questionValue: isSet(object.questionValue) ? globalThis.String(object.questionValue) : "",
      answerValues: globalThis.Array.isArray(object?.answerValues)
        ? object.answerValues.map((e: any) => globalThis.String(e))
        : [],
      correctAnswerIndex: isSet(object.correctAnswerIndex) ? globalThis.Number(object.correctAnswerIndex) : 0,
    };
  },

  toJSON(message: CMsgDOTATriviaQuestion): unknown {
    const obj: any = {};
    if (message.questionId !== 0) {
      obj.questionId = Math.round(message.questionId);
    }
    if (message.category !== 0) {
      obj.category = eDOTATriviaQuestionCategoryToJSON(message.category);
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.questionValue !== "") {
      obj.questionValue = message.questionValue;
    }
    if (message.answerValues?.length) {
      obj.answerValues = message.answerValues;
    }
    if (message.correctAnswerIndex !== 0) {
      obj.correctAnswerIndex = Math.round(message.correctAnswerIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTATriviaQuestion>): CMsgDOTATriviaQuestion {
    return CMsgDOTATriviaQuestion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTATriviaQuestion>): CMsgDOTATriviaQuestion {
    const message = createBaseCMsgDOTATriviaQuestion();
    message.questionId = object.questionId ?? 0;
    message.category = object.category ?? 0;
    message.timestamp = object.timestamp ?? 0;
    message.questionValue = object.questionValue ?? "";
    message.answerValues = object.answerValues?.map((e) => e) || [];
    message.correctAnswerIndex = object.correctAnswerIndex ?? 0;
    return message;
  },
};

function createBaseCMsgDOTATriviaQuestionAnswersSummary(): CMsgDOTATriviaQuestionAnswersSummary {
  return { summaryAvailable: false, pickedCount: [] };
}

export const CMsgDOTATriviaQuestionAnswersSummary: MessageFns<CMsgDOTATriviaQuestionAnswersSummary> = {
  encode(message: CMsgDOTATriviaQuestionAnswersSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.summaryAvailable !== false) {
      writer.uint32(8).bool(message.summaryAvailable);
    }
    writer.uint32(18).fork();
    for (const v of message.pickedCount) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTATriviaQuestionAnswersSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTATriviaQuestionAnswersSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.summaryAvailable = reader.bool();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.pickedCount.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.pickedCount.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTATriviaQuestionAnswersSummary {
    return {
      summaryAvailable: isSet(object.summaryAvailable) ? globalThis.Boolean(object.summaryAvailable) : false,
      pickedCount: globalThis.Array.isArray(object?.pickedCount)
        ? object.pickedCount.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTATriviaQuestionAnswersSummary): unknown {
    const obj: any = {};
    if (message.summaryAvailable !== false) {
      obj.summaryAvailable = message.summaryAvailable;
    }
    if (message.pickedCount?.length) {
      obj.pickedCount = message.pickedCount.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTATriviaQuestionAnswersSummary>): CMsgDOTATriviaQuestionAnswersSummary {
    return CMsgDOTATriviaQuestionAnswersSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTATriviaQuestionAnswersSummary>): CMsgDOTATriviaQuestionAnswersSummary {
    const message = createBaseCMsgDOTATriviaQuestionAnswersSummary();
    message.summaryAvailable = object.summaryAvailable ?? false;
    message.pickedCount = object.pickedCount?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgGameDataSpecialValueBonus(): CMsgGameDataSpecialValueBonus {
  return { name: "", value: 0, operation: 0 };
}

export const CMsgGameDataSpecialValueBonus: MessageFns<CMsgGameDataSpecialValueBonus> = {
  encode(message: CMsgGameDataSpecialValueBonus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    if (message.operation !== 0) {
      writer.uint32(24).uint32(message.operation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGameDataSpecialValueBonus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataSpecialValueBonus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.operation = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataSpecialValueBonus {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      operation: isSet(object.operation) ? globalThis.Number(object.operation) : 0,
    };
  },

  toJSON(message: CMsgGameDataSpecialValueBonus): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (message.operation !== 0) {
      obj.operation = Math.round(message.operation);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataSpecialValueBonus>): CMsgGameDataSpecialValueBonus {
    return CMsgGameDataSpecialValueBonus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataSpecialValueBonus>): CMsgGameDataSpecialValueBonus {
    const message = createBaseCMsgGameDataSpecialValueBonus();
    message.name = object.name ?? "";
    message.value = object.value ?? 0;
    message.operation = object.operation ?? 0;
    return message;
  },
};

function createBaseCMsgGameDataSpecialValues(): CMsgGameDataSpecialValues {
  return {
    name: "",
    valuesFloat: [],
    isPercentage: false,
    headingLoc: "",
    bonuses: [],
    valuesShard: [],
    valuesScepter: [],
  };
}

export const CMsgGameDataSpecialValues: MessageFns<CMsgGameDataSpecialValues> = {
  encode(message: CMsgGameDataSpecialValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    writer.uint32(18).fork();
    for (const v of message.valuesFloat) {
      writer.float(v);
    }
    writer.join();
    if (message.isPercentage !== false) {
      writer.uint32(32).bool(message.isPercentage);
    }
    if (message.headingLoc !== "") {
      writer.uint32(42).string(message.headingLoc);
    }
    for (const v of message.bonuses) {
      CMsgGameDataSpecialValueBonus.encode(v!, writer.uint32(50).fork()).join();
    }
    writer.uint32(58).fork();
    for (const v of message.valuesShard) {
      writer.float(v);
    }
    writer.join();
    writer.uint32(66).fork();
    for (const v of message.valuesScepter) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGameDataSpecialValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataSpecialValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag === 21) {
            message.valuesFloat.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.valuesFloat.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isPercentage = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.headingLoc = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bonuses.push(CMsgGameDataSpecialValueBonus.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag === 61) {
            message.valuesShard.push(reader.float());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.valuesShard.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag === 69) {
            message.valuesScepter.push(reader.float());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.valuesScepter.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataSpecialValues {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      valuesFloat: globalThis.Array.isArray(object?.valuesFloat)
        ? object.valuesFloat.map((e: any) => globalThis.Number(e))
        : [],
      isPercentage: isSet(object.isPercentage) ? globalThis.Boolean(object.isPercentage) : false,
      headingLoc: isSet(object.headingLoc) ? globalThis.String(object.headingLoc) : "",
      bonuses: globalThis.Array.isArray(object?.bonuses)
        ? object.bonuses.map((e: any) => CMsgGameDataSpecialValueBonus.fromJSON(e))
        : [],
      valuesShard: globalThis.Array.isArray(object?.valuesShard)
        ? object.valuesShard.map((e: any) => globalThis.Number(e))
        : [],
      valuesScepter: globalThis.Array.isArray(object?.valuesScepter)
        ? object.valuesScepter.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgGameDataSpecialValues): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.valuesFloat?.length) {
      obj.valuesFloat = message.valuesFloat;
    }
    if (message.isPercentage !== false) {
      obj.isPercentage = message.isPercentage;
    }
    if (message.headingLoc !== "") {
      obj.headingLoc = message.headingLoc;
    }
    if (message.bonuses?.length) {
      obj.bonuses = message.bonuses.map((e) => CMsgGameDataSpecialValueBonus.toJSON(e));
    }
    if (message.valuesShard?.length) {
      obj.valuesShard = message.valuesShard;
    }
    if (message.valuesScepter?.length) {
      obj.valuesScepter = message.valuesScepter;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataSpecialValues>): CMsgGameDataSpecialValues {
    return CMsgGameDataSpecialValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataSpecialValues>): CMsgGameDataSpecialValues {
    const message = createBaseCMsgGameDataSpecialValues();
    message.name = object.name ?? "";
    message.valuesFloat = object.valuesFloat?.map((e) => e) || [];
    message.isPercentage = object.isPercentage ?? false;
    message.headingLoc = object.headingLoc ?? "";
    message.bonuses = object.bonuses?.map((e) => CMsgGameDataSpecialValueBonus.fromPartial(e)) || [];
    message.valuesShard = object.valuesShard?.map((e) => e) || [];
    message.valuesScepter = object.valuesScepter?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgGameDataAbilityOrItem(): CMsgGameDataAbilityOrItem {
  return {
    id: -1,
    name: "",
    nameLoc: "",
    descLoc: "",
    loreLoc: "",
    notesLoc: [],
    shardLoc: "",
    scepterLoc: "",
    type: 0,
    behavior: "0",
    targetTeam: 0,
    targetType: 0,
    flags: 0,
    damage: 0,
    immunity: 0,
    dispellable: 0,
    maxLevel: 0,
    castRanges: [],
    castPoints: [],
    channelTimes: [],
    cooldowns: [],
    durations: [],
    damages: [],
    manaCosts: [],
    goldCosts: [],
    healthCosts: [],
    specialValues: [],
    isItem: false,
    abilityHasScepter: false,
    abilityHasShard: false,
    abilityIsGrantedByScepter: false,
    abilityIsGrantedByShard: false,
    itemCost: 0,
    itemInitialCharges: 0,
    itemNeutralTier: 0,
    itemStockMax: 0,
    itemStockTime: 0,
    itemQuality: 0,
  };
}

export const CMsgGameDataAbilityOrItem: MessageFns<CMsgGameDataAbilityOrItem> = {
  encode(message: CMsgGameDataAbilityOrItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== -1) {
      writer.uint32(8).int32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.nameLoc !== "") {
      writer.uint32(42).string(message.nameLoc);
    }
    if (message.descLoc !== "") {
      writer.uint32(50).string(message.descLoc);
    }
    if (message.loreLoc !== "") {
      writer.uint32(58).string(message.loreLoc);
    }
    for (const v of message.notesLoc) {
      writer.uint32(66).string(v!);
    }
    if (message.shardLoc !== "") {
      writer.uint32(74).string(message.shardLoc);
    }
    if (message.scepterLoc !== "") {
      writer.uint32(82).string(message.scepterLoc);
    }
    if (message.type !== 0) {
      writer.uint32(160).uint32(message.type);
    }
    if (message.behavior !== "0") {
      writer.uint32(168).uint64(message.behavior);
    }
    if (message.targetTeam !== 0) {
      writer.uint32(176).uint32(message.targetTeam);
    }
    if (message.targetType !== 0) {
      writer.uint32(184).uint32(message.targetType);
    }
    if (message.flags !== 0) {
      writer.uint32(192).uint32(message.flags);
    }
    if (message.damage !== 0) {
      writer.uint32(200).uint32(message.damage);
    }
    if (message.immunity !== 0) {
      writer.uint32(208).uint32(message.immunity);
    }
    if (message.dispellable !== 0) {
      writer.uint32(216).uint32(message.dispellable);
    }
    if (message.maxLevel !== 0) {
      writer.uint32(224).uint32(message.maxLevel);
    }
    writer.uint32(242).fork();
    for (const v of message.castRanges) {
      writer.uint32(v);
    }
    writer.join();
    writer.uint32(250).fork();
    for (const v of message.castPoints) {
      writer.float(v);
    }
    writer.join();
    writer.uint32(258).fork();
    for (const v of message.channelTimes) {
      writer.float(v);
    }
    writer.join();
    writer.uint32(266).fork();
    for (const v of message.cooldowns) {
      writer.float(v);
    }
    writer.join();
    writer.uint32(274).fork();
    for (const v of message.durations) {
      writer.float(v);
    }
    writer.join();
    writer.uint32(282).fork();
    for (const v of message.damages) {
      writer.uint32(v);
    }
    writer.join();
    writer.uint32(290).fork();
    for (const v of message.manaCosts) {
      writer.uint32(v);
    }
    writer.join();
    writer.uint32(298).fork();
    for (const v of message.goldCosts) {
      writer.uint32(v);
    }
    writer.join();
    writer.uint32(306).fork();
    for (const v of message.healthCosts) {
      writer.uint32(v);
    }
    writer.join();
    for (const v of message.specialValues) {
      CMsgGameDataSpecialValues.encode(v!, writer.uint32(322).fork()).join();
    }
    if (message.isItem !== false) {
      writer.uint32(400).bool(message.isItem);
    }
    if (message.abilityHasScepter !== false) {
      writer.uint32(480).bool(message.abilityHasScepter);
    }
    if (message.abilityHasShard !== false) {
      writer.uint32(488).bool(message.abilityHasShard);
    }
    if (message.abilityIsGrantedByScepter !== false) {
      writer.uint32(496).bool(message.abilityIsGrantedByScepter);
    }
    if (message.abilityIsGrantedByShard !== false) {
      writer.uint32(504).bool(message.abilityIsGrantedByShard);
    }
    if (message.itemCost !== 0) {
      writer.uint32(560).uint32(message.itemCost);
    }
    if (message.itemInitialCharges !== 0) {
      writer.uint32(568).uint32(message.itemInitialCharges);
    }
    if (message.itemNeutralTier !== 0) {
      writer.uint32(576).uint32(message.itemNeutralTier);
    }
    if (message.itemStockMax !== 0) {
      writer.uint32(584).uint32(message.itemStockMax);
    }
    if (message.itemStockTime !== 0) {
      writer.uint32(597).float(message.itemStockTime);
    }
    if (message.itemQuality !== 0) {
      writer.uint32(680).uint32(message.itemQuality);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGameDataAbilityOrItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataAbilityOrItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nameLoc = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.descLoc = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.loreLoc = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.notesLoc.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.shardLoc = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.scepterLoc = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.type = reader.uint32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.behavior = reader.uint64().toString();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.targetTeam = reader.uint32();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.targetType = reader.uint32();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.flags = reader.uint32();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.damage = reader.uint32();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.immunity = reader.uint32();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.dispellable = reader.uint32();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.maxLevel = reader.uint32();
          continue;
        }
        case 30: {
          if (tag === 240) {
            message.castRanges.push(reader.uint32());

            continue;
          }

          if (tag === 242) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.castRanges.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 31: {
          if (tag === 253) {
            message.castPoints.push(reader.float());

            continue;
          }

          if (tag === 250) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.castPoints.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 32: {
          if (tag === 261) {
            message.channelTimes.push(reader.float());

            continue;
          }

          if (tag === 258) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.channelTimes.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 33: {
          if (tag === 269) {
            message.cooldowns.push(reader.float());

            continue;
          }

          if (tag === 266) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.cooldowns.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 34: {
          if (tag === 277) {
            message.durations.push(reader.float());

            continue;
          }

          if (tag === 274) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.durations.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 35: {
          if (tag === 280) {
            message.damages.push(reader.uint32());

            continue;
          }

          if (tag === 282) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.damages.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 36: {
          if (tag === 288) {
            message.manaCosts.push(reader.uint32());

            continue;
          }

          if (tag === 290) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.manaCosts.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 37: {
          if (tag === 296) {
            message.goldCosts.push(reader.uint32());

            continue;
          }

          if (tag === 298) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.goldCosts.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 38: {
          if (tag === 304) {
            message.healthCosts.push(reader.uint32());

            continue;
          }

          if (tag === 306) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.healthCosts.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.specialValues.push(CMsgGameDataSpecialValues.decode(reader, reader.uint32()));
          continue;
        }
        case 50: {
          if (tag !== 400) {
            break;
          }

          message.isItem = reader.bool();
          continue;
        }
        case 60: {
          if (tag !== 480) {
            break;
          }

          message.abilityHasScepter = reader.bool();
          continue;
        }
        case 61: {
          if (tag !== 488) {
            break;
          }

          message.abilityHasShard = reader.bool();
          continue;
        }
        case 62: {
          if (tag !== 496) {
            break;
          }

          message.abilityIsGrantedByScepter = reader.bool();
          continue;
        }
        case 63: {
          if (tag !== 504) {
            break;
          }

          message.abilityIsGrantedByShard = reader.bool();
          continue;
        }
        case 70: {
          if (tag !== 560) {
            break;
          }

          message.itemCost = reader.uint32();
          continue;
        }
        case 71: {
          if (tag !== 568) {
            break;
          }

          message.itemInitialCharges = reader.uint32();
          continue;
        }
        case 72: {
          if (tag !== 576) {
            break;
          }

          message.itemNeutralTier = reader.uint32();
          continue;
        }
        case 73: {
          if (tag !== 584) {
            break;
          }

          message.itemStockMax = reader.uint32();
          continue;
        }
        case 74: {
          if (tag !== 597) {
            break;
          }

          message.itemStockTime = reader.float();
          continue;
        }
        case 85: {
          if (tag !== 680) {
            break;
          }

          message.itemQuality = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataAbilityOrItem {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : -1,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nameLoc: isSet(object.nameLoc) ? globalThis.String(object.nameLoc) : "",
      descLoc: isSet(object.descLoc) ? globalThis.String(object.descLoc) : "",
      loreLoc: isSet(object.loreLoc) ? globalThis.String(object.loreLoc) : "",
      notesLoc: globalThis.Array.isArray(object?.notesLoc) ? object.notesLoc.map((e: any) => globalThis.String(e)) : [],
      shardLoc: isSet(object.shardLoc) ? globalThis.String(object.shardLoc) : "",
      scepterLoc: isSet(object.scepterLoc) ? globalThis.String(object.scepterLoc) : "",
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      behavior: isSet(object.behavior) ? globalThis.String(object.behavior) : "0",
      targetTeam: isSet(object.targetTeam) ? globalThis.Number(object.targetTeam) : 0,
      targetType: isSet(object.targetType) ? globalThis.Number(object.targetType) : 0,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
      damage: isSet(object.damage) ? globalThis.Number(object.damage) : 0,
      immunity: isSet(object.immunity) ? globalThis.Number(object.immunity) : 0,
      dispellable: isSet(object.dispellable) ? globalThis.Number(object.dispellable) : 0,
      maxLevel: isSet(object.maxLevel) ? globalThis.Number(object.maxLevel) : 0,
      castRanges: globalThis.Array.isArray(object?.castRanges)
        ? object.castRanges.map((e: any) => globalThis.Number(e))
        : [],
      castPoints: globalThis.Array.isArray(object?.castPoints)
        ? object.castPoints.map((e: any) => globalThis.Number(e))
        : [],
      channelTimes: globalThis.Array.isArray(object?.channelTimes)
        ? object.channelTimes.map((e: any) => globalThis.Number(e))
        : [],
      cooldowns: globalThis.Array.isArray(object?.cooldowns)
        ? object.cooldowns.map((e: any) => globalThis.Number(e))
        : [],
      durations: globalThis.Array.isArray(object?.durations)
        ? object.durations.map((e: any) => globalThis.Number(e))
        : [],
      damages: globalThis.Array.isArray(object?.damages) ? object.damages.map((e: any) => globalThis.Number(e)) : [],
      manaCosts: globalThis.Array.isArray(object?.manaCosts)
        ? object.manaCosts.map((e: any) => globalThis.Number(e))
        : [],
      goldCosts: globalThis.Array.isArray(object?.goldCosts)
        ? object.goldCosts.map((e: any) => globalThis.Number(e))
        : [],
      healthCosts: globalThis.Array.isArray(object?.healthCosts)
        ? object.healthCosts.map((e: any) => globalThis.Number(e))
        : [],
      specialValues: globalThis.Array.isArray(object?.specialValues)
        ? object.specialValues.map((e: any) => CMsgGameDataSpecialValues.fromJSON(e))
        : [],
      isItem: isSet(object.isItem) ? globalThis.Boolean(object.isItem) : false,
      abilityHasScepter: isSet(object.abilityHasScepter) ? globalThis.Boolean(object.abilityHasScepter) : false,
      abilityHasShard: isSet(object.abilityHasShard) ? globalThis.Boolean(object.abilityHasShard) : false,
      abilityIsGrantedByScepter: isSet(object.abilityIsGrantedByScepter)
        ? globalThis.Boolean(object.abilityIsGrantedByScepter)
        : false,
      abilityIsGrantedByShard: isSet(object.abilityIsGrantedByShard)
        ? globalThis.Boolean(object.abilityIsGrantedByShard)
        : false,
      itemCost: isSet(object.itemCost) ? globalThis.Number(object.itemCost) : 0,
      itemInitialCharges: isSet(object.itemInitialCharges) ? globalThis.Number(object.itemInitialCharges) : 0,
      itemNeutralTier: isSet(object.itemNeutralTier) ? globalThis.Number(object.itemNeutralTier) : 0,
      itemStockMax: isSet(object.itemStockMax) ? globalThis.Number(object.itemStockMax) : 0,
      itemStockTime: isSet(object.itemStockTime) ? globalThis.Number(object.itemStockTime) : 0,
      itemQuality: isSet(object.itemQuality) ? globalThis.Number(object.itemQuality) : 0,
    };
  },

  toJSON(message: CMsgGameDataAbilityOrItem): unknown {
    const obj: any = {};
    if (message.id !== -1) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.nameLoc !== "") {
      obj.nameLoc = message.nameLoc;
    }
    if (message.descLoc !== "") {
      obj.descLoc = message.descLoc;
    }
    if (message.loreLoc !== "") {
      obj.loreLoc = message.loreLoc;
    }
    if (message.notesLoc?.length) {
      obj.notesLoc = message.notesLoc;
    }
    if (message.shardLoc !== "") {
      obj.shardLoc = message.shardLoc;
    }
    if (message.scepterLoc !== "") {
      obj.scepterLoc = message.scepterLoc;
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.behavior !== "0") {
      obj.behavior = message.behavior;
    }
    if (message.targetTeam !== 0) {
      obj.targetTeam = Math.round(message.targetTeam);
    }
    if (message.targetType !== 0) {
      obj.targetType = Math.round(message.targetType);
    }
    if (message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    if (message.damage !== 0) {
      obj.damage = Math.round(message.damage);
    }
    if (message.immunity !== 0) {
      obj.immunity = Math.round(message.immunity);
    }
    if (message.dispellable !== 0) {
      obj.dispellable = Math.round(message.dispellable);
    }
    if (message.maxLevel !== 0) {
      obj.maxLevel = Math.round(message.maxLevel);
    }
    if (message.castRanges?.length) {
      obj.castRanges = message.castRanges.map((e) => Math.round(e));
    }
    if (message.castPoints?.length) {
      obj.castPoints = message.castPoints;
    }
    if (message.channelTimes?.length) {
      obj.channelTimes = message.channelTimes;
    }
    if (message.cooldowns?.length) {
      obj.cooldowns = message.cooldowns;
    }
    if (message.durations?.length) {
      obj.durations = message.durations;
    }
    if (message.damages?.length) {
      obj.damages = message.damages.map((e) => Math.round(e));
    }
    if (message.manaCosts?.length) {
      obj.manaCosts = message.manaCosts.map((e) => Math.round(e));
    }
    if (message.goldCosts?.length) {
      obj.goldCosts = message.goldCosts.map((e) => Math.round(e));
    }
    if (message.healthCosts?.length) {
      obj.healthCosts = message.healthCosts.map((e) => Math.round(e));
    }
    if (message.specialValues?.length) {
      obj.specialValues = message.specialValues.map((e) => CMsgGameDataSpecialValues.toJSON(e));
    }
    if (message.isItem !== false) {
      obj.isItem = message.isItem;
    }
    if (message.abilityHasScepter !== false) {
      obj.abilityHasScepter = message.abilityHasScepter;
    }
    if (message.abilityHasShard !== false) {
      obj.abilityHasShard = message.abilityHasShard;
    }
    if (message.abilityIsGrantedByScepter !== false) {
      obj.abilityIsGrantedByScepter = message.abilityIsGrantedByScepter;
    }
    if (message.abilityIsGrantedByShard !== false) {
      obj.abilityIsGrantedByShard = message.abilityIsGrantedByShard;
    }
    if (message.itemCost !== 0) {
      obj.itemCost = Math.round(message.itemCost);
    }
    if (message.itemInitialCharges !== 0) {
      obj.itemInitialCharges = Math.round(message.itemInitialCharges);
    }
    if (message.itemNeutralTier !== 0) {
      obj.itemNeutralTier = Math.round(message.itemNeutralTier);
    }
    if (message.itemStockMax !== 0) {
      obj.itemStockMax = Math.round(message.itemStockMax);
    }
    if (message.itemStockTime !== 0) {
      obj.itemStockTime = message.itemStockTime;
    }
    if (message.itemQuality !== 0) {
      obj.itemQuality = Math.round(message.itemQuality);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataAbilityOrItem>): CMsgGameDataAbilityOrItem {
    return CMsgGameDataAbilityOrItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataAbilityOrItem>): CMsgGameDataAbilityOrItem {
    const message = createBaseCMsgGameDataAbilityOrItem();
    message.id = object.id ?? -1;
    message.name = object.name ?? "";
    message.nameLoc = object.nameLoc ?? "";
    message.descLoc = object.descLoc ?? "";
    message.loreLoc = object.loreLoc ?? "";
    message.notesLoc = object.notesLoc?.map((e) => e) || [];
    message.shardLoc = object.shardLoc ?? "";
    message.scepterLoc = object.scepterLoc ?? "";
    message.type = object.type ?? 0;
    message.behavior = object.behavior ?? "0";
    message.targetTeam = object.targetTeam ?? 0;
    message.targetType = object.targetType ?? 0;
    message.flags = object.flags ?? 0;
    message.damage = object.damage ?? 0;
    message.immunity = object.immunity ?? 0;
    message.dispellable = object.dispellable ?? 0;
    message.maxLevel = object.maxLevel ?? 0;
    message.castRanges = object.castRanges?.map((e) => e) || [];
    message.castPoints = object.castPoints?.map((e) => e) || [];
    message.channelTimes = object.channelTimes?.map((e) => e) || [];
    message.cooldowns = object.cooldowns?.map((e) => e) || [];
    message.durations = object.durations?.map((e) => e) || [];
    message.damages = object.damages?.map((e) => e) || [];
    message.manaCosts = object.manaCosts?.map((e) => e) || [];
    message.goldCosts = object.goldCosts?.map((e) => e) || [];
    message.healthCosts = object.healthCosts?.map((e) => e) || [];
    message.specialValues = object.specialValues?.map((e) => CMsgGameDataSpecialValues.fromPartial(e)) || [];
    message.isItem = object.isItem ?? false;
    message.abilityHasScepter = object.abilityHasScepter ?? false;
    message.abilityHasShard = object.abilityHasShard ?? false;
    message.abilityIsGrantedByScepter = object.abilityIsGrantedByScepter ?? false;
    message.abilityIsGrantedByShard = object.abilityIsGrantedByShard ?? false;
    message.itemCost = object.itemCost ?? 0;
    message.itemInitialCharges = object.itemInitialCharges ?? 0;
    message.itemNeutralTier = object.itemNeutralTier ?? 0;
    message.itemStockMax = object.itemStockMax ?? 0;
    message.itemStockTime = object.itemStockTime ?? 0;
    message.itemQuality = object.itemQuality ?? 0;
    return message;
  },
};

function createBaseCMsgGameDataHero(): CMsgGameDataHero {
  return {
    id: 0,
    name: "",
    orderId: 0,
    nameLoc: "",
    bioLoc: "",
    hypeLoc: "",
    npeDescLoc: "",
    strBase: 0,
    strGain: 0,
    agiBase: 0,
    agiGain: 0,
    intBase: 0,
    intGain: 0,
    primaryAttr: 0,
    complexity: 0,
    attackCapability: 0,
    roleLevels: [],
    damageMin: 0,
    damageMax: 0,
    attackRate: 0,
    attackRange: 0,
    projectileSpeed: 0,
    armor: 0,
    magicResistance: 0,
    movementSpeed: 0,
    turnRate: 0,
    sightRangeDay: 0,
    sightRangeNight: 0,
    maxHealth: 0,
    healthRegen: 0,
    maxMana: 0,
    manaRegen: 0,
    abilities: [],
    talents: [],
  };
}

export const CMsgGameDataHero: MessageFns<CMsgGameDataHero> = {
  encode(message: CMsgGameDataHero, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.orderId !== 0) {
      writer.uint32(24).uint32(message.orderId);
    }
    if (message.nameLoc !== "") {
      writer.uint32(42).string(message.nameLoc);
    }
    if (message.bioLoc !== "") {
      writer.uint32(50).string(message.bioLoc);
    }
    if (message.hypeLoc !== "") {
      writer.uint32(58).string(message.hypeLoc);
    }
    if (message.npeDescLoc !== "") {
      writer.uint32(66).string(message.npeDescLoc);
    }
    if (message.strBase !== 0) {
      writer.uint32(80).uint32(message.strBase);
    }
    if (message.strGain !== 0) {
      writer.uint32(93).float(message.strGain);
    }
    if (message.agiBase !== 0) {
      writer.uint32(96).uint32(message.agiBase);
    }
    if (message.agiGain !== 0) {
      writer.uint32(109).float(message.agiGain);
    }
    if (message.intBase !== 0) {
      writer.uint32(112).uint32(message.intBase);
    }
    if (message.intGain !== 0) {
      writer.uint32(125).float(message.intGain);
    }
    if (message.primaryAttr !== 0) {
      writer.uint32(160).uint32(message.primaryAttr);
    }
    if (message.complexity !== 0) {
      writer.uint32(168).uint32(message.complexity);
    }
    if (message.attackCapability !== 0) {
      writer.uint32(176).uint32(message.attackCapability);
    }
    writer.uint32(186).fork();
    for (const v of message.roleLevels) {
      writer.uint32(v);
    }
    writer.join();
    if (message.damageMin !== 0) {
      writer.uint32(192).int32(message.damageMin);
    }
    if (message.damageMax !== 0) {
      writer.uint32(200).int32(message.damageMax);
    }
    if (message.attackRate !== 0) {
      writer.uint32(213).float(message.attackRate);
    }
    if (message.attackRange !== 0) {
      writer.uint32(216).uint32(message.attackRange);
    }
    if (message.projectileSpeed !== 0) {
      writer.uint32(224).uint32(message.projectileSpeed);
    }
    if (message.armor !== 0) {
      writer.uint32(237).float(message.armor);
    }
    if (message.magicResistance !== 0) {
      writer.uint32(240).uint32(message.magicResistance);
    }
    if (message.movementSpeed !== 0) {
      writer.uint32(248).uint32(message.movementSpeed);
    }
    if (message.turnRate !== 0) {
      writer.uint32(261).float(message.turnRate);
    }
    if (message.sightRangeDay !== 0) {
      writer.uint32(264).uint32(message.sightRangeDay);
    }
    if (message.sightRangeNight !== 0) {
      writer.uint32(272).uint32(message.sightRangeNight);
    }
    if (message.maxHealth !== 0) {
      writer.uint32(280).uint32(message.maxHealth);
    }
    if (message.healthRegen !== 0) {
      writer.uint32(293).float(message.healthRegen);
    }
    if (message.maxMana !== 0) {
      writer.uint32(296).uint32(message.maxMana);
    }
    if (message.manaRegen !== 0) {
      writer.uint32(309).float(message.manaRegen);
    }
    for (const v of message.abilities) {
      CMsgGameDataAbilityOrItem.encode(v!, writer.uint32(322).fork()).join();
    }
    for (const v of message.talents) {
      CMsgGameDataAbilityOrItem.encode(v!, writer.uint32(330).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGameDataHero {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataHero();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.orderId = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nameLoc = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bioLoc = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.hypeLoc = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.npeDescLoc = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.strBase = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.strGain = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.agiBase = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 109) {
            break;
          }

          message.agiGain = reader.float();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.intBase = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 125) {
            break;
          }

          message.intGain = reader.float();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.primaryAttr = reader.uint32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.complexity = reader.uint32();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.attackCapability = reader.uint32();
          continue;
        }
        case 23: {
          if (tag === 184) {
            message.roleLevels.push(reader.uint32());

            continue;
          }

          if (tag === 186) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.roleLevels.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.damageMin = reader.int32();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.damageMax = reader.int32();
          continue;
        }
        case 26: {
          if (tag !== 213) {
            break;
          }

          message.attackRate = reader.float();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.attackRange = reader.uint32();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.projectileSpeed = reader.uint32();
          continue;
        }
        case 29: {
          if (tag !== 237) {
            break;
          }

          message.armor = reader.float();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.magicResistance = reader.uint32();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.movementSpeed = reader.uint32();
          continue;
        }
        case 32: {
          if (tag !== 261) {
            break;
          }

          message.turnRate = reader.float();
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.sightRangeDay = reader.uint32();
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.sightRangeNight = reader.uint32();
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.maxHealth = reader.uint32();
          continue;
        }
        case 36: {
          if (tag !== 293) {
            break;
          }

          message.healthRegen = reader.float();
          continue;
        }
        case 37: {
          if (tag !== 296) {
            break;
          }

          message.maxMana = reader.uint32();
          continue;
        }
        case 38: {
          if (tag !== 309) {
            break;
          }

          message.manaRegen = reader.float();
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.abilities.push(CMsgGameDataAbilityOrItem.decode(reader, reader.uint32()));
          continue;
        }
        case 41: {
          if (tag !== 330) {
            break;
          }

          message.talents.push(CMsgGameDataAbilityOrItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataHero {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      orderId: isSet(object.orderId) ? globalThis.Number(object.orderId) : 0,
      nameLoc: isSet(object.nameLoc) ? globalThis.String(object.nameLoc) : "",
      bioLoc: isSet(object.bioLoc) ? globalThis.String(object.bioLoc) : "",
      hypeLoc: isSet(object.hypeLoc) ? globalThis.String(object.hypeLoc) : "",
      npeDescLoc: isSet(object.npeDescLoc) ? globalThis.String(object.npeDescLoc) : "",
      strBase: isSet(object.strBase) ? globalThis.Number(object.strBase) : 0,
      strGain: isSet(object.strGain) ? globalThis.Number(object.strGain) : 0,
      agiBase: isSet(object.agiBase) ? globalThis.Number(object.agiBase) : 0,
      agiGain: isSet(object.agiGain) ? globalThis.Number(object.agiGain) : 0,
      intBase: isSet(object.intBase) ? globalThis.Number(object.intBase) : 0,
      intGain: isSet(object.intGain) ? globalThis.Number(object.intGain) : 0,
      primaryAttr: isSet(object.primaryAttr) ? globalThis.Number(object.primaryAttr) : 0,
      complexity: isSet(object.complexity) ? globalThis.Number(object.complexity) : 0,
      attackCapability: isSet(object.attackCapability) ? globalThis.Number(object.attackCapability) : 0,
      roleLevels: globalThis.Array.isArray(object?.roleLevels)
        ? object.roleLevels.map((e: any) => globalThis.Number(e))
        : [],
      damageMin: isSet(object.damageMin) ? globalThis.Number(object.damageMin) : 0,
      damageMax: isSet(object.damageMax) ? globalThis.Number(object.damageMax) : 0,
      attackRate: isSet(object.attackRate) ? globalThis.Number(object.attackRate) : 0,
      attackRange: isSet(object.attackRange) ? globalThis.Number(object.attackRange) : 0,
      projectileSpeed: isSet(object.projectileSpeed) ? globalThis.Number(object.projectileSpeed) : 0,
      armor: isSet(object.armor) ? globalThis.Number(object.armor) : 0,
      magicResistance: isSet(object.magicResistance) ? globalThis.Number(object.magicResistance) : 0,
      movementSpeed: isSet(object.movementSpeed) ? globalThis.Number(object.movementSpeed) : 0,
      turnRate: isSet(object.turnRate) ? globalThis.Number(object.turnRate) : 0,
      sightRangeDay: isSet(object.sightRangeDay) ? globalThis.Number(object.sightRangeDay) : 0,
      sightRangeNight: isSet(object.sightRangeNight) ? globalThis.Number(object.sightRangeNight) : 0,
      maxHealth: isSet(object.maxHealth) ? globalThis.Number(object.maxHealth) : 0,
      healthRegen: isSet(object.healthRegen) ? globalThis.Number(object.healthRegen) : 0,
      maxMana: isSet(object.maxMana) ? globalThis.Number(object.maxMana) : 0,
      manaRegen: isSet(object.manaRegen) ? globalThis.Number(object.manaRegen) : 0,
      abilities: globalThis.Array.isArray(object?.abilities)
        ? object.abilities.map((e: any) => CMsgGameDataAbilityOrItem.fromJSON(e))
        : [],
      talents: globalThis.Array.isArray(object?.talents)
        ? object.talents.map((e: any) => CMsgGameDataAbilityOrItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGameDataHero): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.orderId !== 0) {
      obj.orderId = Math.round(message.orderId);
    }
    if (message.nameLoc !== "") {
      obj.nameLoc = message.nameLoc;
    }
    if (message.bioLoc !== "") {
      obj.bioLoc = message.bioLoc;
    }
    if (message.hypeLoc !== "") {
      obj.hypeLoc = message.hypeLoc;
    }
    if (message.npeDescLoc !== "") {
      obj.npeDescLoc = message.npeDescLoc;
    }
    if (message.strBase !== 0) {
      obj.strBase = Math.round(message.strBase);
    }
    if (message.strGain !== 0) {
      obj.strGain = message.strGain;
    }
    if (message.agiBase !== 0) {
      obj.agiBase = Math.round(message.agiBase);
    }
    if (message.agiGain !== 0) {
      obj.agiGain = message.agiGain;
    }
    if (message.intBase !== 0) {
      obj.intBase = Math.round(message.intBase);
    }
    if (message.intGain !== 0) {
      obj.intGain = message.intGain;
    }
    if (message.primaryAttr !== 0) {
      obj.primaryAttr = Math.round(message.primaryAttr);
    }
    if (message.complexity !== 0) {
      obj.complexity = Math.round(message.complexity);
    }
    if (message.attackCapability !== 0) {
      obj.attackCapability = Math.round(message.attackCapability);
    }
    if (message.roleLevels?.length) {
      obj.roleLevels = message.roleLevels.map((e) => Math.round(e));
    }
    if (message.damageMin !== 0) {
      obj.damageMin = Math.round(message.damageMin);
    }
    if (message.damageMax !== 0) {
      obj.damageMax = Math.round(message.damageMax);
    }
    if (message.attackRate !== 0) {
      obj.attackRate = message.attackRate;
    }
    if (message.attackRange !== 0) {
      obj.attackRange = Math.round(message.attackRange);
    }
    if (message.projectileSpeed !== 0) {
      obj.projectileSpeed = Math.round(message.projectileSpeed);
    }
    if (message.armor !== 0) {
      obj.armor = message.armor;
    }
    if (message.magicResistance !== 0) {
      obj.magicResistance = Math.round(message.magicResistance);
    }
    if (message.movementSpeed !== 0) {
      obj.movementSpeed = Math.round(message.movementSpeed);
    }
    if (message.turnRate !== 0) {
      obj.turnRate = message.turnRate;
    }
    if (message.sightRangeDay !== 0) {
      obj.sightRangeDay = Math.round(message.sightRangeDay);
    }
    if (message.sightRangeNight !== 0) {
      obj.sightRangeNight = Math.round(message.sightRangeNight);
    }
    if (message.maxHealth !== 0) {
      obj.maxHealth = Math.round(message.maxHealth);
    }
    if (message.healthRegen !== 0) {
      obj.healthRegen = message.healthRegen;
    }
    if (message.maxMana !== 0) {
      obj.maxMana = Math.round(message.maxMana);
    }
    if (message.manaRegen !== 0) {
      obj.manaRegen = message.manaRegen;
    }
    if (message.abilities?.length) {
      obj.abilities = message.abilities.map((e) => CMsgGameDataAbilityOrItem.toJSON(e));
    }
    if (message.talents?.length) {
      obj.talents = message.talents.map((e) => CMsgGameDataAbilityOrItem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataHero>): CMsgGameDataHero {
    return CMsgGameDataHero.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataHero>): CMsgGameDataHero {
    const message = createBaseCMsgGameDataHero();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.orderId = object.orderId ?? 0;
    message.nameLoc = object.nameLoc ?? "";
    message.bioLoc = object.bioLoc ?? "";
    message.hypeLoc = object.hypeLoc ?? "";
    message.npeDescLoc = object.npeDescLoc ?? "";
    message.strBase = object.strBase ?? 0;
    message.strGain = object.strGain ?? 0;
    message.agiBase = object.agiBase ?? 0;
    message.agiGain = object.agiGain ?? 0;
    message.intBase = object.intBase ?? 0;
    message.intGain = object.intGain ?? 0;
    message.primaryAttr = object.primaryAttr ?? 0;
    message.complexity = object.complexity ?? 0;
    message.attackCapability = object.attackCapability ?? 0;
    message.roleLevels = object.roleLevels?.map((e) => e) || [];
    message.damageMin = object.damageMin ?? 0;
    message.damageMax = object.damageMax ?? 0;
    message.attackRate = object.attackRate ?? 0;
    message.attackRange = object.attackRange ?? 0;
    message.projectileSpeed = object.projectileSpeed ?? 0;
    message.armor = object.armor ?? 0;
    message.magicResistance = object.magicResistance ?? 0;
    message.movementSpeed = object.movementSpeed ?? 0;
    message.turnRate = object.turnRate ?? 0;
    message.sightRangeDay = object.sightRangeDay ?? 0;
    message.sightRangeNight = object.sightRangeNight ?? 0;
    message.maxHealth = object.maxHealth ?? 0;
    message.healthRegen = object.healthRegen ?? 0;
    message.maxMana = object.maxMana ?? 0;
    message.manaRegen = object.manaRegen ?? 0;
    message.abilities = object.abilities?.map((e) => CMsgGameDataAbilityOrItem.fromPartial(e)) || [];
    message.talents = object.talents?.map((e) => CMsgGameDataAbilityOrItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGameDataAbilities(): CMsgGameDataAbilities {
  return { abilities: [] };
}

export const CMsgGameDataAbilities: MessageFns<CMsgGameDataAbilities> = {
  encode(message: CMsgGameDataAbilities, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.abilities) {
      CMsgGameDataAbilityOrItem.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGameDataAbilities {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataAbilities();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.abilities.push(CMsgGameDataAbilityOrItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataAbilities {
    return {
      abilities: globalThis.Array.isArray(object?.abilities)
        ? object.abilities.map((e: any) => CMsgGameDataAbilityOrItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGameDataAbilities): unknown {
    const obj: any = {};
    if (message.abilities?.length) {
      obj.abilities = message.abilities.map((e) => CMsgGameDataAbilityOrItem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataAbilities>): CMsgGameDataAbilities {
    return CMsgGameDataAbilities.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataAbilities>): CMsgGameDataAbilities {
    const message = createBaseCMsgGameDataAbilities();
    message.abilities = object.abilities?.map((e) => CMsgGameDataAbilityOrItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGameDataItems(): CMsgGameDataItems {
  return { items: [] };
}

export const CMsgGameDataItems: MessageFns<CMsgGameDataItems> = {
  encode(message: CMsgGameDataItems, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      CMsgGameDataAbilityOrItem.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGameDataItems {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataItems();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(CMsgGameDataAbilityOrItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataItems {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => CMsgGameDataAbilityOrItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGameDataItems): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => CMsgGameDataAbilityOrItem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataItems>): CMsgGameDataItems {
    return CMsgGameDataItems.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataItems>): CMsgGameDataItems {
    const message = createBaseCMsgGameDataItems();
    message.items = object.items?.map((e) => CMsgGameDataAbilityOrItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGameDataHeroes(): CMsgGameDataHeroes {
  return { heroes: [] };
}

export const CMsgGameDataHeroes: MessageFns<CMsgGameDataHeroes> = {
  encode(message: CMsgGameDataHeroes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.heroes) {
      CMsgGameDataHero.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGameDataHeroes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataHeroes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.heroes.push(CMsgGameDataHero.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataHeroes {
    return {
      heroes: globalThis.Array.isArray(object?.heroes)
        ? object.heroes.map((e: any) => CMsgGameDataHero.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGameDataHeroes): unknown {
    const obj: any = {};
    if (message.heroes?.length) {
      obj.heroes = message.heroes.map((e) => CMsgGameDataHero.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataHeroes>): CMsgGameDataHeroes {
    return CMsgGameDataHeroes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataHeroes>): CMsgGameDataHeroes {
    const message = createBaseCMsgGameDataHeroes();
    message.heroes = object.heroes?.map((e) => CMsgGameDataHero.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGameDataHeroList(): CMsgGameDataHeroList {
  return { heroes: [] };
}

export const CMsgGameDataHeroList: MessageFns<CMsgGameDataHeroList> = {
  encode(message: CMsgGameDataHeroList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.heroes) {
      CMsgGameDataHeroList_HeroInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGameDataHeroList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataHeroList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.heroes.push(CMsgGameDataHeroList_HeroInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataHeroList {
    return {
      heroes: globalThis.Array.isArray(object?.heroes)
        ? object.heroes.map((e: any) => CMsgGameDataHeroList_HeroInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGameDataHeroList): unknown {
    const obj: any = {};
    if (message.heroes?.length) {
      obj.heroes = message.heroes.map((e) => CMsgGameDataHeroList_HeroInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataHeroList>): CMsgGameDataHeroList {
    return CMsgGameDataHeroList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataHeroList>): CMsgGameDataHeroList {
    const message = createBaseCMsgGameDataHeroList();
    message.heroes = object.heroes?.map((e) => CMsgGameDataHeroList_HeroInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGameDataHeroList_HeroInfo(): CMsgGameDataHeroList_HeroInfo {
  return { id: 0, name: "", nameLoc: "", nameEnglishLoc: "", primaryAttr: 0, complexity: 0 };
}

export const CMsgGameDataHeroList_HeroInfo: MessageFns<CMsgGameDataHeroList_HeroInfo> = {
  encode(message: CMsgGameDataHeroList_HeroInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.nameLoc !== "") {
      writer.uint32(26).string(message.nameLoc);
    }
    if (message.nameEnglishLoc !== "") {
      writer.uint32(34).string(message.nameEnglishLoc);
    }
    if (message.primaryAttr !== 0) {
      writer.uint32(40).uint32(message.primaryAttr);
    }
    if (message.complexity !== 0) {
      writer.uint32(48).uint32(message.complexity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGameDataHeroList_HeroInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataHeroList_HeroInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nameLoc = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nameEnglishLoc = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.primaryAttr = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.complexity = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataHeroList_HeroInfo {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nameLoc: isSet(object.nameLoc) ? globalThis.String(object.nameLoc) : "",
      nameEnglishLoc: isSet(object.nameEnglishLoc) ? globalThis.String(object.nameEnglishLoc) : "",
      primaryAttr: isSet(object.primaryAttr) ? globalThis.Number(object.primaryAttr) : 0,
      complexity: isSet(object.complexity) ? globalThis.Number(object.complexity) : 0,
    };
  },

  toJSON(message: CMsgGameDataHeroList_HeroInfo): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.nameLoc !== "") {
      obj.nameLoc = message.nameLoc;
    }
    if (message.nameEnglishLoc !== "") {
      obj.nameEnglishLoc = message.nameEnglishLoc;
    }
    if (message.primaryAttr !== 0) {
      obj.primaryAttr = Math.round(message.primaryAttr);
    }
    if (message.complexity !== 0) {
      obj.complexity = Math.round(message.complexity);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataHeroList_HeroInfo>): CMsgGameDataHeroList_HeroInfo {
    return CMsgGameDataHeroList_HeroInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataHeroList_HeroInfo>): CMsgGameDataHeroList_HeroInfo {
    const message = createBaseCMsgGameDataHeroList_HeroInfo();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.nameLoc = object.nameLoc ?? "";
    message.nameEnglishLoc = object.nameEnglishLoc ?? "";
    message.primaryAttr = object.primaryAttr ?? 0;
    message.complexity = object.complexity ?? 0;
    return message;
  },
};

function createBaseCMsgGameDataItemAbilityList(): CMsgGameDataItemAbilityList {
  return { itemabilities: [] };
}

export const CMsgGameDataItemAbilityList: MessageFns<CMsgGameDataItemAbilityList> = {
  encode(message: CMsgGameDataItemAbilityList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.itemabilities) {
      CMsgGameDataItemAbilityList_ItemAbilityInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGameDataItemAbilityList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataItemAbilityList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.itemabilities.push(CMsgGameDataItemAbilityList_ItemAbilityInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataItemAbilityList {
    return {
      itemabilities: globalThis.Array.isArray(object?.itemabilities)
        ? object.itemabilities.map((e: any) => CMsgGameDataItemAbilityList_ItemAbilityInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGameDataItemAbilityList): unknown {
    const obj: any = {};
    if (message.itemabilities?.length) {
      obj.itemabilities = message.itemabilities.map((e) => CMsgGameDataItemAbilityList_ItemAbilityInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataItemAbilityList>): CMsgGameDataItemAbilityList {
    return CMsgGameDataItemAbilityList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataItemAbilityList>): CMsgGameDataItemAbilityList {
    const message = createBaseCMsgGameDataItemAbilityList();
    message.itemabilities =
      object.itemabilities?.map((e) => CMsgGameDataItemAbilityList_ItemAbilityInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGameDataItemAbilityList_ItemAbilityInfo(): CMsgGameDataItemAbilityList_ItemAbilityInfo {
  return { id: -1, name: "", nameLoc: "", nameEnglishLoc: "", neutralItemTier: 0 };
}

export const CMsgGameDataItemAbilityList_ItemAbilityInfo: MessageFns<CMsgGameDataItemAbilityList_ItemAbilityInfo> = {
  encode(
    message: CMsgGameDataItemAbilityList_ItemAbilityInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== -1) {
      writer.uint32(8).int32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.nameLoc !== "") {
      writer.uint32(26).string(message.nameLoc);
    }
    if (message.nameEnglishLoc !== "") {
      writer.uint32(34).string(message.nameEnglishLoc);
    }
    if (message.neutralItemTier !== 0) {
      writer.uint32(40).int32(message.neutralItemTier);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGameDataItemAbilityList_ItemAbilityInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataItemAbilityList_ItemAbilityInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nameLoc = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nameEnglishLoc = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.neutralItemTier = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataItemAbilityList_ItemAbilityInfo {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : -1,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nameLoc: isSet(object.nameLoc) ? globalThis.String(object.nameLoc) : "",
      nameEnglishLoc: isSet(object.nameEnglishLoc) ? globalThis.String(object.nameEnglishLoc) : "",
      neutralItemTier: isSet(object.neutralItemTier) ? globalThis.Number(object.neutralItemTier) : 0,
    };
  },

  toJSON(message: CMsgGameDataItemAbilityList_ItemAbilityInfo): unknown {
    const obj: any = {};
    if (message.id !== -1) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.nameLoc !== "") {
      obj.nameLoc = message.nameLoc;
    }
    if (message.nameEnglishLoc !== "") {
      obj.nameEnglishLoc = message.nameEnglishLoc;
    }
    if (message.neutralItemTier !== 0) {
      obj.neutralItemTier = Math.round(message.neutralItemTier);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataItemAbilityList_ItemAbilityInfo>): CMsgGameDataItemAbilityList_ItemAbilityInfo {
    return CMsgGameDataItemAbilityList_ItemAbilityInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGameDataItemAbilityList_ItemAbilityInfo>,
  ): CMsgGameDataItemAbilityList_ItemAbilityInfo {
    const message = createBaseCMsgGameDataItemAbilityList_ItemAbilityInfo();
    message.id = object.id ?? -1;
    message.name = object.name ?? "";
    message.nameLoc = object.nameLoc ?? "";
    message.nameEnglishLoc = object.nameEnglishLoc ?? "";
    message.neutralItemTier = object.neutralItemTier ?? 0;
    return message;
  },
};

function createBaseCMsgLobbyAbilityDraftData(): CMsgLobbyAbilityDraftData {
  return { shuffleDraftOrder: false };
}

export const CMsgLobbyAbilityDraftData: MessageFns<CMsgLobbyAbilityDraftData> = {
  encode(message: CMsgLobbyAbilityDraftData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shuffleDraftOrder !== false) {
      writer.uint32(8).bool(message.shuffleDraftOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgLobbyAbilityDraftData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLobbyAbilityDraftData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.shuffleDraftOrder = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLobbyAbilityDraftData {
    return {
      shuffleDraftOrder: isSet(object.shuffleDraftOrder) ? globalThis.Boolean(object.shuffleDraftOrder) : false,
    };
  },

  toJSON(message: CMsgLobbyAbilityDraftData): unknown {
    const obj: any = {};
    if (message.shuffleDraftOrder !== false) {
      obj.shuffleDraftOrder = message.shuffleDraftOrder;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLobbyAbilityDraftData>): CMsgLobbyAbilityDraftData {
    return CMsgLobbyAbilityDraftData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLobbyAbilityDraftData>): CMsgLobbyAbilityDraftData {
    const message = createBaseCMsgLobbyAbilityDraftData();
    message.shuffleDraftOrder = object.shuffleDraftOrder ?? false;
    return message;
  },
};

function createBaseCSOEconItemDropRateBonus(): CSOEconItemDropRateBonus {
  return {
    accountId: 0,
    expirationDate: 0,
    bonus: 0,
    bonusCount: 0,
    itemId: "0",
    defIndex: 0,
    secondsLeft: 0,
    boosterType: 0,
  };
}

export const CSOEconItemDropRateBonus: MessageFns<CSOEconItemDropRateBonus> = {
  encode(message: CSOEconItemDropRateBonus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.expirationDate !== 0) {
      writer.uint32(21).fixed32(message.expirationDate);
    }
    if (message.bonus !== 0) {
      writer.uint32(29).float(message.bonus);
    }
    if (message.bonusCount !== 0) {
      writer.uint32(32).uint32(message.bonusCount);
    }
    if (message.itemId !== "0") {
      writer.uint32(40).uint64(message.itemId);
    }
    if (message.defIndex !== 0) {
      writer.uint32(48).uint32(message.defIndex);
    }
    if (message.secondsLeft !== 0) {
      writer.uint32(56).uint32(message.secondsLeft);
    }
    if (message.boosterType !== 0) {
      writer.uint32(64).uint32(message.boosterType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CSOEconItemDropRateBonus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSOEconItemDropRateBonus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.expirationDate = reader.fixed32();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.bonus = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.bonusCount = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.itemId = reader.uint64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.defIndex = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.secondsLeft = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.boosterType = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSOEconItemDropRateBonus {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      expirationDate: isSet(object.expirationDate) ? globalThis.Number(object.expirationDate) : 0,
      bonus: isSet(object.bonus) ? globalThis.Number(object.bonus) : 0,
      bonusCount: isSet(object.bonusCount) ? globalThis.Number(object.bonusCount) : 0,
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "0",
      defIndex: isSet(object.defIndex) ? globalThis.Number(object.defIndex) : 0,
      secondsLeft: isSet(object.secondsLeft) ? globalThis.Number(object.secondsLeft) : 0,
      boosterType: isSet(object.boosterType) ? globalThis.Number(object.boosterType) : 0,
    };
  },

  toJSON(message: CSOEconItemDropRateBonus): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.expirationDate !== 0) {
      obj.expirationDate = Math.round(message.expirationDate);
    }
    if (message.bonus !== 0) {
      obj.bonus = message.bonus;
    }
    if (message.bonusCount !== 0) {
      obj.bonusCount = Math.round(message.bonusCount);
    }
    if (message.itemId !== "0") {
      obj.itemId = message.itemId;
    }
    if (message.defIndex !== 0) {
      obj.defIndex = Math.round(message.defIndex);
    }
    if (message.secondsLeft !== 0) {
      obj.secondsLeft = Math.round(message.secondsLeft);
    }
    if (message.boosterType !== 0) {
      obj.boosterType = Math.round(message.boosterType);
    }
    return obj;
  },

  create(base?: DeepPartial<CSOEconItemDropRateBonus>): CSOEconItemDropRateBonus {
    return CSOEconItemDropRateBonus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSOEconItemDropRateBonus>): CSOEconItemDropRateBonus {
    const message = createBaseCSOEconItemDropRateBonus();
    message.accountId = object.accountId ?? 0;
    message.expirationDate = object.expirationDate ?? 0;
    message.bonus = object.bonus ?? 0;
    message.bonusCount = object.bonusCount ?? 0;
    message.itemId = object.itemId ?? "0";
    message.defIndex = object.defIndex ?? 0;
    message.secondsLeft = object.secondsLeft ?? 0;
    message.boosterType = object.boosterType ?? 0;
    return message;
  },
};

function createBaseCSOEconItemTournamentPassport(): CSOEconItemTournamentPassport {
  return {
    accountId: 0,
    leagueId: 0,
    itemId: "0",
    originalPurchaserId: 0,
    passportsBought: 0,
    version: 0,
    defIndex: 0,
    rewardFlags: 0,
  };
}

export const CSOEconItemTournamentPassport: MessageFns<CSOEconItemTournamentPassport> = {
  encode(message: CSOEconItemTournamentPassport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.leagueId !== 0) {
      writer.uint32(16).uint32(message.leagueId);
    }
    if (message.itemId !== "0") {
      writer.uint32(24).uint64(message.itemId);
    }
    if (message.originalPurchaserId !== 0) {
      writer.uint32(32).uint32(message.originalPurchaserId);
    }
    if (message.passportsBought !== 0) {
      writer.uint32(40).uint32(message.passportsBought);
    }
    if (message.version !== 0) {
      writer.uint32(48).uint32(message.version);
    }
    if (message.defIndex !== 0) {
      writer.uint32(56).uint32(message.defIndex);
    }
    if (message.rewardFlags !== 0) {
      writer.uint32(64).uint32(message.rewardFlags);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CSOEconItemTournamentPassport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSOEconItemTournamentPassport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.itemId = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.originalPurchaserId = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.passportsBought = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.defIndex = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.rewardFlags = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSOEconItemTournamentPassport {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "0",
      originalPurchaserId: isSet(object.originalPurchaserId) ? globalThis.Number(object.originalPurchaserId) : 0,
      passportsBought: isSet(object.passportsBought) ? globalThis.Number(object.passportsBought) : 0,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      defIndex: isSet(object.defIndex) ? globalThis.Number(object.defIndex) : 0,
      rewardFlags: isSet(object.rewardFlags) ? globalThis.Number(object.rewardFlags) : 0,
    };
  },

  toJSON(message: CSOEconItemTournamentPassport): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.itemId !== "0") {
      obj.itemId = message.itemId;
    }
    if (message.originalPurchaserId !== 0) {
      obj.originalPurchaserId = Math.round(message.originalPurchaserId);
    }
    if (message.passportsBought !== 0) {
      obj.passportsBought = Math.round(message.passportsBought);
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.defIndex !== 0) {
      obj.defIndex = Math.round(message.defIndex);
    }
    if (message.rewardFlags !== 0) {
      obj.rewardFlags = Math.round(message.rewardFlags);
    }
    return obj;
  },

  create(base?: DeepPartial<CSOEconItemTournamentPassport>): CSOEconItemTournamentPassport {
    return CSOEconItemTournamentPassport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSOEconItemTournamentPassport>): CSOEconItemTournamentPassport {
    const message = createBaseCSOEconItemTournamentPassport();
    message.accountId = object.accountId ?? 0;
    message.leagueId = object.leagueId ?? 0;
    message.itemId = object.itemId ?? "0";
    message.originalPurchaserId = object.originalPurchaserId ?? 0;
    message.passportsBought = object.passportsBought ?? 0;
    message.version = object.version ?? 0;
    message.defIndex = object.defIndex ?? 0;
    message.rewardFlags = object.rewardFlags ?? 0;
    return message;
  },
};

function createBaseCMsgStickerbookSticker(): CMsgStickerbookSticker {
  return {
    itemDefId: 0,
    stickerNum: 0,
    quality: 0,
    positionX: 0,
    positionY: 0,
    positionZ: 0,
    rotation: 0,
    scale: 0,
    sourceItemId: "0",
    depthBias: 0,
  };
}

export const CMsgStickerbookSticker: MessageFns<CMsgStickerbookSticker> = {
  encode(message: CMsgStickerbookSticker, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.itemDefId !== 0) {
      writer.uint32(8).uint32(message.itemDefId);
    }
    if (message.stickerNum !== 0) {
      writer.uint32(16).uint32(message.stickerNum);
    }
    if (message.quality !== 0) {
      writer.uint32(24).uint32(message.quality);
    }
    if (message.positionX !== 0) {
      writer.uint32(37).float(message.positionX);
    }
    if (message.positionY !== 0) {
      writer.uint32(45).float(message.positionY);
    }
    if (message.positionZ !== 0) {
      writer.uint32(69).float(message.positionZ);
    }
    if (message.rotation !== 0) {
      writer.uint32(53).float(message.rotation);
    }
    if (message.scale !== 0) {
      writer.uint32(61).float(message.scale);
    }
    if (message.sourceItemId !== "0") {
      writer.uint32(72).uint64(message.sourceItemId);
    }
    if (message.depthBias !== 0) {
      writer.uint32(80).uint32(message.depthBias);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgStickerbookSticker {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgStickerbookSticker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.itemDefId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.stickerNum = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.quality = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.positionX = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.positionY = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.positionZ = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.rotation = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.scale = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.sourceItemId = reader.uint64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.depthBias = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgStickerbookSticker {
    return {
      itemDefId: isSet(object.itemDefId) ? globalThis.Number(object.itemDefId) : 0,
      stickerNum: isSet(object.stickerNum) ? globalThis.Number(object.stickerNum) : 0,
      quality: isSet(object.quality) ? globalThis.Number(object.quality) : 0,
      positionX: isSet(object.positionX) ? globalThis.Number(object.positionX) : 0,
      positionY: isSet(object.positionY) ? globalThis.Number(object.positionY) : 0,
      positionZ: isSet(object.positionZ) ? globalThis.Number(object.positionZ) : 0,
      rotation: isSet(object.rotation) ? globalThis.Number(object.rotation) : 0,
      scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0,
      sourceItemId: isSet(object.sourceItemId) ? globalThis.String(object.sourceItemId) : "0",
      depthBias: isSet(object.depthBias) ? globalThis.Number(object.depthBias) : 0,
    };
  },

  toJSON(message: CMsgStickerbookSticker): unknown {
    const obj: any = {};
    if (message.itemDefId !== 0) {
      obj.itemDefId = Math.round(message.itemDefId);
    }
    if (message.stickerNum !== 0) {
      obj.stickerNum = Math.round(message.stickerNum);
    }
    if (message.quality !== 0) {
      obj.quality = Math.round(message.quality);
    }
    if (message.positionX !== 0) {
      obj.positionX = message.positionX;
    }
    if (message.positionY !== 0) {
      obj.positionY = message.positionY;
    }
    if (message.positionZ !== 0) {
      obj.positionZ = message.positionZ;
    }
    if (message.rotation !== 0) {
      obj.rotation = message.rotation;
    }
    if (message.scale !== 0) {
      obj.scale = message.scale;
    }
    if (message.sourceItemId !== "0") {
      obj.sourceItemId = message.sourceItemId;
    }
    if (message.depthBias !== 0) {
      obj.depthBias = Math.round(message.depthBias);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgStickerbookSticker>): CMsgStickerbookSticker {
    return CMsgStickerbookSticker.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgStickerbookSticker>): CMsgStickerbookSticker {
    const message = createBaseCMsgStickerbookSticker();
    message.itemDefId = object.itemDefId ?? 0;
    message.stickerNum = object.stickerNum ?? 0;
    message.quality = object.quality ?? 0;
    message.positionX = object.positionX ?? 0;
    message.positionY = object.positionY ?? 0;
    message.positionZ = object.positionZ ?? 0;
    message.rotation = object.rotation ?? 0;
    message.scale = object.scale ?? 0;
    message.sourceItemId = object.sourceItemId ?? "0";
    message.depthBias = object.depthBias ?? 0;
    return message;
  },
};

function createBaseCMsgStickerbookPage(): CMsgStickerbookPage {
  return { pageNum: 0, eventId: 0, teamId: 0, stickers: [], pageType: 0 };
}

export const CMsgStickerbookPage: MessageFns<CMsgStickerbookPage> = {
  encode(message: CMsgStickerbookPage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageNum !== 0) {
      writer.uint32(8).uint32(message.pageNum);
    }
    if (message.eventId !== 0) {
      writer.uint32(16).int32(message.eventId);
    }
    if (message.teamId !== 0) {
      writer.uint32(24).uint32(message.teamId);
    }
    for (const v of message.stickers) {
      CMsgStickerbookSticker.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.pageType !== 0) {
      writer.uint32(40).int32(message.pageType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgStickerbookPage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgStickerbookPage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageNum = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stickers.push(CMsgStickerbookSticker.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pageType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgStickerbookPage {
    return {
      pageNum: isSet(object.pageNum) ? globalThis.Number(object.pageNum) : 0,
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      stickers: globalThis.Array.isArray(object?.stickers)
        ? object.stickers.map((e: any) => CMsgStickerbookSticker.fromJSON(e))
        : [],
      pageType: isSet(object.pageType) ? eStickerbookPageTypeFromJSON(object.pageType) : 0,
    };
  },

  toJSON(message: CMsgStickerbookPage): unknown {
    const obj: any = {};
    if (message.pageNum !== 0) {
      obj.pageNum = Math.round(message.pageNum);
    }
    if (message.eventId !== 0) {
      obj.eventId = eEventToJSON(message.eventId);
    }
    if (message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.stickers?.length) {
      obj.stickers = message.stickers.map((e) => CMsgStickerbookSticker.toJSON(e));
    }
    if (message.pageType !== 0) {
      obj.pageType = eStickerbookPageTypeToJSON(message.pageType);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgStickerbookPage>): CMsgStickerbookPage {
    return CMsgStickerbookPage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgStickerbookPage>): CMsgStickerbookPage {
    const message = createBaseCMsgStickerbookPage();
    message.pageNum = object.pageNum ?? 0;
    message.eventId = object.eventId ?? 0;
    message.teamId = object.teamId ?? 0;
    message.stickers = object.stickers?.map((e) => CMsgStickerbookSticker.fromPartial(e)) || [];
    message.pageType = object.pageType ?? 0;
    return message;
  },
};

function createBaseCMsgStickerbookTeamPageOrderSequence(): CMsgStickerbookTeamPageOrderSequence {
  return { pageNumbers: [] };
}

export const CMsgStickerbookTeamPageOrderSequence: MessageFns<CMsgStickerbookTeamPageOrderSequence> = {
  encode(message: CMsgStickerbookTeamPageOrderSequence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.pageNumbers) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgStickerbookTeamPageOrderSequence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgStickerbookTeamPageOrderSequence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.pageNumbers.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.pageNumbers.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgStickerbookTeamPageOrderSequence {
    return {
      pageNumbers: globalThis.Array.isArray(object?.pageNumbers)
        ? object.pageNumbers.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgStickerbookTeamPageOrderSequence): unknown {
    const obj: any = {};
    if (message.pageNumbers?.length) {
      obj.pageNumbers = message.pageNumbers.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgStickerbookTeamPageOrderSequence>): CMsgStickerbookTeamPageOrderSequence {
    return CMsgStickerbookTeamPageOrderSequence.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgStickerbookTeamPageOrderSequence>): CMsgStickerbookTeamPageOrderSequence {
    const message = createBaseCMsgStickerbookTeamPageOrderSequence();
    message.pageNumbers = object.pageNumbers?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgStickerbook(): CMsgStickerbook {
  return { pages: [], teamPageOrderSequence: undefined, favoritePageNum: 0 };
}

export const CMsgStickerbook: MessageFns<CMsgStickerbook> = {
  encode(message: CMsgStickerbook, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pages) {
      CMsgStickerbookPage.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.teamPageOrderSequence !== undefined) {
      CMsgStickerbookTeamPageOrderSequence.encode(message.teamPageOrderSequence, writer.uint32(18).fork()).join();
    }
    if (message.favoritePageNum !== 0) {
      writer.uint32(24).uint32(message.favoritePageNum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgStickerbook {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgStickerbook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pages.push(CMsgStickerbookPage.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.teamPageOrderSequence = CMsgStickerbookTeamPageOrderSequence.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.favoritePageNum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgStickerbook {
    return {
      pages: globalThis.Array.isArray(object?.pages)
        ? object.pages.map((e: any) => CMsgStickerbookPage.fromJSON(e))
        : [],
      teamPageOrderSequence: isSet(object.teamPageOrderSequence)
        ? CMsgStickerbookTeamPageOrderSequence.fromJSON(object.teamPageOrderSequence)
        : undefined,
      favoritePageNum: isSet(object.favoritePageNum) ? globalThis.Number(object.favoritePageNum) : 0,
    };
  },

  toJSON(message: CMsgStickerbook): unknown {
    const obj: any = {};
    if (message.pages?.length) {
      obj.pages = message.pages.map((e) => CMsgStickerbookPage.toJSON(e));
    }
    if (message.teamPageOrderSequence !== undefined) {
      obj.teamPageOrderSequence = CMsgStickerbookTeamPageOrderSequence.toJSON(message.teamPageOrderSequence);
    }
    if (message.favoritePageNum !== 0) {
      obj.favoritePageNum = Math.round(message.favoritePageNum);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgStickerbook>): CMsgStickerbook {
    return CMsgStickerbook.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgStickerbook>): CMsgStickerbook {
    const message = createBaseCMsgStickerbook();
    message.pages = object.pages?.map((e) => CMsgStickerbookPage.fromPartial(e)) || [];
    message.teamPageOrderSequence =
      (object.teamPageOrderSequence !== undefined && object.teamPageOrderSequence !== null)
        ? CMsgStickerbookTeamPageOrderSequence.fromPartial(object.teamPageOrderSequence)
        : undefined;
    message.favoritePageNum = object.favoritePageNum ?? 0;
    return message;
  },
};

function createBaseCMsgStickerHero(): CMsgStickerHero {
  return { heroId: 0, itemDefId: 0, quality: 0, sourceItemId: "0" };
}

export const CMsgStickerHero: MessageFns<CMsgStickerHero> = {
  encode(message: CMsgStickerHero, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.heroId !== 0) {
      writer.uint32(8).uint32(message.heroId);
    }
    if (message.itemDefId !== 0) {
      writer.uint32(16).uint32(message.itemDefId);
    }
    if (message.quality !== 0) {
      writer.uint32(24).uint32(message.quality);
    }
    if (message.sourceItemId !== "0") {
      writer.uint32(32).uint64(message.sourceItemId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgStickerHero {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgStickerHero();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.itemDefId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.quality = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sourceItemId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgStickerHero {
    return {
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      itemDefId: isSet(object.itemDefId) ? globalThis.Number(object.itemDefId) : 0,
      quality: isSet(object.quality) ? globalThis.Number(object.quality) : 0,
      sourceItemId: isSet(object.sourceItemId) ? globalThis.String(object.sourceItemId) : "0",
    };
  },

  toJSON(message: CMsgStickerHero): unknown {
    const obj: any = {};
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.itemDefId !== 0) {
      obj.itemDefId = Math.round(message.itemDefId);
    }
    if (message.quality !== 0) {
      obj.quality = Math.round(message.quality);
    }
    if (message.sourceItemId !== "0") {
      obj.sourceItemId = message.sourceItemId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgStickerHero>): CMsgStickerHero {
    return CMsgStickerHero.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgStickerHero>): CMsgStickerHero {
    const message = createBaseCMsgStickerHero();
    message.heroId = object.heroId ?? 0;
    message.itemDefId = object.itemDefId ?? 0;
    message.quality = object.quality ?? 0;
    message.sourceItemId = object.sourceItemId ?? "0";
    return message;
  },
};

function createBaseCMsgStickerHeroes(): CMsgStickerHeroes {
  return { heroes: [] };
}

export const CMsgStickerHeroes: MessageFns<CMsgStickerHeroes> = {
  encode(message: CMsgStickerHeroes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.heroes) {
      CMsgStickerHero.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgStickerHeroes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgStickerHeroes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.heroes.push(CMsgStickerHero.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgStickerHeroes {
    return {
      heroes: globalThis.Array.isArray(object?.heroes)
        ? object.heroes.map((e: any) => CMsgStickerHero.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgStickerHeroes): unknown {
    const obj: any = {};
    if (message.heroes?.length) {
      obj.heroes = message.heroes.map((e) => CMsgStickerHero.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgStickerHeroes>): CMsgStickerHeroes {
    return CMsgStickerHeroes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgStickerHeroes>): CMsgStickerHeroes {
    const message = createBaseCMsgStickerHeroes();
    message.heroes = object.heroes?.map((e) => CMsgStickerHero.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgHeroRoleStats(): CMsgHeroRoleStats {
  return { laneSelectionFlags: 0, matchCount: 0, winCount: 0 };
}

export const CMsgHeroRoleStats: MessageFns<CMsgHeroRoleStats> = {
  encode(message: CMsgHeroRoleStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.laneSelectionFlags !== 0) {
      writer.uint32(8).uint32(message.laneSelectionFlags);
    }
    if (message.matchCount !== 0) {
      writer.uint32(16).uint32(message.matchCount);
    }
    if (message.winCount !== 0) {
      writer.uint32(24).uint32(message.winCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgHeroRoleStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHeroRoleStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.laneSelectionFlags = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.matchCount = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.winCount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHeroRoleStats {
    return {
      laneSelectionFlags: isSet(object.laneSelectionFlags) ? globalThis.Number(object.laneSelectionFlags) : 0,
      matchCount: isSet(object.matchCount) ? globalThis.Number(object.matchCount) : 0,
      winCount: isSet(object.winCount) ? globalThis.Number(object.winCount) : 0,
    };
  },

  toJSON(message: CMsgHeroRoleStats): unknown {
    const obj: any = {};
    if (message.laneSelectionFlags !== 0) {
      obj.laneSelectionFlags = Math.round(message.laneSelectionFlags);
    }
    if (message.matchCount !== 0) {
      obj.matchCount = Math.round(message.matchCount);
    }
    if (message.winCount !== 0) {
      obj.winCount = Math.round(message.winCount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgHeroRoleStats>): CMsgHeroRoleStats {
    return CMsgHeroRoleStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgHeroRoleStats>): CMsgHeroRoleStats {
    const message = createBaseCMsgHeroRoleStats();
    message.laneSelectionFlags = object.laneSelectionFlags ?? 0;
    message.matchCount = object.matchCount ?? 0;
    message.winCount = object.winCount ?? 0;
    return message;
  },
};

function createBaseCMsgHeroRoleHeroStats(): CMsgHeroRoleHeroStats {
  return { heroId: 0, roleStats: [] };
}

export const CMsgHeroRoleHeroStats: MessageFns<CMsgHeroRoleHeroStats> = {
  encode(message: CMsgHeroRoleHeroStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.heroId !== 0) {
      writer.uint32(8).uint32(message.heroId);
    }
    for (const v of message.roleStats) {
      CMsgHeroRoleStats.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgHeroRoleHeroStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHeroRoleHeroStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.roleStats.push(CMsgHeroRoleStats.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHeroRoleHeroStats {
    return {
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      roleStats: globalThis.Array.isArray(object?.roleStats)
        ? object.roleStats.map((e: any) => CMsgHeroRoleStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgHeroRoleHeroStats): unknown {
    const obj: any = {};
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.roleStats?.length) {
      obj.roleStats = message.roleStats.map((e) => CMsgHeroRoleStats.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgHeroRoleHeroStats>): CMsgHeroRoleHeroStats {
    return CMsgHeroRoleHeroStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgHeroRoleHeroStats>): CMsgHeroRoleHeroStats {
    const message = createBaseCMsgHeroRoleHeroStats();
    message.heroId = object.heroId ?? 0;
    message.roleStats = object.roleStats?.map((e) => CMsgHeroRoleStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgHeroRoleRankStats(): CMsgHeroRoleRankStats {
  return { rankTier: 0, heroStats: [] };
}

export const CMsgHeroRoleRankStats: MessageFns<CMsgHeroRoleRankStats> = {
  encode(message: CMsgHeroRoleRankStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rankTier !== 0) {
      writer.uint32(8).uint32(message.rankTier);
    }
    for (const v of message.heroStats) {
      CMsgHeroRoleHeroStats.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgHeroRoleRankStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHeroRoleRankStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rankTier = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.heroStats.push(CMsgHeroRoleHeroStats.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHeroRoleRankStats {
    return {
      rankTier: isSet(object.rankTier) ? globalThis.Number(object.rankTier) : 0,
      heroStats: globalThis.Array.isArray(object?.heroStats)
        ? object.heroStats.map((e: any) => CMsgHeroRoleHeroStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgHeroRoleRankStats): unknown {
    const obj: any = {};
    if (message.rankTier !== 0) {
      obj.rankTier = Math.round(message.rankTier);
    }
    if (message.heroStats?.length) {
      obj.heroStats = message.heroStats.map((e) => CMsgHeroRoleHeroStats.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgHeroRoleRankStats>): CMsgHeroRoleRankStats {
    return CMsgHeroRoleRankStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgHeroRoleRankStats>): CMsgHeroRoleRankStats {
    const message = createBaseCMsgHeroRoleRankStats();
    message.rankTier = object.rankTier ?? 0;
    message.heroStats = object.heroStats?.map((e) => CMsgHeroRoleHeroStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgHeroRoleAllRanksStats(): CMsgHeroRoleAllRanksStats {
  return { startTimestamp: 0, endTimestamp: 0, rankStats: [] };
}

export const CMsgHeroRoleAllRanksStats: MessageFns<CMsgHeroRoleAllRanksStats> = {
  encode(message: CMsgHeroRoleAllRanksStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTimestamp !== 0) {
      writer.uint32(8).uint32(message.startTimestamp);
    }
    if (message.endTimestamp !== 0) {
      writer.uint32(16).uint32(message.endTimestamp);
    }
    for (const v of message.rankStats) {
      CMsgHeroRoleRankStats.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgHeroRoleAllRanksStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHeroRoleAllRanksStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.startTimestamp = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.endTimestamp = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rankStats.push(CMsgHeroRoleRankStats.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHeroRoleAllRanksStats {
    return {
      startTimestamp: isSet(object.startTimestamp) ? globalThis.Number(object.startTimestamp) : 0,
      endTimestamp: isSet(object.endTimestamp) ? globalThis.Number(object.endTimestamp) : 0,
      rankStats: globalThis.Array.isArray(object?.rankStats)
        ? object.rankStats.map((e: any) => CMsgHeroRoleRankStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgHeroRoleAllRanksStats): unknown {
    const obj: any = {};
    if (message.startTimestamp !== 0) {
      obj.startTimestamp = Math.round(message.startTimestamp);
    }
    if (message.endTimestamp !== 0) {
      obj.endTimestamp = Math.round(message.endTimestamp);
    }
    if (message.rankStats?.length) {
      obj.rankStats = message.rankStats.map((e) => CMsgHeroRoleRankStats.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgHeroRoleAllRanksStats>): CMsgHeroRoleAllRanksStats {
    return CMsgHeroRoleAllRanksStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgHeroRoleAllRanksStats>): CMsgHeroRoleAllRanksStats {
    const message = createBaseCMsgHeroRoleAllRanksStats();
    message.startTimestamp = object.startTimestamp ?? 0;
    message.endTimestamp = object.endTimestamp ?? 0;
    message.rankStats = object.rankStats?.map((e) => CMsgHeroRoleRankStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgMapStatsSnapshot(): CMsgMapStatsSnapshot {
  return {
    timestamp: 0,
    famangosGained: "0",
    wisdomRunesGained: "0",
    roshanKillsDay: "0",
    roshanKillsNight: "0",
    portalsUsed: "0",
    lanternsLit: "0",
    minibossKills: "0",
    outpostsCaptured: "0",
    shieldRunesGained: "0",
  };
}

export const CMsgMapStatsSnapshot: MessageFns<CMsgMapStatsSnapshot> = {
  encode(message: CMsgMapStatsSnapshot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== 0) {
      writer.uint32(8).uint32(message.timestamp);
    }
    if (message.famangosGained !== "0") {
      writer.uint32(16).uint64(message.famangosGained);
    }
    if (message.wisdomRunesGained !== "0") {
      writer.uint32(24).uint64(message.wisdomRunesGained);
    }
    if (message.roshanKillsDay !== "0") {
      writer.uint32(32).uint64(message.roshanKillsDay);
    }
    if (message.roshanKillsNight !== "0") {
      writer.uint32(40).uint64(message.roshanKillsNight);
    }
    if (message.portalsUsed !== "0") {
      writer.uint32(48).uint64(message.portalsUsed);
    }
    if (message.lanternsLit !== "0") {
      writer.uint32(56).uint64(message.lanternsLit);
    }
    if (message.minibossKills !== "0") {
      writer.uint32(64).uint64(message.minibossKills);
    }
    if (message.outpostsCaptured !== "0") {
      writer.uint32(72).uint64(message.outpostsCaptured);
    }
    if (message.shieldRunesGained !== "0") {
      writer.uint32(80).uint64(message.shieldRunesGained);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgMapStatsSnapshot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgMapStatsSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.famangosGained = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.wisdomRunesGained = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.roshanKillsDay = reader.uint64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.roshanKillsNight = reader.uint64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.portalsUsed = reader.uint64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.lanternsLit = reader.uint64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.minibossKills = reader.uint64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.outpostsCaptured = reader.uint64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.shieldRunesGained = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgMapStatsSnapshot {
    return {
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      famangosGained: isSet(object.famangosGained) ? globalThis.String(object.famangosGained) : "0",
      wisdomRunesGained: isSet(object.wisdomRunesGained) ? globalThis.String(object.wisdomRunesGained) : "0",
      roshanKillsDay: isSet(object.roshanKillsDay) ? globalThis.String(object.roshanKillsDay) : "0",
      roshanKillsNight: isSet(object.roshanKillsNight) ? globalThis.String(object.roshanKillsNight) : "0",
      portalsUsed: isSet(object.portalsUsed) ? globalThis.String(object.portalsUsed) : "0",
      lanternsLit: isSet(object.lanternsLit) ? globalThis.String(object.lanternsLit) : "0",
      minibossKills: isSet(object.minibossKills) ? globalThis.String(object.minibossKills) : "0",
      outpostsCaptured: isSet(object.outpostsCaptured) ? globalThis.String(object.outpostsCaptured) : "0",
      shieldRunesGained: isSet(object.shieldRunesGained) ? globalThis.String(object.shieldRunesGained) : "0",
    };
  },

  toJSON(message: CMsgMapStatsSnapshot): unknown {
    const obj: any = {};
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.famangosGained !== "0") {
      obj.famangosGained = message.famangosGained;
    }
    if (message.wisdomRunesGained !== "0") {
      obj.wisdomRunesGained = message.wisdomRunesGained;
    }
    if (message.roshanKillsDay !== "0") {
      obj.roshanKillsDay = message.roshanKillsDay;
    }
    if (message.roshanKillsNight !== "0") {
      obj.roshanKillsNight = message.roshanKillsNight;
    }
    if (message.portalsUsed !== "0") {
      obj.portalsUsed = message.portalsUsed;
    }
    if (message.lanternsLit !== "0") {
      obj.lanternsLit = message.lanternsLit;
    }
    if (message.minibossKills !== "0") {
      obj.minibossKills = message.minibossKills;
    }
    if (message.outpostsCaptured !== "0") {
      obj.outpostsCaptured = message.outpostsCaptured;
    }
    if (message.shieldRunesGained !== "0") {
      obj.shieldRunesGained = message.shieldRunesGained;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgMapStatsSnapshot>): CMsgMapStatsSnapshot {
    return CMsgMapStatsSnapshot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgMapStatsSnapshot>): CMsgMapStatsSnapshot {
    const message = createBaseCMsgMapStatsSnapshot();
    message.timestamp = object.timestamp ?? 0;
    message.famangosGained = object.famangosGained ?? "0";
    message.wisdomRunesGained = object.wisdomRunesGained ?? "0";
    message.roshanKillsDay = object.roshanKillsDay ?? "0";
    message.roshanKillsNight = object.roshanKillsNight ?? "0";
    message.portalsUsed = object.portalsUsed ?? "0";
    message.lanternsLit = object.lanternsLit ?? "0";
    message.minibossKills = object.minibossKills ?? "0";
    message.outpostsCaptured = object.outpostsCaptured ?? "0";
    message.shieldRunesGained = object.shieldRunesGained ?? "0";
    return message;
  },
};

function createBaseCMsgGlobalMapStats(): CMsgGlobalMapStats {
  return { current: undefined, windowStart: undefined, windowEnd: undefined };
}

export const CMsgGlobalMapStats: MessageFns<CMsgGlobalMapStats> = {
  encode(message: CMsgGlobalMapStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.current !== undefined) {
      CMsgMapStatsSnapshot.encode(message.current, writer.uint32(10).fork()).join();
    }
    if (message.windowStart !== undefined) {
      CMsgMapStatsSnapshot.encode(message.windowStart, writer.uint32(18).fork()).join();
    }
    if (message.windowEnd !== undefined) {
      CMsgMapStatsSnapshot.encode(message.windowEnd, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGlobalMapStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGlobalMapStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.current = CMsgMapStatsSnapshot.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.windowStart = CMsgMapStatsSnapshot.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.windowEnd = CMsgMapStatsSnapshot.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGlobalMapStats {
    return {
      current: isSet(object.current) ? CMsgMapStatsSnapshot.fromJSON(object.current) : undefined,
      windowStart: isSet(object.windowStart) ? CMsgMapStatsSnapshot.fromJSON(object.windowStart) : undefined,
      windowEnd: isSet(object.windowEnd) ? CMsgMapStatsSnapshot.fromJSON(object.windowEnd) : undefined,
    };
  },

  toJSON(message: CMsgGlobalMapStats): unknown {
    const obj: any = {};
    if (message.current !== undefined) {
      obj.current = CMsgMapStatsSnapshot.toJSON(message.current);
    }
    if (message.windowStart !== undefined) {
      obj.windowStart = CMsgMapStatsSnapshot.toJSON(message.windowStart);
    }
    if (message.windowEnd !== undefined) {
      obj.windowEnd = CMsgMapStatsSnapshot.toJSON(message.windowEnd);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGlobalMapStats>): CMsgGlobalMapStats {
    return CMsgGlobalMapStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGlobalMapStats>): CMsgGlobalMapStats {
    const message = createBaseCMsgGlobalMapStats();
    message.current = (object.current !== undefined && object.current !== null)
      ? CMsgMapStatsSnapshot.fromPartial(object.current)
      : undefined;
    message.windowStart = (object.windowStart !== undefined && object.windowStart !== null)
      ? CMsgMapStatsSnapshot.fromPartial(object.windowStart)
      : undefined;
    message.windowEnd = (object.windowEnd !== undefined && object.windowEnd !== null)
      ? CMsgMapStatsSnapshot.fromPartial(object.windowEnd)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
