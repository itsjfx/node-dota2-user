// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.30.1
// source: base_gcmessages.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { CExtraMsgBlock } from "./gcsdk_gcmessages";
import { EGCPlatform, eGCPlatformFromJSON, eGCPlatformToJSON } from "./steammessages";
import { CMsgSteamLearnAccessTokens } from "./steammessages_steamlearn.steamworkssdk";

export enum EGCBaseMsg {
  k_EMsgGCInviteToParty = 4501,
  k_EMsgGCInvitationCreated = 4502,
  k_EMsgGCPartyInviteResponse = 4503,
  k_EMsgGCKickFromParty = 4504,
  k_EMsgGCLeaveParty = 4505,
  k_EMsgGCServerAvailable = 4506,
  k_EMsgGCClientConnectToServer = 4507,
  k_EMsgGCGameServerInfo = 4508,
  k_EMsgGCLANServerAvailable = 4511,
  k_EMsgGCInviteToLobby = 4512,
  k_EMsgGCLobbyInviteResponse = 4513,
  k_EMsgGCToClientPollFileRequest = 4514,
  k_EMsgGCToClientPollFileResponse = 4515,
  k_EMsgGCToGCPerformManualOp = 4516,
  k_EMsgGCToGCPerformManualOpCompleted = 4517,
  k_EMsgGCToGCReloadServerRegionSettings = 4518,
  k_EMsgGCAdditionalWelcomeMsgList = 4519,
  k_EMsgGCToClientApplyRemoteConVars = 4520,
  k_EMsgGCToServerApplyRemoteConVars = 4521,
  k_EMsgClientToGCIntegrityStatus = 4522,
  k_EMsgClientToGCAggregateMetrics = 4523,
  k_EMsgGCToClientAggregateMetricsBackoff = 4524,
  k_EMsgGCToServerSteamLearnAccessTokensChanged = 4525,
  k_EMsgGCToServerSteamLearnUseHTTP = 4526,
}

export function eGCBaseMsgFromJSON(object: any): EGCBaseMsg {
  switch (object) {
    case 4501:
    case "k_EMsgGCInviteToParty":
      return EGCBaseMsg.k_EMsgGCInviteToParty;
    case 4502:
    case "k_EMsgGCInvitationCreated":
      return EGCBaseMsg.k_EMsgGCInvitationCreated;
    case 4503:
    case "k_EMsgGCPartyInviteResponse":
      return EGCBaseMsg.k_EMsgGCPartyInviteResponse;
    case 4504:
    case "k_EMsgGCKickFromParty":
      return EGCBaseMsg.k_EMsgGCKickFromParty;
    case 4505:
    case "k_EMsgGCLeaveParty":
      return EGCBaseMsg.k_EMsgGCLeaveParty;
    case 4506:
    case "k_EMsgGCServerAvailable":
      return EGCBaseMsg.k_EMsgGCServerAvailable;
    case 4507:
    case "k_EMsgGCClientConnectToServer":
      return EGCBaseMsg.k_EMsgGCClientConnectToServer;
    case 4508:
    case "k_EMsgGCGameServerInfo":
      return EGCBaseMsg.k_EMsgGCGameServerInfo;
    case 4511:
    case "k_EMsgGCLANServerAvailable":
      return EGCBaseMsg.k_EMsgGCLANServerAvailable;
    case 4512:
    case "k_EMsgGCInviteToLobby":
      return EGCBaseMsg.k_EMsgGCInviteToLobby;
    case 4513:
    case "k_EMsgGCLobbyInviteResponse":
      return EGCBaseMsg.k_EMsgGCLobbyInviteResponse;
    case 4514:
    case "k_EMsgGCToClientPollFileRequest":
      return EGCBaseMsg.k_EMsgGCToClientPollFileRequest;
    case 4515:
    case "k_EMsgGCToClientPollFileResponse":
      return EGCBaseMsg.k_EMsgGCToClientPollFileResponse;
    case 4516:
    case "k_EMsgGCToGCPerformManualOp":
      return EGCBaseMsg.k_EMsgGCToGCPerformManualOp;
    case 4517:
    case "k_EMsgGCToGCPerformManualOpCompleted":
      return EGCBaseMsg.k_EMsgGCToGCPerformManualOpCompleted;
    case 4518:
    case "k_EMsgGCToGCReloadServerRegionSettings":
      return EGCBaseMsg.k_EMsgGCToGCReloadServerRegionSettings;
    case 4519:
    case "k_EMsgGCAdditionalWelcomeMsgList":
      return EGCBaseMsg.k_EMsgGCAdditionalWelcomeMsgList;
    case 4520:
    case "k_EMsgGCToClientApplyRemoteConVars":
      return EGCBaseMsg.k_EMsgGCToClientApplyRemoteConVars;
    case 4521:
    case "k_EMsgGCToServerApplyRemoteConVars":
      return EGCBaseMsg.k_EMsgGCToServerApplyRemoteConVars;
    case 4522:
    case "k_EMsgClientToGCIntegrityStatus":
      return EGCBaseMsg.k_EMsgClientToGCIntegrityStatus;
    case 4523:
    case "k_EMsgClientToGCAggregateMetrics":
      return EGCBaseMsg.k_EMsgClientToGCAggregateMetrics;
    case 4524:
    case "k_EMsgGCToClientAggregateMetricsBackoff":
      return EGCBaseMsg.k_EMsgGCToClientAggregateMetricsBackoff;
    case 4525:
    case "k_EMsgGCToServerSteamLearnAccessTokensChanged":
      return EGCBaseMsg.k_EMsgGCToServerSteamLearnAccessTokensChanged;
    case 4526:
    case "k_EMsgGCToServerSteamLearnUseHTTP":
      return EGCBaseMsg.k_EMsgGCToServerSteamLearnUseHTTP;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EGCBaseMsg");
  }
}

export function eGCBaseMsgToJSON(object: EGCBaseMsg): string {
  switch (object) {
    case EGCBaseMsg.k_EMsgGCInviteToParty:
      return "k_EMsgGCInviteToParty";
    case EGCBaseMsg.k_EMsgGCInvitationCreated:
      return "k_EMsgGCInvitationCreated";
    case EGCBaseMsg.k_EMsgGCPartyInviteResponse:
      return "k_EMsgGCPartyInviteResponse";
    case EGCBaseMsg.k_EMsgGCKickFromParty:
      return "k_EMsgGCKickFromParty";
    case EGCBaseMsg.k_EMsgGCLeaveParty:
      return "k_EMsgGCLeaveParty";
    case EGCBaseMsg.k_EMsgGCServerAvailable:
      return "k_EMsgGCServerAvailable";
    case EGCBaseMsg.k_EMsgGCClientConnectToServer:
      return "k_EMsgGCClientConnectToServer";
    case EGCBaseMsg.k_EMsgGCGameServerInfo:
      return "k_EMsgGCGameServerInfo";
    case EGCBaseMsg.k_EMsgGCLANServerAvailable:
      return "k_EMsgGCLANServerAvailable";
    case EGCBaseMsg.k_EMsgGCInviteToLobby:
      return "k_EMsgGCInviteToLobby";
    case EGCBaseMsg.k_EMsgGCLobbyInviteResponse:
      return "k_EMsgGCLobbyInviteResponse";
    case EGCBaseMsg.k_EMsgGCToClientPollFileRequest:
      return "k_EMsgGCToClientPollFileRequest";
    case EGCBaseMsg.k_EMsgGCToClientPollFileResponse:
      return "k_EMsgGCToClientPollFileResponse";
    case EGCBaseMsg.k_EMsgGCToGCPerformManualOp:
      return "k_EMsgGCToGCPerformManualOp";
    case EGCBaseMsg.k_EMsgGCToGCPerformManualOpCompleted:
      return "k_EMsgGCToGCPerformManualOpCompleted";
    case EGCBaseMsg.k_EMsgGCToGCReloadServerRegionSettings:
      return "k_EMsgGCToGCReloadServerRegionSettings";
    case EGCBaseMsg.k_EMsgGCAdditionalWelcomeMsgList:
      return "k_EMsgGCAdditionalWelcomeMsgList";
    case EGCBaseMsg.k_EMsgGCToClientApplyRemoteConVars:
      return "k_EMsgGCToClientApplyRemoteConVars";
    case EGCBaseMsg.k_EMsgGCToServerApplyRemoteConVars:
      return "k_EMsgGCToServerApplyRemoteConVars";
    case EGCBaseMsg.k_EMsgClientToGCIntegrityStatus:
      return "k_EMsgClientToGCIntegrityStatus";
    case EGCBaseMsg.k_EMsgClientToGCAggregateMetrics:
      return "k_EMsgClientToGCAggregateMetrics";
    case EGCBaseMsg.k_EMsgGCToClientAggregateMetricsBackoff:
      return "k_EMsgGCToClientAggregateMetricsBackoff";
    case EGCBaseMsg.k_EMsgGCToServerSteamLearnAccessTokensChanged:
      return "k_EMsgGCToServerSteamLearnAccessTokensChanged";
    case EGCBaseMsg.k_EMsgGCToServerSteamLearnUseHTTP:
      return "k_EMsgGCToServerSteamLearnUseHTTP";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EGCBaseMsg");
  }
}

export enum ECustomGameInstallStatus {
  k_ECustomGameInstallStatus_Unknown = 0,
  k_ECustomGameInstallStatus_Ready = 1,
  k_ECustomGameInstallStatus_Busy = 2,
  k_ECustomGameInstallStatus_FailedGeneric = 101,
  k_ECustomGameInstallStatus_FailedInternalError = 102,
  k_ECustomGameInstallStatus_RequestedTimestampTooOld = 103,
  k_ECustomGameInstallStatus_RequestedTimestampTooNew = 104,
  k_ECustomGameInstallStatus_CRCMismatch = 105,
  k_ECustomGameInstallStatus_FailedSteam = 106,
  k_ECustomGameInstallStatus_FailedCanceled = 107,
}

export function eCustomGameInstallStatusFromJSON(object: any): ECustomGameInstallStatus {
  switch (object) {
    case 0:
    case "k_ECustomGameInstallStatus_Unknown":
      return ECustomGameInstallStatus.k_ECustomGameInstallStatus_Unknown;
    case 1:
    case "k_ECustomGameInstallStatus_Ready":
      return ECustomGameInstallStatus.k_ECustomGameInstallStatus_Ready;
    case 2:
    case "k_ECustomGameInstallStatus_Busy":
      return ECustomGameInstallStatus.k_ECustomGameInstallStatus_Busy;
    case 101:
    case "k_ECustomGameInstallStatus_FailedGeneric":
      return ECustomGameInstallStatus.k_ECustomGameInstallStatus_FailedGeneric;
    case 102:
    case "k_ECustomGameInstallStatus_FailedInternalError":
      return ECustomGameInstallStatus.k_ECustomGameInstallStatus_FailedInternalError;
    case 103:
    case "k_ECustomGameInstallStatus_RequestedTimestampTooOld":
      return ECustomGameInstallStatus.k_ECustomGameInstallStatus_RequestedTimestampTooOld;
    case 104:
    case "k_ECustomGameInstallStatus_RequestedTimestampTooNew":
      return ECustomGameInstallStatus.k_ECustomGameInstallStatus_RequestedTimestampTooNew;
    case 105:
    case "k_ECustomGameInstallStatus_CRCMismatch":
      return ECustomGameInstallStatus.k_ECustomGameInstallStatus_CRCMismatch;
    case 106:
    case "k_ECustomGameInstallStatus_FailedSteam":
      return ECustomGameInstallStatus.k_ECustomGameInstallStatus_FailedSteam;
    case 107:
    case "k_ECustomGameInstallStatus_FailedCanceled":
      return ECustomGameInstallStatus.k_ECustomGameInstallStatus_FailedCanceled;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ECustomGameInstallStatus");
  }
}

export function eCustomGameInstallStatusToJSON(object: ECustomGameInstallStatus): string {
  switch (object) {
    case ECustomGameInstallStatus.k_ECustomGameInstallStatus_Unknown:
      return "k_ECustomGameInstallStatus_Unknown";
    case ECustomGameInstallStatus.k_ECustomGameInstallStatus_Ready:
      return "k_ECustomGameInstallStatus_Ready";
    case ECustomGameInstallStatus.k_ECustomGameInstallStatus_Busy:
      return "k_ECustomGameInstallStatus_Busy";
    case ECustomGameInstallStatus.k_ECustomGameInstallStatus_FailedGeneric:
      return "k_ECustomGameInstallStatus_FailedGeneric";
    case ECustomGameInstallStatus.k_ECustomGameInstallStatus_FailedInternalError:
      return "k_ECustomGameInstallStatus_FailedInternalError";
    case ECustomGameInstallStatus.k_ECustomGameInstallStatus_RequestedTimestampTooOld:
      return "k_ECustomGameInstallStatus_RequestedTimestampTooOld";
    case ECustomGameInstallStatus.k_ECustomGameInstallStatus_RequestedTimestampTooNew:
      return "k_ECustomGameInstallStatus_RequestedTimestampTooNew";
    case ECustomGameInstallStatus.k_ECustomGameInstallStatus_CRCMismatch:
      return "k_ECustomGameInstallStatus_CRCMismatch";
    case ECustomGameInstallStatus.k_ECustomGameInstallStatus_FailedSteam:
      return "k_ECustomGameInstallStatus_FailedSteam";
    case ECustomGameInstallStatus.k_ECustomGameInstallStatus_FailedCanceled:
      return "k_ECustomGameInstallStatus_FailedCanceled";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ECustomGameInstallStatus");
  }
}

export interface CGCStorePurchaseInitLineItem {
  itemDefId: number;
  quantity: number;
  costInLocalCurrency: number;
  purchaseType: number;
  sourceReferenceId: string;
  priceIndex: number;
}

export interface CMsgGCStorePurchaseInit {
  country: string;
  language: number;
  currency: number;
  lineItems: CGCStorePurchaseInitLineItem[];
}

export interface CMsgGCStorePurchaseInitResponse {
  result: number;
  txnId: string;
}

export interface CMsgClientPingData {
  relayCodes: number[];
  relayPings: number[];
  regionCodes: number[];
  regionPings: number[];
  regionPingFailedBitmask: number;
}

export interface CMsgInviteToParty {
  steamId: string;
  clientVersion: number;
  teamId: number;
  asCoach: boolean;
  pingData: CMsgClientPingData | undefined;
}

export interface CMsgInviteToLobby {
  steamId: string;
  clientVersion: number;
}

export interface CMsgInvitationCreated {
  groupId: string;
  steamId: string;
  userOffline: boolean;
}

export interface CMsgPartyInviteResponse {
  partyId: string;
  accept: boolean;
  clientVersion: number;
  pingData: CMsgClientPingData | undefined;
}

export interface CMsgLobbyInviteResponse {
  lobbyId: string;
  accept: boolean;
  clientVersion: number;
  customGameCrc: string;
  customGameTimestamp: number;
}

export interface CMsgKickFromParty {
  steamId: string;
}

export interface CMsgLeaveParty {
}

export interface CMsgCustomGameInstallStatus {
  status: ECustomGameInstallStatus;
  message: string;
  latestTimestampFromSteam: number;
}

export interface CMsgServerAvailable {
  customGameInstallStatus: CMsgCustomGameInstallStatus | undefined;
}

export interface CMsgLANServerAvailable {
  lobbyId: string;
}

export interface CSOEconGameAccountClient {
  additionalBackpackSlots: number;
  trialAccount: boolean;
  eligibleForOnlinePlay: boolean;
  needToChooseMostHelpfulFriend: boolean;
  inCoachesList: boolean;
  tradeBanExpiration: number;
  duelBanExpiration: number;
  madeFirstPurchase: boolean;
}

export interface CMsgApplyStrangePart {
  strangePartItemId: string;
  itemItemId: string;
}

export interface CMsgApplyPennantUpgrade {
  upgradeItemId: string;
  pennantItemId: string;
}

export interface CMsgApplyEggEssence {
  essenceItemId: string;
  eggItemId: string;
}

export interface CSOEconItemAttribute {
  defIndex: number;
  value: number;
  valueBytes: Buffer;
}

export interface CSOEconItemEquipped {
  newClass: number;
  newSlot: number;
}

export interface CSOEconItem {
  id: string;
  accountId: number;
  inventory: number;
  defIndex: number;
  quantity: number;
  level: number;
  quality: number;
  flags: number;
  origin: number;
  attribute: CSOEconItemAttribute[];
  interiorItem: CSOEconItem | undefined;
  style: number;
  originalId: string;
  equippedState: CSOEconItemEquipped[];
}

export interface CMsgSortItems {
  sortType: number;
}

export interface CMsgItemAcknowledged {
  accountId: number;
  inventory: number;
  defIndex: number;
  quality: number;
  rarity: number;
  origin: number;
}

export interface CMsgSetItemPositions {
  itemPositions: CMsgSetItemPositions_ItemPosition[];
}

export interface CMsgSetItemPositions_ItemPosition {
  itemId: string;
  position: number;
}

export interface CMsgGCStorePurchaseCancel {
  txnId: string;
}

export interface CMsgGCStorePurchaseCancelResponse {
  result: number;
}

export interface CMsgGCStorePurchaseFinalize {
  txnId: string;
}

export interface CMsgGCStorePurchaseFinalizeResponse {
  result: number;
  itemIds: string[];
}

export interface CMsgGCToGCBannedWordListUpdated {
  groupId: number;
}

export interface CMsgGCToGCDirtySDOCache {
  sdoType: number;
  keyUint64: string;
}

export interface CMsgSDONoMemcached {
}

export interface CMsgGCToGCUpdateSQLKeyValue {
  keyName: string;
}

export interface CMsgGCServerVersionUpdated {
  serverVersion: number;
}

export interface CMsgGCClientVersionUpdated {
  clientVersion: number;
}

export interface CMsgGCToGCWebAPIAccountChanged {
}

export interface CMsgExtractGems {
  toolItemId: string;
  itemItemId: string;
  itemSocketId: number;
}

export interface CMsgExtractGemsResponse {
  itemId: string;
  response: CMsgExtractGemsResponse_EExtractGems;
}

export enum CMsgExtractGemsResponse_EExtractGems {
  k_ExtractGems_Succeeded = 0,
  k_ExtractGems_Failed_ToolIsInvalid = 1,
  k_ExtractGems_Failed_ItemIsInvalid = 2,
  k_ExtractGems_Failed_ToolCannotRemoveGem = 3,
  k_ExtractGems_Failed_FailedToRemoveGem = 4,
}

export function cMsgExtractGemsResponse_EExtractGemsFromJSON(object: any): CMsgExtractGemsResponse_EExtractGems {
  switch (object) {
    case 0:
    case "k_ExtractGems_Succeeded":
      return CMsgExtractGemsResponse_EExtractGems.k_ExtractGems_Succeeded;
    case 1:
    case "k_ExtractGems_Failed_ToolIsInvalid":
      return CMsgExtractGemsResponse_EExtractGems.k_ExtractGems_Failed_ToolIsInvalid;
    case 2:
    case "k_ExtractGems_Failed_ItemIsInvalid":
      return CMsgExtractGemsResponse_EExtractGems.k_ExtractGems_Failed_ItemIsInvalid;
    case 3:
    case "k_ExtractGems_Failed_ToolCannotRemoveGem":
      return CMsgExtractGemsResponse_EExtractGems.k_ExtractGems_Failed_ToolCannotRemoveGem;
    case 4:
    case "k_ExtractGems_Failed_FailedToRemoveGem":
      return CMsgExtractGemsResponse_EExtractGems.k_ExtractGems_Failed_FailedToRemoveGem;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgExtractGemsResponse_EExtractGems",
      );
  }
}

export function cMsgExtractGemsResponse_EExtractGemsToJSON(object: CMsgExtractGemsResponse_EExtractGems): string {
  switch (object) {
    case CMsgExtractGemsResponse_EExtractGems.k_ExtractGems_Succeeded:
      return "k_ExtractGems_Succeeded";
    case CMsgExtractGemsResponse_EExtractGems.k_ExtractGems_Failed_ToolIsInvalid:
      return "k_ExtractGems_Failed_ToolIsInvalid";
    case CMsgExtractGemsResponse_EExtractGems.k_ExtractGems_Failed_ItemIsInvalid:
      return "k_ExtractGems_Failed_ItemIsInvalid";
    case CMsgExtractGemsResponse_EExtractGems.k_ExtractGems_Failed_ToolCannotRemoveGem:
      return "k_ExtractGems_Failed_ToolCannotRemoveGem";
    case CMsgExtractGemsResponse_EExtractGems.k_ExtractGems_Failed_FailedToRemoveGem:
      return "k_ExtractGems_Failed_FailedToRemoveGem";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgExtractGemsResponse_EExtractGems",
      );
  }
}

export interface CMsgAddSocket {
  toolItemId: string;
  itemItemId: string;
  unusual: boolean;
}

export interface CMsgAddSocketResponse {
  itemId: string;
  updatedSocketIndex: number[];
  response: CMsgAddSocketResponse_EAddSocket;
}

export enum CMsgAddSocketResponse_EAddSocket {
  k_AddSocket_Succeeded = 0,
  k_AddSocket_Failed_ToolIsInvalid = 1,
  k_AddSocket_Failed_ItemCannotBeSocketed = 2,
  k_AddSocket_Failed_FailedToAddSocket = 3,
}

export function cMsgAddSocketResponse_EAddSocketFromJSON(object: any): CMsgAddSocketResponse_EAddSocket {
  switch (object) {
    case 0:
    case "k_AddSocket_Succeeded":
      return CMsgAddSocketResponse_EAddSocket.k_AddSocket_Succeeded;
    case 1:
    case "k_AddSocket_Failed_ToolIsInvalid":
      return CMsgAddSocketResponse_EAddSocket.k_AddSocket_Failed_ToolIsInvalid;
    case 2:
    case "k_AddSocket_Failed_ItemCannotBeSocketed":
      return CMsgAddSocketResponse_EAddSocket.k_AddSocket_Failed_ItemCannotBeSocketed;
    case 3:
    case "k_AddSocket_Failed_FailedToAddSocket":
      return CMsgAddSocketResponse_EAddSocket.k_AddSocket_Failed_FailedToAddSocket;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgAddSocketResponse_EAddSocket");
  }
}

export function cMsgAddSocketResponse_EAddSocketToJSON(object: CMsgAddSocketResponse_EAddSocket): string {
  switch (object) {
    case CMsgAddSocketResponse_EAddSocket.k_AddSocket_Succeeded:
      return "k_AddSocket_Succeeded";
    case CMsgAddSocketResponse_EAddSocket.k_AddSocket_Failed_ToolIsInvalid:
      return "k_AddSocket_Failed_ToolIsInvalid";
    case CMsgAddSocketResponse_EAddSocket.k_AddSocket_Failed_ItemCannotBeSocketed:
      return "k_AddSocket_Failed_ItemCannotBeSocketed";
    case CMsgAddSocketResponse_EAddSocket.k_AddSocket_Failed_FailedToAddSocket:
      return "k_AddSocket_Failed_FailedToAddSocket";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgAddSocketResponse_EAddSocket");
  }
}

export interface CMsgAddItemToSocketData {
  gemItemId: string;
  socketIndex: number;
}

export interface CMsgAddItemToSocket {
  itemItemId: string;
  gemsToSocket: CMsgAddItemToSocketData[];
}

export interface CMsgAddItemToSocketResponse {
  itemItemId: string;
  updatedSocketIndex: number[];
  response: CMsgAddItemToSocketResponse_EAddGem;
}

export enum CMsgAddItemToSocketResponse_EAddGem {
  k_AddGem_Succeeded = 0,
  k_AddGem_Failed_GemIsInvalid = 1,
  k_AddGem_Failed_ItemIsInvalid = 2,
  k_AddGem_Failed_FailedToAddGem = 3,
  k_AddGem_Failed_InvalidGemTypeForSocket = 4,
  k_AddGem_Failed_InvalidGemTypeForHero = 5,
  k_AddGem_Failed_InvalidGemTypeForSlot = 6,
  k_AddGem_Failed_SocketContainsUnremovableGem = 7,
}

export function cMsgAddItemToSocketResponse_EAddGemFromJSON(object: any): CMsgAddItemToSocketResponse_EAddGem {
  switch (object) {
    case 0:
    case "k_AddGem_Succeeded":
      return CMsgAddItemToSocketResponse_EAddGem.k_AddGem_Succeeded;
    case 1:
    case "k_AddGem_Failed_GemIsInvalid":
      return CMsgAddItemToSocketResponse_EAddGem.k_AddGem_Failed_GemIsInvalid;
    case 2:
    case "k_AddGem_Failed_ItemIsInvalid":
      return CMsgAddItemToSocketResponse_EAddGem.k_AddGem_Failed_ItemIsInvalid;
    case 3:
    case "k_AddGem_Failed_FailedToAddGem":
      return CMsgAddItemToSocketResponse_EAddGem.k_AddGem_Failed_FailedToAddGem;
    case 4:
    case "k_AddGem_Failed_InvalidGemTypeForSocket":
      return CMsgAddItemToSocketResponse_EAddGem.k_AddGem_Failed_InvalidGemTypeForSocket;
    case 5:
    case "k_AddGem_Failed_InvalidGemTypeForHero":
      return CMsgAddItemToSocketResponse_EAddGem.k_AddGem_Failed_InvalidGemTypeForHero;
    case 6:
    case "k_AddGem_Failed_InvalidGemTypeForSlot":
      return CMsgAddItemToSocketResponse_EAddGem.k_AddGem_Failed_InvalidGemTypeForSlot;
    case 7:
    case "k_AddGem_Failed_SocketContainsUnremovableGem":
      return CMsgAddItemToSocketResponse_EAddGem.k_AddGem_Failed_SocketContainsUnremovableGem;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgAddItemToSocketResponse_EAddGem");
  }
}

export function cMsgAddItemToSocketResponse_EAddGemToJSON(object: CMsgAddItemToSocketResponse_EAddGem): string {
  switch (object) {
    case CMsgAddItemToSocketResponse_EAddGem.k_AddGem_Succeeded:
      return "k_AddGem_Succeeded";
    case CMsgAddItemToSocketResponse_EAddGem.k_AddGem_Failed_GemIsInvalid:
      return "k_AddGem_Failed_GemIsInvalid";
    case CMsgAddItemToSocketResponse_EAddGem.k_AddGem_Failed_ItemIsInvalid:
      return "k_AddGem_Failed_ItemIsInvalid";
    case CMsgAddItemToSocketResponse_EAddGem.k_AddGem_Failed_FailedToAddGem:
      return "k_AddGem_Failed_FailedToAddGem";
    case CMsgAddItemToSocketResponse_EAddGem.k_AddGem_Failed_InvalidGemTypeForSocket:
      return "k_AddGem_Failed_InvalidGemTypeForSocket";
    case CMsgAddItemToSocketResponse_EAddGem.k_AddGem_Failed_InvalidGemTypeForHero:
      return "k_AddGem_Failed_InvalidGemTypeForHero";
    case CMsgAddItemToSocketResponse_EAddGem.k_AddGem_Failed_InvalidGemTypeForSlot:
      return "k_AddGem_Failed_InvalidGemTypeForSlot";
    case CMsgAddItemToSocketResponse_EAddGem.k_AddGem_Failed_SocketContainsUnremovableGem:
      return "k_AddGem_Failed_SocketContainsUnremovableGem";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgAddItemToSocketResponse_EAddGem");
  }
}

export interface CMsgResetStrangeGemCount {
  itemItemId: string;
  socketIndex: number;
}

export interface CMsgResetStrangeGemCountResponse {
  response: CMsgResetStrangeGemCountResponse_EResetGem;
}

export enum CMsgResetStrangeGemCountResponse_EResetGem {
  k_ResetGem_Succeeded = 0,
  k_ResetGem_Failed_FailedToResetGem = 1,
  k_ResetGem_Failed_ItemIsInvalid = 2,
  k_ResetGem_Failed_InvalidSocketId = 3,
  k_ResetGem_Failed_SocketCannotBeReset = 4,
}

export function cMsgResetStrangeGemCountResponse_EResetGemFromJSON(
  object: any,
): CMsgResetStrangeGemCountResponse_EResetGem {
  switch (object) {
    case 0:
    case "k_ResetGem_Succeeded":
      return CMsgResetStrangeGemCountResponse_EResetGem.k_ResetGem_Succeeded;
    case 1:
    case "k_ResetGem_Failed_FailedToResetGem":
      return CMsgResetStrangeGemCountResponse_EResetGem.k_ResetGem_Failed_FailedToResetGem;
    case 2:
    case "k_ResetGem_Failed_ItemIsInvalid":
      return CMsgResetStrangeGemCountResponse_EResetGem.k_ResetGem_Failed_ItemIsInvalid;
    case 3:
    case "k_ResetGem_Failed_InvalidSocketId":
      return CMsgResetStrangeGemCountResponse_EResetGem.k_ResetGem_Failed_InvalidSocketId;
    case 4:
    case "k_ResetGem_Failed_SocketCannotBeReset":
      return CMsgResetStrangeGemCountResponse_EResetGem.k_ResetGem_Failed_SocketCannotBeReset;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgResetStrangeGemCountResponse_EResetGem",
      );
  }
}

export function cMsgResetStrangeGemCountResponse_EResetGemToJSON(
  object: CMsgResetStrangeGemCountResponse_EResetGem,
): string {
  switch (object) {
    case CMsgResetStrangeGemCountResponse_EResetGem.k_ResetGem_Succeeded:
      return "k_ResetGem_Succeeded";
    case CMsgResetStrangeGemCountResponse_EResetGem.k_ResetGem_Failed_FailedToResetGem:
      return "k_ResetGem_Failed_FailedToResetGem";
    case CMsgResetStrangeGemCountResponse_EResetGem.k_ResetGem_Failed_ItemIsInvalid:
      return "k_ResetGem_Failed_ItemIsInvalid";
    case CMsgResetStrangeGemCountResponse_EResetGem.k_ResetGem_Failed_InvalidSocketId:
      return "k_ResetGem_Failed_InvalidSocketId";
    case CMsgResetStrangeGemCountResponse_EResetGem.k_ResetGem_Failed_SocketCannotBeReset:
      return "k_ResetGem_Failed_SocketCannotBeReset";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgResetStrangeGemCountResponse_EResetGem",
      );
  }
}

export interface CMsgGCToClientPollFileRequest {
  fileName: string;
  clientVersion: number;
  pollId: number;
}

export interface CMsgGCToClientPollFileResponse {
  pollId: number;
  fileSize: number;
  fileCrc: number;
}

export interface CMsgGCToGCPerformManualOp {
  opId: string;
  groupCode: number;
}

export interface CMsgGCToGCPerformManualOpCompleted {
  success: boolean;
  sourceGc: number;
}

export interface CMsgGCToGCReloadServerRegionSettings {
}

export interface CMsgGCAdditionalWelcomeMsgList {
  welcomeMessages: CExtraMsgBlock[];
}

export interface CMsgApplyRemoteConVars {
  conVars: CMsgApplyRemoteConVars_ConVar[];
}

export interface CMsgApplyRemoteConVars_ConVar {
  name: string;
  value: string;
  versionMin: number;
  versionMax: number;
  platform: EGCPlatform;
}

export interface CMsgGCToClientApplyRemoteConVars {
  msg: CMsgApplyRemoteConVars | undefined;
}

export interface CMsgGCToServerApplyRemoteConVars {
  msg: CMsgApplyRemoteConVars | undefined;
}

export interface CMsgClientToGCIntegrityStatus {
  report: string;
  secureAllowed: boolean;
  diagnostics: CMsgClientToGCIntegrityStatus_keyvalue[];
}

export interface CMsgClientToGCIntegrityStatus_keyvalue {
  id: number;
  extended: number;
  value: string;
  stringValue: string;
}

export interface CMsgClientToGCAggregateMetrics {
  metrics: CMsgClientToGCAggregateMetrics_SingleMetric[];
}

export interface CMsgClientToGCAggregateMetrics_SingleMetric {
  metricName: string;
  metricCount: number;
}

export interface CMsgGCToClientAggregateMetricsBackoff {
  uploadRateModifier: number;
}

export interface CMsgGCToServerSteamLearnAccessTokensChanged {
  accessTokens: CMsgSteamLearnAccessTokens | undefined;
}

export interface CMsgGCToServerSteamLearnUseHTTP {
  useHttp: boolean;
}

function createBaseCGCStorePurchaseInitLineItem(): CGCStorePurchaseInitLineItem {
  return { itemDefId: 0, quantity: 0, costInLocalCurrency: 0, purchaseType: 0, sourceReferenceId: "0", priceIndex: 0 };
}

export const CGCStorePurchaseInitLineItem: MessageFns<CGCStorePurchaseInitLineItem> = {
  encode(message: CGCStorePurchaseInitLineItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.itemDefId !== 0) {
      writer.uint32(8).uint32(message.itemDefId);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).uint32(message.quantity);
    }
    if (message.costInLocalCurrency !== 0) {
      writer.uint32(24).uint32(message.costInLocalCurrency);
    }
    if (message.purchaseType !== 0) {
      writer.uint32(32).uint32(message.purchaseType);
    }
    if (message.sourceReferenceId !== "0") {
      writer.uint32(40).uint64(message.sourceReferenceId);
    }
    if (message.priceIndex !== 0) {
      writer.uint32(48).int32(message.priceIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CGCStorePurchaseInitLineItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCStorePurchaseInitLineItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.itemDefId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantity = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.costInLocalCurrency = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.purchaseType = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sourceReferenceId = reader.uint64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.priceIndex = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCStorePurchaseInitLineItem {
    return {
      itemDefId: isSet(object.itemDefId) ? globalThis.Number(object.itemDefId) : 0,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      costInLocalCurrency: isSet(object.costInLocalCurrency) ? globalThis.Number(object.costInLocalCurrency) : 0,
      purchaseType: isSet(object.purchaseType) ? globalThis.Number(object.purchaseType) : 0,
      sourceReferenceId: isSet(object.sourceReferenceId) ? globalThis.String(object.sourceReferenceId) : "0",
      priceIndex: isSet(object.priceIndex) ? globalThis.Number(object.priceIndex) : 0,
    };
  },

  toJSON(message: CGCStorePurchaseInitLineItem): unknown {
    const obj: any = {};
    if (message.itemDefId !== 0) {
      obj.itemDefId = Math.round(message.itemDefId);
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.costInLocalCurrency !== 0) {
      obj.costInLocalCurrency = Math.round(message.costInLocalCurrency);
    }
    if (message.purchaseType !== 0) {
      obj.purchaseType = Math.round(message.purchaseType);
    }
    if (message.sourceReferenceId !== "0") {
      obj.sourceReferenceId = message.sourceReferenceId;
    }
    if (message.priceIndex !== 0) {
      obj.priceIndex = Math.round(message.priceIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CGCStorePurchaseInitLineItem>): CGCStorePurchaseInitLineItem {
    return CGCStorePurchaseInitLineItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCStorePurchaseInitLineItem>): CGCStorePurchaseInitLineItem {
    const message = createBaseCGCStorePurchaseInitLineItem();
    message.itemDefId = object.itemDefId ?? 0;
    message.quantity = object.quantity ?? 0;
    message.costInLocalCurrency = object.costInLocalCurrency ?? 0;
    message.purchaseType = object.purchaseType ?? 0;
    message.sourceReferenceId = object.sourceReferenceId ?? "0";
    message.priceIndex = object.priceIndex ?? 0;
    return message;
  },
};

function createBaseCMsgGCStorePurchaseInit(): CMsgGCStorePurchaseInit {
  return { country: "", language: 0, currency: 0, lineItems: [] };
}

export const CMsgGCStorePurchaseInit: MessageFns<CMsgGCStorePurchaseInit> = {
  encode(message: CMsgGCStorePurchaseInit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.country !== "") {
      writer.uint32(10).string(message.country);
    }
    if (message.language !== 0) {
      writer.uint32(16).int32(message.language);
    }
    if (message.currency !== 0) {
      writer.uint32(24).int32(message.currency);
    }
    for (const v of message.lineItems) {
      CGCStorePurchaseInitLineItem.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCStorePurchaseInit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCStorePurchaseInit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.language = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.currency = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lineItems.push(CGCStorePurchaseInitLineItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCStorePurchaseInit {
    return {
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      language: isSet(object.language) ? globalThis.Number(object.language) : 0,
      currency: isSet(object.currency) ? globalThis.Number(object.currency) : 0,
      lineItems: globalThis.Array.isArray(object?.lineItems)
        ? object.lineItems.map((e: any) => CGCStorePurchaseInitLineItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCStorePurchaseInit): unknown {
    const obj: any = {};
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.language !== 0) {
      obj.language = Math.round(message.language);
    }
    if (message.currency !== 0) {
      obj.currency = Math.round(message.currency);
    }
    if (message.lineItems?.length) {
      obj.lineItems = message.lineItems.map((e) => CGCStorePurchaseInitLineItem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCStorePurchaseInit>): CMsgGCStorePurchaseInit {
    return CMsgGCStorePurchaseInit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCStorePurchaseInit>): CMsgGCStorePurchaseInit {
    const message = createBaseCMsgGCStorePurchaseInit();
    message.country = object.country ?? "";
    message.language = object.language ?? 0;
    message.currency = object.currency ?? 0;
    message.lineItems = object.lineItems?.map((e) => CGCStorePurchaseInitLineItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGCStorePurchaseInitResponse(): CMsgGCStorePurchaseInitResponse {
  return { result: 0, txnId: "0" };
}

export const CMsgGCStorePurchaseInitResponse: MessageFns<CMsgGCStorePurchaseInitResponse> = {
  encode(message: CMsgGCStorePurchaseInitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.txnId !== "0") {
      writer.uint32(16).uint64(message.txnId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCStorePurchaseInitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCStorePurchaseInitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.txnId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCStorePurchaseInitResponse {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : 0,
      txnId: isSet(object.txnId) ? globalThis.String(object.txnId) : "0",
    };
  },

  toJSON(message: CMsgGCStorePurchaseInitResponse): unknown {
    const obj: any = {};
    if (message.result !== 0) {
      obj.result = Math.round(message.result);
    }
    if (message.txnId !== "0") {
      obj.txnId = message.txnId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCStorePurchaseInitResponse>): CMsgGCStorePurchaseInitResponse {
    return CMsgGCStorePurchaseInitResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCStorePurchaseInitResponse>): CMsgGCStorePurchaseInitResponse {
    const message = createBaseCMsgGCStorePurchaseInitResponse();
    message.result = object.result ?? 0;
    message.txnId = object.txnId ?? "0";
    return message;
  },
};

function createBaseCMsgClientPingData(): CMsgClientPingData {
  return { relayCodes: [], relayPings: [], regionCodes: [], regionPings: [], regionPingFailedBitmask: 0 };
}

export const CMsgClientPingData: MessageFns<CMsgClientPingData> = {
  encode(message: CMsgClientPingData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(34).fork();
    for (const v of message.relayCodes) {
      writer.fixed32(v);
    }
    writer.join();
    writer.uint32(42).fork();
    for (const v of message.relayPings) {
      writer.uint32(v);
    }
    writer.join();
    writer.uint32(66).fork();
    for (const v of message.regionCodes) {
      writer.uint32(v);
    }
    writer.join();
    writer.uint32(74).fork();
    for (const v of message.regionPings) {
      writer.uint32(v);
    }
    writer.join();
    if (message.regionPingFailedBitmask !== 0) {
      writer.uint32(80).uint32(message.regionPingFailedBitmask);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientPingData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientPingData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag === 37) {
            message.relayCodes.push(reader.fixed32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.relayCodes.push(reader.fixed32());
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag === 40) {
            message.relayPings.push(reader.uint32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.relayPings.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag === 64) {
            message.regionCodes.push(reader.uint32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.regionCodes.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 9: {
          if (tag === 72) {
            message.regionPings.push(reader.uint32());

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.regionPings.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.regionPingFailedBitmask = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientPingData {
    return {
      relayCodes: globalThis.Array.isArray(object?.relayCodes)
        ? object.relayCodes.map((e: any) => globalThis.Number(e))
        : [],
      relayPings: globalThis.Array.isArray(object?.relayPings)
        ? object.relayPings.map((e: any) => globalThis.Number(e))
        : [],
      regionCodes: globalThis.Array.isArray(object?.regionCodes)
        ? object.regionCodes.map((e: any) => globalThis.Number(e))
        : [],
      regionPings: globalThis.Array.isArray(object?.regionPings)
        ? object.regionPings.map((e: any) => globalThis.Number(e))
        : [],
      regionPingFailedBitmask: isSet(object.regionPingFailedBitmask)
        ? globalThis.Number(object.regionPingFailedBitmask)
        : 0,
    };
  },

  toJSON(message: CMsgClientPingData): unknown {
    const obj: any = {};
    if (message.relayCodes?.length) {
      obj.relayCodes = message.relayCodes.map((e) => Math.round(e));
    }
    if (message.relayPings?.length) {
      obj.relayPings = message.relayPings.map((e) => Math.round(e));
    }
    if (message.regionCodes?.length) {
      obj.regionCodes = message.regionCodes.map((e) => Math.round(e));
    }
    if (message.regionPings?.length) {
      obj.regionPings = message.regionPings.map((e) => Math.round(e));
    }
    if (message.regionPingFailedBitmask !== 0) {
      obj.regionPingFailedBitmask = Math.round(message.regionPingFailedBitmask);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientPingData>): CMsgClientPingData {
    return CMsgClientPingData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientPingData>): CMsgClientPingData {
    const message = createBaseCMsgClientPingData();
    message.relayCodes = object.relayCodes?.map((e) => e) || [];
    message.relayPings = object.relayPings?.map((e) => e) || [];
    message.regionCodes = object.regionCodes?.map((e) => e) || [];
    message.regionPings = object.regionPings?.map((e) => e) || [];
    message.regionPingFailedBitmask = object.regionPingFailedBitmask ?? 0;
    return message;
  },
};

function createBaseCMsgInviteToParty(): CMsgInviteToParty {
  return { steamId: "0", clientVersion: 0, teamId: 0, asCoach: false, pingData: undefined };
}

export const CMsgInviteToParty: MessageFns<CMsgInviteToParty> = {
  encode(message: CMsgInviteToParty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.steamId !== "0") {
      writer.uint32(9).fixed64(message.steamId);
    }
    if (message.clientVersion !== 0) {
      writer.uint32(16).uint32(message.clientVersion);
    }
    if (message.teamId !== 0) {
      writer.uint32(24).uint32(message.teamId);
    }
    if (message.asCoach !== false) {
      writer.uint32(32).bool(message.asCoach);
    }
    if (message.pingData !== undefined) {
      CMsgClientPingData.encode(message.pingData, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgInviteToParty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgInviteToParty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.steamId = reader.fixed64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.clientVersion = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.asCoach = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pingData = CMsgClientPingData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgInviteToParty {
    return {
      steamId: isSet(object.steamId) ? globalThis.String(object.steamId) : "0",
      clientVersion: isSet(object.clientVersion) ? globalThis.Number(object.clientVersion) : 0,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      asCoach: isSet(object.asCoach) ? globalThis.Boolean(object.asCoach) : false,
      pingData: isSet(object.pingData) ? CMsgClientPingData.fromJSON(object.pingData) : undefined,
    };
  },

  toJSON(message: CMsgInviteToParty): unknown {
    const obj: any = {};
    if (message.steamId !== "0") {
      obj.steamId = message.steamId;
    }
    if (message.clientVersion !== 0) {
      obj.clientVersion = Math.round(message.clientVersion);
    }
    if (message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.asCoach !== false) {
      obj.asCoach = message.asCoach;
    }
    if (message.pingData !== undefined) {
      obj.pingData = CMsgClientPingData.toJSON(message.pingData);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgInviteToParty>): CMsgInviteToParty {
    return CMsgInviteToParty.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgInviteToParty>): CMsgInviteToParty {
    const message = createBaseCMsgInviteToParty();
    message.steamId = object.steamId ?? "0";
    message.clientVersion = object.clientVersion ?? 0;
    message.teamId = object.teamId ?? 0;
    message.asCoach = object.asCoach ?? false;
    message.pingData = (object.pingData !== undefined && object.pingData !== null)
      ? CMsgClientPingData.fromPartial(object.pingData)
      : undefined;
    return message;
  },
};

function createBaseCMsgInviteToLobby(): CMsgInviteToLobby {
  return { steamId: "0", clientVersion: 0 };
}

export const CMsgInviteToLobby: MessageFns<CMsgInviteToLobby> = {
  encode(message: CMsgInviteToLobby, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.steamId !== "0") {
      writer.uint32(9).fixed64(message.steamId);
    }
    if (message.clientVersion !== 0) {
      writer.uint32(16).uint32(message.clientVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgInviteToLobby {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgInviteToLobby();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.steamId = reader.fixed64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.clientVersion = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgInviteToLobby {
    return {
      steamId: isSet(object.steamId) ? globalThis.String(object.steamId) : "0",
      clientVersion: isSet(object.clientVersion) ? globalThis.Number(object.clientVersion) : 0,
    };
  },

  toJSON(message: CMsgInviteToLobby): unknown {
    const obj: any = {};
    if (message.steamId !== "0") {
      obj.steamId = message.steamId;
    }
    if (message.clientVersion !== 0) {
      obj.clientVersion = Math.round(message.clientVersion);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgInviteToLobby>): CMsgInviteToLobby {
    return CMsgInviteToLobby.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgInviteToLobby>): CMsgInviteToLobby {
    const message = createBaseCMsgInviteToLobby();
    message.steamId = object.steamId ?? "0";
    message.clientVersion = object.clientVersion ?? 0;
    return message;
  },
};

function createBaseCMsgInvitationCreated(): CMsgInvitationCreated {
  return { groupId: "0", steamId: "0", userOffline: false };
}

export const CMsgInvitationCreated: MessageFns<CMsgInvitationCreated> = {
  encode(message: CMsgInvitationCreated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupId !== "0") {
      writer.uint32(8).uint64(message.groupId);
    }
    if (message.steamId !== "0") {
      writer.uint32(17).fixed64(message.steamId);
    }
    if (message.userOffline !== false) {
      writer.uint32(24).bool(message.userOffline);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgInvitationCreated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgInvitationCreated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.groupId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.steamId = reader.fixed64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.userOffline = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgInvitationCreated {
    return {
      groupId: isSet(object.groupId) ? globalThis.String(object.groupId) : "0",
      steamId: isSet(object.steamId) ? globalThis.String(object.steamId) : "0",
      userOffline: isSet(object.userOffline) ? globalThis.Boolean(object.userOffline) : false,
    };
  },

  toJSON(message: CMsgInvitationCreated): unknown {
    const obj: any = {};
    if (message.groupId !== "0") {
      obj.groupId = message.groupId;
    }
    if (message.steamId !== "0") {
      obj.steamId = message.steamId;
    }
    if (message.userOffline !== false) {
      obj.userOffline = message.userOffline;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgInvitationCreated>): CMsgInvitationCreated {
    return CMsgInvitationCreated.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgInvitationCreated>): CMsgInvitationCreated {
    const message = createBaseCMsgInvitationCreated();
    message.groupId = object.groupId ?? "0";
    message.steamId = object.steamId ?? "0";
    message.userOffline = object.userOffline ?? false;
    return message;
  },
};

function createBaseCMsgPartyInviteResponse(): CMsgPartyInviteResponse {
  return { partyId: "0", accept: false, clientVersion: 0, pingData: undefined };
}

export const CMsgPartyInviteResponse: MessageFns<CMsgPartyInviteResponse> = {
  encode(message: CMsgPartyInviteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.partyId !== "0") {
      writer.uint32(8).uint64(message.partyId);
    }
    if (message.accept !== false) {
      writer.uint32(16).bool(message.accept);
    }
    if (message.clientVersion !== 0) {
      writer.uint32(24).uint32(message.clientVersion);
    }
    if (message.pingData !== undefined) {
      CMsgClientPingData.encode(message.pingData, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgPartyInviteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPartyInviteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.partyId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.accept = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.clientVersion = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pingData = CMsgClientPingData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPartyInviteResponse {
    return {
      partyId: isSet(object.partyId) ? globalThis.String(object.partyId) : "0",
      accept: isSet(object.accept) ? globalThis.Boolean(object.accept) : false,
      clientVersion: isSet(object.clientVersion) ? globalThis.Number(object.clientVersion) : 0,
      pingData: isSet(object.pingData) ? CMsgClientPingData.fromJSON(object.pingData) : undefined,
    };
  },

  toJSON(message: CMsgPartyInviteResponse): unknown {
    const obj: any = {};
    if (message.partyId !== "0") {
      obj.partyId = message.partyId;
    }
    if (message.accept !== false) {
      obj.accept = message.accept;
    }
    if (message.clientVersion !== 0) {
      obj.clientVersion = Math.round(message.clientVersion);
    }
    if (message.pingData !== undefined) {
      obj.pingData = CMsgClientPingData.toJSON(message.pingData);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPartyInviteResponse>): CMsgPartyInviteResponse {
    return CMsgPartyInviteResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPartyInviteResponse>): CMsgPartyInviteResponse {
    const message = createBaseCMsgPartyInviteResponse();
    message.partyId = object.partyId ?? "0";
    message.accept = object.accept ?? false;
    message.clientVersion = object.clientVersion ?? 0;
    message.pingData = (object.pingData !== undefined && object.pingData !== null)
      ? CMsgClientPingData.fromPartial(object.pingData)
      : undefined;
    return message;
  },
};

function createBaseCMsgLobbyInviteResponse(): CMsgLobbyInviteResponse {
  return { lobbyId: "0", accept: false, clientVersion: 0, customGameCrc: "0", customGameTimestamp: 0 };
}

export const CMsgLobbyInviteResponse: MessageFns<CMsgLobbyInviteResponse> = {
  encode(message: CMsgLobbyInviteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lobbyId !== "0") {
      writer.uint32(9).fixed64(message.lobbyId);
    }
    if (message.accept !== false) {
      writer.uint32(16).bool(message.accept);
    }
    if (message.clientVersion !== 0) {
      writer.uint32(24).uint32(message.clientVersion);
    }
    if (message.customGameCrc !== "0") {
      writer.uint32(49).fixed64(message.customGameCrc);
    }
    if (message.customGameTimestamp !== 0) {
      writer.uint32(61).fixed32(message.customGameTimestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgLobbyInviteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLobbyInviteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.lobbyId = reader.fixed64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.accept = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.clientVersion = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.customGameCrc = reader.fixed64().toString();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.customGameTimestamp = reader.fixed32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLobbyInviteResponse {
    return {
      lobbyId: isSet(object.lobbyId) ? globalThis.String(object.lobbyId) : "0",
      accept: isSet(object.accept) ? globalThis.Boolean(object.accept) : false,
      clientVersion: isSet(object.clientVersion) ? globalThis.Number(object.clientVersion) : 0,
      customGameCrc: isSet(object.customGameCrc) ? globalThis.String(object.customGameCrc) : "0",
      customGameTimestamp: isSet(object.customGameTimestamp) ? globalThis.Number(object.customGameTimestamp) : 0,
    };
  },

  toJSON(message: CMsgLobbyInviteResponse): unknown {
    const obj: any = {};
    if (message.lobbyId !== "0") {
      obj.lobbyId = message.lobbyId;
    }
    if (message.accept !== false) {
      obj.accept = message.accept;
    }
    if (message.clientVersion !== 0) {
      obj.clientVersion = Math.round(message.clientVersion);
    }
    if (message.customGameCrc !== "0") {
      obj.customGameCrc = message.customGameCrc;
    }
    if (message.customGameTimestamp !== 0) {
      obj.customGameTimestamp = Math.round(message.customGameTimestamp);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLobbyInviteResponse>): CMsgLobbyInviteResponse {
    return CMsgLobbyInviteResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLobbyInviteResponse>): CMsgLobbyInviteResponse {
    const message = createBaseCMsgLobbyInviteResponse();
    message.lobbyId = object.lobbyId ?? "0";
    message.accept = object.accept ?? false;
    message.clientVersion = object.clientVersion ?? 0;
    message.customGameCrc = object.customGameCrc ?? "0";
    message.customGameTimestamp = object.customGameTimestamp ?? 0;
    return message;
  },
};

function createBaseCMsgKickFromParty(): CMsgKickFromParty {
  return { steamId: "0" };
}

export const CMsgKickFromParty: MessageFns<CMsgKickFromParty> = {
  encode(message: CMsgKickFromParty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.steamId !== "0") {
      writer.uint32(9).fixed64(message.steamId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgKickFromParty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgKickFromParty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.steamId = reader.fixed64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgKickFromParty {
    return { steamId: isSet(object.steamId) ? globalThis.String(object.steamId) : "0" };
  },

  toJSON(message: CMsgKickFromParty): unknown {
    const obj: any = {};
    if (message.steamId !== "0") {
      obj.steamId = message.steamId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgKickFromParty>): CMsgKickFromParty {
    return CMsgKickFromParty.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgKickFromParty>): CMsgKickFromParty {
    const message = createBaseCMsgKickFromParty();
    message.steamId = object.steamId ?? "0";
    return message;
  },
};

function createBaseCMsgLeaveParty(): CMsgLeaveParty {
  return {};
}

export const CMsgLeaveParty: MessageFns<CMsgLeaveParty> = {
  encode(_: CMsgLeaveParty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgLeaveParty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLeaveParty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgLeaveParty {
    return {};
  },

  toJSON(_: CMsgLeaveParty): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgLeaveParty>): CMsgLeaveParty {
    return CMsgLeaveParty.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgLeaveParty>): CMsgLeaveParty {
    const message = createBaseCMsgLeaveParty();
    return message;
  },
};

function createBaseCMsgCustomGameInstallStatus(): CMsgCustomGameInstallStatus {
  return { status: 0, message: "", latestTimestampFromSteam: 0 };
}

export const CMsgCustomGameInstallStatus: MessageFns<CMsgCustomGameInstallStatus> = {
  encode(message: CMsgCustomGameInstallStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.latestTimestampFromSteam !== 0) {
      writer.uint32(29).fixed32(message.latestTimestampFromSteam);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgCustomGameInstallStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgCustomGameInstallStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.latestTimestampFromSteam = reader.fixed32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgCustomGameInstallStatus {
    return {
      status: isSet(object.status) ? eCustomGameInstallStatusFromJSON(object.status) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      latestTimestampFromSteam: isSet(object.latestTimestampFromSteam)
        ? globalThis.Number(object.latestTimestampFromSteam)
        : 0,
    };
  },

  toJSON(message: CMsgCustomGameInstallStatus): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = eCustomGameInstallStatusToJSON(message.status);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.latestTimestampFromSteam !== 0) {
      obj.latestTimestampFromSteam = Math.round(message.latestTimestampFromSteam);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgCustomGameInstallStatus>): CMsgCustomGameInstallStatus {
    return CMsgCustomGameInstallStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgCustomGameInstallStatus>): CMsgCustomGameInstallStatus {
    const message = createBaseCMsgCustomGameInstallStatus();
    message.status = object.status ?? 0;
    message.message = object.message ?? "";
    message.latestTimestampFromSteam = object.latestTimestampFromSteam ?? 0;
    return message;
  },
};

function createBaseCMsgServerAvailable(): CMsgServerAvailable {
  return { customGameInstallStatus: undefined };
}

export const CMsgServerAvailable: MessageFns<CMsgServerAvailable> = {
  encode(message: CMsgServerAvailable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customGameInstallStatus !== undefined) {
      CMsgCustomGameInstallStatus.encode(message.customGameInstallStatus, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgServerAvailable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerAvailable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.customGameInstallStatus = CMsgCustomGameInstallStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerAvailable {
    return {
      customGameInstallStatus: isSet(object.customGameInstallStatus)
        ? CMsgCustomGameInstallStatus.fromJSON(object.customGameInstallStatus)
        : undefined,
    };
  },

  toJSON(message: CMsgServerAvailable): unknown {
    const obj: any = {};
    if (message.customGameInstallStatus !== undefined) {
      obj.customGameInstallStatus = CMsgCustomGameInstallStatus.toJSON(message.customGameInstallStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerAvailable>): CMsgServerAvailable {
    return CMsgServerAvailable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerAvailable>): CMsgServerAvailable {
    const message = createBaseCMsgServerAvailable();
    message.customGameInstallStatus =
      (object.customGameInstallStatus !== undefined && object.customGameInstallStatus !== null)
        ? CMsgCustomGameInstallStatus.fromPartial(object.customGameInstallStatus)
        : undefined;
    return message;
  },
};

function createBaseCMsgLANServerAvailable(): CMsgLANServerAvailable {
  return { lobbyId: "0" };
}

export const CMsgLANServerAvailable: MessageFns<CMsgLANServerAvailable> = {
  encode(message: CMsgLANServerAvailable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lobbyId !== "0") {
      writer.uint32(9).fixed64(message.lobbyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgLANServerAvailable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLANServerAvailable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.lobbyId = reader.fixed64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLANServerAvailable {
    return { lobbyId: isSet(object.lobbyId) ? globalThis.String(object.lobbyId) : "0" };
  },

  toJSON(message: CMsgLANServerAvailable): unknown {
    const obj: any = {};
    if (message.lobbyId !== "0") {
      obj.lobbyId = message.lobbyId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLANServerAvailable>): CMsgLANServerAvailable {
    return CMsgLANServerAvailable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLANServerAvailable>): CMsgLANServerAvailable {
    const message = createBaseCMsgLANServerAvailable();
    message.lobbyId = object.lobbyId ?? "0";
    return message;
  },
};

function createBaseCSOEconGameAccountClient(): CSOEconGameAccountClient {
  return {
    additionalBackpackSlots: 0,
    trialAccount: false,
    eligibleForOnlinePlay: true,
    needToChooseMostHelpfulFriend: false,
    inCoachesList: false,
    tradeBanExpiration: 0,
    duelBanExpiration: 0,
    madeFirstPurchase: false,
  };
}

export const CSOEconGameAccountClient: MessageFns<CSOEconGameAccountClient> = {
  encode(message: CSOEconGameAccountClient, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.additionalBackpackSlots !== 0) {
      writer.uint32(8).uint32(message.additionalBackpackSlots);
    }
    if (message.trialAccount !== false) {
      writer.uint32(16).bool(message.trialAccount);
    }
    if (message.eligibleForOnlinePlay !== true) {
      writer.uint32(24).bool(message.eligibleForOnlinePlay);
    }
    if (message.needToChooseMostHelpfulFriend !== false) {
      writer.uint32(32).bool(message.needToChooseMostHelpfulFriend);
    }
    if (message.inCoachesList !== false) {
      writer.uint32(40).bool(message.inCoachesList);
    }
    if (message.tradeBanExpiration !== 0) {
      writer.uint32(53).fixed32(message.tradeBanExpiration);
    }
    if (message.duelBanExpiration !== 0) {
      writer.uint32(61).fixed32(message.duelBanExpiration);
    }
    if (message.madeFirstPurchase !== false) {
      writer.uint32(72).bool(message.madeFirstPurchase);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CSOEconGameAccountClient {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSOEconGameAccountClient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.additionalBackpackSlots = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.trialAccount = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.eligibleForOnlinePlay = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.needToChooseMostHelpfulFriend = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.inCoachesList = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.tradeBanExpiration = reader.fixed32();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.duelBanExpiration = reader.fixed32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.madeFirstPurchase = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSOEconGameAccountClient {
    return {
      additionalBackpackSlots: isSet(object.additionalBackpackSlots)
        ? globalThis.Number(object.additionalBackpackSlots)
        : 0,
      trialAccount: isSet(object.trialAccount) ? globalThis.Boolean(object.trialAccount) : false,
      eligibleForOnlinePlay: isSet(object.eligibleForOnlinePlay)
        ? globalThis.Boolean(object.eligibleForOnlinePlay)
        : true,
      needToChooseMostHelpfulFriend: isSet(object.needToChooseMostHelpfulFriend)
        ? globalThis.Boolean(object.needToChooseMostHelpfulFriend)
        : false,
      inCoachesList: isSet(object.inCoachesList) ? globalThis.Boolean(object.inCoachesList) : false,
      tradeBanExpiration: isSet(object.tradeBanExpiration) ? globalThis.Number(object.tradeBanExpiration) : 0,
      duelBanExpiration: isSet(object.duelBanExpiration) ? globalThis.Number(object.duelBanExpiration) : 0,
      madeFirstPurchase: isSet(object.madeFirstPurchase) ? globalThis.Boolean(object.madeFirstPurchase) : false,
    };
  },

  toJSON(message: CSOEconGameAccountClient): unknown {
    const obj: any = {};
    if (message.additionalBackpackSlots !== 0) {
      obj.additionalBackpackSlots = Math.round(message.additionalBackpackSlots);
    }
    if (message.trialAccount !== false) {
      obj.trialAccount = message.trialAccount;
    }
    if (message.eligibleForOnlinePlay !== true) {
      obj.eligibleForOnlinePlay = message.eligibleForOnlinePlay;
    }
    if (message.needToChooseMostHelpfulFriend !== false) {
      obj.needToChooseMostHelpfulFriend = message.needToChooseMostHelpfulFriend;
    }
    if (message.inCoachesList !== false) {
      obj.inCoachesList = message.inCoachesList;
    }
    if (message.tradeBanExpiration !== 0) {
      obj.tradeBanExpiration = Math.round(message.tradeBanExpiration);
    }
    if (message.duelBanExpiration !== 0) {
      obj.duelBanExpiration = Math.round(message.duelBanExpiration);
    }
    if (message.madeFirstPurchase !== false) {
      obj.madeFirstPurchase = message.madeFirstPurchase;
    }
    return obj;
  },

  create(base?: DeepPartial<CSOEconGameAccountClient>): CSOEconGameAccountClient {
    return CSOEconGameAccountClient.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSOEconGameAccountClient>): CSOEconGameAccountClient {
    const message = createBaseCSOEconGameAccountClient();
    message.additionalBackpackSlots = object.additionalBackpackSlots ?? 0;
    message.trialAccount = object.trialAccount ?? false;
    message.eligibleForOnlinePlay = object.eligibleForOnlinePlay ?? true;
    message.needToChooseMostHelpfulFriend = object.needToChooseMostHelpfulFriend ?? false;
    message.inCoachesList = object.inCoachesList ?? false;
    message.tradeBanExpiration = object.tradeBanExpiration ?? 0;
    message.duelBanExpiration = object.duelBanExpiration ?? 0;
    message.madeFirstPurchase = object.madeFirstPurchase ?? false;
    return message;
  },
};

function createBaseCMsgApplyStrangePart(): CMsgApplyStrangePart {
  return { strangePartItemId: "0", itemItemId: "0" };
}

export const CMsgApplyStrangePart: MessageFns<CMsgApplyStrangePart> = {
  encode(message: CMsgApplyStrangePart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.strangePartItemId !== "0") {
      writer.uint32(8).uint64(message.strangePartItemId);
    }
    if (message.itemItemId !== "0") {
      writer.uint32(16).uint64(message.itemItemId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgApplyStrangePart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgApplyStrangePart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.strangePartItemId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.itemItemId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgApplyStrangePart {
    return {
      strangePartItemId: isSet(object.strangePartItemId) ? globalThis.String(object.strangePartItemId) : "0",
      itemItemId: isSet(object.itemItemId) ? globalThis.String(object.itemItemId) : "0",
    };
  },

  toJSON(message: CMsgApplyStrangePart): unknown {
    const obj: any = {};
    if (message.strangePartItemId !== "0") {
      obj.strangePartItemId = message.strangePartItemId;
    }
    if (message.itemItemId !== "0") {
      obj.itemItemId = message.itemItemId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgApplyStrangePart>): CMsgApplyStrangePart {
    return CMsgApplyStrangePart.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgApplyStrangePart>): CMsgApplyStrangePart {
    const message = createBaseCMsgApplyStrangePart();
    message.strangePartItemId = object.strangePartItemId ?? "0";
    message.itemItemId = object.itemItemId ?? "0";
    return message;
  },
};

function createBaseCMsgApplyPennantUpgrade(): CMsgApplyPennantUpgrade {
  return { upgradeItemId: "0", pennantItemId: "0" };
}

export const CMsgApplyPennantUpgrade: MessageFns<CMsgApplyPennantUpgrade> = {
  encode(message: CMsgApplyPennantUpgrade, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.upgradeItemId !== "0") {
      writer.uint32(8).uint64(message.upgradeItemId);
    }
    if (message.pennantItemId !== "0") {
      writer.uint32(16).uint64(message.pennantItemId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgApplyPennantUpgrade {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgApplyPennantUpgrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.upgradeItemId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pennantItemId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgApplyPennantUpgrade {
    return {
      upgradeItemId: isSet(object.upgradeItemId) ? globalThis.String(object.upgradeItemId) : "0",
      pennantItemId: isSet(object.pennantItemId) ? globalThis.String(object.pennantItemId) : "0",
    };
  },

  toJSON(message: CMsgApplyPennantUpgrade): unknown {
    const obj: any = {};
    if (message.upgradeItemId !== "0") {
      obj.upgradeItemId = message.upgradeItemId;
    }
    if (message.pennantItemId !== "0") {
      obj.pennantItemId = message.pennantItemId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgApplyPennantUpgrade>): CMsgApplyPennantUpgrade {
    return CMsgApplyPennantUpgrade.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgApplyPennantUpgrade>): CMsgApplyPennantUpgrade {
    const message = createBaseCMsgApplyPennantUpgrade();
    message.upgradeItemId = object.upgradeItemId ?? "0";
    message.pennantItemId = object.pennantItemId ?? "0";
    return message;
  },
};

function createBaseCMsgApplyEggEssence(): CMsgApplyEggEssence {
  return { essenceItemId: "0", eggItemId: "0" };
}

export const CMsgApplyEggEssence: MessageFns<CMsgApplyEggEssence> = {
  encode(message: CMsgApplyEggEssence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.essenceItemId !== "0") {
      writer.uint32(8).uint64(message.essenceItemId);
    }
    if (message.eggItemId !== "0") {
      writer.uint32(16).uint64(message.eggItemId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgApplyEggEssence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgApplyEggEssence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.essenceItemId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.eggItemId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgApplyEggEssence {
    return {
      essenceItemId: isSet(object.essenceItemId) ? globalThis.String(object.essenceItemId) : "0",
      eggItemId: isSet(object.eggItemId) ? globalThis.String(object.eggItemId) : "0",
    };
  },

  toJSON(message: CMsgApplyEggEssence): unknown {
    const obj: any = {};
    if (message.essenceItemId !== "0") {
      obj.essenceItemId = message.essenceItemId;
    }
    if (message.eggItemId !== "0") {
      obj.eggItemId = message.eggItemId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgApplyEggEssence>): CMsgApplyEggEssence {
    return CMsgApplyEggEssence.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgApplyEggEssence>): CMsgApplyEggEssence {
    const message = createBaseCMsgApplyEggEssence();
    message.essenceItemId = object.essenceItemId ?? "0";
    message.eggItemId = object.eggItemId ?? "0";
    return message;
  },
};

function createBaseCSOEconItemAttribute(): CSOEconItemAttribute {
  return { defIndex: 65535, value: 0, valueBytes: Buffer.alloc(0) };
}

export const CSOEconItemAttribute: MessageFns<CSOEconItemAttribute> = {
  encode(message: CSOEconItemAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.defIndex !== 65535) {
      writer.uint32(8).uint32(message.defIndex);
    }
    if (message.value !== 0) {
      writer.uint32(16).uint32(message.value);
    }
    if (message.valueBytes.length !== 0) {
      writer.uint32(26).bytes(message.valueBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CSOEconItemAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSOEconItemAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.defIndex = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.valueBytes = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSOEconItemAttribute {
    return {
      defIndex: isSet(object.defIndex) ? globalThis.Number(object.defIndex) : 65535,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      valueBytes: isSet(object.valueBytes) ? Buffer.from(bytesFromBase64(object.valueBytes)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CSOEconItemAttribute): unknown {
    const obj: any = {};
    if (message.defIndex !== 65535) {
      obj.defIndex = Math.round(message.defIndex);
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.valueBytes.length !== 0) {
      obj.valueBytes = base64FromBytes(message.valueBytes);
    }
    return obj;
  },

  create(base?: DeepPartial<CSOEconItemAttribute>): CSOEconItemAttribute {
    return CSOEconItemAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSOEconItemAttribute>): CSOEconItemAttribute {
    const message = createBaseCSOEconItemAttribute();
    message.defIndex = object.defIndex ?? 65535;
    message.value = object.value ?? 0;
    message.valueBytes = object.valueBytes ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCSOEconItemEquipped(): CSOEconItemEquipped {
  return { newClass: 0, newSlot: 0 };
}

export const CSOEconItemEquipped: MessageFns<CSOEconItemEquipped> = {
  encode(message: CSOEconItemEquipped, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newClass !== 0) {
      writer.uint32(8).uint32(message.newClass);
    }
    if (message.newSlot !== 0) {
      writer.uint32(16).uint32(message.newSlot);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CSOEconItemEquipped {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSOEconItemEquipped();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.newClass = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.newSlot = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSOEconItemEquipped {
    return {
      newClass: isSet(object.newClass) ? globalThis.Number(object.newClass) : 0,
      newSlot: isSet(object.newSlot) ? globalThis.Number(object.newSlot) : 0,
    };
  },

  toJSON(message: CSOEconItemEquipped): unknown {
    const obj: any = {};
    if (message.newClass !== 0) {
      obj.newClass = Math.round(message.newClass);
    }
    if (message.newSlot !== 0) {
      obj.newSlot = Math.round(message.newSlot);
    }
    return obj;
  },

  create(base?: DeepPartial<CSOEconItemEquipped>): CSOEconItemEquipped {
    return CSOEconItemEquipped.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSOEconItemEquipped>): CSOEconItemEquipped {
    const message = createBaseCSOEconItemEquipped();
    message.newClass = object.newClass ?? 0;
    message.newSlot = object.newSlot ?? 0;
    return message;
  },
};

function createBaseCSOEconItem(): CSOEconItem {
  return {
    id: "0",
    accountId: 0,
    inventory: 0,
    defIndex: 0,
    quantity: 1,
    level: 1,
    quality: 4,
    flags: 0,
    origin: 0,
    attribute: [],
    interiorItem: undefined,
    style: 0,
    originalId: "0",
    equippedState: [],
  };
}

export const CSOEconItem: MessageFns<CSOEconItem> = {
  encode(message: CSOEconItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).uint64(message.id);
    }
    if (message.accountId !== 0) {
      writer.uint32(16).uint32(message.accountId);
    }
    if (message.inventory !== 0) {
      writer.uint32(24).uint32(message.inventory);
    }
    if (message.defIndex !== 0) {
      writer.uint32(32).uint32(message.defIndex);
    }
    if (message.quantity !== 1) {
      writer.uint32(40).uint32(message.quantity);
    }
    if (message.level !== 1) {
      writer.uint32(48).uint32(message.level);
    }
    if (message.quality !== 4) {
      writer.uint32(56).uint32(message.quality);
    }
    if (message.flags !== 0) {
      writer.uint32(64).uint32(message.flags);
    }
    if (message.origin !== 0) {
      writer.uint32(72).uint32(message.origin);
    }
    for (const v of message.attribute) {
      CSOEconItemAttribute.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.interiorItem !== undefined) {
      CSOEconItem.encode(message.interiorItem, writer.uint32(106).fork()).join();
    }
    if (message.style !== 0) {
      writer.uint32(120).uint32(message.style);
    }
    if (message.originalId !== "0") {
      writer.uint32(128).uint64(message.originalId);
    }
    for (const v of message.equippedState) {
      CSOEconItemEquipped.encode(v!, writer.uint32(146).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CSOEconItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSOEconItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.inventory = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.defIndex = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.quantity = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.level = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.quality = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.flags = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.origin = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.attribute.push(CSOEconItemAttribute.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.interiorItem = CSOEconItem.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.style = reader.uint32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.originalId = reader.uint64().toString();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.equippedState.push(CSOEconItemEquipped.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSOEconItem {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      inventory: isSet(object.inventory) ? globalThis.Number(object.inventory) : 0,
      defIndex: isSet(object.defIndex) ? globalThis.Number(object.defIndex) : 0,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 1,
      level: isSet(object.level) ? globalThis.Number(object.level) : 1,
      quality: isSet(object.quality) ? globalThis.Number(object.quality) : 4,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
      origin: isSet(object.origin) ? globalThis.Number(object.origin) : 0,
      attribute: globalThis.Array.isArray(object?.attribute)
        ? object.attribute.map((e: any) => CSOEconItemAttribute.fromJSON(e))
        : [],
      interiorItem: isSet(object.interiorItem) ? CSOEconItem.fromJSON(object.interiorItem) : undefined,
      style: isSet(object.style) ? globalThis.Number(object.style) : 0,
      originalId: isSet(object.originalId) ? globalThis.String(object.originalId) : "0",
      equippedState: globalThis.Array.isArray(object?.equippedState)
        ? object.equippedState.map((e: any) => CSOEconItemEquipped.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CSOEconItem): unknown {
    const obj: any = {};
    if (message.id !== "0") {
      obj.id = message.id;
    }
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.inventory !== 0) {
      obj.inventory = Math.round(message.inventory);
    }
    if (message.defIndex !== 0) {
      obj.defIndex = Math.round(message.defIndex);
    }
    if (message.quantity !== 1) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.level !== 1) {
      obj.level = Math.round(message.level);
    }
    if (message.quality !== 4) {
      obj.quality = Math.round(message.quality);
    }
    if (message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    if (message.origin !== 0) {
      obj.origin = Math.round(message.origin);
    }
    if (message.attribute?.length) {
      obj.attribute = message.attribute.map((e) => CSOEconItemAttribute.toJSON(e));
    }
    if (message.interiorItem !== undefined) {
      obj.interiorItem = CSOEconItem.toJSON(message.interiorItem);
    }
    if (message.style !== 0) {
      obj.style = Math.round(message.style);
    }
    if (message.originalId !== "0") {
      obj.originalId = message.originalId;
    }
    if (message.equippedState?.length) {
      obj.equippedState = message.equippedState.map((e) => CSOEconItemEquipped.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CSOEconItem>): CSOEconItem {
    return CSOEconItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSOEconItem>): CSOEconItem {
    const message = createBaseCSOEconItem();
    message.id = object.id ?? "0";
    message.accountId = object.accountId ?? 0;
    message.inventory = object.inventory ?? 0;
    message.defIndex = object.defIndex ?? 0;
    message.quantity = object.quantity ?? 1;
    message.level = object.level ?? 1;
    message.quality = object.quality ?? 4;
    message.flags = object.flags ?? 0;
    message.origin = object.origin ?? 0;
    message.attribute = object.attribute?.map((e) => CSOEconItemAttribute.fromPartial(e)) || [];
    message.interiorItem = (object.interiorItem !== undefined && object.interiorItem !== null)
      ? CSOEconItem.fromPartial(object.interiorItem)
      : undefined;
    message.style = object.style ?? 0;
    message.originalId = object.originalId ?? "0";
    message.equippedState = object.equippedState?.map((e) => CSOEconItemEquipped.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSortItems(): CMsgSortItems {
  return { sortType: 0 };
}

export const CMsgSortItems: MessageFns<CMsgSortItems> = {
  encode(message: CMsgSortItems, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sortType !== 0) {
      writer.uint32(8).uint32(message.sortType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSortItems {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSortItems();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sortType = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSortItems {
    return { sortType: isSet(object.sortType) ? globalThis.Number(object.sortType) : 0 };
  },

  toJSON(message: CMsgSortItems): unknown {
    const obj: any = {};
    if (message.sortType !== 0) {
      obj.sortType = Math.round(message.sortType);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSortItems>): CMsgSortItems {
    return CMsgSortItems.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSortItems>): CMsgSortItems {
    const message = createBaseCMsgSortItems();
    message.sortType = object.sortType ?? 0;
    return message;
  },
};

function createBaseCMsgItemAcknowledged(): CMsgItemAcknowledged {
  return { accountId: 0, inventory: 0, defIndex: 0, quality: 0, rarity: 0, origin: 0 };
}

export const CMsgItemAcknowledged: MessageFns<CMsgItemAcknowledged> = {
  encode(message: CMsgItemAcknowledged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.inventory !== 0) {
      writer.uint32(16).uint32(message.inventory);
    }
    if (message.defIndex !== 0) {
      writer.uint32(24).uint32(message.defIndex);
    }
    if (message.quality !== 0) {
      writer.uint32(32).uint32(message.quality);
    }
    if (message.rarity !== 0) {
      writer.uint32(40).uint32(message.rarity);
    }
    if (message.origin !== 0) {
      writer.uint32(48).uint32(message.origin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgItemAcknowledged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgItemAcknowledged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inventory = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.defIndex = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.quality = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.rarity = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.origin = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgItemAcknowledged {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      inventory: isSet(object.inventory) ? globalThis.Number(object.inventory) : 0,
      defIndex: isSet(object.defIndex) ? globalThis.Number(object.defIndex) : 0,
      quality: isSet(object.quality) ? globalThis.Number(object.quality) : 0,
      rarity: isSet(object.rarity) ? globalThis.Number(object.rarity) : 0,
      origin: isSet(object.origin) ? globalThis.Number(object.origin) : 0,
    };
  },

  toJSON(message: CMsgItemAcknowledged): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.inventory !== 0) {
      obj.inventory = Math.round(message.inventory);
    }
    if (message.defIndex !== 0) {
      obj.defIndex = Math.round(message.defIndex);
    }
    if (message.quality !== 0) {
      obj.quality = Math.round(message.quality);
    }
    if (message.rarity !== 0) {
      obj.rarity = Math.round(message.rarity);
    }
    if (message.origin !== 0) {
      obj.origin = Math.round(message.origin);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgItemAcknowledged>): CMsgItemAcknowledged {
    return CMsgItemAcknowledged.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgItemAcknowledged>): CMsgItemAcknowledged {
    const message = createBaseCMsgItemAcknowledged();
    message.accountId = object.accountId ?? 0;
    message.inventory = object.inventory ?? 0;
    message.defIndex = object.defIndex ?? 0;
    message.quality = object.quality ?? 0;
    message.rarity = object.rarity ?? 0;
    message.origin = object.origin ?? 0;
    return message;
  },
};

function createBaseCMsgSetItemPositions(): CMsgSetItemPositions {
  return { itemPositions: [] };
}

export const CMsgSetItemPositions: MessageFns<CMsgSetItemPositions> = {
  encode(message: CMsgSetItemPositions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.itemPositions) {
      CMsgSetItemPositions_ItemPosition.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSetItemPositions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSetItemPositions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.itemPositions.push(CMsgSetItemPositions_ItemPosition.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSetItemPositions {
    return {
      itemPositions: globalThis.Array.isArray(object?.itemPositions)
        ? object.itemPositions.map((e: any) => CMsgSetItemPositions_ItemPosition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSetItemPositions): unknown {
    const obj: any = {};
    if (message.itemPositions?.length) {
      obj.itemPositions = message.itemPositions.map((e) => CMsgSetItemPositions_ItemPosition.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSetItemPositions>): CMsgSetItemPositions {
    return CMsgSetItemPositions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSetItemPositions>): CMsgSetItemPositions {
    const message = createBaseCMsgSetItemPositions();
    message.itemPositions = object.itemPositions?.map((e) => CMsgSetItemPositions_ItemPosition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSetItemPositions_ItemPosition(): CMsgSetItemPositions_ItemPosition {
  return { itemId: "0", position: 0 };
}

export const CMsgSetItemPositions_ItemPosition: MessageFns<CMsgSetItemPositions_ItemPosition> = {
  encode(message: CMsgSetItemPositions_ItemPosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.itemId !== "0") {
      writer.uint32(8).uint64(message.itemId);
    }
    if (message.position !== 0) {
      writer.uint32(16).uint32(message.position);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSetItemPositions_ItemPosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSetItemPositions_ItemPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.itemId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.position = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSetItemPositions_ItemPosition {
    return {
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "0",
      position: isSet(object.position) ? globalThis.Number(object.position) : 0,
    };
  },

  toJSON(message: CMsgSetItemPositions_ItemPosition): unknown {
    const obj: any = {};
    if (message.itemId !== "0") {
      obj.itemId = message.itemId;
    }
    if (message.position !== 0) {
      obj.position = Math.round(message.position);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSetItemPositions_ItemPosition>): CMsgSetItemPositions_ItemPosition {
    return CMsgSetItemPositions_ItemPosition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSetItemPositions_ItemPosition>): CMsgSetItemPositions_ItemPosition {
    const message = createBaseCMsgSetItemPositions_ItemPosition();
    message.itemId = object.itemId ?? "0";
    message.position = object.position ?? 0;
    return message;
  },
};

function createBaseCMsgGCStorePurchaseCancel(): CMsgGCStorePurchaseCancel {
  return { txnId: "0" };
}

export const CMsgGCStorePurchaseCancel: MessageFns<CMsgGCStorePurchaseCancel> = {
  encode(message: CMsgGCStorePurchaseCancel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txnId !== "0") {
      writer.uint32(8).uint64(message.txnId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCStorePurchaseCancel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCStorePurchaseCancel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.txnId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCStorePurchaseCancel {
    return { txnId: isSet(object.txnId) ? globalThis.String(object.txnId) : "0" };
  },

  toJSON(message: CMsgGCStorePurchaseCancel): unknown {
    const obj: any = {};
    if (message.txnId !== "0") {
      obj.txnId = message.txnId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCStorePurchaseCancel>): CMsgGCStorePurchaseCancel {
    return CMsgGCStorePurchaseCancel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCStorePurchaseCancel>): CMsgGCStorePurchaseCancel {
    const message = createBaseCMsgGCStorePurchaseCancel();
    message.txnId = object.txnId ?? "0";
    return message;
  },
};

function createBaseCMsgGCStorePurchaseCancelResponse(): CMsgGCStorePurchaseCancelResponse {
  return { result: 0 };
}

export const CMsgGCStorePurchaseCancelResponse: MessageFns<CMsgGCStorePurchaseCancelResponse> = {
  encode(message: CMsgGCStorePurchaseCancelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== 0) {
      writer.uint32(8).uint32(message.result);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCStorePurchaseCancelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCStorePurchaseCancelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCStorePurchaseCancelResponse {
    return { result: isSet(object.result) ? globalThis.Number(object.result) : 0 };
  },

  toJSON(message: CMsgGCStorePurchaseCancelResponse): unknown {
    const obj: any = {};
    if (message.result !== 0) {
      obj.result = Math.round(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCStorePurchaseCancelResponse>): CMsgGCStorePurchaseCancelResponse {
    return CMsgGCStorePurchaseCancelResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCStorePurchaseCancelResponse>): CMsgGCStorePurchaseCancelResponse {
    const message = createBaseCMsgGCStorePurchaseCancelResponse();
    message.result = object.result ?? 0;
    return message;
  },
};

function createBaseCMsgGCStorePurchaseFinalize(): CMsgGCStorePurchaseFinalize {
  return { txnId: "0" };
}

export const CMsgGCStorePurchaseFinalize: MessageFns<CMsgGCStorePurchaseFinalize> = {
  encode(message: CMsgGCStorePurchaseFinalize, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txnId !== "0") {
      writer.uint32(8).uint64(message.txnId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCStorePurchaseFinalize {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCStorePurchaseFinalize();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.txnId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCStorePurchaseFinalize {
    return { txnId: isSet(object.txnId) ? globalThis.String(object.txnId) : "0" };
  },

  toJSON(message: CMsgGCStorePurchaseFinalize): unknown {
    const obj: any = {};
    if (message.txnId !== "0") {
      obj.txnId = message.txnId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCStorePurchaseFinalize>): CMsgGCStorePurchaseFinalize {
    return CMsgGCStorePurchaseFinalize.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCStorePurchaseFinalize>): CMsgGCStorePurchaseFinalize {
    const message = createBaseCMsgGCStorePurchaseFinalize();
    message.txnId = object.txnId ?? "0";
    return message;
  },
};

function createBaseCMsgGCStorePurchaseFinalizeResponse(): CMsgGCStorePurchaseFinalizeResponse {
  return { result: 0, itemIds: [] };
}

export const CMsgGCStorePurchaseFinalizeResponse: MessageFns<CMsgGCStorePurchaseFinalizeResponse> = {
  encode(message: CMsgGCStorePurchaseFinalizeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== 0) {
      writer.uint32(8).uint32(message.result);
    }
    writer.uint32(18).fork();
    for (const v of message.itemIds) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCStorePurchaseFinalizeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCStorePurchaseFinalizeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.itemIds.push(reader.uint64().toString());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.itemIds.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCStorePurchaseFinalizeResponse {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : 0,
      itemIds: globalThis.Array.isArray(object?.itemIds) ? object.itemIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CMsgGCStorePurchaseFinalizeResponse): unknown {
    const obj: any = {};
    if (message.result !== 0) {
      obj.result = Math.round(message.result);
    }
    if (message.itemIds?.length) {
      obj.itemIds = message.itemIds;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCStorePurchaseFinalizeResponse>): CMsgGCStorePurchaseFinalizeResponse {
    return CMsgGCStorePurchaseFinalizeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCStorePurchaseFinalizeResponse>): CMsgGCStorePurchaseFinalizeResponse {
    const message = createBaseCMsgGCStorePurchaseFinalizeResponse();
    message.result = object.result ?? 0;
    message.itemIds = object.itemIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgGCToGCBannedWordListUpdated(): CMsgGCToGCBannedWordListUpdated {
  return { groupId: 0 };
}

export const CMsgGCToGCBannedWordListUpdated: MessageFns<CMsgGCToGCBannedWordListUpdated> = {
  encode(message: CMsgGCToGCBannedWordListUpdated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupId !== 0) {
      writer.uint32(8).uint32(message.groupId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCBannedWordListUpdated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCBannedWordListUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.groupId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCBannedWordListUpdated {
    return { groupId: isSet(object.groupId) ? globalThis.Number(object.groupId) : 0 };
  },

  toJSON(message: CMsgGCToGCBannedWordListUpdated): unknown {
    const obj: any = {};
    if (message.groupId !== 0) {
      obj.groupId = Math.round(message.groupId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCBannedWordListUpdated>): CMsgGCToGCBannedWordListUpdated {
    return CMsgGCToGCBannedWordListUpdated.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToGCBannedWordListUpdated>): CMsgGCToGCBannedWordListUpdated {
    const message = createBaseCMsgGCToGCBannedWordListUpdated();
    message.groupId = object.groupId ?? 0;
    return message;
  },
};

function createBaseCMsgGCToGCDirtySDOCache(): CMsgGCToGCDirtySDOCache {
  return { sdoType: 0, keyUint64: "0" };
}

export const CMsgGCToGCDirtySDOCache: MessageFns<CMsgGCToGCDirtySDOCache> = {
  encode(message: CMsgGCToGCDirtySDOCache, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sdoType !== 0) {
      writer.uint32(8).uint32(message.sdoType);
    }
    if (message.keyUint64 !== "0") {
      writer.uint32(16).uint64(message.keyUint64);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCDirtySDOCache {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCDirtySDOCache();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sdoType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.keyUint64 = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCDirtySDOCache {
    return {
      sdoType: isSet(object.sdoType) ? globalThis.Number(object.sdoType) : 0,
      keyUint64: isSet(object.keyUint64) ? globalThis.String(object.keyUint64) : "0",
    };
  },

  toJSON(message: CMsgGCToGCDirtySDOCache): unknown {
    const obj: any = {};
    if (message.sdoType !== 0) {
      obj.sdoType = Math.round(message.sdoType);
    }
    if (message.keyUint64 !== "0") {
      obj.keyUint64 = message.keyUint64;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCDirtySDOCache>): CMsgGCToGCDirtySDOCache {
    return CMsgGCToGCDirtySDOCache.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToGCDirtySDOCache>): CMsgGCToGCDirtySDOCache {
    const message = createBaseCMsgGCToGCDirtySDOCache();
    message.sdoType = object.sdoType ?? 0;
    message.keyUint64 = object.keyUint64 ?? "0";
    return message;
  },
};

function createBaseCMsgSDONoMemcached(): CMsgSDONoMemcached {
  return {};
}

export const CMsgSDONoMemcached: MessageFns<CMsgSDONoMemcached> = {
  encode(_: CMsgSDONoMemcached, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSDONoMemcached {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSDONoMemcached();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgSDONoMemcached {
    return {};
  },

  toJSON(_: CMsgSDONoMemcached): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgSDONoMemcached>): CMsgSDONoMemcached {
    return CMsgSDONoMemcached.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgSDONoMemcached>): CMsgSDONoMemcached {
    const message = createBaseCMsgSDONoMemcached();
    return message;
  },
};

function createBaseCMsgGCToGCUpdateSQLKeyValue(): CMsgGCToGCUpdateSQLKeyValue {
  return { keyName: "" };
}

export const CMsgGCToGCUpdateSQLKeyValue: MessageFns<CMsgGCToGCUpdateSQLKeyValue> = {
  encode(message: CMsgGCToGCUpdateSQLKeyValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyName !== "") {
      writer.uint32(10).string(message.keyName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCUpdateSQLKeyValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCUpdateSQLKeyValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keyName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCUpdateSQLKeyValue {
    return { keyName: isSet(object.keyName) ? globalThis.String(object.keyName) : "" };
  },

  toJSON(message: CMsgGCToGCUpdateSQLKeyValue): unknown {
    const obj: any = {};
    if (message.keyName !== "") {
      obj.keyName = message.keyName;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCUpdateSQLKeyValue>): CMsgGCToGCUpdateSQLKeyValue {
    return CMsgGCToGCUpdateSQLKeyValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToGCUpdateSQLKeyValue>): CMsgGCToGCUpdateSQLKeyValue {
    const message = createBaseCMsgGCToGCUpdateSQLKeyValue();
    message.keyName = object.keyName ?? "";
    return message;
  },
};

function createBaseCMsgGCServerVersionUpdated(): CMsgGCServerVersionUpdated {
  return { serverVersion: 0 };
}

export const CMsgGCServerVersionUpdated: MessageFns<CMsgGCServerVersionUpdated> = {
  encode(message: CMsgGCServerVersionUpdated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serverVersion !== 0) {
      writer.uint32(8).uint32(message.serverVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCServerVersionUpdated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCServerVersionUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.serverVersion = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCServerVersionUpdated {
    return { serverVersion: isSet(object.serverVersion) ? globalThis.Number(object.serverVersion) : 0 };
  },

  toJSON(message: CMsgGCServerVersionUpdated): unknown {
    const obj: any = {};
    if (message.serverVersion !== 0) {
      obj.serverVersion = Math.round(message.serverVersion);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCServerVersionUpdated>): CMsgGCServerVersionUpdated {
    return CMsgGCServerVersionUpdated.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCServerVersionUpdated>): CMsgGCServerVersionUpdated {
    const message = createBaseCMsgGCServerVersionUpdated();
    message.serverVersion = object.serverVersion ?? 0;
    return message;
  },
};

function createBaseCMsgGCClientVersionUpdated(): CMsgGCClientVersionUpdated {
  return { clientVersion: 0 };
}

export const CMsgGCClientVersionUpdated: MessageFns<CMsgGCClientVersionUpdated> = {
  encode(message: CMsgGCClientVersionUpdated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientVersion !== 0) {
      writer.uint32(8).uint32(message.clientVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCClientVersionUpdated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCClientVersionUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.clientVersion = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCClientVersionUpdated {
    return { clientVersion: isSet(object.clientVersion) ? globalThis.Number(object.clientVersion) : 0 };
  },

  toJSON(message: CMsgGCClientVersionUpdated): unknown {
    const obj: any = {};
    if (message.clientVersion !== 0) {
      obj.clientVersion = Math.round(message.clientVersion);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCClientVersionUpdated>): CMsgGCClientVersionUpdated {
    return CMsgGCClientVersionUpdated.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCClientVersionUpdated>): CMsgGCClientVersionUpdated {
    const message = createBaseCMsgGCClientVersionUpdated();
    message.clientVersion = object.clientVersion ?? 0;
    return message;
  },
};

function createBaseCMsgGCToGCWebAPIAccountChanged(): CMsgGCToGCWebAPIAccountChanged {
  return {};
}

export const CMsgGCToGCWebAPIAccountChanged: MessageFns<CMsgGCToGCWebAPIAccountChanged> = {
  encode(_: CMsgGCToGCWebAPIAccountChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCWebAPIAccountChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCWebAPIAccountChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgGCToGCWebAPIAccountChanged {
    return {};
  },

  toJSON(_: CMsgGCToGCWebAPIAccountChanged): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCWebAPIAccountChanged>): CMsgGCToGCWebAPIAccountChanged {
    return CMsgGCToGCWebAPIAccountChanged.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgGCToGCWebAPIAccountChanged>): CMsgGCToGCWebAPIAccountChanged {
    const message = createBaseCMsgGCToGCWebAPIAccountChanged();
    return message;
  },
};

function createBaseCMsgExtractGems(): CMsgExtractGems {
  return { toolItemId: "0", itemItemId: "0", itemSocketId: 65535 };
}

export const CMsgExtractGems: MessageFns<CMsgExtractGems> = {
  encode(message: CMsgExtractGems, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toolItemId !== "0") {
      writer.uint32(8).uint64(message.toolItemId);
    }
    if (message.itemItemId !== "0") {
      writer.uint32(16).uint64(message.itemItemId);
    }
    if (message.itemSocketId !== 65535) {
      writer.uint32(24).uint32(message.itemSocketId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgExtractGems {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgExtractGems();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.toolItemId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.itemItemId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.itemSocketId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgExtractGems {
    return {
      toolItemId: isSet(object.toolItemId) ? globalThis.String(object.toolItemId) : "0",
      itemItemId: isSet(object.itemItemId) ? globalThis.String(object.itemItemId) : "0",
      itemSocketId: isSet(object.itemSocketId) ? globalThis.Number(object.itemSocketId) : 65535,
    };
  },

  toJSON(message: CMsgExtractGems): unknown {
    const obj: any = {};
    if (message.toolItemId !== "0") {
      obj.toolItemId = message.toolItemId;
    }
    if (message.itemItemId !== "0") {
      obj.itemItemId = message.itemItemId;
    }
    if (message.itemSocketId !== 65535) {
      obj.itemSocketId = Math.round(message.itemSocketId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgExtractGems>): CMsgExtractGems {
    return CMsgExtractGems.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgExtractGems>): CMsgExtractGems {
    const message = createBaseCMsgExtractGems();
    message.toolItemId = object.toolItemId ?? "0";
    message.itemItemId = object.itemItemId ?? "0";
    message.itemSocketId = object.itemSocketId ?? 65535;
    return message;
  },
};

function createBaseCMsgExtractGemsResponse(): CMsgExtractGemsResponse {
  return { itemId: "0", response: 0 };
}

export const CMsgExtractGemsResponse: MessageFns<CMsgExtractGemsResponse> = {
  encode(message: CMsgExtractGemsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.itemId !== "0") {
      writer.uint32(8).uint64(message.itemId);
    }
    if (message.response !== 0) {
      writer.uint32(16).int32(message.response);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgExtractGemsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgExtractGemsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.itemId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgExtractGemsResponse {
    return {
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "0",
      response: isSet(object.response) ? cMsgExtractGemsResponse_EExtractGemsFromJSON(object.response) : 0,
    };
  },

  toJSON(message: CMsgExtractGemsResponse): unknown {
    const obj: any = {};
    if (message.itemId !== "0") {
      obj.itemId = message.itemId;
    }
    if (message.response !== 0) {
      obj.response = cMsgExtractGemsResponse_EExtractGemsToJSON(message.response);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgExtractGemsResponse>): CMsgExtractGemsResponse {
    return CMsgExtractGemsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgExtractGemsResponse>): CMsgExtractGemsResponse {
    const message = createBaseCMsgExtractGemsResponse();
    message.itemId = object.itemId ?? "0";
    message.response = object.response ?? 0;
    return message;
  },
};

function createBaseCMsgAddSocket(): CMsgAddSocket {
  return { toolItemId: "0", itemItemId: "0", unusual: false };
}

export const CMsgAddSocket: MessageFns<CMsgAddSocket> = {
  encode(message: CMsgAddSocket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toolItemId !== "0") {
      writer.uint32(8).uint64(message.toolItemId);
    }
    if (message.itemItemId !== "0") {
      writer.uint32(16).uint64(message.itemItemId);
    }
    if (message.unusual !== false) {
      writer.uint32(24).bool(message.unusual);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgAddSocket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAddSocket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.toolItemId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.itemItemId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.unusual = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAddSocket {
    return {
      toolItemId: isSet(object.toolItemId) ? globalThis.String(object.toolItemId) : "0",
      itemItemId: isSet(object.itemItemId) ? globalThis.String(object.itemItemId) : "0",
      unusual: isSet(object.unusual) ? globalThis.Boolean(object.unusual) : false,
    };
  },

  toJSON(message: CMsgAddSocket): unknown {
    const obj: any = {};
    if (message.toolItemId !== "0") {
      obj.toolItemId = message.toolItemId;
    }
    if (message.itemItemId !== "0") {
      obj.itemItemId = message.itemItemId;
    }
    if (message.unusual !== false) {
      obj.unusual = message.unusual;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAddSocket>): CMsgAddSocket {
    return CMsgAddSocket.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAddSocket>): CMsgAddSocket {
    const message = createBaseCMsgAddSocket();
    message.toolItemId = object.toolItemId ?? "0";
    message.itemItemId = object.itemItemId ?? "0";
    message.unusual = object.unusual ?? false;
    return message;
  },
};

function createBaseCMsgAddSocketResponse(): CMsgAddSocketResponse {
  return { itemId: "0", updatedSocketIndex: [], response: 0 };
}

export const CMsgAddSocketResponse: MessageFns<CMsgAddSocketResponse> = {
  encode(message: CMsgAddSocketResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.itemId !== "0") {
      writer.uint32(8).uint64(message.itemId);
    }
    writer.uint32(18).fork();
    for (const v of message.updatedSocketIndex) {
      writer.uint32(v);
    }
    writer.join();
    if (message.response !== 0) {
      writer.uint32(24).int32(message.response);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgAddSocketResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAddSocketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.itemId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.updatedSocketIndex.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.updatedSocketIndex.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAddSocketResponse {
    return {
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "0",
      updatedSocketIndex: globalThis.Array.isArray(object?.updatedSocketIndex)
        ? object.updatedSocketIndex.map((e: any) => globalThis.Number(e))
        : [],
      response: isSet(object.response) ? cMsgAddSocketResponse_EAddSocketFromJSON(object.response) : 0,
    };
  },

  toJSON(message: CMsgAddSocketResponse): unknown {
    const obj: any = {};
    if (message.itemId !== "0") {
      obj.itemId = message.itemId;
    }
    if (message.updatedSocketIndex?.length) {
      obj.updatedSocketIndex = message.updatedSocketIndex.map((e) => Math.round(e));
    }
    if (message.response !== 0) {
      obj.response = cMsgAddSocketResponse_EAddSocketToJSON(message.response);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAddSocketResponse>): CMsgAddSocketResponse {
    return CMsgAddSocketResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAddSocketResponse>): CMsgAddSocketResponse {
    const message = createBaseCMsgAddSocketResponse();
    message.itemId = object.itemId ?? "0";
    message.updatedSocketIndex = object.updatedSocketIndex?.map((e) => e) || [];
    message.response = object.response ?? 0;
    return message;
  },
};

function createBaseCMsgAddItemToSocketData(): CMsgAddItemToSocketData {
  return { gemItemId: "0", socketIndex: 65535 };
}

export const CMsgAddItemToSocketData: MessageFns<CMsgAddItemToSocketData> = {
  encode(message: CMsgAddItemToSocketData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gemItemId !== "0") {
      writer.uint32(8).uint64(message.gemItemId);
    }
    if (message.socketIndex !== 65535) {
      writer.uint32(16).uint32(message.socketIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgAddItemToSocketData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAddItemToSocketData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.gemItemId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.socketIndex = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAddItemToSocketData {
    return {
      gemItemId: isSet(object.gemItemId) ? globalThis.String(object.gemItemId) : "0",
      socketIndex: isSet(object.socketIndex) ? globalThis.Number(object.socketIndex) : 65535,
    };
  },

  toJSON(message: CMsgAddItemToSocketData): unknown {
    const obj: any = {};
    if (message.gemItemId !== "0") {
      obj.gemItemId = message.gemItemId;
    }
    if (message.socketIndex !== 65535) {
      obj.socketIndex = Math.round(message.socketIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAddItemToSocketData>): CMsgAddItemToSocketData {
    return CMsgAddItemToSocketData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAddItemToSocketData>): CMsgAddItemToSocketData {
    const message = createBaseCMsgAddItemToSocketData();
    message.gemItemId = object.gemItemId ?? "0";
    message.socketIndex = object.socketIndex ?? 65535;
    return message;
  },
};

function createBaseCMsgAddItemToSocket(): CMsgAddItemToSocket {
  return { itemItemId: "0", gemsToSocket: [] };
}

export const CMsgAddItemToSocket: MessageFns<CMsgAddItemToSocket> = {
  encode(message: CMsgAddItemToSocket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.itemItemId !== "0") {
      writer.uint32(8).uint64(message.itemItemId);
    }
    for (const v of message.gemsToSocket) {
      CMsgAddItemToSocketData.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgAddItemToSocket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAddItemToSocket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.itemItemId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gemsToSocket.push(CMsgAddItemToSocketData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAddItemToSocket {
    return {
      itemItemId: isSet(object.itemItemId) ? globalThis.String(object.itemItemId) : "0",
      gemsToSocket: globalThis.Array.isArray(object?.gemsToSocket)
        ? object.gemsToSocket.map((e: any) => CMsgAddItemToSocketData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgAddItemToSocket): unknown {
    const obj: any = {};
    if (message.itemItemId !== "0") {
      obj.itemItemId = message.itemItemId;
    }
    if (message.gemsToSocket?.length) {
      obj.gemsToSocket = message.gemsToSocket.map((e) => CMsgAddItemToSocketData.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAddItemToSocket>): CMsgAddItemToSocket {
    return CMsgAddItemToSocket.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAddItemToSocket>): CMsgAddItemToSocket {
    const message = createBaseCMsgAddItemToSocket();
    message.itemItemId = object.itemItemId ?? "0";
    message.gemsToSocket = object.gemsToSocket?.map((e) => CMsgAddItemToSocketData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgAddItemToSocketResponse(): CMsgAddItemToSocketResponse {
  return { itemItemId: "0", updatedSocketIndex: [], response: 0 };
}

export const CMsgAddItemToSocketResponse: MessageFns<CMsgAddItemToSocketResponse> = {
  encode(message: CMsgAddItemToSocketResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.itemItemId !== "0") {
      writer.uint32(8).uint64(message.itemItemId);
    }
    writer.uint32(18).fork();
    for (const v of message.updatedSocketIndex) {
      writer.uint32(v);
    }
    writer.join();
    if (message.response !== 0) {
      writer.uint32(24).int32(message.response);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgAddItemToSocketResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAddItemToSocketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.itemItemId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.updatedSocketIndex.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.updatedSocketIndex.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAddItemToSocketResponse {
    return {
      itemItemId: isSet(object.itemItemId) ? globalThis.String(object.itemItemId) : "0",
      updatedSocketIndex: globalThis.Array.isArray(object?.updatedSocketIndex)
        ? object.updatedSocketIndex.map((e: any) => globalThis.Number(e))
        : [],
      response: isSet(object.response) ? cMsgAddItemToSocketResponse_EAddGemFromJSON(object.response) : 0,
    };
  },

  toJSON(message: CMsgAddItemToSocketResponse): unknown {
    const obj: any = {};
    if (message.itemItemId !== "0") {
      obj.itemItemId = message.itemItemId;
    }
    if (message.updatedSocketIndex?.length) {
      obj.updatedSocketIndex = message.updatedSocketIndex.map((e) => Math.round(e));
    }
    if (message.response !== 0) {
      obj.response = cMsgAddItemToSocketResponse_EAddGemToJSON(message.response);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAddItemToSocketResponse>): CMsgAddItemToSocketResponse {
    return CMsgAddItemToSocketResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAddItemToSocketResponse>): CMsgAddItemToSocketResponse {
    const message = createBaseCMsgAddItemToSocketResponse();
    message.itemItemId = object.itemItemId ?? "0";
    message.updatedSocketIndex = object.updatedSocketIndex?.map((e) => e) || [];
    message.response = object.response ?? 0;
    return message;
  },
};

function createBaseCMsgResetStrangeGemCount(): CMsgResetStrangeGemCount {
  return { itemItemId: "0", socketIndex: 65535 };
}

export const CMsgResetStrangeGemCount: MessageFns<CMsgResetStrangeGemCount> = {
  encode(message: CMsgResetStrangeGemCount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.itemItemId !== "0") {
      writer.uint32(8).uint64(message.itemItemId);
    }
    if (message.socketIndex !== 65535) {
      writer.uint32(16).uint32(message.socketIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgResetStrangeGemCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgResetStrangeGemCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.itemItemId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.socketIndex = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgResetStrangeGemCount {
    return {
      itemItemId: isSet(object.itemItemId) ? globalThis.String(object.itemItemId) : "0",
      socketIndex: isSet(object.socketIndex) ? globalThis.Number(object.socketIndex) : 65535,
    };
  },

  toJSON(message: CMsgResetStrangeGemCount): unknown {
    const obj: any = {};
    if (message.itemItemId !== "0") {
      obj.itemItemId = message.itemItemId;
    }
    if (message.socketIndex !== 65535) {
      obj.socketIndex = Math.round(message.socketIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgResetStrangeGemCount>): CMsgResetStrangeGemCount {
    return CMsgResetStrangeGemCount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgResetStrangeGemCount>): CMsgResetStrangeGemCount {
    const message = createBaseCMsgResetStrangeGemCount();
    message.itemItemId = object.itemItemId ?? "0";
    message.socketIndex = object.socketIndex ?? 65535;
    return message;
  },
};

function createBaseCMsgResetStrangeGemCountResponse(): CMsgResetStrangeGemCountResponse {
  return { response: 0 };
}

export const CMsgResetStrangeGemCountResponse: MessageFns<CMsgResetStrangeGemCountResponse> = {
  encode(message: CMsgResetStrangeGemCountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgResetStrangeGemCountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgResetStrangeGemCountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgResetStrangeGemCountResponse {
    return {
      response: isSet(object.response) ? cMsgResetStrangeGemCountResponse_EResetGemFromJSON(object.response) : 0,
    };
  },

  toJSON(message: CMsgResetStrangeGemCountResponse): unknown {
    const obj: any = {};
    if (message.response !== 0) {
      obj.response = cMsgResetStrangeGemCountResponse_EResetGemToJSON(message.response);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgResetStrangeGemCountResponse>): CMsgResetStrangeGemCountResponse {
    return CMsgResetStrangeGemCountResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgResetStrangeGemCountResponse>): CMsgResetStrangeGemCountResponse {
    const message = createBaseCMsgResetStrangeGemCountResponse();
    message.response = object.response ?? 0;
    return message;
  },
};

function createBaseCMsgGCToClientPollFileRequest(): CMsgGCToClientPollFileRequest {
  return { fileName: "", clientVersion: 0, pollId: 0 };
}

export const CMsgGCToClientPollFileRequest: MessageFns<CMsgGCToClientPollFileRequest> = {
  encode(message: CMsgGCToClientPollFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileName !== "") {
      writer.uint32(10).string(message.fileName);
    }
    if (message.clientVersion !== 0) {
      writer.uint32(16).uint32(message.clientVersion);
    }
    if (message.pollId !== 0) {
      writer.uint32(24).uint32(message.pollId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToClientPollFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientPollFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.clientVersion = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pollId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientPollFileRequest {
    return {
      fileName: isSet(object.fileName) ? globalThis.String(object.fileName) : "",
      clientVersion: isSet(object.clientVersion) ? globalThis.Number(object.clientVersion) : 0,
      pollId: isSet(object.pollId) ? globalThis.Number(object.pollId) : 0,
    };
  },

  toJSON(message: CMsgGCToClientPollFileRequest): unknown {
    const obj: any = {};
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.clientVersion !== 0) {
      obj.clientVersion = Math.round(message.clientVersion);
    }
    if (message.pollId !== 0) {
      obj.pollId = Math.round(message.pollId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToClientPollFileRequest>): CMsgGCToClientPollFileRequest {
    return CMsgGCToClientPollFileRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToClientPollFileRequest>): CMsgGCToClientPollFileRequest {
    const message = createBaseCMsgGCToClientPollFileRequest();
    message.fileName = object.fileName ?? "";
    message.clientVersion = object.clientVersion ?? 0;
    message.pollId = object.pollId ?? 0;
    return message;
  },
};

function createBaseCMsgGCToClientPollFileResponse(): CMsgGCToClientPollFileResponse {
  return { pollId: 0, fileSize: 0, fileCrc: 0 };
}

export const CMsgGCToClientPollFileResponse: MessageFns<CMsgGCToClientPollFileResponse> = {
  encode(message: CMsgGCToClientPollFileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pollId !== 0) {
      writer.uint32(8).uint32(message.pollId);
    }
    if (message.fileSize !== 0) {
      writer.uint32(16).uint32(message.fileSize);
    }
    if (message.fileCrc !== 0) {
      writer.uint32(24).uint32(message.fileCrc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToClientPollFileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientPollFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pollId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fileSize = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fileCrc = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientPollFileResponse {
    return {
      pollId: isSet(object.pollId) ? globalThis.Number(object.pollId) : 0,
      fileSize: isSet(object.fileSize) ? globalThis.Number(object.fileSize) : 0,
      fileCrc: isSet(object.fileCrc) ? globalThis.Number(object.fileCrc) : 0,
    };
  },

  toJSON(message: CMsgGCToClientPollFileResponse): unknown {
    const obj: any = {};
    if (message.pollId !== 0) {
      obj.pollId = Math.round(message.pollId);
    }
    if (message.fileSize !== 0) {
      obj.fileSize = Math.round(message.fileSize);
    }
    if (message.fileCrc !== 0) {
      obj.fileCrc = Math.round(message.fileCrc);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToClientPollFileResponse>): CMsgGCToClientPollFileResponse {
    return CMsgGCToClientPollFileResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToClientPollFileResponse>): CMsgGCToClientPollFileResponse {
    const message = createBaseCMsgGCToClientPollFileResponse();
    message.pollId = object.pollId ?? 0;
    message.fileSize = object.fileSize ?? 0;
    message.fileCrc = object.fileCrc ?? 0;
    return message;
  },
};

function createBaseCMsgGCToGCPerformManualOp(): CMsgGCToGCPerformManualOp {
  return { opId: "0", groupCode: 0 };
}

export const CMsgGCToGCPerformManualOp: MessageFns<CMsgGCToGCPerformManualOp> = {
  encode(message: CMsgGCToGCPerformManualOp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.opId !== "0") {
      writer.uint32(8).uint64(message.opId);
    }
    if (message.groupCode !== 0) {
      writer.uint32(16).uint32(message.groupCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCPerformManualOp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCPerformManualOp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.opId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.groupCode = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCPerformManualOp {
    return {
      opId: isSet(object.opId) ? globalThis.String(object.opId) : "0",
      groupCode: isSet(object.groupCode) ? globalThis.Number(object.groupCode) : 0,
    };
  },

  toJSON(message: CMsgGCToGCPerformManualOp): unknown {
    const obj: any = {};
    if (message.opId !== "0") {
      obj.opId = message.opId;
    }
    if (message.groupCode !== 0) {
      obj.groupCode = Math.round(message.groupCode);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCPerformManualOp>): CMsgGCToGCPerformManualOp {
    return CMsgGCToGCPerformManualOp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToGCPerformManualOp>): CMsgGCToGCPerformManualOp {
    const message = createBaseCMsgGCToGCPerformManualOp();
    message.opId = object.opId ?? "0";
    message.groupCode = object.groupCode ?? 0;
    return message;
  },
};

function createBaseCMsgGCToGCPerformManualOpCompleted(): CMsgGCToGCPerformManualOpCompleted {
  return { success: false, sourceGc: -1 };
}

export const CMsgGCToGCPerformManualOpCompleted: MessageFns<CMsgGCToGCPerformManualOpCompleted> = {
  encode(message: CMsgGCToGCPerformManualOpCompleted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.sourceGc !== -1) {
      writer.uint32(16).int32(message.sourceGc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCPerformManualOpCompleted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCPerformManualOpCompleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sourceGc = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCPerformManualOpCompleted {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      sourceGc: isSet(object.sourceGc) ? globalThis.Number(object.sourceGc) : -1,
    };
  },

  toJSON(message: CMsgGCToGCPerformManualOpCompleted): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.sourceGc !== -1) {
      obj.sourceGc = Math.round(message.sourceGc);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCPerformManualOpCompleted>): CMsgGCToGCPerformManualOpCompleted {
    return CMsgGCToGCPerformManualOpCompleted.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToGCPerformManualOpCompleted>): CMsgGCToGCPerformManualOpCompleted {
    const message = createBaseCMsgGCToGCPerformManualOpCompleted();
    message.success = object.success ?? false;
    message.sourceGc = object.sourceGc ?? -1;
    return message;
  },
};

function createBaseCMsgGCToGCReloadServerRegionSettings(): CMsgGCToGCReloadServerRegionSettings {
  return {};
}

export const CMsgGCToGCReloadServerRegionSettings: MessageFns<CMsgGCToGCReloadServerRegionSettings> = {
  encode(_: CMsgGCToGCReloadServerRegionSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCReloadServerRegionSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCReloadServerRegionSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgGCToGCReloadServerRegionSettings {
    return {};
  },

  toJSON(_: CMsgGCToGCReloadServerRegionSettings): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCReloadServerRegionSettings>): CMsgGCToGCReloadServerRegionSettings {
    return CMsgGCToGCReloadServerRegionSettings.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgGCToGCReloadServerRegionSettings>): CMsgGCToGCReloadServerRegionSettings {
    const message = createBaseCMsgGCToGCReloadServerRegionSettings();
    return message;
  },
};

function createBaseCMsgGCAdditionalWelcomeMsgList(): CMsgGCAdditionalWelcomeMsgList {
  return { welcomeMessages: [] };
}

export const CMsgGCAdditionalWelcomeMsgList: MessageFns<CMsgGCAdditionalWelcomeMsgList> = {
  encode(message: CMsgGCAdditionalWelcomeMsgList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.welcomeMessages) {
      CExtraMsgBlock.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCAdditionalWelcomeMsgList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCAdditionalWelcomeMsgList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.welcomeMessages.push(CExtraMsgBlock.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCAdditionalWelcomeMsgList {
    return {
      welcomeMessages: globalThis.Array.isArray(object?.welcomeMessages)
        ? object.welcomeMessages.map((e: any) => CExtraMsgBlock.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCAdditionalWelcomeMsgList): unknown {
    const obj: any = {};
    if (message.welcomeMessages?.length) {
      obj.welcomeMessages = message.welcomeMessages.map((e) => CExtraMsgBlock.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCAdditionalWelcomeMsgList>): CMsgGCAdditionalWelcomeMsgList {
    return CMsgGCAdditionalWelcomeMsgList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCAdditionalWelcomeMsgList>): CMsgGCAdditionalWelcomeMsgList {
    const message = createBaseCMsgGCAdditionalWelcomeMsgList();
    message.welcomeMessages = object.welcomeMessages?.map((e) => CExtraMsgBlock.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgApplyRemoteConVars(): CMsgApplyRemoteConVars {
  return { conVars: [] };
}

export const CMsgApplyRemoteConVars: MessageFns<CMsgApplyRemoteConVars> = {
  encode(message: CMsgApplyRemoteConVars, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conVars) {
      CMsgApplyRemoteConVars_ConVar.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgApplyRemoteConVars {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgApplyRemoteConVars();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conVars.push(CMsgApplyRemoteConVars_ConVar.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgApplyRemoteConVars {
    return {
      conVars: globalThis.Array.isArray(object?.conVars)
        ? object.conVars.map((e: any) => CMsgApplyRemoteConVars_ConVar.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgApplyRemoteConVars): unknown {
    const obj: any = {};
    if (message.conVars?.length) {
      obj.conVars = message.conVars.map((e) => CMsgApplyRemoteConVars_ConVar.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgApplyRemoteConVars>): CMsgApplyRemoteConVars {
    return CMsgApplyRemoteConVars.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgApplyRemoteConVars>): CMsgApplyRemoteConVars {
    const message = createBaseCMsgApplyRemoteConVars();
    message.conVars = object.conVars?.map((e) => CMsgApplyRemoteConVars_ConVar.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgApplyRemoteConVars_ConVar(): CMsgApplyRemoteConVars_ConVar {
  return { name: "", value: "", versionMin: 0, versionMax: 0, platform: 0 };
}

export const CMsgApplyRemoteConVars_ConVar: MessageFns<CMsgApplyRemoteConVars_ConVar> = {
  encode(message: CMsgApplyRemoteConVars_ConVar, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.versionMin !== 0) {
      writer.uint32(24).uint32(message.versionMin);
    }
    if (message.versionMax !== 0) {
      writer.uint32(32).uint32(message.versionMax);
    }
    if (message.platform !== 0) {
      writer.uint32(40).int32(message.platform);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgApplyRemoteConVars_ConVar {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgApplyRemoteConVars_ConVar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.versionMin = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.versionMax = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.platform = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgApplyRemoteConVars_ConVar {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      versionMin: isSet(object.versionMin) ? globalThis.Number(object.versionMin) : 0,
      versionMax: isSet(object.versionMax) ? globalThis.Number(object.versionMax) : 0,
      platform: isSet(object.platform) ? eGCPlatformFromJSON(object.platform) : 0,
    };
  },

  toJSON(message: CMsgApplyRemoteConVars_ConVar): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.versionMin !== 0) {
      obj.versionMin = Math.round(message.versionMin);
    }
    if (message.versionMax !== 0) {
      obj.versionMax = Math.round(message.versionMax);
    }
    if (message.platform !== 0) {
      obj.platform = eGCPlatformToJSON(message.platform);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgApplyRemoteConVars_ConVar>): CMsgApplyRemoteConVars_ConVar {
    return CMsgApplyRemoteConVars_ConVar.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgApplyRemoteConVars_ConVar>): CMsgApplyRemoteConVars_ConVar {
    const message = createBaseCMsgApplyRemoteConVars_ConVar();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    message.versionMin = object.versionMin ?? 0;
    message.versionMax = object.versionMax ?? 0;
    message.platform = object.platform ?? 0;
    return message;
  },
};

function createBaseCMsgGCToClientApplyRemoteConVars(): CMsgGCToClientApplyRemoteConVars {
  return { msg: undefined };
}

export const CMsgGCToClientApplyRemoteConVars: MessageFns<CMsgGCToClientApplyRemoteConVars> = {
  encode(message: CMsgGCToClientApplyRemoteConVars, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msg !== undefined) {
      CMsgApplyRemoteConVars.encode(message.msg, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToClientApplyRemoteConVars {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientApplyRemoteConVars();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.msg = CMsgApplyRemoteConVars.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientApplyRemoteConVars {
    return { msg: isSet(object.msg) ? CMsgApplyRemoteConVars.fromJSON(object.msg) : undefined };
  },

  toJSON(message: CMsgGCToClientApplyRemoteConVars): unknown {
    const obj: any = {};
    if (message.msg !== undefined) {
      obj.msg = CMsgApplyRemoteConVars.toJSON(message.msg);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToClientApplyRemoteConVars>): CMsgGCToClientApplyRemoteConVars {
    return CMsgGCToClientApplyRemoteConVars.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToClientApplyRemoteConVars>): CMsgGCToClientApplyRemoteConVars {
    const message = createBaseCMsgGCToClientApplyRemoteConVars();
    message.msg = (object.msg !== undefined && object.msg !== null)
      ? CMsgApplyRemoteConVars.fromPartial(object.msg)
      : undefined;
    return message;
  },
};

function createBaseCMsgGCToServerApplyRemoteConVars(): CMsgGCToServerApplyRemoteConVars {
  return { msg: undefined };
}

export const CMsgGCToServerApplyRemoteConVars: MessageFns<CMsgGCToServerApplyRemoteConVars> = {
  encode(message: CMsgGCToServerApplyRemoteConVars, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msg !== undefined) {
      CMsgApplyRemoteConVars.encode(message.msg, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToServerApplyRemoteConVars {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToServerApplyRemoteConVars();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.msg = CMsgApplyRemoteConVars.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToServerApplyRemoteConVars {
    return { msg: isSet(object.msg) ? CMsgApplyRemoteConVars.fromJSON(object.msg) : undefined };
  },

  toJSON(message: CMsgGCToServerApplyRemoteConVars): unknown {
    const obj: any = {};
    if (message.msg !== undefined) {
      obj.msg = CMsgApplyRemoteConVars.toJSON(message.msg);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToServerApplyRemoteConVars>): CMsgGCToServerApplyRemoteConVars {
    return CMsgGCToServerApplyRemoteConVars.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToServerApplyRemoteConVars>): CMsgGCToServerApplyRemoteConVars {
    const message = createBaseCMsgGCToServerApplyRemoteConVars();
    message.msg = (object.msg !== undefined && object.msg !== null)
      ? CMsgApplyRemoteConVars.fromPartial(object.msg)
      : undefined;
    return message;
  },
};

function createBaseCMsgClientToGCIntegrityStatus(): CMsgClientToGCIntegrityStatus {
  return { report: "", secureAllowed: false, diagnostics: [] };
}

export const CMsgClientToGCIntegrityStatus: MessageFns<CMsgClientToGCIntegrityStatus> = {
  encode(message: CMsgClientToGCIntegrityStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.report !== "") {
      writer.uint32(10).string(message.report);
    }
    if (message.secureAllowed !== false) {
      writer.uint32(16).bool(message.secureAllowed);
    }
    for (const v of message.diagnostics) {
      CMsgClientToGCIntegrityStatus_keyvalue.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCIntegrityStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCIntegrityStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.report = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.secureAllowed = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.diagnostics.push(CMsgClientToGCIntegrityStatus_keyvalue.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCIntegrityStatus {
    return {
      report: isSet(object.report) ? globalThis.String(object.report) : "",
      secureAllowed: isSet(object.secureAllowed) ? globalThis.Boolean(object.secureAllowed) : false,
      diagnostics: globalThis.Array.isArray(object?.diagnostics)
        ? object.diagnostics.map((e: any) => CMsgClientToGCIntegrityStatus_keyvalue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientToGCIntegrityStatus): unknown {
    const obj: any = {};
    if (message.report !== "") {
      obj.report = message.report;
    }
    if (message.secureAllowed !== false) {
      obj.secureAllowed = message.secureAllowed;
    }
    if (message.diagnostics?.length) {
      obj.diagnostics = message.diagnostics.map((e) => CMsgClientToGCIntegrityStatus_keyvalue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCIntegrityStatus>): CMsgClientToGCIntegrityStatus {
    return CMsgClientToGCIntegrityStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCIntegrityStatus>): CMsgClientToGCIntegrityStatus {
    const message = createBaseCMsgClientToGCIntegrityStatus();
    message.report = object.report ?? "";
    message.secureAllowed = object.secureAllowed ?? false;
    message.diagnostics = object.diagnostics?.map((e) => CMsgClientToGCIntegrityStatus_keyvalue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgClientToGCIntegrityStatus_keyvalue(): CMsgClientToGCIntegrityStatus_keyvalue {
  return { id: 0, extended: 0, value: "0", stringValue: "" };
}

export const CMsgClientToGCIntegrityStatus_keyvalue: MessageFns<CMsgClientToGCIntegrityStatus_keyvalue> = {
  encode(message: CMsgClientToGCIntegrityStatus_keyvalue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.extended !== 0) {
      writer.uint32(16).uint32(message.extended);
    }
    if (message.value !== "0") {
      writer.uint32(24).uint64(message.value);
    }
    if (message.stringValue !== "") {
      writer.uint32(34).string(message.stringValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCIntegrityStatus_keyvalue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCIntegrityStatus_keyvalue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.extended = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.value = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCIntegrityStatus_keyvalue {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      extended: isSet(object.extended) ? globalThis.Number(object.extended) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "0",
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : "",
    };
  },

  toJSON(message: CMsgClientToGCIntegrityStatus_keyvalue): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.extended !== 0) {
      obj.extended = Math.round(message.extended);
    }
    if (message.value !== "0") {
      obj.value = message.value;
    }
    if (message.stringValue !== "") {
      obj.stringValue = message.stringValue;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCIntegrityStatus_keyvalue>): CMsgClientToGCIntegrityStatus_keyvalue {
    return CMsgClientToGCIntegrityStatus_keyvalue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCIntegrityStatus_keyvalue>): CMsgClientToGCIntegrityStatus_keyvalue {
    const message = createBaseCMsgClientToGCIntegrityStatus_keyvalue();
    message.id = object.id ?? 0;
    message.extended = object.extended ?? 0;
    message.value = object.value ?? "0";
    message.stringValue = object.stringValue ?? "";
    return message;
  },
};

function createBaseCMsgClientToGCAggregateMetrics(): CMsgClientToGCAggregateMetrics {
  return { metrics: [] };
}

export const CMsgClientToGCAggregateMetrics: MessageFns<CMsgClientToGCAggregateMetrics> = {
  encode(message: CMsgClientToGCAggregateMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.metrics) {
      CMsgClientToGCAggregateMetrics_SingleMetric.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCAggregateMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCAggregateMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metrics.push(CMsgClientToGCAggregateMetrics_SingleMetric.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCAggregateMetrics {
    return {
      metrics: globalThis.Array.isArray(object?.metrics)
        ? object.metrics.map((e: any) => CMsgClientToGCAggregateMetrics_SingleMetric.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientToGCAggregateMetrics): unknown {
    const obj: any = {};
    if (message.metrics?.length) {
      obj.metrics = message.metrics.map((e) => CMsgClientToGCAggregateMetrics_SingleMetric.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCAggregateMetrics>): CMsgClientToGCAggregateMetrics {
    return CMsgClientToGCAggregateMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCAggregateMetrics>): CMsgClientToGCAggregateMetrics {
    const message = createBaseCMsgClientToGCAggregateMetrics();
    message.metrics = object.metrics?.map((e) => CMsgClientToGCAggregateMetrics_SingleMetric.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgClientToGCAggregateMetrics_SingleMetric(): CMsgClientToGCAggregateMetrics_SingleMetric {
  return { metricName: "", metricCount: 0 };
}

export const CMsgClientToGCAggregateMetrics_SingleMetric: MessageFns<CMsgClientToGCAggregateMetrics_SingleMetric> = {
  encode(
    message: CMsgClientToGCAggregateMetrics_SingleMetric,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.metricName !== "") {
      writer.uint32(10).string(message.metricName);
    }
    if (message.metricCount !== 0) {
      writer.uint32(16).uint32(message.metricCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCAggregateMetrics_SingleMetric {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCAggregateMetrics_SingleMetric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metricName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.metricCount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCAggregateMetrics_SingleMetric {
    return {
      metricName: isSet(object.metricName) ? globalThis.String(object.metricName) : "",
      metricCount: isSet(object.metricCount) ? globalThis.Number(object.metricCount) : 0,
    };
  },

  toJSON(message: CMsgClientToGCAggregateMetrics_SingleMetric): unknown {
    const obj: any = {};
    if (message.metricName !== "") {
      obj.metricName = message.metricName;
    }
    if (message.metricCount !== 0) {
      obj.metricCount = Math.round(message.metricCount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCAggregateMetrics_SingleMetric>): CMsgClientToGCAggregateMetrics_SingleMetric {
    return CMsgClientToGCAggregateMetrics_SingleMetric.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgClientToGCAggregateMetrics_SingleMetric>,
  ): CMsgClientToGCAggregateMetrics_SingleMetric {
    const message = createBaseCMsgClientToGCAggregateMetrics_SingleMetric();
    message.metricName = object.metricName ?? "";
    message.metricCount = object.metricCount ?? 0;
    return message;
  },
};

function createBaseCMsgGCToClientAggregateMetricsBackoff(): CMsgGCToClientAggregateMetricsBackoff {
  return { uploadRateModifier: 0 };
}

export const CMsgGCToClientAggregateMetricsBackoff: MessageFns<CMsgGCToClientAggregateMetricsBackoff> = {
  encode(message: CMsgGCToClientAggregateMetricsBackoff, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uploadRateModifier !== 0) {
      writer.uint32(13).float(message.uploadRateModifier);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToClientAggregateMetricsBackoff {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientAggregateMetricsBackoff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.uploadRateModifier = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientAggregateMetricsBackoff {
    return { uploadRateModifier: isSet(object.uploadRateModifier) ? globalThis.Number(object.uploadRateModifier) : 0 };
  },

  toJSON(message: CMsgGCToClientAggregateMetricsBackoff): unknown {
    const obj: any = {};
    if (message.uploadRateModifier !== 0) {
      obj.uploadRateModifier = message.uploadRateModifier;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToClientAggregateMetricsBackoff>): CMsgGCToClientAggregateMetricsBackoff {
    return CMsgGCToClientAggregateMetricsBackoff.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToClientAggregateMetricsBackoff>): CMsgGCToClientAggregateMetricsBackoff {
    const message = createBaseCMsgGCToClientAggregateMetricsBackoff();
    message.uploadRateModifier = object.uploadRateModifier ?? 0;
    return message;
  },
};

function createBaseCMsgGCToServerSteamLearnAccessTokensChanged(): CMsgGCToServerSteamLearnAccessTokensChanged {
  return { accessTokens: undefined };
}

export const CMsgGCToServerSteamLearnAccessTokensChanged: MessageFns<CMsgGCToServerSteamLearnAccessTokensChanged> = {
  encode(
    message: CMsgGCToServerSteamLearnAccessTokensChanged,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accessTokens !== undefined) {
      CMsgSteamLearnAccessTokens.encode(message.accessTokens, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToServerSteamLearnAccessTokensChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToServerSteamLearnAccessTokensChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessTokens = CMsgSteamLearnAccessTokens.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToServerSteamLearnAccessTokensChanged {
    return {
      accessTokens: isSet(object.accessTokens) ? CMsgSteamLearnAccessTokens.fromJSON(object.accessTokens) : undefined,
    };
  },

  toJSON(message: CMsgGCToServerSteamLearnAccessTokensChanged): unknown {
    const obj: any = {};
    if (message.accessTokens !== undefined) {
      obj.accessTokens = CMsgSteamLearnAccessTokens.toJSON(message.accessTokens);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToServerSteamLearnAccessTokensChanged>): CMsgGCToServerSteamLearnAccessTokensChanged {
    return CMsgGCToServerSteamLearnAccessTokensChanged.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGCToServerSteamLearnAccessTokensChanged>,
  ): CMsgGCToServerSteamLearnAccessTokensChanged {
    const message = createBaseCMsgGCToServerSteamLearnAccessTokensChanged();
    message.accessTokens = (object.accessTokens !== undefined && object.accessTokens !== null)
      ? CMsgSteamLearnAccessTokens.fromPartial(object.accessTokens)
      : undefined;
    return message;
  },
};

function createBaseCMsgGCToServerSteamLearnUseHTTP(): CMsgGCToServerSteamLearnUseHTTP {
  return { useHttp: false };
}

export const CMsgGCToServerSteamLearnUseHTTP: MessageFns<CMsgGCToServerSteamLearnUseHTTP> = {
  encode(message: CMsgGCToServerSteamLearnUseHTTP, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useHttp !== false) {
      writer.uint32(8).bool(message.useHttp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToServerSteamLearnUseHTTP {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToServerSteamLearnUseHTTP();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.useHttp = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToServerSteamLearnUseHTTP {
    return { useHttp: isSet(object.useHttp) ? globalThis.Boolean(object.useHttp) : false };
  },

  toJSON(message: CMsgGCToServerSteamLearnUseHTTP): unknown {
    const obj: any = {};
    if (message.useHttp !== false) {
      obj.useHttp = message.useHttp;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToServerSteamLearnUseHTTP>): CMsgGCToServerSteamLearnUseHTTP {
    return CMsgGCToServerSteamLearnUseHTTP.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToServerSteamLearnUseHTTP>): CMsgGCToServerSteamLearnUseHTTP {
    const message = createBaseCMsgGCToServerSteamLearnUseHTTP();
    message.useHttp = object.useHttp ?? false;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
