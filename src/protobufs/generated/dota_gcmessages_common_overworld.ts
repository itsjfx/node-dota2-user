// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.4.1
//   protoc               v5.28.3
// source: dota_gcmessages_common_overworld.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { CMsgDOTAClaimEventActionResponse } from "./dota_gcmessages_common";
import { CMsgSurvivorsUserData } from "./dota_gcmessages_common_survivors";
import { CExtraMsgBlock } from "./gcsdk_gcmessages";

export enum EOverworldNodeState {
  k_eOverworldNodeState_Invalid = 0,
  k_eOverworldNodeState_Locked = 1,
  k_eOverworldNodeState_Unlocked = 2,
}

export function eOverworldNodeStateFromJSON(object: any): EOverworldNodeState {
  switch (object) {
    case 0:
    case "k_eOverworldNodeState_Invalid":
      return EOverworldNodeState.k_eOverworldNodeState_Invalid;
    case 1:
    case "k_eOverworldNodeState_Locked":
      return EOverworldNodeState.k_eOverworldNodeState_Locked;
    case 2:
    case "k_eOverworldNodeState_Unlocked":
      return EOverworldNodeState.k_eOverworldNodeState_Unlocked;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EOverworldNodeState");
  }
}

export function eOverworldNodeStateToJSON(object: EOverworldNodeState): string {
  switch (object) {
    case EOverworldNodeState.k_eOverworldNodeState_Invalid:
      return "k_eOverworldNodeState_Invalid";
    case EOverworldNodeState.k_eOverworldNodeState_Locked:
      return "k_eOverworldNodeState_Locked";
    case EOverworldNodeState.k_eOverworldNodeState_Unlocked:
      return "k_eOverworldNodeState_Unlocked";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EOverworldNodeState");
  }
}

export enum EOverworldPathState {
  k_eOverworldPathState_Invalid = 0,
  k_eOverworldPathState_Incomplete = 1,
  k_eOverworldPathState_Complete = 2,
}

export function eOverworldPathStateFromJSON(object: any): EOverworldPathState {
  switch (object) {
    case 0:
    case "k_eOverworldPathState_Invalid":
      return EOverworldPathState.k_eOverworldPathState_Invalid;
    case 1:
    case "k_eOverworldPathState_Incomplete":
      return EOverworldPathState.k_eOverworldPathState_Incomplete;
    case 2:
    case "k_eOverworldPathState_Complete":
      return EOverworldPathState.k_eOverworldPathState_Complete;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EOverworldPathState");
  }
}

export function eOverworldPathStateToJSON(object: EOverworldPathState): string {
  switch (object) {
    case EOverworldPathState.k_eOverworldPathState_Invalid:
      return "k_eOverworldPathState_Invalid";
    case EOverworldPathState.k_eOverworldPathState_Incomplete:
      return "k_eOverworldPathState_Incomplete";
    case EOverworldPathState.k_eOverworldPathState_Complete:
      return "k_eOverworldPathState_Complete";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EOverworldPathState");
  }
}

export enum EOverworldAuditAction {
  k_eOverworldAuditAction_Invalid = 0,
  k_eOverworldAuditAction_DevModifyTokens = 1,
  k_eOverworldAuditAction_DevClearInventory = 2,
  k_eOverworldAuditAction_DevGrantTokens = 3,
  k_eOverworldAuditAction_CompletePath = 4,
  k_eOverworldAuditAction_ClaimEncounterReward = 5,
  k_eOverworldAuditAction_DevResetNode = 6,
  k_eOverworldAuditAction_DevResetPath = 7,
  k_eOverworldAuditAction_MatchRewardsFull = 8,
  k_eOverworldAuditAction_MatchRewardsHalf = 9,
  k_eOverworldAuditAction_EventActionTokenGrant = 10,
  k_eOverworldAuditAction_TokenTraderLost = 11,
  k_eOverworldAuditAction_TokenTraderGained = 12,
  k_eOverworldAuditAction_EncounterRewardTokenCost = 13,
  k_eOverworldAuditAction_EncounterRewardTokenReward = 14,
  k_eOverworldAuditAction_SupportGrantTokens = 16,
  k_eOverworldAuditAction_TokenGiftSent = 17,
}

export function eOverworldAuditActionFromJSON(object: any): EOverworldAuditAction {
  switch (object) {
    case 0:
    case "k_eOverworldAuditAction_Invalid":
      return EOverworldAuditAction.k_eOverworldAuditAction_Invalid;
    case 1:
    case "k_eOverworldAuditAction_DevModifyTokens":
      return EOverworldAuditAction.k_eOverworldAuditAction_DevModifyTokens;
    case 2:
    case "k_eOverworldAuditAction_DevClearInventory":
      return EOverworldAuditAction.k_eOverworldAuditAction_DevClearInventory;
    case 3:
    case "k_eOverworldAuditAction_DevGrantTokens":
      return EOverworldAuditAction.k_eOverworldAuditAction_DevGrantTokens;
    case 4:
    case "k_eOverworldAuditAction_CompletePath":
      return EOverworldAuditAction.k_eOverworldAuditAction_CompletePath;
    case 5:
    case "k_eOverworldAuditAction_ClaimEncounterReward":
      return EOverworldAuditAction.k_eOverworldAuditAction_ClaimEncounterReward;
    case 6:
    case "k_eOverworldAuditAction_DevResetNode":
      return EOverworldAuditAction.k_eOverworldAuditAction_DevResetNode;
    case 7:
    case "k_eOverworldAuditAction_DevResetPath":
      return EOverworldAuditAction.k_eOverworldAuditAction_DevResetPath;
    case 8:
    case "k_eOverworldAuditAction_MatchRewardsFull":
      return EOverworldAuditAction.k_eOverworldAuditAction_MatchRewardsFull;
    case 9:
    case "k_eOverworldAuditAction_MatchRewardsHalf":
      return EOverworldAuditAction.k_eOverworldAuditAction_MatchRewardsHalf;
    case 10:
    case "k_eOverworldAuditAction_EventActionTokenGrant":
      return EOverworldAuditAction.k_eOverworldAuditAction_EventActionTokenGrant;
    case 11:
    case "k_eOverworldAuditAction_TokenTraderLost":
      return EOverworldAuditAction.k_eOverworldAuditAction_TokenTraderLost;
    case 12:
    case "k_eOverworldAuditAction_TokenTraderGained":
      return EOverworldAuditAction.k_eOverworldAuditAction_TokenTraderGained;
    case 13:
    case "k_eOverworldAuditAction_EncounterRewardTokenCost":
      return EOverworldAuditAction.k_eOverworldAuditAction_EncounterRewardTokenCost;
    case 14:
    case "k_eOverworldAuditAction_EncounterRewardTokenReward":
      return EOverworldAuditAction.k_eOverworldAuditAction_EncounterRewardTokenReward;
    case 16:
    case "k_eOverworldAuditAction_SupportGrantTokens":
      return EOverworldAuditAction.k_eOverworldAuditAction_SupportGrantTokens;
    case 17:
    case "k_eOverworldAuditAction_TokenGiftSent":
      return EOverworldAuditAction.k_eOverworldAuditAction_TokenGiftSent;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EOverworldAuditAction");
  }
}

export function eOverworldAuditActionToJSON(object: EOverworldAuditAction): string {
  switch (object) {
    case EOverworldAuditAction.k_eOverworldAuditAction_Invalid:
      return "k_eOverworldAuditAction_Invalid";
    case EOverworldAuditAction.k_eOverworldAuditAction_DevModifyTokens:
      return "k_eOverworldAuditAction_DevModifyTokens";
    case EOverworldAuditAction.k_eOverworldAuditAction_DevClearInventory:
      return "k_eOverworldAuditAction_DevClearInventory";
    case EOverworldAuditAction.k_eOverworldAuditAction_DevGrantTokens:
      return "k_eOverworldAuditAction_DevGrantTokens";
    case EOverworldAuditAction.k_eOverworldAuditAction_CompletePath:
      return "k_eOverworldAuditAction_CompletePath";
    case EOverworldAuditAction.k_eOverworldAuditAction_ClaimEncounterReward:
      return "k_eOverworldAuditAction_ClaimEncounterReward";
    case EOverworldAuditAction.k_eOverworldAuditAction_DevResetNode:
      return "k_eOverworldAuditAction_DevResetNode";
    case EOverworldAuditAction.k_eOverworldAuditAction_DevResetPath:
      return "k_eOverworldAuditAction_DevResetPath";
    case EOverworldAuditAction.k_eOverworldAuditAction_MatchRewardsFull:
      return "k_eOverworldAuditAction_MatchRewardsFull";
    case EOverworldAuditAction.k_eOverworldAuditAction_MatchRewardsHalf:
      return "k_eOverworldAuditAction_MatchRewardsHalf";
    case EOverworldAuditAction.k_eOverworldAuditAction_EventActionTokenGrant:
      return "k_eOverworldAuditAction_EventActionTokenGrant";
    case EOverworldAuditAction.k_eOverworldAuditAction_TokenTraderLost:
      return "k_eOverworldAuditAction_TokenTraderLost";
    case EOverworldAuditAction.k_eOverworldAuditAction_TokenTraderGained:
      return "k_eOverworldAuditAction_TokenTraderGained";
    case EOverworldAuditAction.k_eOverworldAuditAction_EncounterRewardTokenCost:
      return "k_eOverworldAuditAction_EncounterRewardTokenCost";
    case EOverworldAuditAction.k_eOverworldAuditAction_EncounterRewardTokenReward:
      return "k_eOverworldAuditAction_EncounterRewardTokenReward";
    case EOverworldAuditAction.k_eOverworldAuditAction_SupportGrantTokens:
      return "k_eOverworldAuditAction_SupportGrantTokens";
    case EOverworldAuditAction.k_eOverworldAuditAction_TokenGiftSent:
      return "k_eOverworldAuditAction_TokenGiftSent";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EOverworldAuditAction");
  }
}

export enum EOverworldMinigameAction {
  k_eOverworldMinigameAction_Invalid = 0,
  k_eOverworldMinigameAction_DevReset = 1,
  k_eOverworldMinigameAction_DevGiveCurrency = 2,
  k_eOverworldMinigameAction_Purchase = 3,
  k_eOverworldMinigameAction_SetOption = 4,
  k_eOverworldMinigameAction_ReportCurrencyGained = 5,
  k_eOverworldMinigameAction_UnlockDifficulty = 6,
}

export function eOverworldMinigameActionFromJSON(object: any): EOverworldMinigameAction {
  switch (object) {
    case 0:
    case "k_eOverworldMinigameAction_Invalid":
      return EOverworldMinigameAction.k_eOverworldMinigameAction_Invalid;
    case 1:
    case "k_eOverworldMinigameAction_DevReset":
      return EOverworldMinigameAction.k_eOverworldMinigameAction_DevReset;
    case 2:
    case "k_eOverworldMinigameAction_DevGiveCurrency":
      return EOverworldMinigameAction.k_eOverworldMinigameAction_DevGiveCurrency;
    case 3:
    case "k_eOverworldMinigameAction_Purchase":
      return EOverworldMinigameAction.k_eOverworldMinigameAction_Purchase;
    case 4:
    case "k_eOverworldMinigameAction_SetOption":
      return EOverworldMinigameAction.k_eOverworldMinigameAction_SetOption;
    case 5:
    case "k_eOverworldMinigameAction_ReportCurrencyGained":
      return EOverworldMinigameAction.k_eOverworldMinigameAction_ReportCurrencyGained;
    case 6:
    case "k_eOverworldMinigameAction_UnlockDifficulty":
      return EOverworldMinigameAction.k_eOverworldMinigameAction_UnlockDifficulty;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EOverworldMinigameAction");
  }
}

export function eOverworldMinigameActionToJSON(object: EOverworldMinigameAction): string {
  switch (object) {
    case EOverworldMinigameAction.k_eOverworldMinigameAction_Invalid:
      return "k_eOverworldMinigameAction_Invalid";
    case EOverworldMinigameAction.k_eOverworldMinigameAction_DevReset:
      return "k_eOverworldMinigameAction_DevReset";
    case EOverworldMinigameAction.k_eOverworldMinigameAction_DevGiveCurrency:
      return "k_eOverworldMinigameAction_DevGiveCurrency";
    case EOverworldMinigameAction.k_eOverworldMinigameAction_Purchase:
      return "k_eOverworldMinigameAction_Purchase";
    case EOverworldMinigameAction.k_eOverworldMinigameAction_SetOption:
      return "k_eOverworldMinigameAction_SetOption";
    case EOverworldMinigameAction.k_eOverworldMinigameAction_ReportCurrencyGained:
      return "k_eOverworldMinigameAction_ReportCurrencyGained";
    case EOverworldMinigameAction.k_eOverworldMinigameAction_UnlockDifficulty:
      return "k_eOverworldMinigameAction_UnlockDifficulty";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EOverworldMinigameAction");
  }
}

export interface CMsgOverworldTokenCount {
  tokenId: number;
  tokenCount: number;
}

export interface CMsgOverworldTokenQuantity {
  tokenCounts: CMsgOverworldTokenCount[];
}

export interface CMsgOverworldEncounterTokenTreasureData {
  rewardOptions: CMsgOverworldEncounterTokenTreasureData_RewardOption[];
}

export interface CMsgOverworldEncounterTokenTreasureData_RewardOption {
  rewardData: number;
  tokenCost: CMsgOverworldTokenQuantity | undefined;
  tokenReward: CMsgOverworldTokenQuantity | undefined;
}

export interface CMsgOverworldEncounterTokenQuestData {
  quests: CMsgOverworldEncounterTokenQuestData_Quest[];
}

export interface CMsgOverworldEncounterTokenQuestData_Quest {
  rewardData: number;
  tokenCost: CMsgOverworldTokenQuantity | undefined;
  tokenReward: CMsgOverworldTokenQuantity | undefined;
}

export interface CMsgOverworldHeroList {
  heroIds: number[];
}

export interface CMsgOverworldEncounterChooseHeroData {
  heroList: CMsgOverworldHeroList | undefined;
  additive: boolean;
}

export interface CMsgOverworldEncounterProgressData {
  choice: number;
  progress: number;
  maxProgress: number;
  visited: boolean;
}

export interface CMsgOverworldEncounterData {
  extraEncounterData: CExtraMsgBlock[];
}

export interface CMsgOverworldNode {
  nodeId: number;
  nodeState: EOverworldNodeState;
  nodeEncounterData: CMsgOverworldEncounterData | undefined;
}

export interface CMsgOverworldPath {
  pathId: number;
  pathCost: CMsgOverworldTokenQuantity | undefined;
  pathState: EOverworldPathState;
}

export interface CMsgOverworldMinigameCustomData {
  survivorsData?: CMsgSurvivorsUserData | undefined;
}

export interface CMsgOverworldMinigameUserData {
  nodeId: number;
  currencyAmount: number;
  customData: CMsgOverworldMinigameCustomData | undefined;
}

export interface CMsgOverworldUserData {
  tokenInventory: CMsgOverworldTokenQuantity | undefined;
  overworldNodes: CMsgOverworldNode[];
  overworldPaths: CMsgOverworldPath[];
  currentNodeId: number;
  minigameData: CMsgOverworldUserData_MinigameDataEntry[];
}

export interface CMsgOverworldUserData_MinigameDataEntry {
  key: number;
  value: CMsgOverworldMinigameUserData | undefined;
}

export interface CMsgOverworldMatchRewards {
  players: CMsgOverworldMatchRewards_Player[];
}

export interface CMsgOverworldMatchRewards_Player {
  playerSlot: number;
  tokens: CMsgOverworldTokenQuantity | undefined;
  overworldId: number;
}

export interface CMsgClientToGCOverworldGetUserData {
  overworldId: number;
}

export interface CMsgClientToGCOverworldGetUserDataResponse {
  response: CMsgClientToGCOverworldGetUserDataResponse_EResponse;
  userData: CMsgOverworldUserData | undefined;
}

export enum CMsgClientToGCOverworldGetUserDataResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
  k_eTimeout = 4,
  k_eInvalidOverworld = 5,
}

export function cMsgClientToGCOverworldGetUserDataResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCOverworldGetUserDataResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCOverworldGetUserDataResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCOverworldGetUserDataResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgClientToGCOverworldGetUserDataResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgClientToGCOverworldGetUserDataResponse_EResponse.k_eDisabled;
    case 4:
    case "k_eTimeout":
      return CMsgClientToGCOverworldGetUserDataResponse_EResponse.k_eTimeout;
    case 5:
    case "k_eInvalidOverworld":
      return CMsgClientToGCOverworldGetUserDataResponse_EResponse.k_eInvalidOverworld;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldGetUserDataResponse_EResponse",
      );
  }
}

export function cMsgClientToGCOverworldGetUserDataResponse_EResponseToJSON(
  object: CMsgClientToGCOverworldGetUserDataResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCOverworldGetUserDataResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCOverworldGetUserDataResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCOverworldGetUserDataResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCOverworldGetUserDataResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    case CMsgClientToGCOverworldGetUserDataResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCOverworldGetUserDataResponse_EResponse.k_eInvalidOverworld:
      return "k_eInvalidOverworld";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldGetUserDataResponse_EResponse",
      );
  }
}

export interface CMsgGCToClientOverworldUserDataUpdated {
  overworldId: number;
  userData: CMsgOverworldUserData | undefined;
}

export interface CMsgClientToGCOverworldCompletePath {
  overworldId: number;
  pathId: number;
}

export interface CMsgClientToGCOverworldCompletePathResponse {
  response: CMsgClientToGCOverworldCompletePathResponse_EResponse;
  claimResponse: CMsgDOTAClaimEventActionResponse | undefined;
}

export enum CMsgClientToGCOverworldCompletePathResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
  k_eTimeout = 4,
  k_eInvalidOverworld = 5,
  k_eInvalidPath = 6,
  k_eNotEnoughTokens = 7,
  k_ePathIsLocked = 8,
  k_ePathAlreadyUnlocked = 9,
}

export function cMsgClientToGCOverworldCompletePathResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCOverworldCompletePathResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCOverworldCompletePathResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCOverworldCompletePathResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgClientToGCOverworldCompletePathResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgClientToGCOverworldCompletePathResponse_EResponse.k_eDisabled;
    case 4:
    case "k_eTimeout":
      return CMsgClientToGCOverworldCompletePathResponse_EResponse.k_eTimeout;
    case 5:
    case "k_eInvalidOverworld":
      return CMsgClientToGCOverworldCompletePathResponse_EResponse.k_eInvalidOverworld;
    case 6:
    case "k_eInvalidPath":
      return CMsgClientToGCOverworldCompletePathResponse_EResponse.k_eInvalidPath;
    case 7:
    case "k_eNotEnoughTokens":
      return CMsgClientToGCOverworldCompletePathResponse_EResponse.k_eNotEnoughTokens;
    case 8:
    case "k_ePathIsLocked":
      return CMsgClientToGCOverworldCompletePathResponse_EResponse.k_ePathIsLocked;
    case 9:
    case "k_ePathAlreadyUnlocked":
      return CMsgClientToGCOverworldCompletePathResponse_EResponse.k_ePathAlreadyUnlocked;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldCompletePathResponse_EResponse",
      );
  }
}

export function cMsgClientToGCOverworldCompletePathResponse_EResponseToJSON(
  object: CMsgClientToGCOverworldCompletePathResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCOverworldCompletePathResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCOverworldCompletePathResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCOverworldCompletePathResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCOverworldCompletePathResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    case CMsgClientToGCOverworldCompletePathResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCOverworldCompletePathResponse_EResponse.k_eInvalidOverworld:
      return "k_eInvalidOverworld";
    case CMsgClientToGCOverworldCompletePathResponse_EResponse.k_eInvalidPath:
      return "k_eInvalidPath";
    case CMsgClientToGCOverworldCompletePathResponse_EResponse.k_eNotEnoughTokens:
      return "k_eNotEnoughTokens";
    case CMsgClientToGCOverworldCompletePathResponse_EResponse.k_ePathIsLocked:
      return "k_ePathIsLocked";
    case CMsgClientToGCOverworldCompletePathResponse_EResponse.k_ePathAlreadyUnlocked:
      return "k_ePathAlreadyUnlocked";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldCompletePathResponse_EResponse",
      );
  }
}

export interface CMsgOverworldEncounterPitFighterRewardData {
  tokenId: number;
  choice: number;
}

export interface CMsgClientToGCOverworldClaimEncounterReward {
  overworldId: number;
  nodeId: number;
  rewardData: number;
  periodicResourceId: number;
  extraRewardData: CMsgOverworldEncounterData | undefined;
  leaderboardData: number;
  leaderboardIndex: number;
}

export interface CMsgClientToGCOverworldClaimEncounterRewardResponse {
  response: CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse;
  claimResponse: CMsgDOTAClaimEventActionResponse | undefined;
  tokensReceived: CMsgOverworldTokenQuantity | undefined;
}

export enum CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
  k_eTimeout = 4,
  k_eInvalidOverworld = 5,
  k_eInvalidNode = 6,
  k_eNodeLocked = 7,
  k_eRewardAlreadyClaimed = 8,
  k_eNodeNotEncounter = 9,
  k_eEncounterMissingRewards = 10,
  k_eInvalidEncounterRewardStyle = 11,
  k_eInvalidEncounterData = 12,
  k_eNotEnoughTokensForReward = 13,
  k_eNotEnoughResourceForReward = 14,
  k_eInvalidRewardData = 15,
}

export function cMsgClientToGCOverworldClaimEncounterRewardResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eDisabled;
    case 4:
    case "k_eTimeout":
      return CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eTimeout;
    case 5:
    case "k_eInvalidOverworld":
      return CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eInvalidOverworld;
    case 6:
    case "k_eInvalidNode":
      return CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eInvalidNode;
    case 7:
    case "k_eNodeLocked":
      return CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eNodeLocked;
    case 8:
    case "k_eRewardAlreadyClaimed":
      return CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eRewardAlreadyClaimed;
    case 9:
    case "k_eNodeNotEncounter":
      return CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eNodeNotEncounter;
    case 10:
    case "k_eEncounterMissingRewards":
      return CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eEncounterMissingRewards;
    case 11:
    case "k_eInvalidEncounterRewardStyle":
      return CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eInvalidEncounterRewardStyle;
    case 12:
    case "k_eInvalidEncounterData":
      return CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eInvalidEncounterData;
    case 13:
    case "k_eNotEnoughTokensForReward":
      return CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eNotEnoughTokensForReward;
    case 14:
    case "k_eNotEnoughResourceForReward":
      return CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eNotEnoughResourceForReward;
    case 15:
    case "k_eInvalidRewardData":
      return CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eInvalidRewardData;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse",
      );
  }
}

export function cMsgClientToGCOverworldClaimEncounterRewardResponse_EResponseToJSON(
  object: CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    case CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eInvalidOverworld:
      return "k_eInvalidOverworld";
    case CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eInvalidNode:
      return "k_eInvalidNode";
    case CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eNodeLocked:
      return "k_eNodeLocked";
    case CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eRewardAlreadyClaimed:
      return "k_eRewardAlreadyClaimed";
    case CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eNodeNotEncounter:
      return "k_eNodeNotEncounter";
    case CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eEncounterMissingRewards:
      return "k_eEncounterMissingRewards";
    case CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eInvalidEncounterRewardStyle:
      return "k_eInvalidEncounterRewardStyle";
    case CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eInvalidEncounterData:
      return "k_eInvalidEncounterData";
    case CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eNotEnoughTokensForReward:
      return "k_eNotEnoughTokensForReward";
    case CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eNotEnoughResourceForReward:
      return "k_eNotEnoughResourceForReward";
    case CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse.k_eInvalidRewardData:
      return "k_eInvalidRewardData";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCOverworldVisitEncounter {
  overworldId: number;
  nodeId: number;
}

export interface CMsgClientToGCOverworldVisitEncounterResponse {
  response: CMsgClientToGCOverworldVisitEncounterResponse_EResponse;
}

export enum CMsgClientToGCOverworldVisitEncounterResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
  k_eTimeout = 4,
  k_eInvalidOverworld = 5,
  k_eInvalidNode = 6,
  k_eNodeLocked = 7,
  k_eNodeNotEncounter = 8,
  k_eAlreadyVisited = 9,
}

export function cMsgClientToGCOverworldVisitEncounterResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCOverworldVisitEncounterResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCOverworldVisitEncounterResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCOverworldVisitEncounterResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgClientToGCOverworldVisitEncounterResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgClientToGCOverworldVisitEncounterResponse_EResponse.k_eDisabled;
    case 4:
    case "k_eTimeout":
      return CMsgClientToGCOverworldVisitEncounterResponse_EResponse.k_eTimeout;
    case 5:
    case "k_eInvalidOverworld":
      return CMsgClientToGCOverworldVisitEncounterResponse_EResponse.k_eInvalidOverworld;
    case 6:
    case "k_eInvalidNode":
      return CMsgClientToGCOverworldVisitEncounterResponse_EResponse.k_eInvalidNode;
    case 7:
    case "k_eNodeLocked":
      return CMsgClientToGCOverworldVisitEncounterResponse_EResponse.k_eNodeLocked;
    case 8:
    case "k_eNodeNotEncounter":
      return CMsgClientToGCOverworldVisitEncounterResponse_EResponse.k_eNodeNotEncounter;
    case 9:
    case "k_eAlreadyVisited":
      return CMsgClientToGCOverworldVisitEncounterResponse_EResponse.k_eAlreadyVisited;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldVisitEncounterResponse_EResponse",
      );
  }
}

export function cMsgClientToGCOverworldVisitEncounterResponse_EResponseToJSON(
  object: CMsgClientToGCOverworldVisitEncounterResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCOverworldVisitEncounterResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCOverworldVisitEncounterResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCOverworldVisitEncounterResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCOverworldVisitEncounterResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    case CMsgClientToGCOverworldVisitEncounterResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCOverworldVisitEncounterResponse_EResponse.k_eInvalidOverworld:
      return "k_eInvalidOverworld";
    case CMsgClientToGCOverworldVisitEncounterResponse_EResponse.k_eInvalidNode:
      return "k_eInvalidNode";
    case CMsgClientToGCOverworldVisitEncounterResponse_EResponse.k_eNodeLocked:
      return "k_eNodeLocked";
    case CMsgClientToGCOverworldVisitEncounterResponse_EResponse.k_eNodeNotEncounter:
      return "k_eNodeNotEncounter";
    case CMsgClientToGCOverworldVisitEncounterResponse_EResponse.k_eAlreadyVisited:
      return "k_eAlreadyVisited";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldVisitEncounterResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCOverworldMoveToNode {
  overworldId: number;
  nodeId: number;
}

export interface CMsgClientToGCOverworldMoveToNodeResponse {
  response: CMsgClientToGCOverworldMoveToNodeResponse_EResponse;
}

export enum CMsgClientToGCOverworldMoveToNodeResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
  k_eTimeout = 4,
  k_eInvalidOverworld = 5,
  k_eInvalidNode = 6,
  k_eNodeLocked = 7,
}

export function cMsgClientToGCOverworldMoveToNodeResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCOverworldMoveToNodeResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCOverworldMoveToNodeResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCOverworldMoveToNodeResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgClientToGCOverworldMoveToNodeResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgClientToGCOverworldMoveToNodeResponse_EResponse.k_eDisabled;
    case 4:
    case "k_eTimeout":
      return CMsgClientToGCOverworldMoveToNodeResponse_EResponse.k_eTimeout;
    case 5:
    case "k_eInvalidOverworld":
      return CMsgClientToGCOverworldMoveToNodeResponse_EResponse.k_eInvalidOverworld;
    case 6:
    case "k_eInvalidNode":
      return CMsgClientToGCOverworldMoveToNodeResponse_EResponse.k_eInvalidNode;
    case 7:
    case "k_eNodeLocked":
      return CMsgClientToGCOverworldMoveToNodeResponse_EResponse.k_eNodeLocked;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldMoveToNodeResponse_EResponse",
      );
  }
}

export function cMsgClientToGCOverworldMoveToNodeResponse_EResponseToJSON(
  object: CMsgClientToGCOverworldMoveToNodeResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCOverworldMoveToNodeResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCOverworldMoveToNodeResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCOverworldMoveToNodeResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCOverworldMoveToNodeResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    case CMsgClientToGCOverworldMoveToNodeResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCOverworldMoveToNodeResponse_EResponse.k_eInvalidOverworld:
      return "k_eInvalidOverworld";
    case CMsgClientToGCOverworldMoveToNodeResponse_EResponse.k_eInvalidNode:
      return "k_eInvalidNode";
    case CMsgClientToGCOverworldMoveToNodeResponse_EResponse.k_eNodeLocked:
      return "k_eNodeLocked";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldMoveToNodeResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCOverworldTradeTokens {
  overworldId: number;
  tokenOffer: CMsgOverworldTokenQuantity | undefined;
  tokenRequest: CMsgOverworldTokenQuantity | undefined;
  recipe: number;
  encounterId: number;
}

export interface CMsgClientToGCOverworldTradeTokensResponse {
  response: CMsgClientToGCOverworldTradeTokensResponse_EResponse;
  tokensReceived: CMsgOverworldTokenQuantity | undefined;
}

export enum CMsgClientToGCOverworldTradeTokensResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
  k_eTimeout = 4,
  k_eNotAllowed = 5,
  k_eNodeLocked = 6,
  k_eInvalidOverworld = 7,
  k_eInvalidOffer = 8,
  k_eNotEnoughTokens = 9,
  k_eInvalidNode = 10,
  k_eInvalidEncounter = 11,
  k_eRewardDoesNotMatchRecipe = 12,
}

export function cMsgClientToGCOverworldTradeTokensResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCOverworldTradeTokensResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eDisabled;
    case 4:
    case "k_eTimeout":
      return CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eTimeout;
    case 5:
    case "k_eNotAllowed":
      return CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eNotAllowed;
    case 6:
    case "k_eNodeLocked":
      return CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eNodeLocked;
    case 7:
    case "k_eInvalidOverworld":
      return CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eInvalidOverworld;
    case 8:
    case "k_eInvalidOffer":
      return CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eInvalidOffer;
    case 9:
    case "k_eNotEnoughTokens":
      return CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eNotEnoughTokens;
    case 10:
    case "k_eInvalidNode":
      return CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eInvalidNode;
    case 11:
    case "k_eInvalidEncounter":
      return CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eInvalidEncounter;
    case 12:
    case "k_eRewardDoesNotMatchRecipe":
      return CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eRewardDoesNotMatchRecipe;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldTradeTokensResponse_EResponse",
      );
  }
}

export function cMsgClientToGCOverworldTradeTokensResponse_EResponseToJSON(
  object: CMsgClientToGCOverworldTradeTokensResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    case CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eNotAllowed:
      return "k_eNotAllowed";
    case CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eNodeLocked:
      return "k_eNodeLocked";
    case CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eInvalidOverworld:
      return "k_eInvalidOverworld";
    case CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eInvalidOffer:
      return "k_eInvalidOffer";
    case CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eNotEnoughTokens:
      return "k_eNotEnoughTokens";
    case CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eInvalidNode:
      return "k_eInvalidNode";
    case CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eInvalidEncounter:
      return "k_eInvalidEncounter";
    case CMsgClientToGCOverworldTradeTokensResponse_EResponse.k_eRewardDoesNotMatchRecipe:
      return "k_eRewardDoesNotMatchRecipe";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldTradeTokensResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCOverworldGiftTokens {
  overworldId: number;
  tokenGift: CMsgOverworldTokenCount | undefined;
  recipientAccountId: number;
  periodicResourceId: number;
}

export interface CMsgClientToGCOverworldGiftTokensResponse {
  response: CMsgClientToGCOverworldGiftTokensResponse_EResponse;
}

export enum CMsgClientToGCOverworldGiftTokensResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
  k_eTimeout = 4,
  k_eNotAllowed = 5,
  k_eNodeLocked = 6,
  k_eInvalidOverworld = 7,
  k_eInvalidGift = 8,
  k_eNotEnoughTokens = 9,
  k_eInvalidRecipient = 10,
  k_eNotEnoughPeriodicResource = 11,
}

export function cMsgClientToGCOverworldGiftTokensResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCOverworldGiftTokensResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eDisabled;
    case 4:
    case "k_eTimeout":
      return CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eTimeout;
    case 5:
    case "k_eNotAllowed":
      return CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eNotAllowed;
    case 6:
    case "k_eNodeLocked":
      return CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eNodeLocked;
    case 7:
    case "k_eInvalidOverworld":
      return CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eInvalidOverworld;
    case 8:
    case "k_eInvalidGift":
      return CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eInvalidGift;
    case 9:
    case "k_eNotEnoughTokens":
      return CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eNotEnoughTokens;
    case 10:
    case "k_eInvalidRecipient":
      return CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eInvalidRecipient;
    case 11:
    case "k_eNotEnoughPeriodicResource":
      return CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eNotEnoughPeriodicResource;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldGiftTokensResponse_EResponse",
      );
  }
}

export function cMsgClientToGCOverworldGiftTokensResponse_EResponseToJSON(
  object: CMsgClientToGCOverworldGiftTokensResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    case CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eNotAllowed:
      return "k_eNotAllowed";
    case CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eNodeLocked:
      return "k_eNodeLocked";
    case CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eInvalidOverworld:
      return "k_eInvalidOverworld";
    case CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eInvalidGift:
      return "k_eInvalidGift";
    case CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eNotEnoughTokens:
      return "k_eNotEnoughTokens";
    case CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eInvalidRecipient:
      return "k_eInvalidRecipient";
    case CMsgClientToGCOverworldGiftTokensResponse_EResponse.k_eNotEnoughPeriodicResource:
      return "k_eNotEnoughPeriodicResource";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldGiftTokensResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCOverworldRequestTokensNeededByFriend {
  friendAccountId: number;
  overworldId: number;
}

export interface CMsgClientToGCOverworldRequestTokensNeededByFriendResponse {
  response: CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse;
  tokenQuantity: CMsgOverworldTokenQuantity | undefined;
}

export enum CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
  k_eTimeout = 4,
  k_eNotAllowed = 5,
  k_eNodeLocked = 6,
  k_eInvalidOverworld = 7,
  k_eInvalidFriend = 8,
  k_eTooManyRequests = 9,
}

export function cMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse.k_eDisabled;
    case 4:
    case "k_eTimeout":
      return CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse.k_eTimeout;
    case 5:
    case "k_eNotAllowed":
      return CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse.k_eNotAllowed;
    case 6:
    case "k_eNodeLocked":
      return CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse.k_eNodeLocked;
    case 7:
    case "k_eInvalidOverworld":
      return CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse.k_eInvalidOverworld;
    case 8:
    case "k_eInvalidFriend":
      return CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse.k_eInvalidFriend;
    case 9:
    case "k_eTooManyRequests":
      return CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse.k_eTooManyRequests;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object +
          " for enum CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse",
      );
  }
}

export function cMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponseToJSON(
  object: CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    case CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse.k_eNotAllowed:
      return "k_eNotAllowed";
    case CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse.k_eNodeLocked:
      return "k_eNodeLocked";
    case CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse.k_eInvalidOverworld:
      return "k_eInvalidOverworld";
    case CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse.k_eInvalidFriend:
      return "k_eInvalidFriend";
    case CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse.k_eTooManyRequests:
      return "k_eTooManyRequests";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object +
          " for enum CMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCOverworldDevResetAll {
  overworldId: number;
}

export interface CMsgClientToGCOverworldDevResetAllResponse {
  response: CMsgClientToGCOverworldDevResetAllResponse_EResponse;
}

export enum CMsgClientToGCOverworldDevResetAllResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
  k_eTimeout = 4,
  k_eNotAllowed = 5,
  k_eInvalidOverworld = 6,
}

export function cMsgClientToGCOverworldDevResetAllResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCOverworldDevResetAllResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCOverworldDevResetAllResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCOverworldDevResetAllResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgClientToGCOverworldDevResetAllResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgClientToGCOverworldDevResetAllResponse_EResponse.k_eDisabled;
    case 4:
    case "k_eTimeout":
      return CMsgClientToGCOverworldDevResetAllResponse_EResponse.k_eTimeout;
    case 5:
    case "k_eNotAllowed":
      return CMsgClientToGCOverworldDevResetAllResponse_EResponse.k_eNotAllowed;
    case 6:
    case "k_eInvalidOverworld":
      return CMsgClientToGCOverworldDevResetAllResponse_EResponse.k_eInvalidOverworld;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldDevResetAllResponse_EResponse",
      );
  }
}

export function cMsgClientToGCOverworldDevResetAllResponse_EResponseToJSON(
  object: CMsgClientToGCOverworldDevResetAllResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCOverworldDevResetAllResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCOverworldDevResetAllResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCOverworldDevResetAllResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCOverworldDevResetAllResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    case CMsgClientToGCOverworldDevResetAllResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCOverworldDevResetAllResponse_EResponse.k_eNotAllowed:
      return "k_eNotAllowed";
    case CMsgClientToGCOverworldDevResetAllResponse_EResponse.k_eInvalidOverworld:
      return "k_eInvalidOverworld";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldDevResetAllResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCOverworldDevResetNode {
  overworldId: number;
  nodeId: number;
}

export interface CMsgClientToGCOverworldDevResetNodeResponse {
  response: CMsgClientToGCOverworldDevResetNodeResponse_EResponse;
}

export enum CMsgClientToGCOverworldDevResetNodeResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
  k_eTimeout = 4,
  k_eNotAllowed = 5,
  k_eInvalidOverworld = 6,
  k_eInvalidNode = 7,
}

export function cMsgClientToGCOverworldDevResetNodeResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCOverworldDevResetNodeResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCOverworldDevResetNodeResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCOverworldDevResetNodeResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgClientToGCOverworldDevResetNodeResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgClientToGCOverworldDevResetNodeResponse_EResponse.k_eDisabled;
    case 4:
    case "k_eTimeout":
      return CMsgClientToGCOverworldDevResetNodeResponse_EResponse.k_eTimeout;
    case 5:
    case "k_eNotAllowed":
      return CMsgClientToGCOverworldDevResetNodeResponse_EResponse.k_eNotAllowed;
    case 6:
    case "k_eInvalidOverworld":
      return CMsgClientToGCOverworldDevResetNodeResponse_EResponse.k_eInvalidOverworld;
    case 7:
    case "k_eInvalidNode":
      return CMsgClientToGCOverworldDevResetNodeResponse_EResponse.k_eInvalidNode;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldDevResetNodeResponse_EResponse",
      );
  }
}

export function cMsgClientToGCOverworldDevResetNodeResponse_EResponseToJSON(
  object: CMsgClientToGCOverworldDevResetNodeResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCOverworldDevResetNodeResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCOverworldDevResetNodeResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCOverworldDevResetNodeResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCOverworldDevResetNodeResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    case CMsgClientToGCOverworldDevResetNodeResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCOverworldDevResetNodeResponse_EResponse.k_eNotAllowed:
      return "k_eNotAllowed";
    case CMsgClientToGCOverworldDevResetNodeResponse_EResponse.k_eInvalidOverworld:
      return "k_eInvalidOverworld";
    case CMsgClientToGCOverworldDevResetNodeResponse_EResponse.k_eInvalidNode:
      return "k_eInvalidNode";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldDevResetNodeResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCOverworldDevGrantTokens {
  overworldId: number;
  tokenQuantity: CMsgOverworldTokenQuantity | undefined;
}

export interface CMsgClientToGCOverworldDevGrantTokensResponse {
  response: CMsgClientToGCOverworldDevGrantTokensResponse_EResponse;
}

export enum CMsgClientToGCOverworldDevGrantTokensResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
  k_eTimeout = 4,
  k_eNotAllowed = 5,
  k_eInvalidOverworld = 6,
}

export function cMsgClientToGCOverworldDevGrantTokensResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCOverworldDevGrantTokensResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCOverworldDevGrantTokensResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCOverworldDevGrantTokensResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgClientToGCOverworldDevGrantTokensResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgClientToGCOverworldDevGrantTokensResponse_EResponse.k_eDisabled;
    case 4:
    case "k_eTimeout":
      return CMsgClientToGCOverworldDevGrantTokensResponse_EResponse.k_eTimeout;
    case 5:
    case "k_eNotAllowed":
      return CMsgClientToGCOverworldDevGrantTokensResponse_EResponse.k_eNotAllowed;
    case 6:
    case "k_eInvalidOverworld":
      return CMsgClientToGCOverworldDevGrantTokensResponse_EResponse.k_eInvalidOverworld;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldDevGrantTokensResponse_EResponse",
      );
  }
}

export function cMsgClientToGCOverworldDevGrantTokensResponse_EResponseToJSON(
  object: CMsgClientToGCOverworldDevGrantTokensResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCOverworldDevGrantTokensResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCOverworldDevGrantTokensResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCOverworldDevGrantTokensResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCOverworldDevGrantTokensResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    case CMsgClientToGCOverworldDevGrantTokensResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCOverworldDevGrantTokensResponse_EResponse.k_eNotAllowed:
      return "k_eNotAllowed";
    case CMsgClientToGCOverworldDevGrantTokensResponse_EResponse.k_eInvalidOverworld:
      return "k_eInvalidOverworld";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldDevGrantTokensResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCOverworldDevClearInventory {
  overworldId: number;
}

export interface CMsgClientToGCOverworldDevClearInventoryResponse {
  response: CMsgClientToGCOverworldDevClearInventoryResponse_EResponse;
}

export enum CMsgClientToGCOverworldDevClearInventoryResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
  k_eTimeout = 4,
  k_eNotAllowed = 5,
  k_eInvalidOverworld = 6,
}

export function cMsgClientToGCOverworldDevClearInventoryResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCOverworldDevClearInventoryResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCOverworldDevClearInventoryResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCOverworldDevClearInventoryResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgClientToGCOverworldDevClearInventoryResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgClientToGCOverworldDevClearInventoryResponse_EResponse.k_eDisabled;
    case 4:
    case "k_eTimeout":
      return CMsgClientToGCOverworldDevClearInventoryResponse_EResponse.k_eTimeout;
    case 5:
    case "k_eNotAllowed":
      return CMsgClientToGCOverworldDevClearInventoryResponse_EResponse.k_eNotAllowed;
    case 6:
    case "k_eInvalidOverworld":
      return CMsgClientToGCOverworldDevClearInventoryResponse_EResponse.k_eInvalidOverworld;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldDevClearInventoryResponse_EResponse",
      );
  }
}

export function cMsgClientToGCOverworldDevClearInventoryResponse_EResponseToJSON(
  object: CMsgClientToGCOverworldDevClearInventoryResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCOverworldDevClearInventoryResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCOverworldDevClearInventoryResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCOverworldDevClearInventoryResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCOverworldDevClearInventoryResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    case CMsgClientToGCOverworldDevClearInventoryResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCOverworldDevClearInventoryResponse_EResponse.k_eNotAllowed:
      return "k_eNotAllowed";
    case CMsgClientToGCOverworldDevClearInventoryResponse_EResponse.k_eInvalidOverworld:
      return "k_eInvalidOverworld";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldDevClearInventoryResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCOverworldFeedback {
  language: number;
  overworldId: number;
  feedback: string;
}

export interface CMsgClientToGCOverworldFeedbackResponse {
  response: CMsgClientToGCOverworldFeedbackResponse_EResponse;
}

export enum CMsgClientToGCOverworldFeedbackResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
  k_eTimeout = 4,
  k_eNotAllowed = 5,
  k_eInvalidOverworld = 6,
}

export function cMsgClientToGCOverworldFeedbackResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCOverworldFeedbackResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCOverworldFeedbackResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCOverworldFeedbackResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgClientToGCOverworldFeedbackResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgClientToGCOverworldFeedbackResponse_EResponse.k_eDisabled;
    case 4:
    case "k_eTimeout":
      return CMsgClientToGCOverworldFeedbackResponse_EResponse.k_eTimeout;
    case 5:
    case "k_eNotAllowed":
      return CMsgClientToGCOverworldFeedbackResponse_EResponse.k_eNotAllowed;
    case 6:
    case "k_eInvalidOverworld":
      return CMsgClientToGCOverworldFeedbackResponse_EResponse.k_eInvalidOverworld;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldFeedbackResponse_EResponse",
      );
  }
}

export function cMsgClientToGCOverworldFeedbackResponse_EResponseToJSON(
  object: CMsgClientToGCOverworldFeedbackResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCOverworldFeedbackResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCOverworldFeedbackResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCOverworldFeedbackResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCOverworldFeedbackResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    case CMsgClientToGCOverworldFeedbackResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCOverworldFeedbackResponse_EResponse.k_eNotAllowed:
      return "k_eNotAllowed";
    case CMsgClientToGCOverworldFeedbackResponse_EResponse.k_eInvalidOverworld:
      return "k_eInvalidOverworld";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldFeedbackResponse_EResponse",
      );
  }
}

export interface CMsgClientToGCOverworldGetDynamicImage {
  magic: number;
  imageId: number;
  language: number;
}

export interface CMsgClientToGCOverworldGetDynamicImageResponse {
  imageId: number;
  images: CMsgClientToGCOverworldGetDynamicImageResponse_Image[];
}

export enum CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat {
  k_eUnknown = 0,
  k_ePNG = 1,
  k_eData = 2,
}

export function cMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormatFromJSON(
  object: any,
): CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat {
  switch (object) {
    case 0:
    case "k_eUnknown":
      return CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat.k_eUnknown;
    case 1:
    case "k_ePNG":
      return CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat.k_ePNG;
    case 2:
    case "k_eData":
      return CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat.k_eData;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object +
          " for enum CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat",
      );
  }
}

export function cMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormatToJSON(
  object: CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat,
): string {
  switch (object) {
    case CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat.k_eUnknown:
      return "k_eUnknown";
    case CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat.k_ePNG:
      return "k_ePNG";
    case CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat.k_eData:
      return "k_eData";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object +
          " for enum CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat",
      );
  }
}

export interface CMsgClientToGCOverworldGetDynamicImageResponse_Image {
  width: number;
  height: number;
  format: CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat;
  imageBytes: Buffer;
}

export interface CMsgClientToGCOverworldMinigameAction {
  overworldId: number;
  nodeId: number;
  action: EOverworldMinigameAction;
  selection: number;
  optionValue: number;
  currencyAmount: number;
}

export interface CMsgClientToGCOverworldMinigameActionResponse {
  response: CMsgClientToGCOverworldMinigameActionResponse_EResponse;
}

export enum CMsgClientToGCOverworldMinigameActionResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
  k_eTimeout = 4,
  k_eInvalidOverworld = 5,
  k_eInvalidNode = 6,
  k_eNodeLocked = 7,
  k_eInvalidSelection = 8,
  k_eNotEnoughTokens = 9,
  k_eNotEnoughMinigameCurrency = 10,
  k_eNotAllowed = 11,
}

export function cMsgClientToGCOverworldMinigameActionResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCOverworldMinigameActionResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eDisabled;
    case 4:
    case "k_eTimeout":
      return CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eTimeout;
    case 5:
    case "k_eInvalidOverworld":
      return CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eInvalidOverworld;
    case 6:
    case "k_eInvalidNode":
      return CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eInvalidNode;
    case 7:
    case "k_eNodeLocked":
      return CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eNodeLocked;
    case 8:
    case "k_eInvalidSelection":
      return CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eInvalidSelection;
    case 9:
    case "k_eNotEnoughTokens":
      return CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eNotEnoughTokens;
    case 10:
    case "k_eNotEnoughMinigameCurrency":
      return CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eNotEnoughMinigameCurrency;
    case 11:
    case "k_eNotAllowed":
      return CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eNotAllowed;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldMinigameActionResponse_EResponse",
      );
  }
}

export function cMsgClientToGCOverworldMinigameActionResponse_EResponseToJSON(
  object: CMsgClientToGCOverworldMinigameActionResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    case CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eInvalidOverworld:
      return "k_eInvalidOverworld";
    case CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eInvalidNode:
      return "k_eInvalidNode";
    case CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eNodeLocked:
      return "k_eNodeLocked";
    case CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eInvalidSelection:
      return "k_eInvalidSelection";
    case CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eNotEnoughTokens:
      return "k_eNotEnoughTokens";
    case CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eNotEnoughMinigameCurrency:
      return "k_eNotEnoughMinigameCurrency";
    case CMsgClientToGCOverworldMinigameActionResponse_EResponse.k_eNotAllowed:
      return "k_eNotAllowed";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCOverworldMinigameActionResponse_EResponse",
      );
  }
}

function createBaseCMsgOverworldTokenCount(): CMsgOverworldTokenCount {
  return { tokenId: 0, tokenCount: 0 };
}

export const CMsgOverworldTokenCount: MessageFns<CMsgOverworldTokenCount> = {
  encode(message: CMsgOverworldTokenCount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenId !== 0) {
      writer.uint32(8).uint32(message.tokenId);
    }
    if (message.tokenCount !== 0) {
      writer.uint32(16).uint32(message.tokenCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgOverworldTokenCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgOverworldTokenCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tokenId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tokenCount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgOverworldTokenCount {
    return {
      tokenId: isSet(object.tokenId) ? globalThis.Number(object.tokenId) : 0,
      tokenCount: isSet(object.tokenCount) ? globalThis.Number(object.tokenCount) : 0,
    };
  },

  toJSON(message: CMsgOverworldTokenCount): unknown {
    const obj: any = {};
    if (message.tokenId !== 0) {
      obj.tokenId = Math.round(message.tokenId);
    }
    if (message.tokenCount !== 0) {
      obj.tokenCount = Math.round(message.tokenCount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgOverworldTokenCount>): CMsgOverworldTokenCount {
    return CMsgOverworldTokenCount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgOverworldTokenCount>): CMsgOverworldTokenCount {
    const message = createBaseCMsgOverworldTokenCount();
    message.tokenId = object.tokenId ?? 0;
    message.tokenCount = object.tokenCount ?? 0;
    return message;
  },
};

function createBaseCMsgOverworldTokenQuantity(): CMsgOverworldTokenQuantity {
  return { tokenCounts: [] };
}

export const CMsgOverworldTokenQuantity: MessageFns<CMsgOverworldTokenQuantity> = {
  encode(message: CMsgOverworldTokenQuantity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tokenCounts) {
      CMsgOverworldTokenCount.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgOverworldTokenQuantity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgOverworldTokenQuantity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenCounts.push(CMsgOverworldTokenCount.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgOverworldTokenQuantity {
    return {
      tokenCounts: globalThis.Array.isArray(object?.tokenCounts)
        ? object.tokenCounts.map((e: any) => CMsgOverworldTokenCount.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgOverworldTokenQuantity): unknown {
    const obj: any = {};
    if (message.tokenCounts?.length) {
      obj.tokenCounts = message.tokenCounts.map((e) => CMsgOverworldTokenCount.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgOverworldTokenQuantity>): CMsgOverworldTokenQuantity {
    return CMsgOverworldTokenQuantity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgOverworldTokenQuantity>): CMsgOverworldTokenQuantity {
    const message = createBaseCMsgOverworldTokenQuantity();
    message.tokenCounts = object.tokenCounts?.map((e) => CMsgOverworldTokenCount.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgOverworldEncounterTokenTreasureData(): CMsgOverworldEncounterTokenTreasureData {
  return { rewardOptions: [] };
}

export const CMsgOverworldEncounterTokenTreasureData: MessageFns<CMsgOverworldEncounterTokenTreasureData> = {
  encode(message: CMsgOverworldEncounterTokenTreasureData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rewardOptions) {
      CMsgOverworldEncounterTokenTreasureData_RewardOption.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgOverworldEncounterTokenTreasureData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgOverworldEncounterTokenTreasureData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rewardOptions.push(
            CMsgOverworldEncounterTokenTreasureData_RewardOption.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgOverworldEncounterTokenTreasureData {
    return {
      rewardOptions: globalThis.Array.isArray(object?.rewardOptions)
        ? object.rewardOptions.map((e: any) => CMsgOverworldEncounterTokenTreasureData_RewardOption.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgOverworldEncounterTokenTreasureData): unknown {
    const obj: any = {};
    if (message.rewardOptions?.length) {
      obj.rewardOptions = message.rewardOptions.map((e) =>
        CMsgOverworldEncounterTokenTreasureData_RewardOption.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgOverworldEncounterTokenTreasureData>): CMsgOverworldEncounterTokenTreasureData {
    return CMsgOverworldEncounterTokenTreasureData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgOverworldEncounterTokenTreasureData>): CMsgOverworldEncounterTokenTreasureData {
    const message = createBaseCMsgOverworldEncounterTokenTreasureData();
    message.rewardOptions =
      object.rewardOptions?.map((e) => CMsgOverworldEncounterTokenTreasureData_RewardOption.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgOverworldEncounterTokenTreasureData_RewardOption(): CMsgOverworldEncounterTokenTreasureData_RewardOption {
  return { rewardData: 0, tokenCost: undefined, tokenReward: undefined };
}

export const CMsgOverworldEncounterTokenTreasureData_RewardOption: MessageFns<
  CMsgOverworldEncounterTokenTreasureData_RewardOption
> = {
  encode(
    message: CMsgOverworldEncounterTokenTreasureData_RewardOption,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.rewardData !== 0) {
      writer.uint32(8).uint32(message.rewardData);
    }
    if (message.tokenCost !== undefined) {
      CMsgOverworldTokenQuantity.encode(message.tokenCost, writer.uint32(18).fork()).join();
    }
    if (message.tokenReward !== undefined) {
      CMsgOverworldTokenQuantity.encode(message.tokenReward, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgOverworldEncounterTokenTreasureData_RewardOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgOverworldEncounterTokenTreasureData_RewardOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rewardData = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenCost = CMsgOverworldTokenQuantity.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenReward = CMsgOverworldTokenQuantity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgOverworldEncounterTokenTreasureData_RewardOption {
    return {
      rewardData: isSet(object.rewardData) ? globalThis.Number(object.rewardData) : 0,
      tokenCost: isSet(object.tokenCost) ? CMsgOverworldTokenQuantity.fromJSON(object.tokenCost) : undefined,
      tokenReward: isSet(object.tokenReward) ? CMsgOverworldTokenQuantity.fromJSON(object.tokenReward) : undefined,
    };
  },

  toJSON(message: CMsgOverworldEncounterTokenTreasureData_RewardOption): unknown {
    const obj: any = {};
    if (message.rewardData !== 0) {
      obj.rewardData = Math.round(message.rewardData);
    }
    if (message.tokenCost !== undefined) {
      obj.tokenCost = CMsgOverworldTokenQuantity.toJSON(message.tokenCost);
    }
    if (message.tokenReward !== undefined) {
      obj.tokenReward = CMsgOverworldTokenQuantity.toJSON(message.tokenReward);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgOverworldEncounterTokenTreasureData_RewardOption>,
  ): CMsgOverworldEncounterTokenTreasureData_RewardOption {
    return CMsgOverworldEncounterTokenTreasureData_RewardOption.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgOverworldEncounterTokenTreasureData_RewardOption>,
  ): CMsgOverworldEncounterTokenTreasureData_RewardOption {
    const message = createBaseCMsgOverworldEncounterTokenTreasureData_RewardOption();
    message.rewardData = object.rewardData ?? 0;
    message.tokenCost = (object.tokenCost !== undefined && object.tokenCost !== null)
      ? CMsgOverworldTokenQuantity.fromPartial(object.tokenCost)
      : undefined;
    message.tokenReward = (object.tokenReward !== undefined && object.tokenReward !== null)
      ? CMsgOverworldTokenQuantity.fromPartial(object.tokenReward)
      : undefined;
    return message;
  },
};

function createBaseCMsgOverworldEncounterTokenQuestData(): CMsgOverworldEncounterTokenQuestData {
  return { quests: [] };
}

export const CMsgOverworldEncounterTokenQuestData: MessageFns<CMsgOverworldEncounterTokenQuestData> = {
  encode(message: CMsgOverworldEncounterTokenQuestData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.quests) {
      CMsgOverworldEncounterTokenQuestData_Quest.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgOverworldEncounterTokenQuestData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgOverworldEncounterTokenQuestData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.quests.push(CMsgOverworldEncounterTokenQuestData_Quest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgOverworldEncounterTokenQuestData {
    return {
      quests: globalThis.Array.isArray(object?.quests)
        ? object.quests.map((e: any) => CMsgOverworldEncounterTokenQuestData_Quest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgOverworldEncounterTokenQuestData): unknown {
    const obj: any = {};
    if (message.quests?.length) {
      obj.quests = message.quests.map((e) => CMsgOverworldEncounterTokenQuestData_Quest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgOverworldEncounterTokenQuestData>): CMsgOverworldEncounterTokenQuestData {
    return CMsgOverworldEncounterTokenQuestData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgOverworldEncounterTokenQuestData>): CMsgOverworldEncounterTokenQuestData {
    const message = createBaseCMsgOverworldEncounterTokenQuestData();
    message.quests = object.quests?.map((e) => CMsgOverworldEncounterTokenQuestData_Quest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgOverworldEncounterTokenQuestData_Quest(): CMsgOverworldEncounterTokenQuestData_Quest {
  return { rewardData: 0, tokenCost: undefined, tokenReward: undefined };
}

export const CMsgOverworldEncounterTokenQuestData_Quest: MessageFns<CMsgOverworldEncounterTokenQuestData_Quest> = {
  encode(message: CMsgOverworldEncounterTokenQuestData_Quest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rewardData !== 0) {
      writer.uint32(8).uint32(message.rewardData);
    }
    if (message.tokenCost !== undefined) {
      CMsgOverworldTokenQuantity.encode(message.tokenCost, writer.uint32(18).fork()).join();
    }
    if (message.tokenReward !== undefined) {
      CMsgOverworldTokenQuantity.encode(message.tokenReward, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgOverworldEncounterTokenQuestData_Quest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgOverworldEncounterTokenQuestData_Quest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rewardData = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenCost = CMsgOverworldTokenQuantity.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenReward = CMsgOverworldTokenQuantity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgOverworldEncounterTokenQuestData_Quest {
    return {
      rewardData: isSet(object.rewardData) ? globalThis.Number(object.rewardData) : 0,
      tokenCost: isSet(object.tokenCost) ? CMsgOverworldTokenQuantity.fromJSON(object.tokenCost) : undefined,
      tokenReward: isSet(object.tokenReward) ? CMsgOverworldTokenQuantity.fromJSON(object.tokenReward) : undefined,
    };
  },

  toJSON(message: CMsgOverworldEncounterTokenQuestData_Quest): unknown {
    const obj: any = {};
    if (message.rewardData !== 0) {
      obj.rewardData = Math.round(message.rewardData);
    }
    if (message.tokenCost !== undefined) {
      obj.tokenCost = CMsgOverworldTokenQuantity.toJSON(message.tokenCost);
    }
    if (message.tokenReward !== undefined) {
      obj.tokenReward = CMsgOverworldTokenQuantity.toJSON(message.tokenReward);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgOverworldEncounterTokenQuestData_Quest>): CMsgOverworldEncounterTokenQuestData_Quest {
    return CMsgOverworldEncounterTokenQuestData_Quest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgOverworldEncounterTokenQuestData_Quest>,
  ): CMsgOverworldEncounterTokenQuestData_Quest {
    const message = createBaseCMsgOverworldEncounterTokenQuestData_Quest();
    message.rewardData = object.rewardData ?? 0;
    message.tokenCost = (object.tokenCost !== undefined && object.tokenCost !== null)
      ? CMsgOverworldTokenQuantity.fromPartial(object.tokenCost)
      : undefined;
    message.tokenReward = (object.tokenReward !== undefined && object.tokenReward !== null)
      ? CMsgOverworldTokenQuantity.fromPartial(object.tokenReward)
      : undefined;
    return message;
  },
};

function createBaseCMsgOverworldHeroList(): CMsgOverworldHeroList {
  return { heroIds: [] };
}

export const CMsgOverworldHeroList: MessageFns<CMsgOverworldHeroList> = {
  encode(message: CMsgOverworldHeroList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.heroIds) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgOverworldHeroList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgOverworldHeroList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.heroIds.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.heroIds.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgOverworldHeroList {
    return {
      heroIds: globalThis.Array.isArray(object?.heroIds) ? object.heroIds.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CMsgOverworldHeroList): unknown {
    const obj: any = {};
    if (message.heroIds?.length) {
      obj.heroIds = message.heroIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgOverworldHeroList>): CMsgOverworldHeroList {
    return CMsgOverworldHeroList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgOverworldHeroList>): CMsgOverworldHeroList {
    const message = createBaseCMsgOverworldHeroList();
    message.heroIds = object.heroIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgOverworldEncounterChooseHeroData(): CMsgOverworldEncounterChooseHeroData {
  return { heroList: undefined, additive: false };
}

export const CMsgOverworldEncounterChooseHeroData: MessageFns<CMsgOverworldEncounterChooseHeroData> = {
  encode(message: CMsgOverworldEncounterChooseHeroData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.heroList !== undefined) {
      CMsgOverworldHeroList.encode(message.heroList, writer.uint32(10).fork()).join();
    }
    if (message.additive !== false) {
      writer.uint32(16).bool(message.additive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgOverworldEncounterChooseHeroData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgOverworldEncounterChooseHeroData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.heroList = CMsgOverworldHeroList.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.additive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgOverworldEncounterChooseHeroData {
    return {
      heroList: isSet(object.heroList) ? CMsgOverworldHeroList.fromJSON(object.heroList) : undefined,
      additive: isSet(object.additive) ? globalThis.Boolean(object.additive) : false,
    };
  },

  toJSON(message: CMsgOverworldEncounterChooseHeroData): unknown {
    const obj: any = {};
    if (message.heroList !== undefined) {
      obj.heroList = CMsgOverworldHeroList.toJSON(message.heroList);
    }
    if (message.additive !== false) {
      obj.additive = message.additive;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgOverworldEncounterChooseHeroData>): CMsgOverworldEncounterChooseHeroData {
    return CMsgOverworldEncounterChooseHeroData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgOverworldEncounterChooseHeroData>): CMsgOverworldEncounterChooseHeroData {
    const message = createBaseCMsgOverworldEncounterChooseHeroData();
    message.heroList = (object.heroList !== undefined && object.heroList !== null)
      ? CMsgOverworldHeroList.fromPartial(object.heroList)
      : undefined;
    message.additive = object.additive ?? false;
    return message;
  },
};

function createBaseCMsgOverworldEncounterProgressData(): CMsgOverworldEncounterProgressData {
  return { choice: 0, progress: 0, maxProgress: 0, visited: false };
}

export const CMsgOverworldEncounterProgressData: MessageFns<CMsgOverworldEncounterProgressData> = {
  encode(message: CMsgOverworldEncounterProgressData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.choice !== 0) {
      writer.uint32(8).int32(message.choice);
    }
    if (message.progress !== 0) {
      writer.uint32(16).int32(message.progress);
    }
    if (message.maxProgress !== 0) {
      writer.uint32(24).int32(message.maxProgress);
    }
    if (message.visited !== false) {
      writer.uint32(32).bool(message.visited);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgOverworldEncounterProgressData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgOverworldEncounterProgressData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.choice = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.progress = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxProgress = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.visited = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgOverworldEncounterProgressData {
    return {
      choice: isSet(object.choice) ? globalThis.Number(object.choice) : 0,
      progress: isSet(object.progress) ? globalThis.Number(object.progress) : 0,
      maxProgress: isSet(object.maxProgress) ? globalThis.Number(object.maxProgress) : 0,
      visited: isSet(object.visited) ? globalThis.Boolean(object.visited) : false,
    };
  },

  toJSON(message: CMsgOverworldEncounterProgressData): unknown {
    const obj: any = {};
    if (message.choice !== 0) {
      obj.choice = Math.round(message.choice);
    }
    if (message.progress !== 0) {
      obj.progress = Math.round(message.progress);
    }
    if (message.maxProgress !== 0) {
      obj.maxProgress = Math.round(message.maxProgress);
    }
    if (message.visited !== false) {
      obj.visited = message.visited;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgOverworldEncounterProgressData>): CMsgOverworldEncounterProgressData {
    return CMsgOverworldEncounterProgressData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgOverworldEncounterProgressData>): CMsgOverworldEncounterProgressData {
    const message = createBaseCMsgOverworldEncounterProgressData();
    message.choice = object.choice ?? 0;
    message.progress = object.progress ?? 0;
    message.maxProgress = object.maxProgress ?? 0;
    message.visited = object.visited ?? false;
    return message;
  },
};

function createBaseCMsgOverworldEncounterData(): CMsgOverworldEncounterData {
  return { extraEncounterData: [] };
}

export const CMsgOverworldEncounterData: MessageFns<CMsgOverworldEncounterData> = {
  encode(message: CMsgOverworldEncounterData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.extraEncounterData) {
      CExtraMsgBlock.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgOverworldEncounterData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgOverworldEncounterData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.extraEncounterData.push(CExtraMsgBlock.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgOverworldEncounterData {
    return {
      extraEncounterData: globalThis.Array.isArray(object?.extraEncounterData)
        ? object.extraEncounterData.map((e: any) => CExtraMsgBlock.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgOverworldEncounterData): unknown {
    const obj: any = {};
    if (message.extraEncounterData?.length) {
      obj.extraEncounterData = message.extraEncounterData.map((e) => CExtraMsgBlock.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgOverworldEncounterData>): CMsgOverworldEncounterData {
    return CMsgOverworldEncounterData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgOverworldEncounterData>): CMsgOverworldEncounterData {
    const message = createBaseCMsgOverworldEncounterData();
    message.extraEncounterData = object.extraEncounterData?.map((e) => CExtraMsgBlock.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgOverworldNode(): CMsgOverworldNode {
  return { nodeId: 0, nodeState: 0, nodeEncounterData: undefined };
}

export const CMsgOverworldNode: MessageFns<CMsgOverworldNode> = {
  encode(message: CMsgOverworldNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== 0) {
      writer.uint32(8).uint32(message.nodeId);
    }
    if (message.nodeState !== 0) {
      writer.uint32(16).int32(message.nodeState);
    }
    if (message.nodeEncounterData !== undefined) {
      CMsgOverworldEncounterData.encode(message.nodeEncounterData, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgOverworldNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgOverworldNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nodeId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nodeState = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nodeEncounterData = CMsgOverworldEncounterData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgOverworldNode {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0,
      nodeState: isSet(object.nodeState) ? eOverworldNodeStateFromJSON(object.nodeState) : 0,
      nodeEncounterData: isSet(object.nodeEncounterData)
        ? CMsgOverworldEncounterData.fromJSON(object.nodeEncounterData)
        : undefined,
    };
  },

  toJSON(message: CMsgOverworldNode): unknown {
    const obj: any = {};
    if (message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    if (message.nodeState !== 0) {
      obj.nodeState = eOverworldNodeStateToJSON(message.nodeState);
    }
    if (message.nodeEncounterData !== undefined) {
      obj.nodeEncounterData = CMsgOverworldEncounterData.toJSON(message.nodeEncounterData);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgOverworldNode>): CMsgOverworldNode {
    return CMsgOverworldNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgOverworldNode>): CMsgOverworldNode {
    const message = createBaseCMsgOverworldNode();
    message.nodeId = object.nodeId ?? 0;
    message.nodeState = object.nodeState ?? 0;
    message.nodeEncounterData = (object.nodeEncounterData !== undefined && object.nodeEncounterData !== null)
      ? CMsgOverworldEncounterData.fromPartial(object.nodeEncounterData)
      : undefined;
    return message;
  },
};

function createBaseCMsgOverworldPath(): CMsgOverworldPath {
  return { pathId: 0, pathCost: undefined, pathState: 0 };
}

export const CMsgOverworldPath: MessageFns<CMsgOverworldPath> = {
  encode(message: CMsgOverworldPath, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pathId !== 0) {
      writer.uint32(8).uint32(message.pathId);
    }
    if (message.pathCost !== undefined) {
      CMsgOverworldTokenQuantity.encode(message.pathCost, writer.uint32(18).fork()).join();
    }
    if (message.pathState !== 0) {
      writer.uint32(24).int32(message.pathState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgOverworldPath {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgOverworldPath();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pathId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pathCost = CMsgOverworldTokenQuantity.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pathState = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgOverworldPath {
    return {
      pathId: isSet(object.pathId) ? globalThis.Number(object.pathId) : 0,
      pathCost: isSet(object.pathCost) ? CMsgOverworldTokenQuantity.fromJSON(object.pathCost) : undefined,
      pathState: isSet(object.pathState) ? eOverworldPathStateFromJSON(object.pathState) : 0,
    };
  },

  toJSON(message: CMsgOverworldPath): unknown {
    const obj: any = {};
    if (message.pathId !== 0) {
      obj.pathId = Math.round(message.pathId);
    }
    if (message.pathCost !== undefined) {
      obj.pathCost = CMsgOverworldTokenQuantity.toJSON(message.pathCost);
    }
    if (message.pathState !== 0) {
      obj.pathState = eOverworldPathStateToJSON(message.pathState);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgOverworldPath>): CMsgOverworldPath {
    return CMsgOverworldPath.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgOverworldPath>): CMsgOverworldPath {
    const message = createBaseCMsgOverworldPath();
    message.pathId = object.pathId ?? 0;
    message.pathCost = (object.pathCost !== undefined && object.pathCost !== null)
      ? CMsgOverworldTokenQuantity.fromPartial(object.pathCost)
      : undefined;
    message.pathState = object.pathState ?? 0;
    return message;
  },
};

function createBaseCMsgOverworldMinigameCustomData(): CMsgOverworldMinigameCustomData {
  return { survivorsData: undefined };
}

export const CMsgOverworldMinigameCustomData: MessageFns<CMsgOverworldMinigameCustomData> = {
  encode(message: CMsgOverworldMinigameCustomData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.survivorsData !== undefined) {
      CMsgSurvivorsUserData.encode(message.survivorsData, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgOverworldMinigameCustomData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgOverworldMinigameCustomData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.survivorsData = CMsgSurvivorsUserData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgOverworldMinigameCustomData {
    return {
      survivorsData: isSet(object.survivorsData) ? CMsgSurvivorsUserData.fromJSON(object.survivorsData) : undefined,
    };
  },

  toJSON(message: CMsgOverworldMinigameCustomData): unknown {
    const obj: any = {};
    if (message.survivorsData !== undefined) {
      obj.survivorsData = CMsgSurvivorsUserData.toJSON(message.survivorsData);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgOverworldMinigameCustomData>): CMsgOverworldMinigameCustomData {
    return CMsgOverworldMinigameCustomData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgOverworldMinigameCustomData>): CMsgOverworldMinigameCustomData {
    const message = createBaseCMsgOverworldMinigameCustomData();
    message.survivorsData = (object.survivorsData !== undefined && object.survivorsData !== null)
      ? CMsgSurvivorsUserData.fromPartial(object.survivorsData)
      : undefined;
    return message;
  },
};

function createBaseCMsgOverworldMinigameUserData(): CMsgOverworldMinigameUserData {
  return { nodeId: 0, currencyAmount: 0, customData: undefined };
}

export const CMsgOverworldMinigameUserData: MessageFns<CMsgOverworldMinigameUserData> = {
  encode(message: CMsgOverworldMinigameUserData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== 0) {
      writer.uint32(8).uint32(message.nodeId);
    }
    if (message.currencyAmount !== 0) {
      writer.uint32(16).uint32(message.currencyAmount);
    }
    if (message.customData !== undefined) {
      CMsgOverworldMinigameCustomData.encode(message.customData, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgOverworldMinigameUserData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgOverworldMinigameUserData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nodeId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.currencyAmount = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.customData = CMsgOverworldMinigameCustomData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgOverworldMinigameUserData {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0,
      currencyAmount: isSet(object.currencyAmount) ? globalThis.Number(object.currencyAmount) : 0,
      customData: isSet(object.customData) ? CMsgOverworldMinigameCustomData.fromJSON(object.customData) : undefined,
    };
  },

  toJSON(message: CMsgOverworldMinigameUserData): unknown {
    const obj: any = {};
    if (message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    if (message.currencyAmount !== 0) {
      obj.currencyAmount = Math.round(message.currencyAmount);
    }
    if (message.customData !== undefined) {
      obj.customData = CMsgOverworldMinigameCustomData.toJSON(message.customData);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgOverworldMinigameUserData>): CMsgOverworldMinigameUserData {
    return CMsgOverworldMinigameUserData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgOverworldMinigameUserData>): CMsgOverworldMinigameUserData {
    const message = createBaseCMsgOverworldMinigameUserData();
    message.nodeId = object.nodeId ?? 0;
    message.currencyAmount = object.currencyAmount ?? 0;
    message.customData = (object.customData !== undefined && object.customData !== null)
      ? CMsgOverworldMinigameCustomData.fromPartial(object.customData)
      : undefined;
    return message;
  },
};

function createBaseCMsgOverworldUserData(): CMsgOverworldUserData {
  return { tokenInventory: undefined, overworldNodes: [], overworldPaths: [], currentNodeId: 0, minigameData: [] };
}

export const CMsgOverworldUserData: MessageFns<CMsgOverworldUserData> = {
  encode(message: CMsgOverworldUserData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenInventory !== undefined) {
      CMsgOverworldTokenQuantity.encode(message.tokenInventory, writer.uint32(10).fork()).join();
    }
    for (const v of message.overworldNodes) {
      CMsgOverworldNode.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.overworldPaths) {
      CMsgOverworldPath.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.currentNodeId !== 0) {
      writer.uint32(32).uint32(message.currentNodeId);
    }
    for (const v of message.minigameData) {
      CMsgOverworldUserData_MinigameDataEntry.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgOverworldUserData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgOverworldUserData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenInventory = CMsgOverworldTokenQuantity.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.overworldNodes.push(CMsgOverworldNode.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.overworldPaths.push(CMsgOverworldPath.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.currentNodeId = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.minigameData.push(CMsgOverworldUserData_MinigameDataEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgOverworldUserData {
    return {
      tokenInventory: isSet(object.tokenInventory)
        ? CMsgOverworldTokenQuantity.fromJSON(object.tokenInventory)
        : undefined,
      overworldNodes: globalThis.Array.isArray(object?.overworldNodes)
        ? object.overworldNodes.map((e: any) => CMsgOverworldNode.fromJSON(e))
        : [],
      overworldPaths: globalThis.Array.isArray(object?.overworldPaths)
        ? object.overworldPaths.map((e: any) => CMsgOverworldPath.fromJSON(e))
        : [],
      currentNodeId: isSet(object.currentNodeId) ? globalThis.Number(object.currentNodeId) : 0,
      minigameData: globalThis.Array.isArray(object?.minigameData)
        ? object.minigameData.map((e: any) => CMsgOverworldUserData_MinigameDataEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgOverworldUserData): unknown {
    const obj: any = {};
    if (message.tokenInventory !== undefined) {
      obj.tokenInventory = CMsgOverworldTokenQuantity.toJSON(message.tokenInventory);
    }
    if (message.overworldNodes?.length) {
      obj.overworldNodes = message.overworldNodes.map((e) => CMsgOverworldNode.toJSON(e));
    }
    if (message.overworldPaths?.length) {
      obj.overworldPaths = message.overworldPaths.map((e) => CMsgOverworldPath.toJSON(e));
    }
    if (message.currentNodeId !== 0) {
      obj.currentNodeId = Math.round(message.currentNodeId);
    }
    if (message.minigameData?.length) {
      obj.minigameData = message.minigameData.map((e) => CMsgOverworldUserData_MinigameDataEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgOverworldUserData>): CMsgOverworldUserData {
    return CMsgOverworldUserData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgOverworldUserData>): CMsgOverworldUserData {
    const message = createBaseCMsgOverworldUserData();
    message.tokenInventory = (object.tokenInventory !== undefined && object.tokenInventory !== null)
      ? CMsgOverworldTokenQuantity.fromPartial(object.tokenInventory)
      : undefined;
    message.overworldNodes = object.overworldNodes?.map((e) => CMsgOverworldNode.fromPartial(e)) || [];
    message.overworldPaths = object.overworldPaths?.map((e) => CMsgOverworldPath.fromPartial(e)) || [];
    message.currentNodeId = object.currentNodeId ?? 0;
    message.minigameData = object.minigameData?.map((e) => CMsgOverworldUserData_MinigameDataEntry.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseCMsgOverworldUserData_MinigameDataEntry(): CMsgOverworldUserData_MinigameDataEntry {
  return { key: 0, value: undefined };
}

export const CMsgOverworldUserData_MinigameDataEntry: MessageFns<CMsgOverworldUserData_MinigameDataEntry> = {
  encode(message: CMsgOverworldUserData_MinigameDataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      CMsgOverworldMinigameUserData.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgOverworldUserData_MinigameDataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgOverworldUserData_MinigameDataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = CMsgOverworldMinigameUserData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgOverworldUserData_MinigameDataEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? CMsgOverworldMinigameUserData.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: CMsgOverworldUserData_MinigameDataEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = CMsgOverworldMinigameUserData.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgOverworldUserData_MinigameDataEntry>): CMsgOverworldUserData_MinigameDataEntry {
    return CMsgOverworldUserData_MinigameDataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgOverworldUserData_MinigameDataEntry>): CMsgOverworldUserData_MinigameDataEntry {
    const message = createBaseCMsgOverworldUserData_MinigameDataEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? CMsgOverworldMinigameUserData.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCMsgOverworldMatchRewards(): CMsgOverworldMatchRewards {
  return { players: [] };
}

export const CMsgOverworldMatchRewards: MessageFns<CMsgOverworldMatchRewards> = {
  encode(message: CMsgOverworldMatchRewards, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.players) {
      CMsgOverworldMatchRewards_Player.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgOverworldMatchRewards {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgOverworldMatchRewards();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.players.push(CMsgOverworldMatchRewards_Player.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgOverworldMatchRewards {
    return {
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgOverworldMatchRewards_Player.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgOverworldMatchRewards): unknown {
    const obj: any = {};
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgOverworldMatchRewards_Player.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgOverworldMatchRewards>): CMsgOverworldMatchRewards {
    return CMsgOverworldMatchRewards.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgOverworldMatchRewards>): CMsgOverworldMatchRewards {
    const message = createBaseCMsgOverworldMatchRewards();
    message.players = object.players?.map((e) => CMsgOverworldMatchRewards_Player.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgOverworldMatchRewards_Player(): CMsgOverworldMatchRewards_Player {
  return { playerSlot: 0, tokens: undefined, overworldId: 0 };
}

export const CMsgOverworldMatchRewards_Player: MessageFns<CMsgOverworldMatchRewards_Player> = {
  encode(message: CMsgOverworldMatchRewards_Player, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerSlot !== 0) {
      writer.uint32(8).uint32(message.playerSlot);
    }
    if (message.tokens !== undefined) {
      CMsgOverworldTokenQuantity.encode(message.tokens, writer.uint32(18).fork()).join();
    }
    if (message.overworldId !== 0) {
      writer.uint32(24).uint32(message.overworldId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgOverworldMatchRewards_Player {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgOverworldMatchRewards_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.playerSlot = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokens = CMsgOverworldTokenQuantity.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.overworldId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgOverworldMatchRewards_Player {
    return {
      playerSlot: isSet(object.playerSlot) ? globalThis.Number(object.playerSlot) : 0,
      tokens: isSet(object.tokens) ? CMsgOverworldTokenQuantity.fromJSON(object.tokens) : undefined,
      overworldId: isSet(object.overworldId) ? globalThis.Number(object.overworldId) : 0,
    };
  },

  toJSON(message: CMsgOverworldMatchRewards_Player): unknown {
    const obj: any = {};
    if (message.playerSlot !== 0) {
      obj.playerSlot = Math.round(message.playerSlot);
    }
    if (message.tokens !== undefined) {
      obj.tokens = CMsgOverworldTokenQuantity.toJSON(message.tokens);
    }
    if (message.overworldId !== 0) {
      obj.overworldId = Math.round(message.overworldId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgOverworldMatchRewards_Player>): CMsgOverworldMatchRewards_Player {
    return CMsgOverworldMatchRewards_Player.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgOverworldMatchRewards_Player>): CMsgOverworldMatchRewards_Player {
    const message = createBaseCMsgOverworldMatchRewards_Player();
    message.playerSlot = object.playerSlot ?? 0;
    message.tokens = (object.tokens !== undefined && object.tokens !== null)
      ? CMsgOverworldTokenQuantity.fromPartial(object.tokens)
      : undefined;
    message.overworldId = object.overworldId ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldGetUserData(): CMsgClientToGCOverworldGetUserData {
  return { overworldId: 0 };
}

export const CMsgClientToGCOverworldGetUserData: MessageFns<CMsgClientToGCOverworldGetUserData> = {
  encode(message: CMsgClientToGCOverworldGetUserData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overworldId !== 0) {
      writer.uint32(8).uint32(message.overworldId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldGetUserData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldGetUserData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.overworldId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldGetUserData {
    return { overworldId: isSet(object.overworldId) ? globalThis.Number(object.overworldId) : 0 };
  },

  toJSON(message: CMsgClientToGCOverworldGetUserData): unknown {
    const obj: any = {};
    if (message.overworldId !== 0) {
      obj.overworldId = Math.round(message.overworldId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldGetUserData>): CMsgClientToGCOverworldGetUserData {
    return CMsgClientToGCOverworldGetUserData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCOverworldGetUserData>): CMsgClientToGCOverworldGetUserData {
    const message = createBaseCMsgClientToGCOverworldGetUserData();
    message.overworldId = object.overworldId ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldGetUserDataResponse(): CMsgClientToGCOverworldGetUserDataResponse {
  return { response: 0, userData: undefined };
}

export const CMsgClientToGCOverworldGetUserDataResponse: MessageFns<CMsgClientToGCOverworldGetUserDataResponse> = {
  encode(message: CMsgClientToGCOverworldGetUserDataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    if (message.userData !== undefined) {
      CMsgOverworldUserData.encode(message.userData, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldGetUserDataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldGetUserDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userData = CMsgOverworldUserData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldGetUserDataResponse {
    return {
      response: isSet(object.response)
        ? cMsgClientToGCOverworldGetUserDataResponse_EResponseFromJSON(object.response)
        : 0,
      userData: isSet(object.userData) ? CMsgOverworldUserData.fromJSON(object.userData) : undefined,
    };
  },

  toJSON(message: CMsgClientToGCOverworldGetUserDataResponse): unknown {
    const obj: any = {};
    if (message.response !== 0) {
      obj.response = cMsgClientToGCOverworldGetUserDataResponse_EResponseToJSON(message.response);
    }
    if (message.userData !== undefined) {
      obj.userData = CMsgOverworldUserData.toJSON(message.userData);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldGetUserDataResponse>): CMsgClientToGCOverworldGetUserDataResponse {
    return CMsgClientToGCOverworldGetUserDataResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgClientToGCOverworldGetUserDataResponse>,
  ): CMsgClientToGCOverworldGetUserDataResponse {
    const message = createBaseCMsgClientToGCOverworldGetUserDataResponse();
    message.response = object.response ?? 0;
    message.userData = (object.userData !== undefined && object.userData !== null)
      ? CMsgOverworldUserData.fromPartial(object.userData)
      : undefined;
    return message;
  },
};

function createBaseCMsgGCToClientOverworldUserDataUpdated(): CMsgGCToClientOverworldUserDataUpdated {
  return { overworldId: 0, userData: undefined };
}

export const CMsgGCToClientOverworldUserDataUpdated: MessageFns<CMsgGCToClientOverworldUserDataUpdated> = {
  encode(message: CMsgGCToClientOverworldUserDataUpdated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overworldId !== 0) {
      writer.uint32(8).uint32(message.overworldId);
    }
    if (message.userData !== undefined) {
      CMsgOverworldUserData.encode(message.userData, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToClientOverworldUserDataUpdated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientOverworldUserDataUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.overworldId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userData = CMsgOverworldUserData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientOverworldUserDataUpdated {
    return {
      overworldId: isSet(object.overworldId) ? globalThis.Number(object.overworldId) : 0,
      userData: isSet(object.userData) ? CMsgOverworldUserData.fromJSON(object.userData) : undefined,
    };
  },

  toJSON(message: CMsgGCToClientOverworldUserDataUpdated): unknown {
    const obj: any = {};
    if (message.overworldId !== 0) {
      obj.overworldId = Math.round(message.overworldId);
    }
    if (message.userData !== undefined) {
      obj.userData = CMsgOverworldUserData.toJSON(message.userData);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToClientOverworldUserDataUpdated>): CMsgGCToClientOverworldUserDataUpdated {
    return CMsgGCToClientOverworldUserDataUpdated.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToClientOverworldUserDataUpdated>): CMsgGCToClientOverworldUserDataUpdated {
    const message = createBaseCMsgGCToClientOverworldUserDataUpdated();
    message.overworldId = object.overworldId ?? 0;
    message.userData = (object.userData !== undefined && object.userData !== null)
      ? CMsgOverworldUserData.fromPartial(object.userData)
      : undefined;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldCompletePath(): CMsgClientToGCOverworldCompletePath {
  return { overworldId: 0, pathId: 0 };
}

export const CMsgClientToGCOverworldCompletePath: MessageFns<CMsgClientToGCOverworldCompletePath> = {
  encode(message: CMsgClientToGCOverworldCompletePath, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overworldId !== 0) {
      writer.uint32(8).uint32(message.overworldId);
    }
    if (message.pathId !== 0) {
      writer.uint32(16).uint32(message.pathId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldCompletePath {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldCompletePath();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.overworldId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pathId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldCompletePath {
    return {
      overworldId: isSet(object.overworldId) ? globalThis.Number(object.overworldId) : 0,
      pathId: isSet(object.pathId) ? globalThis.Number(object.pathId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCOverworldCompletePath): unknown {
    const obj: any = {};
    if (message.overworldId !== 0) {
      obj.overworldId = Math.round(message.overworldId);
    }
    if (message.pathId !== 0) {
      obj.pathId = Math.round(message.pathId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldCompletePath>): CMsgClientToGCOverworldCompletePath {
    return CMsgClientToGCOverworldCompletePath.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCOverworldCompletePath>): CMsgClientToGCOverworldCompletePath {
    const message = createBaseCMsgClientToGCOverworldCompletePath();
    message.overworldId = object.overworldId ?? 0;
    message.pathId = object.pathId ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldCompletePathResponse(): CMsgClientToGCOverworldCompletePathResponse {
  return { response: 0, claimResponse: undefined };
}

export const CMsgClientToGCOverworldCompletePathResponse: MessageFns<CMsgClientToGCOverworldCompletePathResponse> = {
  encode(
    message: CMsgClientToGCOverworldCompletePathResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    if (message.claimResponse !== undefined) {
      CMsgDOTAClaimEventActionResponse.encode(message.claimResponse, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldCompletePathResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldCompletePathResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.claimResponse = CMsgDOTAClaimEventActionResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldCompletePathResponse {
    return {
      response: isSet(object.response)
        ? cMsgClientToGCOverworldCompletePathResponse_EResponseFromJSON(object.response)
        : 0,
      claimResponse: isSet(object.claimResponse)
        ? CMsgDOTAClaimEventActionResponse.fromJSON(object.claimResponse)
        : undefined,
    };
  },

  toJSON(message: CMsgClientToGCOverworldCompletePathResponse): unknown {
    const obj: any = {};
    if (message.response !== 0) {
      obj.response = cMsgClientToGCOverworldCompletePathResponse_EResponseToJSON(message.response);
    }
    if (message.claimResponse !== undefined) {
      obj.claimResponse = CMsgDOTAClaimEventActionResponse.toJSON(message.claimResponse);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldCompletePathResponse>): CMsgClientToGCOverworldCompletePathResponse {
    return CMsgClientToGCOverworldCompletePathResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgClientToGCOverworldCompletePathResponse>,
  ): CMsgClientToGCOverworldCompletePathResponse {
    const message = createBaseCMsgClientToGCOverworldCompletePathResponse();
    message.response = object.response ?? 0;
    message.claimResponse = (object.claimResponse !== undefined && object.claimResponse !== null)
      ? CMsgDOTAClaimEventActionResponse.fromPartial(object.claimResponse)
      : undefined;
    return message;
  },
};

function createBaseCMsgOverworldEncounterPitFighterRewardData(): CMsgOverworldEncounterPitFighterRewardData {
  return { tokenId: 0, choice: 0 };
}

export const CMsgOverworldEncounterPitFighterRewardData: MessageFns<CMsgOverworldEncounterPitFighterRewardData> = {
  encode(message: CMsgOverworldEncounterPitFighterRewardData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenId !== 0) {
      writer.uint32(8).uint32(message.tokenId);
    }
    if (message.choice !== 0) {
      writer.uint32(16).uint32(message.choice);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgOverworldEncounterPitFighterRewardData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgOverworldEncounterPitFighterRewardData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tokenId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.choice = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgOverworldEncounterPitFighterRewardData {
    return {
      tokenId: isSet(object.tokenId) ? globalThis.Number(object.tokenId) : 0,
      choice: isSet(object.choice) ? globalThis.Number(object.choice) : 0,
    };
  },

  toJSON(message: CMsgOverworldEncounterPitFighterRewardData): unknown {
    const obj: any = {};
    if (message.tokenId !== 0) {
      obj.tokenId = Math.round(message.tokenId);
    }
    if (message.choice !== 0) {
      obj.choice = Math.round(message.choice);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgOverworldEncounterPitFighterRewardData>): CMsgOverworldEncounterPitFighterRewardData {
    return CMsgOverworldEncounterPitFighterRewardData.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgOverworldEncounterPitFighterRewardData>,
  ): CMsgOverworldEncounterPitFighterRewardData {
    const message = createBaseCMsgOverworldEncounterPitFighterRewardData();
    message.tokenId = object.tokenId ?? 0;
    message.choice = object.choice ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldClaimEncounterReward(): CMsgClientToGCOverworldClaimEncounterReward {
  return {
    overworldId: 0,
    nodeId: 0,
    rewardData: 0,
    periodicResourceId: 0,
    extraRewardData: undefined,
    leaderboardData: 0,
    leaderboardIndex: 0,
  };
}

export const CMsgClientToGCOverworldClaimEncounterReward: MessageFns<CMsgClientToGCOverworldClaimEncounterReward> = {
  encode(
    message: CMsgClientToGCOverworldClaimEncounterReward,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.overworldId !== 0) {
      writer.uint32(8).uint32(message.overworldId);
    }
    if (message.nodeId !== 0) {
      writer.uint32(16).uint32(message.nodeId);
    }
    if (message.rewardData !== 0) {
      writer.uint32(24).uint32(message.rewardData);
    }
    if (message.periodicResourceId !== 0) {
      writer.uint32(32).uint32(message.periodicResourceId);
    }
    if (message.extraRewardData !== undefined) {
      CMsgOverworldEncounterData.encode(message.extraRewardData, writer.uint32(42).fork()).join();
    }
    if (message.leaderboardData !== 0) {
      writer.uint32(48).uint32(message.leaderboardData);
    }
    if (message.leaderboardIndex !== 0) {
      writer.uint32(56).uint32(message.leaderboardIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldClaimEncounterReward {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldClaimEncounterReward();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.overworldId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nodeId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rewardData = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.periodicResourceId = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.extraRewardData = CMsgOverworldEncounterData.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.leaderboardData = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.leaderboardIndex = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldClaimEncounterReward {
    return {
      overworldId: isSet(object.overworldId) ? globalThis.Number(object.overworldId) : 0,
      nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0,
      rewardData: isSet(object.rewardData) ? globalThis.Number(object.rewardData) : 0,
      periodicResourceId: isSet(object.periodicResourceId) ? globalThis.Number(object.periodicResourceId) : 0,
      extraRewardData: isSet(object.extraRewardData)
        ? CMsgOverworldEncounterData.fromJSON(object.extraRewardData)
        : undefined,
      leaderboardData: isSet(object.leaderboardData) ? globalThis.Number(object.leaderboardData) : 0,
      leaderboardIndex: isSet(object.leaderboardIndex) ? globalThis.Number(object.leaderboardIndex) : 0,
    };
  },

  toJSON(message: CMsgClientToGCOverworldClaimEncounterReward): unknown {
    const obj: any = {};
    if (message.overworldId !== 0) {
      obj.overworldId = Math.round(message.overworldId);
    }
    if (message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    if (message.rewardData !== 0) {
      obj.rewardData = Math.round(message.rewardData);
    }
    if (message.periodicResourceId !== 0) {
      obj.periodicResourceId = Math.round(message.periodicResourceId);
    }
    if (message.extraRewardData !== undefined) {
      obj.extraRewardData = CMsgOverworldEncounterData.toJSON(message.extraRewardData);
    }
    if (message.leaderboardData !== 0) {
      obj.leaderboardData = Math.round(message.leaderboardData);
    }
    if (message.leaderboardIndex !== 0) {
      obj.leaderboardIndex = Math.round(message.leaderboardIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldClaimEncounterReward>): CMsgClientToGCOverworldClaimEncounterReward {
    return CMsgClientToGCOverworldClaimEncounterReward.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgClientToGCOverworldClaimEncounterReward>,
  ): CMsgClientToGCOverworldClaimEncounterReward {
    const message = createBaseCMsgClientToGCOverworldClaimEncounterReward();
    message.overworldId = object.overworldId ?? 0;
    message.nodeId = object.nodeId ?? 0;
    message.rewardData = object.rewardData ?? 0;
    message.periodicResourceId = object.periodicResourceId ?? 0;
    message.extraRewardData = (object.extraRewardData !== undefined && object.extraRewardData !== null)
      ? CMsgOverworldEncounterData.fromPartial(object.extraRewardData)
      : undefined;
    message.leaderboardData = object.leaderboardData ?? 0;
    message.leaderboardIndex = object.leaderboardIndex ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldClaimEncounterRewardResponse(): CMsgClientToGCOverworldClaimEncounterRewardResponse {
  return { response: 0, claimResponse: undefined, tokensReceived: undefined };
}

export const CMsgClientToGCOverworldClaimEncounterRewardResponse: MessageFns<
  CMsgClientToGCOverworldClaimEncounterRewardResponse
> = {
  encode(
    message: CMsgClientToGCOverworldClaimEncounterRewardResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    if (message.claimResponse !== undefined) {
      CMsgDOTAClaimEventActionResponse.encode(message.claimResponse, writer.uint32(18).fork()).join();
    }
    if (message.tokensReceived !== undefined) {
      CMsgOverworldTokenQuantity.encode(message.tokensReceived, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldClaimEncounterRewardResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldClaimEncounterRewardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.claimResponse = CMsgDOTAClaimEventActionResponse.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokensReceived = CMsgOverworldTokenQuantity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldClaimEncounterRewardResponse {
    return {
      response: isSet(object.response)
        ? cMsgClientToGCOverworldClaimEncounterRewardResponse_EResponseFromJSON(object.response)
        : 0,
      claimResponse: isSet(object.claimResponse)
        ? CMsgDOTAClaimEventActionResponse.fromJSON(object.claimResponse)
        : undefined,
      tokensReceived: isSet(object.tokensReceived)
        ? CMsgOverworldTokenQuantity.fromJSON(object.tokensReceived)
        : undefined,
    };
  },

  toJSON(message: CMsgClientToGCOverworldClaimEncounterRewardResponse): unknown {
    const obj: any = {};
    if (message.response !== 0) {
      obj.response = cMsgClientToGCOverworldClaimEncounterRewardResponse_EResponseToJSON(message.response);
    }
    if (message.claimResponse !== undefined) {
      obj.claimResponse = CMsgDOTAClaimEventActionResponse.toJSON(message.claimResponse);
    }
    if (message.tokensReceived !== undefined) {
      obj.tokensReceived = CMsgOverworldTokenQuantity.toJSON(message.tokensReceived);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgClientToGCOverworldClaimEncounterRewardResponse>,
  ): CMsgClientToGCOverworldClaimEncounterRewardResponse {
    return CMsgClientToGCOverworldClaimEncounterRewardResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgClientToGCOverworldClaimEncounterRewardResponse>,
  ): CMsgClientToGCOverworldClaimEncounterRewardResponse {
    const message = createBaseCMsgClientToGCOverworldClaimEncounterRewardResponse();
    message.response = object.response ?? 0;
    message.claimResponse = (object.claimResponse !== undefined && object.claimResponse !== null)
      ? CMsgDOTAClaimEventActionResponse.fromPartial(object.claimResponse)
      : undefined;
    message.tokensReceived = (object.tokensReceived !== undefined && object.tokensReceived !== null)
      ? CMsgOverworldTokenQuantity.fromPartial(object.tokensReceived)
      : undefined;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldVisitEncounter(): CMsgClientToGCOverworldVisitEncounter {
  return { overworldId: 0, nodeId: 0 };
}

export const CMsgClientToGCOverworldVisitEncounter: MessageFns<CMsgClientToGCOverworldVisitEncounter> = {
  encode(message: CMsgClientToGCOverworldVisitEncounter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overworldId !== 0) {
      writer.uint32(8).uint32(message.overworldId);
    }
    if (message.nodeId !== 0) {
      writer.uint32(16).uint32(message.nodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldVisitEncounter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldVisitEncounter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.overworldId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nodeId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldVisitEncounter {
    return {
      overworldId: isSet(object.overworldId) ? globalThis.Number(object.overworldId) : 0,
      nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCOverworldVisitEncounter): unknown {
    const obj: any = {};
    if (message.overworldId !== 0) {
      obj.overworldId = Math.round(message.overworldId);
    }
    if (message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldVisitEncounter>): CMsgClientToGCOverworldVisitEncounter {
    return CMsgClientToGCOverworldVisitEncounter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCOverworldVisitEncounter>): CMsgClientToGCOverworldVisitEncounter {
    const message = createBaseCMsgClientToGCOverworldVisitEncounter();
    message.overworldId = object.overworldId ?? 0;
    message.nodeId = object.nodeId ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldVisitEncounterResponse(): CMsgClientToGCOverworldVisitEncounterResponse {
  return { response: 0 };
}

export const CMsgClientToGCOverworldVisitEncounterResponse: MessageFns<CMsgClientToGCOverworldVisitEncounterResponse> =
  {
    encode(
      message: CMsgClientToGCOverworldVisitEncounterResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.response !== 0) {
        writer.uint32(8).int32(message.response);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldVisitEncounterResponse {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCMsgClientToGCOverworldVisitEncounterResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.response = reader.int32() as any;
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CMsgClientToGCOverworldVisitEncounterResponse {
      return {
        response: isSet(object.response)
          ? cMsgClientToGCOverworldVisitEncounterResponse_EResponseFromJSON(object.response)
          : 0,
      };
    },

    toJSON(message: CMsgClientToGCOverworldVisitEncounterResponse): unknown {
      const obj: any = {};
      if (message.response !== 0) {
        obj.response = cMsgClientToGCOverworldVisitEncounterResponse_EResponseToJSON(message.response);
      }
      return obj;
    },

    create(
      base?: DeepPartial<CMsgClientToGCOverworldVisitEncounterResponse>,
    ): CMsgClientToGCOverworldVisitEncounterResponse {
      return CMsgClientToGCOverworldVisitEncounterResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<CMsgClientToGCOverworldVisitEncounterResponse>,
    ): CMsgClientToGCOverworldVisitEncounterResponse {
      const message = createBaseCMsgClientToGCOverworldVisitEncounterResponse();
      message.response = object.response ?? 0;
      return message;
    },
  };

function createBaseCMsgClientToGCOverworldMoveToNode(): CMsgClientToGCOverworldMoveToNode {
  return { overworldId: 0, nodeId: 0 };
}

export const CMsgClientToGCOverworldMoveToNode: MessageFns<CMsgClientToGCOverworldMoveToNode> = {
  encode(message: CMsgClientToGCOverworldMoveToNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overworldId !== 0) {
      writer.uint32(8).uint32(message.overworldId);
    }
    if (message.nodeId !== 0) {
      writer.uint32(16).uint32(message.nodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldMoveToNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldMoveToNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.overworldId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nodeId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldMoveToNode {
    return {
      overworldId: isSet(object.overworldId) ? globalThis.Number(object.overworldId) : 0,
      nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCOverworldMoveToNode): unknown {
    const obj: any = {};
    if (message.overworldId !== 0) {
      obj.overworldId = Math.round(message.overworldId);
    }
    if (message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldMoveToNode>): CMsgClientToGCOverworldMoveToNode {
    return CMsgClientToGCOverworldMoveToNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCOverworldMoveToNode>): CMsgClientToGCOverworldMoveToNode {
    const message = createBaseCMsgClientToGCOverworldMoveToNode();
    message.overworldId = object.overworldId ?? 0;
    message.nodeId = object.nodeId ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldMoveToNodeResponse(): CMsgClientToGCOverworldMoveToNodeResponse {
  return { response: 0 };
}

export const CMsgClientToGCOverworldMoveToNodeResponse: MessageFns<CMsgClientToGCOverworldMoveToNodeResponse> = {
  encode(message: CMsgClientToGCOverworldMoveToNodeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldMoveToNodeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldMoveToNodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldMoveToNodeResponse {
    return {
      response: isSet(object.response)
        ? cMsgClientToGCOverworldMoveToNodeResponse_EResponseFromJSON(object.response)
        : 0,
    };
  },

  toJSON(message: CMsgClientToGCOverworldMoveToNodeResponse): unknown {
    const obj: any = {};
    if (message.response !== 0) {
      obj.response = cMsgClientToGCOverworldMoveToNodeResponse_EResponseToJSON(message.response);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldMoveToNodeResponse>): CMsgClientToGCOverworldMoveToNodeResponse {
    return CMsgClientToGCOverworldMoveToNodeResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgClientToGCOverworldMoveToNodeResponse>,
  ): CMsgClientToGCOverworldMoveToNodeResponse {
    const message = createBaseCMsgClientToGCOverworldMoveToNodeResponse();
    message.response = object.response ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldTradeTokens(): CMsgClientToGCOverworldTradeTokens {
  return { overworldId: 0, tokenOffer: undefined, tokenRequest: undefined, recipe: 0, encounterId: 0 };
}

export const CMsgClientToGCOverworldTradeTokens: MessageFns<CMsgClientToGCOverworldTradeTokens> = {
  encode(message: CMsgClientToGCOverworldTradeTokens, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overworldId !== 0) {
      writer.uint32(8).uint32(message.overworldId);
    }
    if (message.tokenOffer !== undefined) {
      CMsgOverworldTokenQuantity.encode(message.tokenOffer, writer.uint32(18).fork()).join();
    }
    if (message.tokenRequest !== undefined) {
      CMsgOverworldTokenQuantity.encode(message.tokenRequest, writer.uint32(26).fork()).join();
    }
    if (message.recipe !== 0) {
      writer.uint32(32).uint32(message.recipe);
    }
    if (message.encounterId !== 0) {
      writer.uint32(40).uint32(message.encounterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldTradeTokens {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldTradeTokens();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.overworldId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenOffer = CMsgOverworldTokenQuantity.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenRequest = CMsgOverworldTokenQuantity.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.recipe = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.encounterId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldTradeTokens {
    return {
      overworldId: isSet(object.overworldId) ? globalThis.Number(object.overworldId) : 0,
      tokenOffer: isSet(object.tokenOffer) ? CMsgOverworldTokenQuantity.fromJSON(object.tokenOffer) : undefined,
      tokenRequest: isSet(object.tokenRequest) ? CMsgOverworldTokenQuantity.fromJSON(object.tokenRequest) : undefined,
      recipe: isSet(object.recipe) ? globalThis.Number(object.recipe) : 0,
      encounterId: isSet(object.encounterId) ? globalThis.Number(object.encounterId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCOverworldTradeTokens): unknown {
    const obj: any = {};
    if (message.overworldId !== 0) {
      obj.overworldId = Math.round(message.overworldId);
    }
    if (message.tokenOffer !== undefined) {
      obj.tokenOffer = CMsgOverworldTokenQuantity.toJSON(message.tokenOffer);
    }
    if (message.tokenRequest !== undefined) {
      obj.tokenRequest = CMsgOverworldTokenQuantity.toJSON(message.tokenRequest);
    }
    if (message.recipe !== 0) {
      obj.recipe = Math.round(message.recipe);
    }
    if (message.encounterId !== 0) {
      obj.encounterId = Math.round(message.encounterId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldTradeTokens>): CMsgClientToGCOverworldTradeTokens {
    return CMsgClientToGCOverworldTradeTokens.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCOverworldTradeTokens>): CMsgClientToGCOverworldTradeTokens {
    const message = createBaseCMsgClientToGCOverworldTradeTokens();
    message.overworldId = object.overworldId ?? 0;
    message.tokenOffer = (object.tokenOffer !== undefined && object.tokenOffer !== null)
      ? CMsgOverworldTokenQuantity.fromPartial(object.tokenOffer)
      : undefined;
    message.tokenRequest = (object.tokenRequest !== undefined && object.tokenRequest !== null)
      ? CMsgOverworldTokenQuantity.fromPartial(object.tokenRequest)
      : undefined;
    message.recipe = object.recipe ?? 0;
    message.encounterId = object.encounterId ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldTradeTokensResponse(): CMsgClientToGCOverworldTradeTokensResponse {
  return { response: 0, tokensReceived: undefined };
}

export const CMsgClientToGCOverworldTradeTokensResponse: MessageFns<CMsgClientToGCOverworldTradeTokensResponse> = {
  encode(message: CMsgClientToGCOverworldTradeTokensResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    if (message.tokensReceived !== undefined) {
      CMsgOverworldTokenQuantity.encode(message.tokensReceived, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldTradeTokensResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldTradeTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokensReceived = CMsgOverworldTokenQuantity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldTradeTokensResponse {
    return {
      response: isSet(object.response)
        ? cMsgClientToGCOverworldTradeTokensResponse_EResponseFromJSON(object.response)
        : 0,
      tokensReceived: isSet(object.tokensReceived)
        ? CMsgOverworldTokenQuantity.fromJSON(object.tokensReceived)
        : undefined,
    };
  },

  toJSON(message: CMsgClientToGCOverworldTradeTokensResponse): unknown {
    const obj: any = {};
    if (message.response !== 0) {
      obj.response = cMsgClientToGCOverworldTradeTokensResponse_EResponseToJSON(message.response);
    }
    if (message.tokensReceived !== undefined) {
      obj.tokensReceived = CMsgOverworldTokenQuantity.toJSON(message.tokensReceived);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldTradeTokensResponse>): CMsgClientToGCOverworldTradeTokensResponse {
    return CMsgClientToGCOverworldTradeTokensResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgClientToGCOverworldTradeTokensResponse>,
  ): CMsgClientToGCOverworldTradeTokensResponse {
    const message = createBaseCMsgClientToGCOverworldTradeTokensResponse();
    message.response = object.response ?? 0;
    message.tokensReceived = (object.tokensReceived !== undefined && object.tokensReceived !== null)
      ? CMsgOverworldTokenQuantity.fromPartial(object.tokensReceived)
      : undefined;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldGiftTokens(): CMsgClientToGCOverworldGiftTokens {
  return { overworldId: 0, tokenGift: undefined, recipientAccountId: 0, periodicResourceId: 0 };
}

export const CMsgClientToGCOverworldGiftTokens: MessageFns<CMsgClientToGCOverworldGiftTokens> = {
  encode(message: CMsgClientToGCOverworldGiftTokens, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overworldId !== 0) {
      writer.uint32(8).uint32(message.overworldId);
    }
    if (message.tokenGift !== undefined) {
      CMsgOverworldTokenCount.encode(message.tokenGift, writer.uint32(18).fork()).join();
    }
    if (message.recipientAccountId !== 0) {
      writer.uint32(24).uint32(message.recipientAccountId);
    }
    if (message.periodicResourceId !== 0) {
      writer.uint32(32).uint32(message.periodicResourceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldGiftTokens {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldGiftTokens();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.overworldId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenGift = CMsgOverworldTokenCount.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.recipientAccountId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.periodicResourceId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldGiftTokens {
    return {
      overworldId: isSet(object.overworldId) ? globalThis.Number(object.overworldId) : 0,
      tokenGift: isSet(object.tokenGift) ? CMsgOverworldTokenCount.fromJSON(object.tokenGift) : undefined,
      recipientAccountId: isSet(object.recipientAccountId) ? globalThis.Number(object.recipientAccountId) : 0,
      periodicResourceId: isSet(object.periodicResourceId) ? globalThis.Number(object.periodicResourceId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCOverworldGiftTokens): unknown {
    const obj: any = {};
    if (message.overworldId !== 0) {
      obj.overworldId = Math.round(message.overworldId);
    }
    if (message.tokenGift !== undefined) {
      obj.tokenGift = CMsgOverworldTokenCount.toJSON(message.tokenGift);
    }
    if (message.recipientAccountId !== 0) {
      obj.recipientAccountId = Math.round(message.recipientAccountId);
    }
    if (message.periodicResourceId !== 0) {
      obj.periodicResourceId = Math.round(message.periodicResourceId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldGiftTokens>): CMsgClientToGCOverworldGiftTokens {
    return CMsgClientToGCOverworldGiftTokens.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCOverworldGiftTokens>): CMsgClientToGCOverworldGiftTokens {
    const message = createBaseCMsgClientToGCOverworldGiftTokens();
    message.overworldId = object.overworldId ?? 0;
    message.tokenGift = (object.tokenGift !== undefined && object.tokenGift !== null)
      ? CMsgOverworldTokenCount.fromPartial(object.tokenGift)
      : undefined;
    message.recipientAccountId = object.recipientAccountId ?? 0;
    message.periodicResourceId = object.periodicResourceId ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldGiftTokensResponse(): CMsgClientToGCOverworldGiftTokensResponse {
  return { response: 0 };
}

export const CMsgClientToGCOverworldGiftTokensResponse: MessageFns<CMsgClientToGCOverworldGiftTokensResponse> = {
  encode(message: CMsgClientToGCOverworldGiftTokensResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldGiftTokensResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldGiftTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldGiftTokensResponse {
    return {
      response: isSet(object.response)
        ? cMsgClientToGCOverworldGiftTokensResponse_EResponseFromJSON(object.response)
        : 0,
    };
  },

  toJSON(message: CMsgClientToGCOverworldGiftTokensResponse): unknown {
    const obj: any = {};
    if (message.response !== 0) {
      obj.response = cMsgClientToGCOverworldGiftTokensResponse_EResponseToJSON(message.response);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldGiftTokensResponse>): CMsgClientToGCOverworldGiftTokensResponse {
    return CMsgClientToGCOverworldGiftTokensResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgClientToGCOverworldGiftTokensResponse>,
  ): CMsgClientToGCOverworldGiftTokensResponse {
    const message = createBaseCMsgClientToGCOverworldGiftTokensResponse();
    message.response = object.response ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldRequestTokensNeededByFriend(): CMsgClientToGCOverworldRequestTokensNeededByFriend {
  return { friendAccountId: 0, overworldId: 0 };
}

export const CMsgClientToGCOverworldRequestTokensNeededByFriend: MessageFns<
  CMsgClientToGCOverworldRequestTokensNeededByFriend
> = {
  encode(
    message: CMsgClientToGCOverworldRequestTokensNeededByFriend,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.friendAccountId !== 0) {
      writer.uint32(8).uint32(message.friendAccountId);
    }
    if (message.overworldId !== 0) {
      writer.uint32(16).uint32(message.overworldId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldRequestTokensNeededByFriend {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldRequestTokensNeededByFriend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.friendAccountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.overworldId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldRequestTokensNeededByFriend {
    return {
      friendAccountId: isSet(object.friendAccountId) ? globalThis.Number(object.friendAccountId) : 0,
      overworldId: isSet(object.overworldId) ? globalThis.Number(object.overworldId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCOverworldRequestTokensNeededByFriend): unknown {
    const obj: any = {};
    if (message.friendAccountId !== 0) {
      obj.friendAccountId = Math.round(message.friendAccountId);
    }
    if (message.overworldId !== 0) {
      obj.overworldId = Math.round(message.overworldId);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgClientToGCOverworldRequestTokensNeededByFriend>,
  ): CMsgClientToGCOverworldRequestTokensNeededByFriend {
    return CMsgClientToGCOverworldRequestTokensNeededByFriend.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgClientToGCOverworldRequestTokensNeededByFriend>,
  ): CMsgClientToGCOverworldRequestTokensNeededByFriend {
    const message = createBaseCMsgClientToGCOverworldRequestTokensNeededByFriend();
    message.friendAccountId = object.friendAccountId ?? 0;
    message.overworldId = object.overworldId ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldRequestTokensNeededByFriendResponse(): CMsgClientToGCOverworldRequestTokensNeededByFriendResponse {
  return { response: 0, tokenQuantity: undefined };
}

export const CMsgClientToGCOverworldRequestTokensNeededByFriendResponse: MessageFns<
  CMsgClientToGCOverworldRequestTokensNeededByFriendResponse
> = {
  encode(
    message: CMsgClientToGCOverworldRequestTokensNeededByFriendResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    if (message.tokenQuantity !== undefined) {
      CMsgOverworldTokenQuantity.encode(message.tokenQuantity, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CMsgClientToGCOverworldRequestTokensNeededByFriendResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldRequestTokensNeededByFriendResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenQuantity = CMsgOverworldTokenQuantity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldRequestTokensNeededByFriendResponse {
    return {
      response: isSet(object.response)
        ? cMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponseFromJSON(object.response)
        : 0,
      tokenQuantity: isSet(object.tokenQuantity)
        ? CMsgOverworldTokenQuantity.fromJSON(object.tokenQuantity)
        : undefined,
    };
  },

  toJSON(message: CMsgClientToGCOverworldRequestTokensNeededByFriendResponse): unknown {
    const obj: any = {};
    if (message.response !== 0) {
      obj.response = cMsgClientToGCOverworldRequestTokensNeededByFriendResponse_EResponseToJSON(message.response);
    }
    if (message.tokenQuantity !== undefined) {
      obj.tokenQuantity = CMsgOverworldTokenQuantity.toJSON(message.tokenQuantity);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgClientToGCOverworldRequestTokensNeededByFriendResponse>,
  ): CMsgClientToGCOverworldRequestTokensNeededByFriendResponse {
    return CMsgClientToGCOverworldRequestTokensNeededByFriendResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgClientToGCOverworldRequestTokensNeededByFriendResponse>,
  ): CMsgClientToGCOverworldRequestTokensNeededByFriendResponse {
    const message = createBaseCMsgClientToGCOverworldRequestTokensNeededByFriendResponse();
    message.response = object.response ?? 0;
    message.tokenQuantity = (object.tokenQuantity !== undefined && object.tokenQuantity !== null)
      ? CMsgOverworldTokenQuantity.fromPartial(object.tokenQuantity)
      : undefined;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldDevResetAll(): CMsgClientToGCOverworldDevResetAll {
  return { overworldId: 0 };
}

export const CMsgClientToGCOverworldDevResetAll: MessageFns<CMsgClientToGCOverworldDevResetAll> = {
  encode(message: CMsgClientToGCOverworldDevResetAll, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overworldId !== 0) {
      writer.uint32(8).uint32(message.overworldId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldDevResetAll {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldDevResetAll();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.overworldId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldDevResetAll {
    return { overworldId: isSet(object.overworldId) ? globalThis.Number(object.overworldId) : 0 };
  },

  toJSON(message: CMsgClientToGCOverworldDevResetAll): unknown {
    const obj: any = {};
    if (message.overworldId !== 0) {
      obj.overworldId = Math.round(message.overworldId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldDevResetAll>): CMsgClientToGCOverworldDevResetAll {
    return CMsgClientToGCOverworldDevResetAll.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCOverworldDevResetAll>): CMsgClientToGCOverworldDevResetAll {
    const message = createBaseCMsgClientToGCOverworldDevResetAll();
    message.overworldId = object.overworldId ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldDevResetAllResponse(): CMsgClientToGCOverworldDevResetAllResponse {
  return { response: 0 };
}

export const CMsgClientToGCOverworldDevResetAllResponse: MessageFns<CMsgClientToGCOverworldDevResetAllResponse> = {
  encode(message: CMsgClientToGCOverworldDevResetAllResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldDevResetAllResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldDevResetAllResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldDevResetAllResponse {
    return {
      response: isSet(object.response)
        ? cMsgClientToGCOverworldDevResetAllResponse_EResponseFromJSON(object.response)
        : 0,
    };
  },

  toJSON(message: CMsgClientToGCOverworldDevResetAllResponse): unknown {
    const obj: any = {};
    if (message.response !== 0) {
      obj.response = cMsgClientToGCOverworldDevResetAllResponse_EResponseToJSON(message.response);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldDevResetAllResponse>): CMsgClientToGCOverworldDevResetAllResponse {
    return CMsgClientToGCOverworldDevResetAllResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgClientToGCOverworldDevResetAllResponse>,
  ): CMsgClientToGCOverworldDevResetAllResponse {
    const message = createBaseCMsgClientToGCOverworldDevResetAllResponse();
    message.response = object.response ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldDevResetNode(): CMsgClientToGCOverworldDevResetNode {
  return { overworldId: 0, nodeId: 0 };
}

export const CMsgClientToGCOverworldDevResetNode: MessageFns<CMsgClientToGCOverworldDevResetNode> = {
  encode(message: CMsgClientToGCOverworldDevResetNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overworldId !== 0) {
      writer.uint32(8).uint32(message.overworldId);
    }
    if (message.nodeId !== 0) {
      writer.uint32(16).uint32(message.nodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldDevResetNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldDevResetNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.overworldId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nodeId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldDevResetNode {
    return {
      overworldId: isSet(object.overworldId) ? globalThis.Number(object.overworldId) : 0,
      nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCOverworldDevResetNode): unknown {
    const obj: any = {};
    if (message.overworldId !== 0) {
      obj.overworldId = Math.round(message.overworldId);
    }
    if (message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldDevResetNode>): CMsgClientToGCOverworldDevResetNode {
    return CMsgClientToGCOverworldDevResetNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCOverworldDevResetNode>): CMsgClientToGCOverworldDevResetNode {
    const message = createBaseCMsgClientToGCOverworldDevResetNode();
    message.overworldId = object.overworldId ?? 0;
    message.nodeId = object.nodeId ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldDevResetNodeResponse(): CMsgClientToGCOverworldDevResetNodeResponse {
  return { response: 0 };
}

export const CMsgClientToGCOverworldDevResetNodeResponse: MessageFns<CMsgClientToGCOverworldDevResetNodeResponse> = {
  encode(
    message: CMsgClientToGCOverworldDevResetNodeResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldDevResetNodeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldDevResetNodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldDevResetNodeResponse {
    return {
      response: isSet(object.response)
        ? cMsgClientToGCOverworldDevResetNodeResponse_EResponseFromJSON(object.response)
        : 0,
    };
  },

  toJSON(message: CMsgClientToGCOverworldDevResetNodeResponse): unknown {
    const obj: any = {};
    if (message.response !== 0) {
      obj.response = cMsgClientToGCOverworldDevResetNodeResponse_EResponseToJSON(message.response);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldDevResetNodeResponse>): CMsgClientToGCOverworldDevResetNodeResponse {
    return CMsgClientToGCOverworldDevResetNodeResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgClientToGCOverworldDevResetNodeResponse>,
  ): CMsgClientToGCOverworldDevResetNodeResponse {
    const message = createBaseCMsgClientToGCOverworldDevResetNodeResponse();
    message.response = object.response ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldDevGrantTokens(): CMsgClientToGCOverworldDevGrantTokens {
  return { overworldId: 0, tokenQuantity: undefined };
}

export const CMsgClientToGCOverworldDevGrantTokens: MessageFns<CMsgClientToGCOverworldDevGrantTokens> = {
  encode(message: CMsgClientToGCOverworldDevGrantTokens, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overworldId !== 0) {
      writer.uint32(8).uint32(message.overworldId);
    }
    if (message.tokenQuantity !== undefined) {
      CMsgOverworldTokenQuantity.encode(message.tokenQuantity, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldDevGrantTokens {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldDevGrantTokens();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.overworldId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenQuantity = CMsgOverworldTokenQuantity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldDevGrantTokens {
    return {
      overworldId: isSet(object.overworldId) ? globalThis.Number(object.overworldId) : 0,
      tokenQuantity: isSet(object.tokenQuantity)
        ? CMsgOverworldTokenQuantity.fromJSON(object.tokenQuantity)
        : undefined,
    };
  },

  toJSON(message: CMsgClientToGCOverworldDevGrantTokens): unknown {
    const obj: any = {};
    if (message.overworldId !== 0) {
      obj.overworldId = Math.round(message.overworldId);
    }
    if (message.tokenQuantity !== undefined) {
      obj.tokenQuantity = CMsgOverworldTokenQuantity.toJSON(message.tokenQuantity);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldDevGrantTokens>): CMsgClientToGCOverworldDevGrantTokens {
    return CMsgClientToGCOverworldDevGrantTokens.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCOverworldDevGrantTokens>): CMsgClientToGCOverworldDevGrantTokens {
    const message = createBaseCMsgClientToGCOverworldDevGrantTokens();
    message.overworldId = object.overworldId ?? 0;
    message.tokenQuantity = (object.tokenQuantity !== undefined && object.tokenQuantity !== null)
      ? CMsgOverworldTokenQuantity.fromPartial(object.tokenQuantity)
      : undefined;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldDevGrantTokensResponse(): CMsgClientToGCOverworldDevGrantTokensResponse {
  return { response: 0 };
}

export const CMsgClientToGCOverworldDevGrantTokensResponse: MessageFns<CMsgClientToGCOverworldDevGrantTokensResponse> =
  {
    encode(
      message: CMsgClientToGCOverworldDevGrantTokensResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.response !== 0) {
        writer.uint32(8).int32(message.response);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldDevGrantTokensResponse {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCMsgClientToGCOverworldDevGrantTokensResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.response = reader.int32() as any;
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CMsgClientToGCOverworldDevGrantTokensResponse {
      return {
        response: isSet(object.response)
          ? cMsgClientToGCOverworldDevGrantTokensResponse_EResponseFromJSON(object.response)
          : 0,
      };
    },

    toJSON(message: CMsgClientToGCOverworldDevGrantTokensResponse): unknown {
      const obj: any = {};
      if (message.response !== 0) {
        obj.response = cMsgClientToGCOverworldDevGrantTokensResponse_EResponseToJSON(message.response);
      }
      return obj;
    },

    create(
      base?: DeepPartial<CMsgClientToGCOverworldDevGrantTokensResponse>,
    ): CMsgClientToGCOverworldDevGrantTokensResponse {
      return CMsgClientToGCOverworldDevGrantTokensResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<CMsgClientToGCOverworldDevGrantTokensResponse>,
    ): CMsgClientToGCOverworldDevGrantTokensResponse {
      const message = createBaseCMsgClientToGCOverworldDevGrantTokensResponse();
      message.response = object.response ?? 0;
      return message;
    },
  };

function createBaseCMsgClientToGCOverworldDevClearInventory(): CMsgClientToGCOverworldDevClearInventory {
  return { overworldId: 0 };
}

export const CMsgClientToGCOverworldDevClearInventory: MessageFns<CMsgClientToGCOverworldDevClearInventory> = {
  encode(message: CMsgClientToGCOverworldDevClearInventory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overworldId !== 0) {
      writer.uint32(8).uint32(message.overworldId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldDevClearInventory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldDevClearInventory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.overworldId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldDevClearInventory {
    return { overworldId: isSet(object.overworldId) ? globalThis.Number(object.overworldId) : 0 };
  },

  toJSON(message: CMsgClientToGCOverworldDevClearInventory): unknown {
    const obj: any = {};
    if (message.overworldId !== 0) {
      obj.overworldId = Math.round(message.overworldId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldDevClearInventory>): CMsgClientToGCOverworldDevClearInventory {
    return CMsgClientToGCOverworldDevClearInventory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCOverworldDevClearInventory>): CMsgClientToGCOverworldDevClearInventory {
    const message = createBaseCMsgClientToGCOverworldDevClearInventory();
    message.overworldId = object.overworldId ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldDevClearInventoryResponse(): CMsgClientToGCOverworldDevClearInventoryResponse {
  return { response: 0 };
}

export const CMsgClientToGCOverworldDevClearInventoryResponse: MessageFns<
  CMsgClientToGCOverworldDevClearInventoryResponse
> = {
  encode(
    message: CMsgClientToGCOverworldDevClearInventoryResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldDevClearInventoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldDevClearInventoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldDevClearInventoryResponse {
    return {
      response: isSet(object.response)
        ? cMsgClientToGCOverworldDevClearInventoryResponse_EResponseFromJSON(object.response)
        : 0,
    };
  },

  toJSON(message: CMsgClientToGCOverworldDevClearInventoryResponse): unknown {
    const obj: any = {};
    if (message.response !== 0) {
      obj.response = cMsgClientToGCOverworldDevClearInventoryResponse_EResponseToJSON(message.response);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgClientToGCOverworldDevClearInventoryResponse>,
  ): CMsgClientToGCOverworldDevClearInventoryResponse {
    return CMsgClientToGCOverworldDevClearInventoryResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgClientToGCOverworldDevClearInventoryResponse>,
  ): CMsgClientToGCOverworldDevClearInventoryResponse {
    const message = createBaseCMsgClientToGCOverworldDevClearInventoryResponse();
    message.response = object.response ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldFeedback(): CMsgClientToGCOverworldFeedback {
  return { language: 0, overworldId: 0, feedback: "" };
}

export const CMsgClientToGCOverworldFeedback: MessageFns<CMsgClientToGCOverworldFeedback> = {
  encode(message: CMsgClientToGCOverworldFeedback, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.language !== 0) {
      writer.uint32(8).uint32(message.language);
    }
    if (message.overworldId !== 0) {
      writer.uint32(16).uint32(message.overworldId);
    }
    if (message.feedback !== "") {
      writer.uint32(26).string(message.feedback);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldFeedback {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldFeedback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.language = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.overworldId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.feedback = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldFeedback {
    return {
      language: isSet(object.language) ? globalThis.Number(object.language) : 0,
      overworldId: isSet(object.overworldId) ? globalThis.Number(object.overworldId) : 0,
      feedback: isSet(object.feedback) ? globalThis.String(object.feedback) : "",
    };
  },

  toJSON(message: CMsgClientToGCOverworldFeedback): unknown {
    const obj: any = {};
    if (message.language !== 0) {
      obj.language = Math.round(message.language);
    }
    if (message.overworldId !== 0) {
      obj.overworldId = Math.round(message.overworldId);
    }
    if (message.feedback !== "") {
      obj.feedback = message.feedback;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldFeedback>): CMsgClientToGCOverworldFeedback {
    return CMsgClientToGCOverworldFeedback.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCOverworldFeedback>): CMsgClientToGCOverworldFeedback {
    const message = createBaseCMsgClientToGCOverworldFeedback();
    message.language = object.language ?? 0;
    message.overworldId = object.overworldId ?? 0;
    message.feedback = object.feedback ?? "";
    return message;
  },
};

function createBaseCMsgClientToGCOverworldFeedbackResponse(): CMsgClientToGCOverworldFeedbackResponse {
  return { response: 0 };
}

export const CMsgClientToGCOverworldFeedbackResponse: MessageFns<CMsgClientToGCOverworldFeedbackResponse> = {
  encode(message: CMsgClientToGCOverworldFeedbackResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldFeedbackResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldFeedbackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldFeedbackResponse {
    return {
      response: isSet(object.response) ? cMsgClientToGCOverworldFeedbackResponse_EResponseFromJSON(object.response) : 0,
    };
  },

  toJSON(message: CMsgClientToGCOverworldFeedbackResponse): unknown {
    const obj: any = {};
    if (message.response !== 0) {
      obj.response = cMsgClientToGCOverworldFeedbackResponse_EResponseToJSON(message.response);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldFeedbackResponse>): CMsgClientToGCOverworldFeedbackResponse {
    return CMsgClientToGCOverworldFeedbackResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCOverworldFeedbackResponse>): CMsgClientToGCOverworldFeedbackResponse {
    const message = createBaseCMsgClientToGCOverworldFeedbackResponse();
    message.response = object.response ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldGetDynamicImage(): CMsgClientToGCOverworldGetDynamicImage {
  return { magic: 0, imageId: 0, language: 0 };
}

export const CMsgClientToGCOverworldGetDynamicImage: MessageFns<CMsgClientToGCOverworldGetDynamicImage> = {
  encode(message: CMsgClientToGCOverworldGetDynamicImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.magic !== 0) {
      writer.uint32(8).uint32(message.magic);
    }
    if (message.imageId !== 0) {
      writer.uint32(16).uint32(message.imageId);
    }
    if (message.language !== 0) {
      writer.uint32(24).uint32(message.language);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldGetDynamicImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldGetDynamicImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.magic = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.imageId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.language = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldGetDynamicImage {
    return {
      magic: isSet(object.magic) ? globalThis.Number(object.magic) : 0,
      imageId: isSet(object.imageId) ? globalThis.Number(object.imageId) : 0,
      language: isSet(object.language) ? globalThis.Number(object.language) : 0,
    };
  },

  toJSON(message: CMsgClientToGCOverworldGetDynamicImage): unknown {
    const obj: any = {};
    if (message.magic !== 0) {
      obj.magic = Math.round(message.magic);
    }
    if (message.imageId !== 0) {
      obj.imageId = Math.round(message.imageId);
    }
    if (message.language !== 0) {
      obj.language = Math.round(message.language);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldGetDynamicImage>): CMsgClientToGCOverworldGetDynamicImage {
    return CMsgClientToGCOverworldGetDynamicImage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCOverworldGetDynamicImage>): CMsgClientToGCOverworldGetDynamicImage {
    const message = createBaseCMsgClientToGCOverworldGetDynamicImage();
    message.magic = object.magic ?? 0;
    message.imageId = object.imageId ?? 0;
    message.language = object.language ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldGetDynamicImageResponse(): CMsgClientToGCOverworldGetDynamicImageResponse {
  return { imageId: 0, images: [] };
}

export const CMsgClientToGCOverworldGetDynamicImageResponse: MessageFns<
  CMsgClientToGCOverworldGetDynamicImageResponse
> = {
  encode(
    message: CMsgClientToGCOverworldGetDynamicImageResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.imageId !== 0) {
      writer.uint32(8).uint32(message.imageId);
    }
    for (const v of message.images) {
      CMsgClientToGCOverworldGetDynamicImageResponse_Image.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldGetDynamicImageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldGetDynamicImageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.imageId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.images.push(CMsgClientToGCOverworldGetDynamicImageResponse_Image.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldGetDynamicImageResponse {
    return {
      imageId: isSet(object.imageId) ? globalThis.Number(object.imageId) : 0,
      images: globalThis.Array.isArray(object?.images)
        ? object.images.map((e: any) => CMsgClientToGCOverworldGetDynamicImageResponse_Image.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientToGCOverworldGetDynamicImageResponse): unknown {
    const obj: any = {};
    if (message.imageId !== 0) {
      obj.imageId = Math.round(message.imageId);
    }
    if (message.images?.length) {
      obj.images = message.images.map((e) => CMsgClientToGCOverworldGetDynamicImageResponse_Image.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgClientToGCOverworldGetDynamicImageResponse>,
  ): CMsgClientToGCOverworldGetDynamicImageResponse {
    return CMsgClientToGCOverworldGetDynamicImageResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgClientToGCOverworldGetDynamicImageResponse>,
  ): CMsgClientToGCOverworldGetDynamicImageResponse {
    const message = createBaseCMsgClientToGCOverworldGetDynamicImageResponse();
    message.imageId = object.imageId ?? 0;
    message.images = object.images?.map((e) => CMsgClientToGCOverworldGetDynamicImageResponse_Image.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseCMsgClientToGCOverworldGetDynamicImageResponse_Image(): CMsgClientToGCOverworldGetDynamicImageResponse_Image {
  return { width: 0, height: 0, format: 0, imageBytes: Buffer.alloc(0) };
}

export const CMsgClientToGCOverworldGetDynamicImageResponse_Image: MessageFns<
  CMsgClientToGCOverworldGetDynamicImageResponse_Image
> = {
  encode(
    message: CMsgClientToGCOverworldGetDynamicImageResponse_Image,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.width !== 0) {
      writer.uint32(8).uint32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(16).uint32(message.height);
    }
    if (message.format !== 0) {
      writer.uint32(24).int32(message.format);
    }
    if (message.imageBytes.length !== 0) {
      writer.uint32(34).bytes(message.imageBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldGetDynamicImageResponse_Image {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldGetDynamicImageResponse_Image();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.width = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.height = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.imageBytes = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldGetDynamicImageResponse_Image {
    return {
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      format: isSet(object.format)
        ? cMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormatFromJSON(object.format)
        : 0,
      imageBytes: isSet(object.imageBytes) ? Buffer.from(bytesFromBase64(object.imageBytes)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CMsgClientToGCOverworldGetDynamicImageResponse_Image): unknown {
    const obj: any = {};
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.format !== 0) {
      obj.format = cMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormatToJSON(message.format);
    }
    if (message.imageBytes.length !== 0) {
      obj.imageBytes = base64FromBytes(message.imageBytes);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgClientToGCOverworldGetDynamicImageResponse_Image>,
  ): CMsgClientToGCOverworldGetDynamicImageResponse_Image {
    return CMsgClientToGCOverworldGetDynamicImageResponse_Image.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgClientToGCOverworldGetDynamicImageResponse_Image>,
  ): CMsgClientToGCOverworldGetDynamicImageResponse_Image {
    const message = createBaseCMsgClientToGCOverworldGetDynamicImageResponse_Image();
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.format = object.format ?? 0;
    message.imageBytes = object.imageBytes ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCMsgClientToGCOverworldMinigameAction(): CMsgClientToGCOverworldMinigameAction {
  return { overworldId: 0, nodeId: 0, action: 0, selection: 0, optionValue: 0, currencyAmount: 0 };
}

export const CMsgClientToGCOverworldMinigameAction: MessageFns<CMsgClientToGCOverworldMinigameAction> = {
  encode(message: CMsgClientToGCOverworldMinigameAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overworldId !== 0) {
      writer.uint32(8).uint32(message.overworldId);
    }
    if (message.nodeId !== 0) {
      writer.uint32(16).uint32(message.nodeId);
    }
    if (message.action !== 0) {
      writer.uint32(24).int32(message.action);
    }
    if (message.selection !== 0) {
      writer.uint32(32).uint32(message.selection);
    }
    if (message.optionValue !== 0) {
      writer.uint32(40).uint32(message.optionValue);
    }
    if (message.currencyAmount !== 0) {
      writer.uint32(48).uint32(message.currencyAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldMinigameAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCOverworldMinigameAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.overworldId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nodeId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.selection = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.optionValue = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.currencyAmount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCOverworldMinigameAction {
    return {
      overworldId: isSet(object.overworldId) ? globalThis.Number(object.overworldId) : 0,
      nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0,
      action: isSet(object.action) ? eOverworldMinigameActionFromJSON(object.action) : 0,
      selection: isSet(object.selection) ? globalThis.Number(object.selection) : 0,
      optionValue: isSet(object.optionValue) ? globalThis.Number(object.optionValue) : 0,
      currencyAmount: isSet(object.currencyAmount) ? globalThis.Number(object.currencyAmount) : 0,
    };
  },

  toJSON(message: CMsgClientToGCOverworldMinigameAction): unknown {
    const obj: any = {};
    if (message.overworldId !== 0) {
      obj.overworldId = Math.round(message.overworldId);
    }
    if (message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    if (message.action !== 0) {
      obj.action = eOverworldMinigameActionToJSON(message.action);
    }
    if (message.selection !== 0) {
      obj.selection = Math.round(message.selection);
    }
    if (message.optionValue !== 0) {
      obj.optionValue = Math.round(message.optionValue);
    }
    if (message.currencyAmount !== 0) {
      obj.currencyAmount = Math.round(message.currencyAmount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCOverworldMinigameAction>): CMsgClientToGCOverworldMinigameAction {
    return CMsgClientToGCOverworldMinigameAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCOverworldMinigameAction>): CMsgClientToGCOverworldMinigameAction {
    const message = createBaseCMsgClientToGCOverworldMinigameAction();
    message.overworldId = object.overworldId ?? 0;
    message.nodeId = object.nodeId ?? 0;
    message.action = object.action ?? 0;
    message.selection = object.selection ?? 0;
    message.optionValue = object.optionValue ?? 0;
    message.currencyAmount = object.currencyAmount ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCOverworldMinigameActionResponse(): CMsgClientToGCOverworldMinigameActionResponse {
  return { response: 0 };
}

export const CMsgClientToGCOverworldMinigameActionResponse: MessageFns<CMsgClientToGCOverworldMinigameActionResponse> =
  {
    encode(
      message: CMsgClientToGCOverworldMinigameActionResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.response !== 0) {
        writer.uint32(8).int32(message.response);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCOverworldMinigameActionResponse {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCMsgClientToGCOverworldMinigameActionResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.response = reader.int32() as any;
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CMsgClientToGCOverworldMinigameActionResponse {
      return {
        response: isSet(object.response)
          ? cMsgClientToGCOverworldMinigameActionResponse_EResponseFromJSON(object.response)
          : 0,
      };
    },

    toJSON(message: CMsgClientToGCOverworldMinigameActionResponse): unknown {
      const obj: any = {};
      if (message.response !== 0) {
        obj.response = cMsgClientToGCOverworldMinigameActionResponse_EResponseToJSON(message.response);
      }
      return obj;
    },

    create(
      base?: DeepPartial<CMsgClientToGCOverworldMinigameActionResponse>,
    ): CMsgClientToGCOverworldMinigameActionResponse {
      return CMsgClientToGCOverworldMinigameActionResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<CMsgClientToGCOverworldMinigameActionResponse>,
    ): CMsgClientToGCOverworldMinigameActionResponse {
      const message = createBaseCMsgClientToGCOverworldMinigameActionResponse();
      message.response = object.response ?? 0;
      return message;
    },
  };

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
