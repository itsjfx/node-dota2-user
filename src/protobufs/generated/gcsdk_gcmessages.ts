// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.30.1
// source: gcsdk_gcmessages.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { CGCSystemMsgGetAccountDetailsResponse } from "./steammessages";
import { CMsgSteamLearnAccessTokens } from "./steammessages_steamlearn.steamworkssdk";

export enum ESourceEngine {
  k_ESE_Source1 = 0,
  k_ESE_Source2 = 1,
}

export function eSourceEngineFromJSON(object: any): ESourceEngine {
  switch (object) {
    case 0:
    case "k_ESE_Source1":
      return ESourceEngine.k_ESE_Source1;
    case 1:
    case "k_ESE_Source2":
      return ESourceEngine.k_ESE_Source2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESourceEngine");
  }
}

export function eSourceEngineToJSON(object: ESourceEngine): string {
  switch (object) {
    case ESourceEngine.k_ESE_Source1:
      return "k_ESE_Source1";
    case ESourceEngine.k_ESE_Source2:
      return "k_ESE_Source2";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESourceEngine");
  }
}

export enum PartnerAccountType {
  PARTNER_NONE = 0,
  PARTNER_PERFECT_WORLD = 1,
  PARTNER_INVALID = 3,
}

export function partnerAccountTypeFromJSON(object: any): PartnerAccountType {
  switch (object) {
    case 0:
    case "PARTNER_NONE":
      return PartnerAccountType.PARTNER_NONE;
    case 1:
    case "PARTNER_PERFECT_WORLD":
      return PartnerAccountType.PARTNER_PERFECT_WORLD;
    case 3:
    case "PARTNER_INVALID":
      return PartnerAccountType.PARTNER_INVALID;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PartnerAccountType");
  }
}

export function partnerAccountTypeToJSON(object: PartnerAccountType): string {
  switch (object) {
    case PartnerAccountType.PARTNER_NONE:
      return "PARTNER_NONE";
    case PartnerAccountType.PARTNER_PERFECT_WORLD:
      return "PARTNER_PERFECT_WORLD";
    case PartnerAccountType.PARTNER_INVALID:
      return "PARTNER_INVALID";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PartnerAccountType");
  }
}

export enum GCConnectionStatus {
  GCConnectionStatus_HAVE_SESSION = 0,
  GCConnectionStatus_GC_GOING_DOWN = 1,
  GCConnectionStatus_NO_SESSION = 2,
  GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE = 3,
  GCConnectionStatus_NO_STEAM = 4,
  GCConnectionStatus_SUSPENDED = 5,
  GCConnectionStatus_STEAM_GOING_DOWN = 6,
}

export function gCConnectionStatusFromJSON(object: any): GCConnectionStatus {
  switch (object) {
    case 0:
    case "GCConnectionStatus_HAVE_SESSION":
      return GCConnectionStatus.GCConnectionStatus_HAVE_SESSION;
    case 1:
    case "GCConnectionStatus_GC_GOING_DOWN":
      return GCConnectionStatus.GCConnectionStatus_GC_GOING_DOWN;
    case 2:
    case "GCConnectionStatus_NO_SESSION":
      return GCConnectionStatus.GCConnectionStatus_NO_SESSION;
    case 3:
    case "GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE":
      return GCConnectionStatus.GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE;
    case 4:
    case "GCConnectionStatus_NO_STEAM":
      return GCConnectionStatus.GCConnectionStatus_NO_STEAM;
    case 5:
    case "GCConnectionStatus_SUSPENDED":
      return GCConnectionStatus.GCConnectionStatus_SUSPENDED;
    case 6:
    case "GCConnectionStatus_STEAM_GOING_DOWN":
      return GCConnectionStatus.GCConnectionStatus_STEAM_GOING_DOWN;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum GCConnectionStatus");
  }
}

export function gCConnectionStatusToJSON(object: GCConnectionStatus): string {
  switch (object) {
    case GCConnectionStatus.GCConnectionStatus_HAVE_SESSION:
      return "GCConnectionStatus_HAVE_SESSION";
    case GCConnectionStatus.GCConnectionStatus_GC_GOING_DOWN:
      return "GCConnectionStatus_GC_GOING_DOWN";
    case GCConnectionStatus.GCConnectionStatus_NO_SESSION:
      return "GCConnectionStatus_NO_SESSION";
    case GCConnectionStatus.GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE:
      return "GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE";
    case GCConnectionStatus.GCConnectionStatus_NO_STEAM:
      return "GCConnectionStatus_NO_STEAM";
    case GCConnectionStatus.GCConnectionStatus_SUSPENDED:
      return "GCConnectionStatus_SUSPENDED";
    case GCConnectionStatus.GCConnectionStatus_STEAM_GOING_DOWN:
      return "GCConnectionStatus_STEAM_GOING_DOWN";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum GCConnectionStatus");
  }
}

export interface CExtraMsgBlock {
  msgType: number;
  contents: Buffer;
  msgKey: string;
  isCompressed: boolean;
}

export interface CMsgSteamLearnServerInfo {
  accessTokens: CMsgSteamLearnAccessTokens | undefined;
  projectInfos: CMsgSteamLearnServerInfo_ProjectInfo[];
}

export interface CMsgSteamLearnServerInfo_ProjectInfo {
  projectId: number;
  snapshotPublishedVersion: number;
  inferencePublishedVersion: number;
  snapshotPercentage: number;
  snapshotEnabled: boolean;
}

export interface CMsgGCAssertJobData {
  messageType: string;
  messageData: Buffer;
}

export interface CMsgGCConCommand {
  command: string;
}

export interface CMsgSDOAssert {
  sdoType: number;
  requests: CMsgSDOAssert_Request[];
}

export interface CMsgSDOAssert_Request {
  key: string[];
  requestingJob: string;
}

export interface CMsgSOIDOwner {
  type: number;
  id: string;
}

export interface CMsgSOSingleObject {
  typeId: number;
  objectData: Buffer;
  version: string;
  ownerSoid: CMsgSOIDOwner | undefined;
  serviceId: number;
}

export interface CMsgSOMultipleObjects {
  objectsModified: CMsgSOMultipleObjects_SingleObject[];
  version: string;
  objectsAdded: CMsgSOMultipleObjects_SingleObject[];
  objectsRemoved: CMsgSOMultipleObjects_SingleObject[];
  ownerSoid: CMsgSOIDOwner | undefined;
  serviceId: number;
}

export interface CMsgSOMultipleObjects_SingleObject {
  typeId: number;
  objectData: Buffer;
}

export interface CMsgSOCacheSubscribed {
  objects: CMsgSOCacheSubscribed_SubscribedType[];
  version: string;
  ownerSoid: CMsgSOIDOwner | undefined;
  serviceId: number;
  serviceList: number[];
  syncVersion: string;
}

export interface CMsgSOCacheSubscribed_SubscribedType {
  typeId: number;
  objectData: Buffer[];
}

export interface CMsgSOCacheSubscribedUpToDate {
  version: string;
  ownerSoid: CMsgSOIDOwner | undefined;
  serviceId: number;
  serviceList: number[];
  syncVersion: string;
}

export interface CMsgSOCacheUnsubscribed {
  ownerSoid: CMsgSOIDOwner | undefined;
}

export interface CMsgSOCacheSubscriptionCheck {
  version: string;
  ownerSoid: CMsgSOIDOwner | undefined;
  serviceId: number;
  serviceList: number[];
  syncVersion: string;
}

export interface CMsgSOCacheSubscriptionRefresh {
  ownerSoid: CMsgSOIDOwner | undefined;
}

export interface CMsgSOCacheVersion {
  version: string;
}

export interface CMsgGCMultiplexMessage {
  msgtype: number;
  payload: Buffer;
  steamids: string[];
}

export interface CMsgGCToGCSubGCStarting {
  dirIndex: number;
}

export interface CGCToGCMsgMasterAck {
  dirIndex: number;
  machineName: string;
  processName: string;
  directory: CGCToGCMsgMasterAck_Process[];
}

export interface CGCToGCMsgMasterAck_Process {
  dirIndex: number;
  typeInstances: number[];
}

export interface CGCToGCMsgMasterAckResponse {
  eresult: number;
}

export interface CMsgGCToGCUniverseStartup {
  isInitialStartup: boolean;
}

export interface CMsgGCToGCUniverseStartupResponse {
  eresult: number;
}

export interface CGCToGCMsgMasterStartupComplete {
  gcInfo: CGCToGCMsgMasterStartupComplete_GCInfo[];
}

export interface CGCToGCMsgMasterStartupComplete_GCInfo {
  dirIndex: number;
  machineName: string;
}

export interface CGCToGCMsgRouted {
  msgType: number;
  senderId: string;
  netMessage: Buffer;
}

export interface CGCToGCMsgRoutedReply {
  msgType: number;
  netMessage: Buffer;
}

export interface CMsgGCUpdateSubGCSessionInfo {
  updates: CMsgGCUpdateSubGCSessionInfo_CMsgUpdate[];
}

export interface CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
  steamid: string;
  ip: number;
  trusted: boolean;
}

export interface CMsgGCRequestSubGCSessionInfo {
  steamid: string;
}

export interface CMsgGCRequestSubGCSessionInfoResponse {
  ip: number;
  trusted: boolean;
  port: number;
  success: boolean;
}

export interface CMsgSOCacheHaveVersion {
  soid: CMsgSOIDOwner | undefined;
  version: string;
  serviceId: number;
  cachedFileVersion: number;
}

export interface CMsgClientHello {
  version: number;
  socacheHaveVersions: CMsgSOCacheHaveVersion[];
  clientSessionNeed: number;
  clientLauncher: PartnerAccountType;
  secretKey: string;
  clientLanguage: number;
  engine: ESourceEngine;
  steamdatagramLogin: Buffer;
  platformId: number;
  gameMsg: Buffer;
  osType: number;
  renderSystem: number;
  renderSystemReq: number;
  screenWidth: number;
  screenHeight: number;
  screenRefresh: number;
  renderWidth: number;
  renderHeight: number;
  swapWidth: number;
  swapHeight: number;
  isSteamChina: boolean;
  isSteamChinaClient: boolean;
  platformName: string;
}

export interface CMsgClientWelcome {
  version: number;
  gameData: Buffer;
  outofdateSubscribedCaches: CMsgSOCacheSubscribed[];
  uptodateSubscribedCaches: CMsgSOCacheSubscriptionCheck[];
  location: CMsgClientWelcome_Location | undefined;
  gcSocacheFileVersion: number;
  txnCountryCode: string;
  gameData2: Buffer;
  rtime32GcWelcomeTimestamp: number;
  currency: number;
  balance: number;
  balanceUrl: string;
  hasAcceptedChinaSsa: boolean;
  isBannedSteamChina: boolean;
  additionalWelcomeMsgs: CExtraMsgBlock | undefined;
  steamLearnServerInfo: CMsgSteamLearnServerInfo | undefined;
}

export interface CMsgClientWelcome_Location {
  latitude: number;
  longitude: number;
  country: string;
}

export interface CMsgConnectionStatus {
  status: GCConnectionStatus;
  clientSessionNeed: number;
  queuePosition: number;
  queueSize: number;
  waitSeconds: number;
  estimatedWaitSecondsRemaining: number;
}

export interface CMsgGCToGCSOCacheSubscribe {
  subscriber: string;
  subscribeToId: string;
  syncVersion: string;
  haveVersions: CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions[];
  subscribeToType: number;
}

export interface CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
  serviceId: number;
  version: string;
}

export interface CMsgGCToGCSOCacheUnsubscribe {
  subscriber: string;
  unsubscribeFromId: string;
  unsubscribeFromType: number;
}

export interface CMsgGCClientPing {
}

export interface CMsgGCToGCForwardAccountDetails {
  steamid: string;
  accountDetails: CGCSystemMsgGetAccountDetailsResponse | undefined;
  ageSeconds: number;
}

export interface CMsgGCToGCLoadSessionSOCache {
  accountId: number;
  forwardAccountDetails: CMsgGCToGCForwardAccountDetails | undefined;
}

export interface CMsgGCToGCLoadSessionSOCacheResponse {
}

export interface CMsgGCToGCUpdateSessionStats {
  userSessions: number;
  serverSessions: number;
  inLogonSurge: boolean;
}

export interface CMsgGCToClientRequestDropped {
}

export interface CWorkshopPopulateItemDescriptionsRequest {
  appid: number;
  languages: CWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock[];
}

export interface CWorkshopPopulateItemDescriptionsRequest_SingleItemDescription {
  gameitemid: number;
  itemDescription: string;
}

export interface CWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock {
  language: string;
  descriptions: CWorkshopPopulateItemDescriptionsRequest_SingleItemDescription[];
}

export interface CWorkshopGetContributorsRequest {
  appid: number;
  gameitemid: number;
}

export interface CWorkshopGetContributorsResponse {
  contributors: string[];
}

export interface CWorkshopSetItemPaymentRulesRequest {
  appid: number;
  gameitemid: number;
  associatedWorkshopFiles: CWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule[];
  partnerAccounts: CWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule[];
  validateOnly: boolean;
  makeWorkshopFilesSubscribable: boolean;
  associatedWorkshopFileForDirectPayments: CWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule | undefined;
}

export interface CWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule {
  workshopFileId: string;
  revenuePercentage: number;
  ruleDescription: string;
  ruleType: number;
}

export interface CWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule {
  workshopFileId: string;
  ruleDescription: string;
}

export interface CWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule {
  accountId: number;
  revenuePercentage: number;
  ruleDescription: string;
}

export interface CWorkshopSetItemPaymentRulesResponse {
  validationErrors: string[];
}

export interface CCommunityClanAnnouncementInfo {
  gid: string;
  clanid: string;
  posterid: string;
  headline: string;
  posttime: number;
  updatetime: number;
  body: string;
  commentcount: number;
  tags: string[];
  language: number;
  hidden: boolean;
  forumTopicId: string;
}

export interface CCommunityGetClanAnnouncementsRequest {
  steamid: string;
  offset: number;
  count: number;
  maxchars: number;
  stripHtml: boolean;
  requiredTags: string[];
  requireNoTags: boolean;
  languagePreference: number[];
  hiddenOnly: boolean;
  onlyGid: boolean;
  rtimeOldestDate: number;
  includeHidden: boolean;
  includePartnerEvents: boolean;
}

export interface CCommunityGetClanAnnouncementsResponse {
  maxchars: number;
  stripHtml: boolean;
  announcements: CCommunityClanAnnouncementInfo[];
}

export interface CBroadcastPostGameDataFrameRequest {
  appid: number;
  steamid: string;
  broadcastId: string;
  frameData: Buffer;
}

export interface CMsgSerializedSOCache {
  fileVersion: number;
  caches: CMsgSerializedSOCache_Cache[];
  gcSocacheFileVersion: number;
}

export interface CMsgSerializedSOCache_TypeCache {
  type: number;
  objects: Buffer[];
  serviceId: number;
}

export interface CMsgSerializedSOCache_Cache {
  type: number;
  id: string;
  versions: CMsgSerializedSOCache_Cache_Version[];
  typeCaches: CMsgSerializedSOCache_TypeCache[];
}

export interface CMsgSerializedSOCache_Cache_Version {
  service: number;
  version: string;
}

export interface CMsgGCToClientPollConvarRequest {
  convarName: string;
  pollId: number;
}

export interface CMsgGCToClientPollConvarResponse {
  pollId: number;
  convarValue: string;
}

export interface CGCMsgCompressedMsgToClient {
  msgId: number;
  compressedMsg: Buffer;
}

export interface CMsgGCToGCMasterBroadcastMessage {
  usersPerSecond: number;
  sendToUsers: boolean;
  sendToServers: boolean;
  msgId: number;
  msgData: Buffer;
}

export interface CMsgGCToGCMasterSubscribeToCache {
  soidType: number;
  soidId: string;
  accountIds: number[];
  steamIds: string[];
}

export interface CMsgGCToGCMasterSubscribeToCacheResponse {
}

export interface CMsgGCToGCMasterSubscribeToCacheAsync {
  subscribeMsg: CMsgGCToGCMasterSubscribeToCache | undefined;
}

export interface CMsgGCToGCMasterUnsubscribeFromCache {
  soidType: number;
  soidId: string;
  accountIds: number[];
  steamIds: string[];
}

export interface CMsgGCToGCMasterDestroyCache {
  soidType: number;
  soidId: string;
}

function createBaseCExtraMsgBlock(): CExtraMsgBlock {
  return { msgType: 0, contents: Buffer.alloc(0), msgKey: "0", isCompressed: false };
}

export const CExtraMsgBlock: MessageFns<CExtraMsgBlock> = {
  encode(message: CExtraMsgBlock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msgType !== 0) {
      writer.uint32(8).uint32(message.msgType);
    }
    if (message.contents.length !== 0) {
      writer.uint32(18).bytes(message.contents);
    }
    if (message.msgKey !== "0") {
      writer.uint32(24).uint64(message.msgKey);
    }
    if (message.isCompressed !== false) {
      writer.uint32(32).bool(message.isCompressed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CExtraMsgBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCExtraMsgBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.msgType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contents = Buffer.from(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.msgKey = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isCompressed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CExtraMsgBlock {
    return {
      msgType: isSet(object.msgType) ? globalThis.Number(object.msgType) : 0,
      contents: isSet(object.contents) ? Buffer.from(bytesFromBase64(object.contents)) : Buffer.alloc(0),
      msgKey: isSet(object.msgKey) ? globalThis.String(object.msgKey) : "0",
      isCompressed: isSet(object.isCompressed) ? globalThis.Boolean(object.isCompressed) : false,
    };
  },

  toJSON(message: CExtraMsgBlock): unknown {
    const obj: any = {};
    if (message.msgType !== 0) {
      obj.msgType = Math.round(message.msgType);
    }
    if (message.contents.length !== 0) {
      obj.contents = base64FromBytes(message.contents);
    }
    if (message.msgKey !== "0") {
      obj.msgKey = message.msgKey;
    }
    if (message.isCompressed !== false) {
      obj.isCompressed = message.isCompressed;
    }
    return obj;
  },

  create(base?: DeepPartial<CExtraMsgBlock>): CExtraMsgBlock {
    return CExtraMsgBlock.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CExtraMsgBlock>): CExtraMsgBlock {
    const message = createBaseCExtraMsgBlock();
    message.msgType = object.msgType ?? 0;
    message.contents = object.contents ?? Buffer.alloc(0);
    message.msgKey = object.msgKey ?? "0";
    message.isCompressed = object.isCompressed ?? false;
    return message;
  },
};

function createBaseCMsgSteamLearnServerInfo(): CMsgSteamLearnServerInfo {
  return { accessTokens: undefined, projectInfos: [] };
}

export const CMsgSteamLearnServerInfo: MessageFns<CMsgSteamLearnServerInfo> = {
  encode(message: CMsgSteamLearnServerInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessTokens !== undefined) {
      CMsgSteamLearnAccessTokens.encode(message.accessTokens, writer.uint32(34).fork()).join();
    }
    for (const v of message.projectInfos) {
      CMsgSteamLearnServerInfo_ProjectInfo.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnServerInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnServerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.accessTokens = CMsgSteamLearnAccessTokens.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.projectInfos.push(CMsgSteamLearnServerInfo_ProjectInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnServerInfo {
    return {
      accessTokens: isSet(object.accessTokens) ? CMsgSteamLearnAccessTokens.fromJSON(object.accessTokens) : undefined,
      projectInfos: globalThis.Array.isArray(object?.projectInfos)
        ? object.projectInfos.map((e: any) => CMsgSteamLearnServerInfo_ProjectInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnServerInfo): unknown {
    const obj: any = {};
    if (message.accessTokens !== undefined) {
      obj.accessTokens = CMsgSteamLearnAccessTokens.toJSON(message.accessTokens);
    }
    if (message.projectInfos?.length) {
      obj.projectInfos = message.projectInfos.map((e) => CMsgSteamLearnServerInfo_ProjectInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnServerInfo>): CMsgSteamLearnServerInfo {
    return CMsgSteamLearnServerInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnServerInfo>): CMsgSteamLearnServerInfo {
    const message = createBaseCMsgSteamLearnServerInfo();
    message.accessTokens = (object.accessTokens !== undefined && object.accessTokens !== null)
      ? CMsgSteamLearnAccessTokens.fromPartial(object.accessTokens)
      : undefined;
    message.projectInfos = object.projectInfos?.map((e) => CMsgSteamLearnServerInfo_ProjectInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnServerInfo_ProjectInfo(): CMsgSteamLearnServerInfo_ProjectInfo {
  return {
    projectId: 0,
    snapshotPublishedVersion: 0,
    inferencePublishedVersion: 0,
    snapshotPercentage: 0,
    snapshotEnabled: false,
  };
}

export const CMsgSteamLearnServerInfo_ProjectInfo: MessageFns<CMsgSteamLearnServerInfo_ProjectInfo> = {
  encode(message: CMsgSteamLearnServerInfo_ProjectInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== 0) {
      writer.uint32(8).uint32(message.projectId);
    }
    if (message.snapshotPublishedVersion !== 0) {
      writer.uint32(16).uint32(message.snapshotPublishedVersion);
    }
    if (message.inferencePublishedVersion !== 0) {
      writer.uint32(24).uint32(message.inferencePublishedVersion);
    }
    if (message.snapshotPercentage !== 0) {
      writer.uint32(48).uint32(message.snapshotPercentage);
    }
    if (message.snapshotEnabled !== false) {
      writer.uint32(56).bool(message.snapshotEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnServerInfo_ProjectInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnServerInfo_ProjectInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.projectId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.snapshotPublishedVersion = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.inferencePublishedVersion = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.snapshotPercentage = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.snapshotEnabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnServerInfo_ProjectInfo {
    return {
      projectId: isSet(object.projectId) ? globalThis.Number(object.projectId) : 0,
      snapshotPublishedVersion: isSet(object.snapshotPublishedVersion)
        ? globalThis.Number(object.snapshotPublishedVersion)
        : 0,
      inferencePublishedVersion: isSet(object.inferencePublishedVersion)
        ? globalThis.Number(object.inferencePublishedVersion)
        : 0,
      snapshotPercentage: isSet(object.snapshotPercentage) ? globalThis.Number(object.snapshotPercentage) : 0,
      snapshotEnabled: isSet(object.snapshotEnabled) ? globalThis.Boolean(object.snapshotEnabled) : false,
    };
  },

  toJSON(message: CMsgSteamLearnServerInfo_ProjectInfo): unknown {
    const obj: any = {};
    if (message.projectId !== 0) {
      obj.projectId = Math.round(message.projectId);
    }
    if (message.snapshotPublishedVersion !== 0) {
      obj.snapshotPublishedVersion = Math.round(message.snapshotPublishedVersion);
    }
    if (message.inferencePublishedVersion !== 0) {
      obj.inferencePublishedVersion = Math.round(message.inferencePublishedVersion);
    }
    if (message.snapshotPercentage !== 0) {
      obj.snapshotPercentage = Math.round(message.snapshotPercentage);
    }
    if (message.snapshotEnabled !== false) {
      obj.snapshotEnabled = message.snapshotEnabled;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnServerInfo_ProjectInfo>): CMsgSteamLearnServerInfo_ProjectInfo {
    return CMsgSteamLearnServerInfo_ProjectInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnServerInfo_ProjectInfo>): CMsgSteamLearnServerInfo_ProjectInfo {
    const message = createBaseCMsgSteamLearnServerInfo_ProjectInfo();
    message.projectId = object.projectId ?? 0;
    message.snapshotPublishedVersion = object.snapshotPublishedVersion ?? 0;
    message.inferencePublishedVersion = object.inferencePublishedVersion ?? 0;
    message.snapshotPercentage = object.snapshotPercentage ?? 0;
    message.snapshotEnabled = object.snapshotEnabled ?? false;
    return message;
  },
};

function createBaseCMsgGCAssertJobData(): CMsgGCAssertJobData {
  return { messageType: "", messageData: Buffer.alloc(0) };
}

export const CMsgGCAssertJobData: MessageFns<CMsgGCAssertJobData> = {
  encode(message: CMsgGCAssertJobData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.messageType !== "") {
      writer.uint32(10).string(message.messageType);
    }
    if (message.messageData.length !== 0) {
      writer.uint32(18).bytes(message.messageData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCAssertJobData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCAssertJobData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messageType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageData = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCAssertJobData {
    return {
      messageType: isSet(object.messageType) ? globalThis.String(object.messageType) : "",
      messageData: isSet(object.messageData) ? Buffer.from(bytesFromBase64(object.messageData)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CMsgGCAssertJobData): unknown {
    const obj: any = {};
    if (message.messageType !== "") {
      obj.messageType = message.messageType;
    }
    if (message.messageData.length !== 0) {
      obj.messageData = base64FromBytes(message.messageData);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCAssertJobData>): CMsgGCAssertJobData {
    return CMsgGCAssertJobData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCAssertJobData>): CMsgGCAssertJobData {
    const message = createBaseCMsgGCAssertJobData();
    message.messageType = object.messageType ?? "";
    message.messageData = object.messageData ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCMsgGCConCommand(): CMsgGCConCommand {
  return { command: "" };
}

export const CMsgGCConCommand: MessageFns<CMsgGCConCommand> = {
  encode(message: CMsgGCConCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== "") {
      writer.uint32(10).string(message.command);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCConCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCConCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.command = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCConCommand {
    return { command: isSet(object.command) ? globalThis.String(object.command) : "" };
  },

  toJSON(message: CMsgGCConCommand): unknown {
    const obj: any = {};
    if (message.command !== "") {
      obj.command = message.command;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCConCommand>): CMsgGCConCommand {
    return CMsgGCConCommand.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCConCommand>): CMsgGCConCommand {
    const message = createBaseCMsgGCConCommand();
    message.command = object.command ?? "";
    return message;
  },
};

function createBaseCMsgSDOAssert(): CMsgSDOAssert {
  return { sdoType: 0, requests: [] };
}

export const CMsgSDOAssert: MessageFns<CMsgSDOAssert> = {
  encode(message: CMsgSDOAssert, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sdoType !== 0) {
      writer.uint32(8).int32(message.sdoType);
    }
    for (const v of message.requests) {
      CMsgSDOAssert_Request.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSDOAssert {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSDOAssert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sdoType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requests.push(CMsgSDOAssert_Request.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSDOAssert {
    return {
      sdoType: isSet(object.sdoType) ? globalThis.Number(object.sdoType) : 0,
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => CMsgSDOAssert_Request.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSDOAssert): unknown {
    const obj: any = {};
    if (message.sdoType !== 0) {
      obj.sdoType = Math.round(message.sdoType);
    }
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => CMsgSDOAssert_Request.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSDOAssert>): CMsgSDOAssert {
    return CMsgSDOAssert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSDOAssert>): CMsgSDOAssert {
    const message = createBaseCMsgSDOAssert();
    message.sdoType = object.sdoType ?? 0;
    message.requests = object.requests?.map((e) => CMsgSDOAssert_Request.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSDOAssert_Request(): CMsgSDOAssert_Request {
  return { key: [], requestingJob: "" };
}

export const CMsgSDOAssert_Request: MessageFns<CMsgSDOAssert_Request> = {
  encode(message: CMsgSDOAssert_Request, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.key) {
      writer.uint64(v);
    }
    writer.join();
    if (message.requestingJob !== "") {
      writer.uint32(18).string(message.requestingJob);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSDOAssert_Request {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSDOAssert_Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.key.push(reader.uint64().toString());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.key.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requestingJob = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSDOAssert_Request {
    return {
      key: globalThis.Array.isArray(object?.key) ? object.key.map((e: any) => globalThis.String(e)) : [],
      requestingJob: isSet(object.requestingJob) ? globalThis.String(object.requestingJob) : "",
    };
  },

  toJSON(message: CMsgSDOAssert_Request): unknown {
    const obj: any = {};
    if (message.key?.length) {
      obj.key = message.key;
    }
    if (message.requestingJob !== "") {
      obj.requestingJob = message.requestingJob;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSDOAssert_Request>): CMsgSDOAssert_Request {
    return CMsgSDOAssert_Request.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSDOAssert_Request>): CMsgSDOAssert_Request {
    const message = createBaseCMsgSDOAssert_Request();
    message.key = object.key?.map((e) => e) || [];
    message.requestingJob = object.requestingJob ?? "";
    return message;
  },
};

function createBaseCMsgSOIDOwner(): CMsgSOIDOwner {
  return { type: 0, id: "0" };
}

export const CMsgSOIDOwner: MessageFns<CMsgSOIDOwner> = {
  encode(message: CMsgSOIDOwner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).uint32(message.type);
    }
    if (message.id !== "0") {
      writer.uint32(16).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSOIDOwner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSOIDOwner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSOIDOwner {
    return {
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
    };
  },

  toJSON(message: CMsgSOIDOwner): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.id !== "0") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSOIDOwner>): CMsgSOIDOwner {
    return CMsgSOIDOwner.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSOIDOwner>): CMsgSOIDOwner {
    const message = createBaseCMsgSOIDOwner();
    message.type = object.type ?? 0;
    message.id = object.id ?? "0";
    return message;
  },
};

function createBaseCMsgSOSingleObject(): CMsgSOSingleObject {
  return { typeId: 0, objectData: Buffer.alloc(0), version: "0", ownerSoid: undefined, serviceId: 0 };
}

export const CMsgSOSingleObject: MessageFns<CMsgSOSingleObject> = {
  encode(message: CMsgSOSingleObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.typeId !== 0) {
      writer.uint32(16).int32(message.typeId);
    }
    if (message.objectData.length !== 0) {
      writer.uint32(26).bytes(message.objectData);
    }
    if (message.version !== "0") {
      writer.uint32(33).fixed64(message.version);
    }
    if (message.ownerSoid !== undefined) {
      CMsgSOIDOwner.encode(message.ownerSoid, writer.uint32(42).fork()).join();
    }
    if (message.serviceId !== 0) {
      writer.uint32(48).uint32(message.serviceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSOSingleObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSOSingleObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.typeId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.objectData = Buffer.from(reader.bytes());
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.version = reader.fixed64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ownerSoid = CMsgSOIDOwner.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.serviceId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSOSingleObject {
    return {
      typeId: isSet(object.typeId) ? globalThis.Number(object.typeId) : 0,
      objectData: isSet(object.objectData) ? Buffer.from(bytesFromBase64(object.objectData)) : Buffer.alloc(0),
      version: isSet(object.version) ? globalThis.String(object.version) : "0",
      ownerSoid: isSet(object.ownerSoid) ? CMsgSOIDOwner.fromJSON(object.ownerSoid) : undefined,
      serviceId: isSet(object.serviceId) ? globalThis.Number(object.serviceId) : 0,
    };
  },

  toJSON(message: CMsgSOSingleObject): unknown {
    const obj: any = {};
    if (message.typeId !== 0) {
      obj.typeId = Math.round(message.typeId);
    }
    if (message.objectData.length !== 0) {
      obj.objectData = base64FromBytes(message.objectData);
    }
    if (message.version !== "0") {
      obj.version = message.version;
    }
    if (message.ownerSoid !== undefined) {
      obj.ownerSoid = CMsgSOIDOwner.toJSON(message.ownerSoid);
    }
    if (message.serviceId !== 0) {
      obj.serviceId = Math.round(message.serviceId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSOSingleObject>): CMsgSOSingleObject {
    return CMsgSOSingleObject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSOSingleObject>): CMsgSOSingleObject {
    const message = createBaseCMsgSOSingleObject();
    message.typeId = object.typeId ?? 0;
    message.objectData = object.objectData ?? Buffer.alloc(0);
    message.version = object.version ?? "0";
    message.ownerSoid = (object.ownerSoid !== undefined && object.ownerSoid !== null)
      ? CMsgSOIDOwner.fromPartial(object.ownerSoid)
      : undefined;
    message.serviceId = object.serviceId ?? 0;
    return message;
  },
};

function createBaseCMsgSOMultipleObjects(): CMsgSOMultipleObjects {
  return {
    objectsModified: [],
    version: "0",
    objectsAdded: [],
    objectsRemoved: [],
    ownerSoid: undefined,
    serviceId: 0,
  };
}

export const CMsgSOMultipleObjects: MessageFns<CMsgSOMultipleObjects> = {
  encode(message: CMsgSOMultipleObjects, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.objectsModified) {
      CMsgSOMultipleObjects_SingleObject.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.version !== "0") {
      writer.uint32(25).fixed64(message.version);
    }
    for (const v of message.objectsAdded) {
      CMsgSOMultipleObjects_SingleObject.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.objectsRemoved) {
      CMsgSOMultipleObjects_SingleObject.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.ownerSoid !== undefined) {
      CMsgSOIDOwner.encode(message.ownerSoid, writer.uint32(50).fork()).join();
    }
    if (message.serviceId !== 0) {
      writer.uint32(56).uint32(message.serviceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSOMultipleObjects {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSOMultipleObjects();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.objectsModified.push(CMsgSOMultipleObjects_SingleObject.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.version = reader.fixed64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.objectsAdded.push(CMsgSOMultipleObjects_SingleObject.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.objectsRemoved.push(CMsgSOMultipleObjects_SingleObject.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.ownerSoid = CMsgSOIDOwner.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.serviceId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSOMultipleObjects {
    return {
      objectsModified: globalThis.Array.isArray(object?.objectsModified)
        ? object.objectsModified.map((e: any) => CMsgSOMultipleObjects_SingleObject.fromJSON(e))
        : [],
      version: isSet(object.version) ? globalThis.String(object.version) : "0",
      objectsAdded: globalThis.Array.isArray(object?.objectsAdded)
        ? object.objectsAdded.map((e: any) => CMsgSOMultipleObjects_SingleObject.fromJSON(e))
        : [],
      objectsRemoved: globalThis.Array.isArray(object?.objectsRemoved)
        ? object.objectsRemoved.map((e: any) => CMsgSOMultipleObjects_SingleObject.fromJSON(e))
        : [],
      ownerSoid: isSet(object.ownerSoid) ? CMsgSOIDOwner.fromJSON(object.ownerSoid) : undefined,
      serviceId: isSet(object.serviceId) ? globalThis.Number(object.serviceId) : 0,
    };
  },

  toJSON(message: CMsgSOMultipleObjects): unknown {
    const obj: any = {};
    if (message.objectsModified?.length) {
      obj.objectsModified = message.objectsModified.map((e) => CMsgSOMultipleObjects_SingleObject.toJSON(e));
    }
    if (message.version !== "0") {
      obj.version = message.version;
    }
    if (message.objectsAdded?.length) {
      obj.objectsAdded = message.objectsAdded.map((e) => CMsgSOMultipleObjects_SingleObject.toJSON(e));
    }
    if (message.objectsRemoved?.length) {
      obj.objectsRemoved = message.objectsRemoved.map((e) => CMsgSOMultipleObjects_SingleObject.toJSON(e));
    }
    if (message.ownerSoid !== undefined) {
      obj.ownerSoid = CMsgSOIDOwner.toJSON(message.ownerSoid);
    }
    if (message.serviceId !== 0) {
      obj.serviceId = Math.round(message.serviceId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSOMultipleObjects>): CMsgSOMultipleObjects {
    return CMsgSOMultipleObjects.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSOMultipleObjects>): CMsgSOMultipleObjects {
    const message = createBaseCMsgSOMultipleObjects();
    message.objectsModified = object.objectsModified?.map((e) => CMsgSOMultipleObjects_SingleObject.fromPartial(e)) ||
      [];
    message.version = object.version ?? "0";
    message.objectsAdded = object.objectsAdded?.map((e) => CMsgSOMultipleObjects_SingleObject.fromPartial(e)) || [];
    message.objectsRemoved = object.objectsRemoved?.map((e) => CMsgSOMultipleObjects_SingleObject.fromPartial(e)) || [];
    message.ownerSoid = (object.ownerSoid !== undefined && object.ownerSoid !== null)
      ? CMsgSOIDOwner.fromPartial(object.ownerSoid)
      : undefined;
    message.serviceId = object.serviceId ?? 0;
    return message;
  },
};

function createBaseCMsgSOMultipleObjects_SingleObject(): CMsgSOMultipleObjects_SingleObject {
  return { typeId: 0, objectData: Buffer.alloc(0) };
}

export const CMsgSOMultipleObjects_SingleObject: MessageFns<CMsgSOMultipleObjects_SingleObject> = {
  encode(message: CMsgSOMultipleObjects_SingleObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.typeId !== 0) {
      writer.uint32(8).int32(message.typeId);
    }
    if (message.objectData.length !== 0) {
      writer.uint32(18).bytes(message.objectData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSOMultipleObjects_SingleObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSOMultipleObjects_SingleObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.typeId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.objectData = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSOMultipleObjects_SingleObject {
    return {
      typeId: isSet(object.typeId) ? globalThis.Number(object.typeId) : 0,
      objectData: isSet(object.objectData) ? Buffer.from(bytesFromBase64(object.objectData)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CMsgSOMultipleObjects_SingleObject): unknown {
    const obj: any = {};
    if (message.typeId !== 0) {
      obj.typeId = Math.round(message.typeId);
    }
    if (message.objectData.length !== 0) {
      obj.objectData = base64FromBytes(message.objectData);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSOMultipleObjects_SingleObject>): CMsgSOMultipleObjects_SingleObject {
    return CMsgSOMultipleObjects_SingleObject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSOMultipleObjects_SingleObject>): CMsgSOMultipleObjects_SingleObject {
    const message = createBaseCMsgSOMultipleObjects_SingleObject();
    message.typeId = object.typeId ?? 0;
    message.objectData = object.objectData ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCMsgSOCacheSubscribed(): CMsgSOCacheSubscribed {
  return { objects: [], version: "0", ownerSoid: undefined, serviceId: 0, serviceList: [], syncVersion: "0" };
}

export const CMsgSOCacheSubscribed: MessageFns<CMsgSOCacheSubscribed> = {
  encode(message: CMsgSOCacheSubscribed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.objects) {
      CMsgSOCacheSubscribed_SubscribedType.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.version !== "0") {
      writer.uint32(25).fixed64(message.version);
    }
    if (message.ownerSoid !== undefined) {
      CMsgSOIDOwner.encode(message.ownerSoid, writer.uint32(34).fork()).join();
    }
    if (message.serviceId !== 0) {
      writer.uint32(40).uint32(message.serviceId);
    }
    writer.uint32(50).fork();
    for (const v of message.serviceList) {
      writer.uint32(v);
    }
    writer.join();
    if (message.syncVersion !== "0") {
      writer.uint32(57).fixed64(message.syncVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSOCacheSubscribed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSOCacheSubscribed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.objects.push(CMsgSOCacheSubscribed_SubscribedType.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.version = reader.fixed64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ownerSoid = CMsgSOIDOwner.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.serviceId = reader.uint32();
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.serviceList.push(reader.uint32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.serviceList.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.syncVersion = reader.fixed64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSOCacheSubscribed {
    return {
      objects: globalThis.Array.isArray(object?.objects)
        ? object.objects.map((e: any) => CMsgSOCacheSubscribed_SubscribedType.fromJSON(e))
        : [],
      version: isSet(object.version) ? globalThis.String(object.version) : "0",
      ownerSoid: isSet(object.ownerSoid) ? CMsgSOIDOwner.fromJSON(object.ownerSoid) : undefined,
      serviceId: isSet(object.serviceId) ? globalThis.Number(object.serviceId) : 0,
      serviceList: globalThis.Array.isArray(object?.serviceList)
        ? object.serviceList.map((e: any) => globalThis.Number(e))
        : [],
      syncVersion: isSet(object.syncVersion) ? globalThis.String(object.syncVersion) : "0",
    };
  },

  toJSON(message: CMsgSOCacheSubscribed): unknown {
    const obj: any = {};
    if (message.objects?.length) {
      obj.objects = message.objects.map((e) => CMsgSOCacheSubscribed_SubscribedType.toJSON(e));
    }
    if (message.version !== "0") {
      obj.version = message.version;
    }
    if (message.ownerSoid !== undefined) {
      obj.ownerSoid = CMsgSOIDOwner.toJSON(message.ownerSoid);
    }
    if (message.serviceId !== 0) {
      obj.serviceId = Math.round(message.serviceId);
    }
    if (message.serviceList?.length) {
      obj.serviceList = message.serviceList.map((e) => Math.round(e));
    }
    if (message.syncVersion !== "0") {
      obj.syncVersion = message.syncVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSOCacheSubscribed>): CMsgSOCacheSubscribed {
    return CMsgSOCacheSubscribed.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSOCacheSubscribed>): CMsgSOCacheSubscribed {
    const message = createBaseCMsgSOCacheSubscribed();
    message.objects = object.objects?.map((e) => CMsgSOCacheSubscribed_SubscribedType.fromPartial(e)) || [];
    message.version = object.version ?? "0";
    message.ownerSoid = (object.ownerSoid !== undefined && object.ownerSoid !== null)
      ? CMsgSOIDOwner.fromPartial(object.ownerSoid)
      : undefined;
    message.serviceId = object.serviceId ?? 0;
    message.serviceList = object.serviceList?.map((e) => e) || [];
    message.syncVersion = object.syncVersion ?? "0";
    return message;
  },
};

function createBaseCMsgSOCacheSubscribed_SubscribedType(): CMsgSOCacheSubscribed_SubscribedType {
  return { typeId: 0, objectData: [] };
}

export const CMsgSOCacheSubscribed_SubscribedType: MessageFns<CMsgSOCacheSubscribed_SubscribedType> = {
  encode(message: CMsgSOCacheSubscribed_SubscribedType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.typeId !== 0) {
      writer.uint32(8).int32(message.typeId);
    }
    for (const v of message.objectData) {
      writer.uint32(18).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSOCacheSubscribed_SubscribedType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSOCacheSubscribed_SubscribedType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.typeId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.objectData.push(Buffer.from(reader.bytes()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSOCacheSubscribed_SubscribedType {
    return {
      typeId: isSet(object.typeId) ? globalThis.Number(object.typeId) : 0,
      objectData: globalThis.Array.isArray(object?.objectData)
        ? object.objectData.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
    };
  },

  toJSON(message: CMsgSOCacheSubscribed_SubscribedType): unknown {
    const obj: any = {};
    if (message.typeId !== 0) {
      obj.typeId = Math.round(message.typeId);
    }
    if (message.objectData?.length) {
      obj.objectData = message.objectData.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSOCacheSubscribed_SubscribedType>): CMsgSOCacheSubscribed_SubscribedType {
    return CMsgSOCacheSubscribed_SubscribedType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSOCacheSubscribed_SubscribedType>): CMsgSOCacheSubscribed_SubscribedType {
    const message = createBaseCMsgSOCacheSubscribed_SubscribedType();
    message.typeId = object.typeId ?? 0;
    message.objectData = object.objectData?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgSOCacheSubscribedUpToDate(): CMsgSOCacheSubscribedUpToDate {
  return { version: "0", ownerSoid: undefined, serviceId: 0, serviceList: [], syncVersion: "0" };
}

export const CMsgSOCacheSubscribedUpToDate: MessageFns<CMsgSOCacheSubscribedUpToDate> = {
  encode(message: CMsgSOCacheSubscribedUpToDate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "0") {
      writer.uint32(9).fixed64(message.version);
    }
    if (message.ownerSoid !== undefined) {
      CMsgSOIDOwner.encode(message.ownerSoid, writer.uint32(18).fork()).join();
    }
    if (message.serviceId !== 0) {
      writer.uint32(24).uint32(message.serviceId);
    }
    writer.uint32(34).fork();
    for (const v of message.serviceList) {
      writer.uint32(v);
    }
    writer.join();
    if (message.syncVersion !== "0") {
      writer.uint32(41).fixed64(message.syncVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSOCacheSubscribedUpToDate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSOCacheSubscribedUpToDate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.version = reader.fixed64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerSoid = CMsgSOIDOwner.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.serviceId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.serviceList.push(reader.uint32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.serviceList.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.syncVersion = reader.fixed64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSOCacheSubscribedUpToDate {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "0",
      ownerSoid: isSet(object.ownerSoid) ? CMsgSOIDOwner.fromJSON(object.ownerSoid) : undefined,
      serviceId: isSet(object.serviceId) ? globalThis.Number(object.serviceId) : 0,
      serviceList: globalThis.Array.isArray(object?.serviceList)
        ? object.serviceList.map((e: any) => globalThis.Number(e))
        : [],
      syncVersion: isSet(object.syncVersion) ? globalThis.String(object.syncVersion) : "0",
    };
  },

  toJSON(message: CMsgSOCacheSubscribedUpToDate): unknown {
    const obj: any = {};
    if (message.version !== "0") {
      obj.version = message.version;
    }
    if (message.ownerSoid !== undefined) {
      obj.ownerSoid = CMsgSOIDOwner.toJSON(message.ownerSoid);
    }
    if (message.serviceId !== 0) {
      obj.serviceId = Math.round(message.serviceId);
    }
    if (message.serviceList?.length) {
      obj.serviceList = message.serviceList.map((e) => Math.round(e));
    }
    if (message.syncVersion !== "0") {
      obj.syncVersion = message.syncVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSOCacheSubscribedUpToDate>): CMsgSOCacheSubscribedUpToDate {
    return CMsgSOCacheSubscribedUpToDate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSOCacheSubscribedUpToDate>): CMsgSOCacheSubscribedUpToDate {
    const message = createBaseCMsgSOCacheSubscribedUpToDate();
    message.version = object.version ?? "0";
    message.ownerSoid = (object.ownerSoid !== undefined && object.ownerSoid !== null)
      ? CMsgSOIDOwner.fromPartial(object.ownerSoid)
      : undefined;
    message.serviceId = object.serviceId ?? 0;
    message.serviceList = object.serviceList?.map((e) => e) || [];
    message.syncVersion = object.syncVersion ?? "0";
    return message;
  },
};

function createBaseCMsgSOCacheUnsubscribed(): CMsgSOCacheUnsubscribed {
  return { ownerSoid: undefined };
}

export const CMsgSOCacheUnsubscribed: MessageFns<CMsgSOCacheUnsubscribed> = {
  encode(message: CMsgSOCacheUnsubscribed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownerSoid !== undefined) {
      CMsgSOIDOwner.encode(message.ownerSoid, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSOCacheUnsubscribed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSOCacheUnsubscribed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerSoid = CMsgSOIDOwner.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSOCacheUnsubscribed {
    return { ownerSoid: isSet(object.ownerSoid) ? CMsgSOIDOwner.fromJSON(object.ownerSoid) : undefined };
  },

  toJSON(message: CMsgSOCacheUnsubscribed): unknown {
    const obj: any = {};
    if (message.ownerSoid !== undefined) {
      obj.ownerSoid = CMsgSOIDOwner.toJSON(message.ownerSoid);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSOCacheUnsubscribed>): CMsgSOCacheUnsubscribed {
    return CMsgSOCacheUnsubscribed.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSOCacheUnsubscribed>): CMsgSOCacheUnsubscribed {
    const message = createBaseCMsgSOCacheUnsubscribed();
    message.ownerSoid = (object.ownerSoid !== undefined && object.ownerSoid !== null)
      ? CMsgSOIDOwner.fromPartial(object.ownerSoid)
      : undefined;
    return message;
  },
};

function createBaseCMsgSOCacheSubscriptionCheck(): CMsgSOCacheSubscriptionCheck {
  return { version: "0", ownerSoid: undefined, serviceId: 0, serviceList: [], syncVersion: "0" };
}

export const CMsgSOCacheSubscriptionCheck: MessageFns<CMsgSOCacheSubscriptionCheck> = {
  encode(message: CMsgSOCacheSubscriptionCheck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "0") {
      writer.uint32(17).fixed64(message.version);
    }
    if (message.ownerSoid !== undefined) {
      CMsgSOIDOwner.encode(message.ownerSoid, writer.uint32(26).fork()).join();
    }
    if (message.serviceId !== 0) {
      writer.uint32(32).uint32(message.serviceId);
    }
    writer.uint32(42).fork();
    for (const v of message.serviceList) {
      writer.uint32(v);
    }
    writer.join();
    if (message.syncVersion !== "0") {
      writer.uint32(49).fixed64(message.syncVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSOCacheSubscriptionCheck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSOCacheSubscriptionCheck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.version = reader.fixed64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ownerSoid = CMsgSOIDOwner.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.serviceId = reader.uint32();
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.serviceList.push(reader.uint32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.serviceList.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.syncVersion = reader.fixed64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSOCacheSubscriptionCheck {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "0",
      ownerSoid: isSet(object.ownerSoid) ? CMsgSOIDOwner.fromJSON(object.ownerSoid) : undefined,
      serviceId: isSet(object.serviceId) ? globalThis.Number(object.serviceId) : 0,
      serviceList: globalThis.Array.isArray(object?.serviceList)
        ? object.serviceList.map((e: any) => globalThis.Number(e))
        : [],
      syncVersion: isSet(object.syncVersion) ? globalThis.String(object.syncVersion) : "0",
    };
  },

  toJSON(message: CMsgSOCacheSubscriptionCheck): unknown {
    const obj: any = {};
    if (message.version !== "0") {
      obj.version = message.version;
    }
    if (message.ownerSoid !== undefined) {
      obj.ownerSoid = CMsgSOIDOwner.toJSON(message.ownerSoid);
    }
    if (message.serviceId !== 0) {
      obj.serviceId = Math.round(message.serviceId);
    }
    if (message.serviceList?.length) {
      obj.serviceList = message.serviceList.map((e) => Math.round(e));
    }
    if (message.syncVersion !== "0") {
      obj.syncVersion = message.syncVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSOCacheSubscriptionCheck>): CMsgSOCacheSubscriptionCheck {
    return CMsgSOCacheSubscriptionCheck.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSOCacheSubscriptionCheck>): CMsgSOCacheSubscriptionCheck {
    const message = createBaseCMsgSOCacheSubscriptionCheck();
    message.version = object.version ?? "0";
    message.ownerSoid = (object.ownerSoid !== undefined && object.ownerSoid !== null)
      ? CMsgSOIDOwner.fromPartial(object.ownerSoid)
      : undefined;
    message.serviceId = object.serviceId ?? 0;
    message.serviceList = object.serviceList?.map((e) => e) || [];
    message.syncVersion = object.syncVersion ?? "0";
    return message;
  },
};

function createBaseCMsgSOCacheSubscriptionRefresh(): CMsgSOCacheSubscriptionRefresh {
  return { ownerSoid: undefined };
}

export const CMsgSOCacheSubscriptionRefresh: MessageFns<CMsgSOCacheSubscriptionRefresh> = {
  encode(message: CMsgSOCacheSubscriptionRefresh, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownerSoid !== undefined) {
      CMsgSOIDOwner.encode(message.ownerSoid, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSOCacheSubscriptionRefresh {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSOCacheSubscriptionRefresh();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerSoid = CMsgSOIDOwner.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSOCacheSubscriptionRefresh {
    return { ownerSoid: isSet(object.ownerSoid) ? CMsgSOIDOwner.fromJSON(object.ownerSoid) : undefined };
  },

  toJSON(message: CMsgSOCacheSubscriptionRefresh): unknown {
    const obj: any = {};
    if (message.ownerSoid !== undefined) {
      obj.ownerSoid = CMsgSOIDOwner.toJSON(message.ownerSoid);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSOCacheSubscriptionRefresh>): CMsgSOCacheSubscriptionRefresh {
    return CMsgSOCacheSubscriptionRefresh.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSOCacheSubscriptionRefresh>): CMsgSOCacheSubscriptionRefresh {
    const message = createBaseCMsgSOCacheSubscriptionRefresh();
    message.ownerSoid = (object.ownerSoid !== undefined && object.ownerSoid !== null)
      ? CMsgSOIDOwner.fromPartial(object.ownerSoid)
      : undefined;
    return message;
  },
};

function createBaseCMsgSOCacheVersion(): CMsgSOCacheVersion {
  return { version: "0" };
}

export const CMsgSOCacheVersion: MessageFns<CMsgSOCacheVersion> = {
  encode(message: CMsgSOCacheVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "0") {
      writer.uint32(9).fixed64(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSOCacheVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSOCacheVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.version = reader.fixed64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSOCacheVersion {
    return { version: isSet(object.version) ? globalThis.String(object.version) : "0" };
  },

  toJSON(message: CMsgSOCacheVersion): unknown {
    const obj: any = {};
    if (message.version !== "0") {
      obj.version = message.version;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSOCacheVersion>): CMsgSOCacheVersion {
    return CMsgSOCacheVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSOCacheVersion>): CMsgSOCacheVersion {
    const message = createBaseCMsgSOCacheVersion();
    message.version = object.version ?? "0";
    return message;
  },
};

function createBaseCMsgGCMultiplexMessage(): CMsgGCMultiplexMessage {
  return { msgtype: 0, payload: Buffer.alloc(0), steamids: [] };
}

export const CMsgGCMultiplexMessage: MessageFns<CMsgGCMultiplexMessage> = {
  encode(message: CMsgGCMultiplexMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msgtype !== 0) {
      writer.uint32(8).uint32(message.msgtype);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    writer.uint32(26).fork();
    for (const v of message.steamids) {
      writer.fixed64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCMultiplexMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCMultiplexMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.msgtype = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = Buffer.from(reader.bytes());
          continue;
        }
        case 3: {
          if (tag === 25) {
            message.steamids.push(reader.fixed64().toString());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.steamids.push(reader.fixed64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCMultiplexMessage {
    return {
      msgtype: isSet(object.msgtype) ? globalThis.Number(object.msgtype) : 0,
      payload: isSet(object.payload) ? Buffer.from(bytesFromBase64(object.payload)) : Buffer.alloc(0),
      steamids: globalThis.Array.isArray(object?.steamids) ? object.steamids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CMsgGCMultiplexMessage): unknown {
    const obj: any = {};
    if (message.msgtype !== 0) {
      obj.msgtype = Math.round(message.msgtype);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.steamids?.length) {
      obj.steamids = message.steamids;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCMultiplexMessage>): CMsgGCMultiplexMessage {
    return CMsgGCMultiplexMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCMultiplexMessage>): CMsgGCMultiplexMessage {
    const message = createBaseCMsgGCMultiplexMessage();
    message.msgtype = object.msgtype ?? 0;
    message.payload = object.payload ?? Buffer.alloc(0);
    message.steamids = object.steamids?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgGCToGCSubGCStarting(): CMsgGCToGCSubGCStarting {
  return { dirIndex: -1 };
}

export const CMsgGCToGCSubGCStarting: MessageFns<CMsgGCToGCSubGCStarting> = {
  encode(message: CMsgGCToGCSubGCStarting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dirIndex !== -1) {
      writer.uint32(8).int32(message.dirIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCSubGCStarting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCSubGCStarting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.dirIndex = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCSubGCStarting {
    return { dirIndex: isSet(object.dirIndex) ? globalThis.Number(object.dirIndex) : -1 };
  },

  toJSON(message: CMsgGCToGCSubGCStarting): unknown {
    const obj: any = {};
    if (message.dirIndex !== -1) {
      obj.dirIndex = Math.round(message.dirIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCSubGCStarting>): CMsgGCToGCSubGCStarting {
    return CMsgGCToGCSubGCStarting.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToGCSubGCStarting>): CMsgGCToGCSubGCStarting {
    const message = createBaseCMsgGCToGCSubGCStarting();
    message.dirIndex = object.dirIndex ?? -1;
    return message;
  },
};

function createBaseCGCToGCMsgMasterAck(): CGCToGCMsgMasterAck {
  return { dirIndex: -1, machineName: "", processName: "", directory: [] };
}

export const CGCToGCMsgMasterAck: MessageFns<CGCToGCMsgMasterAck> = {
  encode(message: CGCToGCMsgMasterAck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dirIndex !== -1) {
      writer.uint32(8).int32(message.dirIndex);
    }
    if (message.machineName !== "") {
      writer.uint32(26).string(message.machineName);
    }
    if (message.processName !== "") {
      writer.uint32(34).string(message.processName);
    }
    for (const v of message.directory) {
      CGCToGCMsgMasterAck_Process.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CGCToGCMsgMasterAck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCToGCMsgMasterAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.dirIndex = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.machineName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.processName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.directory.push(CGCToGCMsgMasterAck_Process.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCToGCMsgMasterAck {
    return {
      dirIndex: isSet(object.dirIndex) ? globalThis.Number(object.dirIndex) : -1,
      machineName: isSet(object.machineName) ? globalThis.String(object.machineName) : "",
      processName: isSet(object.processName) ? globalThis.String(object.processName) : "",
      directory: globalThis.Array.isArray(object?.directory)
        ? object.directory.map((e: any) => CGCToGCMsgMasterAck_Process.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CGCToGCMsgMasterAck): unknown {
    const obj: any = {};
    if (message.dirIndex !== -1) {
      obj.dirIndex = Math.round(message.dirIndex);
    }
    if (message.machineName !== "") {
      obj.machineName = message.machineName;
    }
    if (message.processName !== "") {
      obj.processName = message.processName;
    }
    if (message.directory?.length) {
      obj.directory = message.directory.map((e) => CGCToGCMsgMasterAck_Process.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CGCToGCMsgMasterAck>): CGCToGCMsgMasterAck {
    return CGCToGCMsgMasterAck.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCToGCMsgMasterAck>): CGCToGCMsgMasterAck {
    const message = createBaseCGCToGCMsgMasterAck();
    message.dirIndex = object.dirIndex ?? -1;
    message.machineName = object.machineName ?? "";
    message.processName = object.processName ?? "";
    message.directory = object.directory?.map((e) => CGCToGCMsgMasterAck_Process.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCGCToGCMsgMasterAck_Process(): CGCToGCMsgMasterAck_Process {
  return { dirIndex: -1, typeInstances: [] };
}

export const CGCToGCMsgMasterAck_Process: MessageFns<CGCToGCMsgMasterAck_Process> = {
  encode(message: CGCToGCMsgMasterAck_Process, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dirIndex !== -1) {
      writer.uint32(8).int32(message.dirIndex);
    }
    writer.uint32(18).fork();
    for (const v of message.typeInstances) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CGCToGCMsgMasterAck_Process {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCToGCMsgMasterAck_Process();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.dirIndex = reader.int32();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.typeInstances.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.typeInstances.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCToGCMsgMasterAck_Process {
    return {
      dirIndex: isSet(object.dirIndex) ? globalThis.Number(object.dirIndex) : -1,
      typeInstances: globalThis.Array.isArray(object?.typeInstances)
        ? object.typeInstances.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CGCToGCMsgMasterAck_Process): unknown {
    const obj: any = {};
    if (message.dirIndex !== -1) {
      obj.dirIndex = Math.round(message.dirIndex);
    }
    if (message.typeInstances?.length) {
      obj.typeInstances = message.typeInstances.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CGCToGCMsgMasterAck_Process>): CGCToGCMsgMasterAck_Process {
    return CGCToGCMsgMasterAck_Process.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCToGCMsgMasterAck_Process>): CGCToGCMsgMasterAck_Process {
    const message = createBaseCGCToGCMsgMasterAck_Process();
    message.dirIndex = object.dirIndex ?? -1;
    message.typeInstances = object.typeInstances?.map((e) => e) || [];
    return message;
  },
};

function createBaseCGCToGCMsgMasterAckResponse(): CGCToGCMsgMasterAckResponse {
  return { eresult: 2 };
}

export const CGCToGCMsgMasterAckResponse: MessageFns<CGCToGCMsgMasterAckResponse> = {
  encode(message: CGCToGCMsgMasterAckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eresult !== 2) {
      writer.uint32(8).int32(message.eresult);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CGCToGCMsgMasterAckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCToGCMsgMasterAckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.eresult = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCToGCMsgMasterAckResponse {
    return { eresult: isSet(object.eresult) ? globalThis.Number(object.eresult) : 2 };
  },

  toJSON(message: CGCToGCMsgMasterAckResponse): unknown {
    const obj: any = {};
    if (message.eresult !== 2) {
      obj.eresult = Math.round(message.eresult);
    }
    return obj;
  },

  create(base?: DeepPartial<CGCToGCMsgMasterAckResponse>): CGCToGCMsgMasterAckResponse {
    return CGCToGCMsgMasterAckResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCToGCMsgMasterAckResponse>): CGCToGCMsgMasterAckResponse {
    const message = createBaseCGCToGCMsgMasterAckResponse();
    message.eresult = object.eresult ?? 2;
    return message;
  },
};

function createBaseCMsgGCToGCUniverseStartup(): CMsgGCToGCUniverseStartup {
  return { isInitialStartup: false };
}

export const CMsgGCToGCUniverseStartup: MessageFns<CMsgGCToGCUniverseStartup> = {
  encode(message: CMsgGCToGCUniverseStartup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isInitialStartup !== false) {
      writer.uint32(8).bool(message.isInitialStartup);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCUniverseStartup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCUniverseStartup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isInitialStartup = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCUniverseStartup {
    return { isInitialStartup: isSet(object.isInitialStartup) ? globalThis.Boolean(object.isInitialStartup) : false };
  },

  toJSON(message: CMsgGCToGCUniverseStartup): unknown {
    const obj: any = {};
    if (message.isInitialStartup !== false) {
      obj.isInitialStartup = message.isInitialStartup;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCUniverseStartup>): CMsgGCToGCUniverseStartup {
    return CMsgGCToGCUniverseStartup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToGCUniverseStartup>): CMsgGCToGCUniverseStartup {
    const message = createBaseCMsgGCToGCUniverseStartup();
    message.isInitialStartup = object.isInitialStartup ?? false;
    return message;
  },
};

function createBaseCMsgGCToGCUniverseStartupResponse(): CMsgGCToGCUniverseStartupResponse {
  return { eresult: 0 };
}

export const CMsgGCToGCUniverseStartupResponse: MessageFns<CMsgGCToGCUniverseStartupResponse> = {
  encode(message: CMsgGCToGCUniverseStartupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eresult !== 0) {
      writer.uint32(8).int32(message.eresult);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCUniverseStartupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCUniverseStartupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.eresult = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCUniverseStartupResponse {
    return { eresult: isSet(object.eresult) ? globalThis.Number(object.eresult) : 0 };
  },

  toJSON(message: CMsgGCToGCUniverseStartupResponse): unknown {
    const obj: any = {};
    if (message.eresult !== 0) {
      obj.eresult = Math.round(message.eresult);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCUniverseStartupResponse>): CMsgGCToGCUniverseStartupResponse {
    return CMsgGCToGCUniverseStartupResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToGCUniverseStartupResponse>): CMsgGCToGCUniverseStartupResponse {
    const message = createBaseCMsgGCToGCUniverseStartupResponse();
    message.eresult = object.eresult ?? 0;
    return message;
  },
};

function createBaseCGCToGCMsgMasterStartupComplete(): CGCToGCMsgMasterStartupComplete {
  return { gcInfo: [] };
}

export const CGCToGCMsgMasterStartupComplete: MessageFns<CGCToGCMsgMasterStartupComplete> = {
  encode(message: CGCToGCMsgMasterStartupComplete, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.gcInfo) {
      CGCToGCMsgMasterStartupComplete_GCInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CGCToGCMsgMasterStartupComplete {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCToGCMsgMasterStartupComplete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gcInfo.push(CGCToGCMsgMasterStartupComplete_GCInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCToGCMsgMasterStartupComplete {
    return {
      gcInfo: globalThis.Array.isArray(object?.gcInfo)
        ? object.gcInfo.map((e: any) => CGCToGCMsgMasterStartupComplete_GCInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CGCToGCMsgMasterStartupComplete): unknown {
    const obj: any = {};
    if (message.gcInfo?.length) {
      obj.gcInfo = message.gcInfo.map((e) => CGCToGCMsgMasterStartupComplete_GCInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CGCToGCMsgMasterStartupComplete>): CGCToGCMsgMasterStartupComplete {
    return CGCToGCMsgMasterStartupComplete.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCToGCMsgMasterStartupComplete>): CGCToGCMsgMasterStartupComplete {
    const message = createBaseCGCToGCMsgMasterStartupComplete();
    message.gcInfo = object.gcInfo?.map((e) => CGCToGCMsgMasterStartupComplete_GCInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCGCToGCMsgMasterStartupComplete_GCInfo(): CGCToGCMsgMasterStartupComplete_GCInfo {
  return { dirIndex: -1, machineName: "" };
}

export const CGCToGCMsgMasterStartupComplete_GCInfo: MessageFns<CGCToGCMsgMasterStartupComplete_GCInfo> = {
  encode(message: CGCToGCMsgMasterStartupComplete_GCInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dirIndex !== -1) {
      writer.uint32(8).int32(message.dirIndex);
    }
    if (message.machineName !== "") {
      writer.uint32(18).string(message.machineName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CGCToGCMsgMasterStartupComplete_GCInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCToGCMsgMasterStartupComplete_GCInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.dirIndex = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.machineName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCToGCMsgMasterStartupComplete_GCInfo {
    return {
      dirIndex: isSet(object.dirIndex) ? globalThis.Number(object.dirIndex) : -1,
      machineName: isSet(object.machineName) ? globalThis.String(object.machineName) : "",
    };
  },

  toJSON(message: CGCToGCMsgMasterStartupComplete_GCInfo): unknown {
    const obj: any = {};
    if (message.dirIndex !== -1) {
      obj.dirIndex = Math.round(message.dirIndex);
    }
    if (message.machineName !== "") {
      obj.machineName = message.machineName;
    }
    return obj;
  },

  create(base?: DeepPartial<CGCToGCMsgMasterStartupComplete_GCInfo>): CGCToGCMsgMasterStartupComplete_GCInfo {
    return CGCToGCMsgMasterStartupComplete_GCInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCToGCMsgMasterStartupComplete_GCInfo>): CGCToGCMsgMasterStartupComplete_GCInfo {
    const message = createBaseCGCToGCMsgMasterStartupComplete_GCInfo();
    message.dirIndex = object.dirIndex ?? -1;
    message.machineName = object.machineName ?? "";
    return message;
  },
};

function createBaseCGCToGCMsgRouted(): CGCToGCMsgRouted {
  return { msgType: 0, senderId: "0", netMessage: Buffer.alloc(0) };
}

export const CGCToGCMsgRouted: MessageFns<CGCToGCMsgRouted> = {
  encode(message: CGCToGCMsgRouted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msgType !== 0) {
      writer.uint32(8).uint32(message.msgType);
    }
    if (message.senderId !== "0") {
      writer.uint32(17).fixed64(message.senderId);
    }
    if (message.netMessage.length !== 0) {
      writer.uint32(26).bytes(message.netMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CGCToGCMsgRouted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCToGCMsgRouted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.msgType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.senderId = reader.fixed64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.netMessage = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCToGCMsgRouted {
    return {
      msgType: isSet(object.msgType) ? globalThis.Number(object.msgType) : 0,
      senderId: isSet(object.senderId) ? globalThis.String(object.senderId) : "0",
      netMessage: isSet(object.netMessage) ? Buffer.from(bytesFromBase64(object.netMessage)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CGCToGCMsgRouted): unknown {
    const obj: any = {};
    if (message.msgType !== 0) {
      obj.msgType = Math.round(message.msgType);
    }
    if (message.senderId !== "0") {
      obj.senderId = message.senderId;
    }
    if (message.netMessage.length !== 0) {
      obj.netMessage = base64FromBytes(message.netMessage);
    }
    return obj;
  },

  create(base?: DeepPartial<CGCToGCMsgRouted>): CGCToGCMsgRouted {
    return CGCToGCMsgRouted.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCToGCMsgRouted>): CGCToGCMsgRouted {
    const message = createBaseCGCToGCMsgRouted();
    message.msgType = object.msgType ?? 0;
    message.senderId = object.senderId ?? "0";
    message.netMessage = object.netMessage ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCGCToGCMsgRoutedReply(): CGCToGCMsgRoutedReply {
  return { msgType: 0, netMessage: Buffer.alloc(0) };
}

export const CGCToGCMsgRoutedReply: MessageFns<CGCToGCMsgRoutedReply> = {
  encode(message: CGCToGCMsgRoutedReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msgType !== 0) {
      writer.uint32(8).uint32(message.msgType);
    }
    if (message.netMessage.length !== 0) {
      writer.uint32(18).bytes(message.netMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CGCToGCMsgRoutedReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCToGCMsgRoutedReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.msgType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.netMessage = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCToGCMsgRoutedReply {
    return {
      msgType: isSet(object.msgType) ? globalThis.Number(object.msgType) : 0,
      netMessage: isSet(object.netMessage) ? Buffer.from(bytesFromBase64(object.netMessage)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CGCToGCMsgRoutedReply): unknown {
    const obj: any = {};
    if (message.msgType !== 0) {
      obj.msgType = Math.round(message.msgType);
    }
    if (message.netMessage.length !== 0) {
      obj.netMessage = base64FromBytes(message.netMessage);
    }
    return obj;
  },

  create(base?: DeepPartial<CGCToGCMsgRoutedReply>): CGCToGCMsgRoutedReply {
    return CGCToGCMsgRoutedReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCToGCMsgRoutedReply>): CGCToGCMsgRoutedReply {
    const message = createBaseCGCToGCMsgRoutedReply();
    message.msgType = object.msgType ?? 0;
    message.netMessage = object.netMessage ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCMsgGCUpdateSubGCSessionInfo(): CMsgGCUpdateSubGCSessionInfo {
  return { updates: [] };
}

export const CMsgGCUpdateSubGCSessionInfo: MessageFns<CMsgGCUpdateSubGCSessionInfo> = {
  encode(message: CMsgGCUpdateSubGCSessionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.updates) {
      CMsgGCUpdateSubGCSessionInfo_CMsgUpdate.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCUpdateSubGCSessionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCUpdateSubGCSessionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.updates.push(CMsgGCUpdateSubGCSessionInfo_CMsgUpdate.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCUpdateSubGCSessionInfo {
    return {
      updates: globalThis.Array.isArray(object?.updates)
        ? object.updates.map((e: any) => CMsgGCUpdateSubGCSessionInfo_CMsgUpdate.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCUpdateSubGCSessionInfo): unknown {
    const obj: any = {};
    if (message.updates?.length) {
      obj.updates = message.updates.map((e) => CMsgGCUpdateSubGCSessionInfo_CMsgUpdate.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCUpdateSubGCSessionInfo>): CMsgGCUpdateSubGCSessionInfo {
    return CMsgGCUpdateSubGCSessionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCUpdateSubGCSessionInfo>): CMsgGCUpdateSubGCSessionInfo {
    const message = createBaseCMsgGCUpdateSubGCSessionInfo();
    message.updates = object.updates?.map((e) => CMsgGCUpdateSubGCSessionInfo_CMsgUpdate.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGCUpdateSubGCSessionInfo_CMsgUpdate(): CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
  return { steamid: "0", ip: 0, trusted: false };
}

export const CMsgGCUpdateSubGCSessionInfo_CMsgUpdate: MessageFns<CMsgGCUpdateSubGCSessionInfo_CMsgUpdate> = {
  encode(message: CMsgGCUpdateSubGCSessionInfo_CMsgUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.steamid !== "0") {
      writer.uint32(9).fixed64(message.steamid);
    }
    if (message.ip !== 0) {
      writer.uint32(21).fixed32(message.ip);
    }
    if (message.trusted !== false) {
      writer.uint32(24).bool(message.trusted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCUpdateSubGCSessionInfo_CMsgUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.steamid = reader.fixed64().toString();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.ip = reader.fixed32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.trusted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
    return {
      steamid: isSet(object.steamid) ? globalThis.String(object.steamid) : "0",
      ip: isSet(object.ip) ? globalThis.Number(object.ip) : 0,
      trusted: isSet(object.trusted) ? globalThis.Boolean(object.trusted) : false,
    };
  },

  toJSON(message: CMsgGCUpdateSubGCSessionInfo_CMsgUpdate): unknown {
    const obj: any = {};
    if (message.steamid !== "0") {
      obj.steamid = message.steamid;
    }
    if (message.ip !== 0) {
      obj.ip = Math.round(message.ip);
    }
    if (message.trusted !== false) {
      obj.trusted = message.trusted;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCUpdateSubGCSessionInfo_CMsgUpdate>): CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
    return CMsgGCUpdateSubGCSessionInfo_CMsgUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCUpdateSubGCSessionInfo_CMsgUpdate>): CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
    const message = createBaseCMsgGCUpdateSubGCSessionInfo_CMsgUpdate();
    message.steamid = object.steamid ?? "0";
    message.ip = object.ip ?? 0;
    message.trusted = object.trusted ?? false;
    return message;
  },
};

function createBaseCMsgGCRequestSubGCSessionInfo(): CMsgGCRequestSubGCSessionInfo {
  return { steamid: "0" };
}

export const CMsgGCRequestSubGCSessionInfo: MessageFns<CMsgGCRequestSubGCSessionInfo> = {
  encode(message: CMsgGCRequestSubGCSessionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.steamid !== "0") {
      writer.uint32(9).fixed64(message.steamid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCRequestSubGCSessionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCRequestSubGCSessionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.steamid = reader.fixed64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCRequestSubGCSessionInfo {
    return { steamid: isSet(object.steamid) ? globalThis.String(object.steamid) : "0" };
  },

  toJSON(message: CMsgGCRequestSubGCSessionInfo): unknown {
    const obj: any = {};
    if (message.steamid !== "0") {
      obj.steamid = message.steamid;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCRequestSubGCSessionInfo>): CMsgGCRequestSubGCSessionInfo {
    return CMsgGCRequestSubGCSessionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCRequestSubGCSessionInfo>): CMsgGCRequestSubGCSessionInfo {
    const message = createBaseCMsgGCRequestSubGCSessionInfo();
    message.steamid = object.steamid ?? "0";
    return message;
  },
};

function createBaseCMsgGCRequestSubGCSessionInfoResponse(): CMsgGCRequestSubGCSessionInfoResponse {
  return { ip: 0, trusted: false, port: 0, success: false };
}

export const CMsgGCRequestSubGCSessionInfoResponse: MessageFns<CMsgGCRequestSubGCSessionInfoResponse> = {
  encode(message: CMsgGCRequestSubGCSessionInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ip !== 0) {
      writer.uint32(13).fixed32(message.ip);
    }
    if (message.trusted !== false) {
      writer.uint32(16).bool(message.trusted);
    }
    if (message.port !== 0) {
      writer.uint32(24).uint32(message.port);
    }
    if (message.success !== false) {
      writer.uint32(32).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCRequestSubGCSessionInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCRequestSubGCSessionInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.ip = reader.fixed32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.trusted = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.port = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCRequestSubGCSessionInfoResponse {
    return {
      ip: isSet(object.ip) ? globalThis.Number(object.ip) : 0,
      trusted: isSet(object.trusted) ? globalThis.Boolean(object.trusted) : false,
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
    };
  },

  toJSON(message: CMsgGCRequestSubGCSessionInfoResponse): unknown {
    const obj: any = {};
    if (message.ip !== 0) {
      obj.ip = Math.round(message.ip);
    }
    if (message.trusted !== false) {
      obj.trusted = message.trusted;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCRequestSubGCSessionInfoResponse>): CMsgGCRequestSubGCSessionInfoResponse {
    return CMsgGCRequestSubGCSessionInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCRequestSubGCSessionInfoResponse>): CMsgGCRequestSubGCSessionInfoResponse {
    const message = createBaseCMsgGCRequestSubGCSessionInfoResponse();
    message.ip = object.ip ?? 0;
    message.trusted = object.trusted ?? false;
    message.port = object.port ?? 0;
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseCMsgSOCacheHaveVersion(): CMsgSOCacheHaveVersion {
  return { soid: undefined, version: "0", serviceId: 0, cachedFileVersion: 0 };
}

export const CMsgSOCacheHaveVersion: MessageFns<CMsgSOCacheHaveVersion> = {
  encode(message: CMsgSOCacheHaveVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.soid !== undefined) {
      CMsgSOIDOwner.encode(message.soid, writer.uint32(10).fork()).join();
    }
    if (message.version !== "0") {
      writer.uint32(17).fixed64(message.version);
    }
    if (message.serviceId !== 0) {
      writer.uint32(24).uint32(message.serviceId);
    }
    if (message.cachedFileVersion !== 0) {
      writer.uint32(32).uint32(message.cachedFileVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSOCacheHaveVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSOCacheHaveVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.soid = CMsgSOIDOwner.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.version = reader.fixed64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.serviceId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.cachedFileVersion = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSOCacheHaveVersion {
    return {
      soid: isSet(object.soid) ? CMsgSOIDOwner.fromJSON(object.soid) : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : "0",
      serviceId: isSet(object.serviceId) ? globalThis.Number(object.serviceId) : 0,
      cachedFileVersion: isSet(object.cachedFileVersion) ? globalThis.Number(object.cachedFileVersion) : 0,
    };
  },

  toJSON(message: CMsgSOCacheHaveVersion): unknown {
    const obj: any = {};
    if (message.soid !== undefined) {
      obj.soid = CMsgSOIDOwner.toJSON(message.soid);
    }
    if (message.version !== "0") {
      obj.version = message.version;
    }
    if (message.serviceId !== 0) {
      obj.serviceId = Math.round(message.serviceId);
    }
    if (message.cachedFileVersion !== 0) {
      obj.cachedFileVersion = Math.round(message.cachedFileVersion);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSOCacheHaveVersion>): CMsgSOCacheHaveVersion {
    return CMsgSOCacheHaveVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSOCacheHaveVersion>): CMsgSOCacheHaveVersion {
    const message = createBaseCMsgSOCacheHaveVersion();
    message.soid = (object.soid !== undefined && object.soid !== null)
      ? CMsgSOIDOwner.fromPartial(object.soid)
      : undefined;
    message.version = object.version ?? "0";
    message.serviceId = object.serviceId ?? 0;
    message.cachedFileVersion = object.cachedFileVersion ?? 0;
    return message;
  },
};

function createBaseCMsgClientHello(): CMsgClientHello {
  return {
    version: 0,
    socacheHaveVersions: [],
    clientSessionNeed: 0,
    clientLauncher: 0,
    secretKey: "",
    clientLanguage: 0,
    engine: 0,
    steamdatagramLogin: Buffer.alloc(0),
    platformId: 0,
    gameMsg: Buffer.alloc(0),
    osType: 0,
    renderSystem: 0,
    renderSystemReq: 0,
    screenWidth: 0,
    screenHeight: 0,
    screenRefresh: 0,
    renderWidth: 0,
    renderHeight: 0,
    swapWidth: 0,
    swapHeight: 0,
    isSteamChina: false,
    isSteamChinaClient: false,
    platformName: "",
  };
}

export const CMsgClientHello: MessageFns<CMsgClientHello> = {
  encode(message: CMsgClientHello, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    for (const v of message.socacheHaveVersions) {
      CMsgSOCacheHaveVersion.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.clientSessionNeed !== 0) {
      writer.uint32(24).uint32(message.clientSessionNeed);
    }
    if (message.clientLauncher !== 0) {
      writer.uint32(32).int32(message.clientLauncher);
    }
    if (message.secretKey !== "") {
      writer.uint32(42).string(message.secretKey);
    }
    if (message.clientLanguage !== 0) {
      writer.uint32(48).uint32(message.clientLanguage);
    }
    if (message.engine !== 0) {
      writer.uint32(56).int32(message.engine);
    }
    if (message.steamdatagramLogin.length !== 0) {
      writer.uint32(66).bytes(message.steamdatagramLogin);
    }
    if (message.platformId !== 0) {
      writer.uint32(72).uint32(message.platformId);
    }
    if (message.gameMsg.length !== 0) {
      writer.uint32(82).bytes(message.gameMsg);
    }
    if (message.osType !== 0) {
      writer.uint32(88).int32(message.osType);
    }
    if (message.renderSystem !== 0) {
      writer.uint32(96).uint32(message.renderSystem);
    }
    if (message.renderSystemReq !== 0) {
      writer.uint32(104).uint32(message.renderSystemReq);
    }
    if (message.screenWidth !== 0) {
      writer.uint32(112).uint32(message.screenWidth);
    }
    if (message.screenHeight !== 0) {
      writer.uint32(120).uint32(message.screenHeight);
    }
    if (message.screenRefresh !== 0) {
      writer.uint32(128).uint32(message.screenRefresh);
    }
    if (message.renderWidth !== 0) {
      writer.uint32(136).uint32(message.renderWidth);
    }
    if (message.renderHeight !== 0) {
      writer.uint32(144).uint32(message.renderHeight);
    }
    if (message.swapWidth !== 0) {
      writer.uint32(152).uint32(message.swapWidth);
    }
    if (message.swapHeight !== 0) {
      writer.uint32(160).uint32(message.swapHeight);
    }
    if (message.isSteamChina !== false) {
      writer.uint32(176).bool(message.isSteamChina);
    }
    if (message.isSteamChinaClient !== false) {
      writer.uint32(192).bool(message.isSteamChinaClient);
    }
    if (message.platformName !== "") {
      writer.uint32(186).string(message.platformName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientHello {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientHello();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.socacheHaveVersions.push(CMsgSOCacheHaveVersion.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.clientSessionNeed = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.clientLauncher = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.secretKey = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.clientLanguage = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.engine = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.steamdatagramLogin = Buffer.from(reader.bytes());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.platformId = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.gameMsg = Buffer.from(reader.bytes());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.osType = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.renderSystem = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.renderSystemReq = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.screenWidth = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.screenHeight = reader.uint32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.screenRefresh = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.renderWidth = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.renderHeight = reader.uint32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.swapWidth = reader.uint32();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.swapHeight = reader.uint32();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.isSteamChina = reader.bool();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.isSteamChinaClient = reader.bool();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.platformName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientHello {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      socacheHaveVersions: globalThis.Array.isArray(object?.socacheHaveVersions)
        ? object.socacheHaveVersions.map((e: any) => CMsgSOCacheHaveVersion.fromJSON(e))
        : [],
      clientSessionNeed: isSet(object.clientSessionNeed) ? globalThis.Number(object.clientSessionNeed) : 0,
      clientLauncher: isSet(object.clientLauncher) ? partnerAccountTypeFromJSON(object.clientLauncher) : 0,
      secretKey: isSet(object.secretKey) ? globalThis.String(object.secretKey) : "",
      clientLanguage: isSet(object.clientLanguage) ? globalThis.Number(object.clientLanguage) : 0,
      engine: isSet(object.engine) ? eSourceEngineFromJSON(object.engine) : 0,
      steamdatagramLogin: isSet(object.steamdatagramLogin)
        ? Buffer.from(bytesFromBase64(object.steamdatagramLogin))
        : Buffer.alloc(0),
      platformId: isSet(object.platformId) ? globalThis.Number(object.platformId) : 0,
      gameMsg: isSet(object.gameMsg) ? Buffer.from(bytesFromBase64(object.gameMsg)) : Buffer.alloc(0),
      osType: isSet(object.osType) ? globalThis.Number(object.osType) : 0,
      renderSystem: isSet(object.renderSystem) ? globalThis.Number(object.renderSystem) : 0,
      renderSystemReq: isSet(object.renderSystemReq) ? globalThis.Number(object.renderSystemReq) : 0,
      screenWidth: isSet(object.screenWidth) ? globalThis.Number(object.screenWidth) : 0,
      screenHeight: isSet(object.screenHeight) ? globalThis.Number(object.screenHeight) : 0,
      screenRefresh: isSet(object.screenRefresh) ? globalThis.Number(object.screenRefresh) : 0,
      renderWidth: isSet(object.renderWidth) ? globalThis.Number(object.renderWidth) : 0,
      renderHeight: isSet(object.renderHeight) ? globalThis.Number(object.renderHeight) : 0,
      swapWidth: isSet(object.swapWidth) ? globalThis.Number(object.swapWidth) : 0,
      swapHeight: isSet(object.swapHeight) ? globalThis.Number(object.swapHeight) : 0,
      isSteamChina: isSet(object.isSteamChina) ? globalThis.Boolean(object.isSteamChina) : false,
      isSteamChinaClient: isSet(object.isSteamChinaClient) ? globalThis.Boolean(object.isSteamChinaClient) : false,
      platformName: isSet(object.platformName) ? globalThis.String(object.platformName) : "",
    };
  },

  toJSON(message: CMsgClientHello): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.socacheHaveVersions?.length) {
      obj.socacheHaveVersions = message.socacheHaveVersions.map((e) => CMsgSOCacheHaveVersion.toJSON(e));
    }
    if (message.clientSessionNeed !== 0) {
      obj.clientSessionNeed = Math.round(message.clientSessionNeed);
    }
    if (message.clientLauncher !== 0) {
      obj.clientLauncher = partnerAccountTypeToJSON(message.clientLauncher);
    }
    if (message.secretKey !== "") {
      obj.secretKey = message.secretKey;
    }
    if (message.clientLanguage !== 0) {
      obj.clientLanguage = Math.round(message.clientLanguage);
    }
    if (message.engine !== 0) {
      obj.engine = eSourceEngineToJSON(message.engine);
    }
    if (message.steamdatagramLogin.length !== 0) {
      obj.steamdatagramLogin = base64FromBytes(message.steamdatagramLogin);
    }
    if (message.platformId !== 0) {
      obj.platformId = Math.round(message.platformId);
    }
    if (message.gameMsg.length !== 0) {
      obj.gameMsg = base64FromBytes(message.gameMsg);
    }
    if (message.osType !== 0) {
      obj.osType = Math.round(message.osType);
    }
    if (message.renderSystem !== 0) {
      obj.renderSystem = Math.round(message.renderSystem);
    }
    if (message.renderSystemReq !== 0) {
      obj.renderSystemReq = Math.round(message.renderSystemReq);
    }
    if (message.screenWidth !== 0) {
      obj.screenWidth = Math.round(message.screenWidth);
    }
    if (message.screenHeight !== 0) {
      obj.screenHeight = Math.round(message.screenHeight);
    }
    if (message.screenRefresh !== 0) {
      obj.screenRefresh = Math.round(message.screenRefresh);
    }
    if (message.renderWidth !== 0) {
      obj.renderWidth = Math.round(message.renderWidth);
    }
    if (message.renderHeight !== 0) {
      obj.renderHeight = Math.round(message.renderHeight);
    }
    if (message.swapWidth !== 0) {
      obj.swapWidth = Math.round(message.swapWidth);
    }
    if (message.swapHeight !== 0) {
      obj.swapHeight = Math.round(message.swapHeight);
    }
    if (message.isSteamChina !== false) {
      obj.isSteamChina = message.isSteamChina;
    }
    if (message.isSteamChinaClient !== false) {
      obj.isSteamChinaClient = message.isSteamChinaClient;
    }
    if (message.platformName !== "") {
      obj.platformName = message.platformName;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientHello>): CMsgClientHello {
    return CMsgClientHello.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientHello>): CMsgClientHello {
    const message = createBaseCMsgClientHello();
    message.version = object.version ?? 0;
    message.socacheHaveVersions = object.socacheHaveVersions?.map((e) => CMsgSOCacheHaveVersion.fromPartial(e)) || [];
    message.clientSessionNeed = object.clientSessionNeed ?? 0;
    message.clientLauncher = object.clientLauncher ?? 0;
    message.secretKey = object.secretKey ?? "";
    message.clientLanguage = object.clientLanguage ?? 0;
    message.engine = object.engine ?? 0;
    message.steamdatagramLogin = object.steamdatagramLogin ?? Buffer.alloc(0);
    message.platformId = object.platformId ?? 0;
    message.gameMsg = object.gameMsg ?? Buffer.alloc(0);
    message.osType = object.osType ?? 0;
    message.renderSystem = object.renderSystem ?? 0;
    message.renderSystemReq = object.renderSystemReq ?? 0;
    message.screenWidth = object.screenWidth ?? 0;
    message.screenHeight = object.screenHeight ?? 0;
    message.screenRefresh = object.screenRefresh ?? 0;
    message.renderWidth = object.renderWidth ?? 0;
    message.renderHeight = object.renderHeight ?? 0;
    message.swapWidth = object.swapWidth ?? 0;
    message.swapHeight = object.swapHeight ?? 0;
    message.isSteamChina = object.isSteamChina ?? false;
    message.isSteamChinaClient = object.isSteamChinaClient ?? false;
    message.platformName = object.platformName ?? "";
    return message;
  },
};

function createBaseCMsgClientWelcome(): CMsgClientWelcome {
  return {
    version: 0,
    gameData: Buffer.alloc(0),
    outofdateSubscribedCaches: [],
    uptodateSubscribedCaches: [],
    location: undefined,
    gcSocacheFileVersion: 0,
    txnCountryCode: "",
    gameData2: Buffer.alloc(0),
    rtime32GcWelcomeTimestamp: 0,
    currency: 0,
    balance: 0,
    balanceUrl: "",
    hasAcceptedChinaSsa: false,
    isBannedSteamChina: false,
    additionalWelcomeMsgs: undefined,
    steamLearnServerInfo: undefined,
  };
}

export const CMsgClientWelcome: MessageFns<CMsgClientWelcome> = {
  encode(message: CMsgClientWelcome, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    if (message.gameData.length !== 0) {
      writer.uint32(18).bytes(message.gameData);
    }
    for (const v of message.outofdateSubscribedCaches) {
      CMsgSOCacheSubscribed.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.uptodateSubscribedCaches) {
      CMsgSOCacheSubscriptionCheck.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.location !== undefined) {
      CMsgClientWelcome_Location.encode(message.location, writer.uint32(42).fork()).join();
    }
    if (message.gcSocacheFileVersion !== 0) {
      writer.uint32(72).uint32(message.gcSocacheFileVersion);
    }
    if (message.txnCountryCode !== "") {
      writer.uint32(82).string(message.txnCountryCode);
    }
    if (message.gameData2.length !== 0) {
      writer.uint32(90).bytes(message.gameData2);
    }
    if (message.rtime32GcWelcomeTimestamp !== 0) {
      writer.uint32(96).uint32(message.rtime32GcWelcomeTimestamp);
    }
    if (message.currency !== 0) {
      writer.uint32(104).uint32(message.currency);
    }
    if (message.balance !== 0) {
      writer.uint32(112).uint32(message.balance);
    }
    if (message.balanceUrl !== "") {
      writer.uint32(122).string(message.balanceUrl);
    }
    if (message.hasAcceptedChinaSsa !== false) {
      writer.uint32(128).bool(message.hasAcceptedChinaSsa);
    }
    if (message.isBannedSteamChina !== false) {
      writer.uint32(136).bool(message.isBannedSteamChina);
    }
    if (message.additionalWelcomeMsgs !== undefined) {
      CExtraMsgBlock.encode(message.additionalWelcomeMsgs, writer.uint32(146).fork()).join();
    }
    if (message.steamLearnServerInfo !== undefined) {
      CMsgSteamLearnServerInfo.encode(message.steamLearnServerInfo, writer.uint32(162).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientWelcome {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientWelcome();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gameData = Buffer.from(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.outofdateSubscribedCaches.push(CMsgSOCacheSubscribed.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.uptodateSubscribedCaches.push(CMsgSOCacheSubscriptionCheck.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.location = CMsgClientWelcome_Location.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.gcSocacheFileVersion = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.txnCountryCode = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.gameData2 = Buffer.from(reader.bytes());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.rtime32GcWelcomeTimestamp = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.currency = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.balance = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.balanceUrl = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.hasAcceptedChinaSsa = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.isBannedSteamChina = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.additionalWelcomeMsgs = CExtraMsgBlock.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.steamLearnServerInfo = CMsgSteamLearnServerInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientWelcome {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      gameData: isSet(object.gameData) ? Buffer.from(bytesFromBase64(object.gameData)) : Buffer.alloc(0),
      outofdateSubscribedCaches: globalThis.Array.isArray(object?.outofdateSubscribedCaches)
        ? object.outofdateSubscribedCaches.map((e: any) => CMsgSOCacheSubscribed.fromJSON(e))
        : [],
      uptodateSubscribedCaches: globalThis.Array.isArray(object?.uptodateSubscribedCaches)
        ? object.uptodateSubscribedCaches.map((e: any) => CMsgSOCacheSubscriptionCheck.fromJSON(e))
        : [],
      location: isSet(object.location) ? CMsgClientWelcome_Location.fromJSON(object.location) : undefined,
      gcSocacheFileVersion: isSet(object.gcSocacheFileVersion) ? globalThis.Number(object.gcSocacheFileVersion) : 0,
      txnCountryCode: isSet(object.txnCountryCode) ? globalThis.String(object.txnCountryCode) : "",
      gameData2: isSet(object.gameData2) ? Buffer.from(bytesFromBase64(object.gameData2)) : Buffer.alloc(0),
      rtime32GcWelcomeTimestamp: isSet(object.rtime32GcWelcomeTimestamp)
        ? globalThis.Number(object.rtime32GcWelcomeTimestamp)
        : 0,
      currency: isSet(object.currency) ? globalThis.Number(object.currency) : 0,
      balance: isSet(object.balance) ? globalThis.Number(object.balance) : 0,
      balanceUrl: isSet(object.balanceUrl) ? globalThis.String(object.balanceUrl) : "",
      hasAcceptedChinaSsa: isSet(object.hasAcceptedChinaSsa) ? globalThis.Boolean(object.hasAcceptedChinaSsa) : false,
      isBannedSteamChina: isSet(object.isBannedSteamChina) ? globalThis.Boolean(object.isBannedSteamChina) : false,
      additionalWelcomeMsgs: isSet(object.additionalWelcomeMsgs)
        ? CExtraMsgBlock.fromJSON(object.additionalWelcomeMsgs)
        : undefined,
      steamLearnServerInfo: isSet(object.steamLearnServerInfo)
        ? CMsgSteamLearnServerInfo.fromJSON(object.steamLearnServerInfo)
        : undefined,
    };
  },

  toJSON(message: CMsgClientWelcome): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.gameData.length !== 0) {
      obj.gameData = base64FromBytes(message.gameData);
    }
    if (message.outofdateSubscribedCaches?.length) {
      obj.outofdateSubscribedCaches = message.outofdateSubscribedCaches.map((e) => CMsgSOCacheSubscribed.toJSON(e));
    }
    if (message.uptodateSubscribedCaches?.length) {
      obj.uptodateSubscribedCaches = message.uptodateSubscribedCaches.map((e) =>
        CMsgSOCacheSubscriptionCheck.toJSON(e)
      );
    }
    if (message.location !== undefined) {
      obj.location = CMsgClientWelcome_Location.toJSON(message.location);
    }
    if (message.gcSocacheFileVersion !== 0) {
      obj.gcSocacheFileVersion = Math.round(message.gcSocacheFileVersion);
    }
    if (message.txnCountryCode !== "") {
      obj.txnCountryCode = message.txnCountryCode;
    }
    if (message.gameData2.length !== 0) {
      obj.gameData2 = base64FromBytes(message.gameData2);
    }
    if (message.rtime32GcWelcomeTimestamp !== 0) {
      obj.rtime32GcWelcomeTimestamp = Math.round(message.rtime32GcWelcomeTimestamp);
    }
    if (message.currency !== 0) {
      obj.currency = Math.round(message.currency);
    }
    if (message.balance !== 0) {
      obj.balance = Math.round(message.balance);
    }
    if (message.balanceUrl !== "") {
      obj.balanceUrl = message.balanceUrl;
    }
    if (message.hasAcceptedChinaSsa !== false) {
      obj.hasAcceptedChinaSsa = message.hasAcceptedChinaSsa;
    }
    if (message.isBannedSteamChina !== false) {
      obj.isBannedSteamChina = message.isBannedSteamChina;
    }
    if (message.additionalWelcomeMsgs !== undefined) {
      obj.additionalWelcomeMsgs = CExtraMsgBlock.toJSON(message.additionalWelcomeMsgs);
    }
    if (message.steamLearnServerInfo !== undefined) {
      obj.steamLearnServerInfo = CMsgSteamLearnServerInfo.toJSON(message.steamLearnServerInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientWelcome>): CMsgClientWelcome {
    return CMsgClientWelcome.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientWelcome>): CMsgClientWelcome {
    const message = createBaseCMsgClientWelcome();
    message.version = object.version ?? 0;
    message.gameData = object.gameData ?? Buffer.alloc(0);
    message.outofdateSubscribedCaches =
      object.outofdateSubscribedCaches?.map((e) => CMsgSOCacheSubscribed.fromPartial(e)) || [];
    message.uptodateSubscribedCaches =
      object.uptodateSubscribedCaches?.map((e) => CMsgSOCacheSubscriptionCheck.fromPartial(e)) || [];
    message.location = (object.location !== undefined && object.location !== null)
      ? CMsgClientWelcome_Location.fromPartial(object.location)
      : undefined;
    message.gcSocacheFileVersion = object.gcSocacheFileVersion ?? 0;
    message.txnCountryCode = object.txnCountryCode ?? "";
    message.gameData2 = object.gameData2 ?? Buffer.alloc(0);
    message.rtime32GcWelcomeTimestamp = object.rtime32GcWelcomeTimestamp ?? 0;
    message.currency = object.currency ?? 0;
    message.balance = object.balance ?? 0;
    message.balanceUrl = object.balanceUrl ?? "";
    message.hasAcceptedChinaSsa = object.hasAcceptedChinaSsa ?? false;
    message.isBannedSteamChina = object.isBannedSteamChina ?? false;
    message.additionalWelcomeMsgs =
      (object.additionalWelcomeMsgs !== undefined && object.additionalWelcomeMsgs !== null)
        ? CExtraMsgBlock.fromPartial(object.additionalWelcomeMsgs)
        : undefined;
    message.steamLearnServerInfo = (object.steamLearnServerInfo !== undefined && object.steamLearnServerInfo !== null)
      ? CMsgSteamLearnServerInfo.fromPartial(object.steamLearnServerInfo)
      : undefined;
    return message;
  },
};

function createBaseCMsgClientWelcome_Location(): CMsgClientWelcome_Location {
  return { latitude: 0, longitude: 0, country: "" };
}

export const CMsgClientWelcome_Location: MessageFns<CMsgClientWelcome_Location> = {
  encode(message: CMsgClientWelcome_Location, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.latitude !== 0) {
      writer.uint32(13).float(message.latitude);
    }
    if (message.longitude !== 0) {
      writer.uint32(21).float(message.longitude);
    }
    if (message.country !== "") {
      writer.uint32(26).string(message.country);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientWelcome_Location {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientWelcome_Location();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.latitude = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.longitude = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.country = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientWelcome_Location {
    return {
      latitude: isSet(object.latitude) ? globalThis.Number(object.latitude) : 0,
      longitude: isSet(object.longitude) ? globalThis.Number(object.longitude) : 0,
      country: isSet(object.country) ? globalThis.String(object.country) : "",
    };
  },

  toJSON(message: CMsgClientWelcome_Location): unknown {
    const obj: any = {};
    if (message.latitude !== 0) {
      obj.latitude = message.latitude;
    }
    if (message.longitude !== 0) {
      obj.longitude = message.longitude;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientWelcome_Location>): CMsgClientWelcome_Location {
    return CMsgClientWelcome_Location.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientWelcome_Location>): CMsgClientWelcome_Location {
    const message = createBaseCMsgClientWelcome_Location();
    message.latitude = object.latitude ?? 0;
    message.longitude = object.longitude ?? 0;
    message.country = object.country ?? "";
    return message;
  },
};

function createBaseCMsgConnectionStatus(): CMsgConnectionStatus {
  return {
    status: 0,
    clientSessionNeed: 0,
    queuePosition: 0,
    queueSize: 0,
    waitSeconds: 0,
    estimatedWaitSecondsRemaining: 0,
  };
}

export const CMsgConnectionStatus: MessageFns<CMsgConnectionStatus> = {
  encode(message: CMsgConnectionStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.clientSessionNeed !== 0) {
      writer.uint32(16).uint32(message.clientSessionNeed);
    }
    if (message.queuePosition !== 0) {
      writer.uint32(24).int32(message.queuePosition);
    }
    if (message.queueSize !== 0) {
      writer.uint32(32).int32(message.queueSize);
    }
    if (message.waitSeconds !== 0) {
      writer.uint32(40).int32(message.waitSeconds);
    }
    if (message.estimatedWaitSecondsRemaining !== 0) {
      writer.uint32(48).int32(message.estimatedWaitSecondsRemaining);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgConnectionStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgConnectionStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.clientSessionNeed = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.queuePosition = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.queueSize = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.waitSeconds = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.estimatedWaitSecondsRemaining = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgConnectionStatus {
    return {
      status: isSet(object.status) ? gCConnectionStatusFromJSON(object.status) : 0,
      clientSessionNeed: isSet(object.clientSessionNeed) ? globalThis.Number(object.clientSessionNeed) : 0,
      queuePosition: isSet(object.queuePosition) ? globalThis.Number(object.queuePosition) : 0,
      queueSize: isSet(object.queueSize) ? globalThis.Number(object.queueSize) : 0,
      waitSeconds: isSet(object.waitSeconds) ? globalThis.Number(object.waitSeconds) : 0,
      estimatedWaitSecondsRemaining: isSet(object.estimatedWaitSecondsRemaining)
        ? globalThis.Number(object.estimatedWaitSecondsRemaining)
        : 0,
    };
  },

  toJSON(message: CMsgConnectionStatus): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = gCConnectionStatusToJSON(message.status);
    }
    if (message.clientSessionNeed !== 0) {
      obj.clientSessionNeed = Math.round(message.clientSessionNeed);
    }
    if (message.queuePosition !== 0) {
      obj.queuePosition = Math.round(message.queuePosition);
    }
    if (message.queueSize !== 0) {
      obj.queueSize = Math.round(message.queueSize);
    }
    if (message.waitSeconds !== 0) {
      obj.waitSeconds = Math.round(message.waitSeconds);
    }
    if (message.estimatedWaitSecondsRemaining !== 0) {
      obj.estimatedWaitSecondsRemaining = Math.round(message.estimatedWaitSecondsRemaining);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgConnectionStatus>): CMsgConnectionStatus {
    return CMsgConnectionStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgConnectionStatus>): CMsgConnectionStatus {
    const message = createBaseCMsgConnectionStatus();
    message.status = object.status ?? 0;
    message.clientSessionNeed = object.clientSessionNeed ?? 0;
    message.queuePosition = object.queuePosition ?? 0;
    message.queueSize = object.queueSize ?? 0;
    message.waitSeconds = object.waitSeconds ?? 0;
    message.estimatedWaitSecondsRemaining = object.estimatedWaitSecondsRemaining ?? 0;
    return message;
  },
};

function createBaseCMsgGCToGCSOCacheSubscribe(): CMsgGCToGCSOCacheSubscribe {
  return { subscriber: "0", subscribeToId: "0", syncVersion: "0", haveVersions: [], subscribeToType: 0 };
}

export const CMsgGCToGCSOCacheSubscribe: MessageFns<CMsgGCToGCSOCacheSubscribe> = {
  encode(message: CMsgGCToGCSOCacheSubscribe, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscriber !== "0") {
      writer.uint32(9).fixed64(message.subscriber);
    }
    if (message.subscribeToId !== "0") {
      writer.uint32(17).fixed64(message.subscribeToId);
    }
    if (message.syncVersion !== "0") {
      writer.uint32(25).fixed64(message.syncVersion);
    }
    for (const v of message.haveVersions) {
      CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.subscribeToType !== 0) {
      writer.uint32(40).uint32(message.subscribeToType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCSOCacheSubscribe {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCSOCacheSubscribe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.subscriber = reader.fixed64().toString();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.subscribeToId = reader.fixed64().toString();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.syncVersion = reader.fixed64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.haveVersions.push(CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.subscribeToType = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCSOCacheSubscribe {
    return {
      subscriber: isSet(object.subscriber) ? globalThis.String(object.subscriber) : "0",
      subscribeToId: isSet(object.subscribeToId) ? globalThis.String(object.subscribeToId) : "0",
      syncVersion: isSet(object.syncVersion) ? globalThis.String(object.syncVersion) : "0",
      haveVersions: globalThis.Array.isArray(object?.haveVersions)
        ? object.haveVersions.map((e: any) => CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions.fromJSON(e))
        : [],
      subscribeToType: isSet(object.subscribeToType) ? globalThis.Number(object.subscribeToType) : 0,
    };
  },

  toJSON(message: CMsgGCToGCSOCacheSubscribe): unknown {
    const obj: any = {};
    if (message.subscriber !== "0") {
      obj.subscriber = message.subscriber;
    }
    if (message.subscribeToId !== "0") {
      obj.subscribeToId = message.subscribeToId;
    }
    if (message.syncVersion !== "0") {
      obj.syncVersion = message.syncVersion;
    }
    if (message.haveVersions?.length) {
      obj.haveVersions = message.haveVersions.map((e) => CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions.toJSON(e));
    }
    if (message.subscribeToType !== 0) {
      obj.subscribeToType = Math.round(message.subscribeToType);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCSOCacheSubscribe>): CMsgGCToGCSOCacheSubscribe {
    return CMsgGCToGCSOCacheSubscribe.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToGCSOCacheSubscribe>): CMsgGCToGCSOCacheSubscribe {
    const message = createBaseCMsgGCToGCSOCacheSubscribe();
    message.subscriber = object.subscriber ?? "0";
    message.subscribeToId = object.subscribeToId ?? "0";
    message.syncVersion = object.syncVersion ?? "0";
    message.haveVersions =
      object.haveVersions?.map((e) => CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions.fromPartial(e)) || [];
    message.subscribeToType = object.subscribeToType ?? 0;
    return message;
  },
};

function createBaseCMsgGCToGCSOCacheSubscribe_CMsgHaveVersions(): CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
  return { serviceId: 0, version: "0" };
}

export const CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions: MessageFns<CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions> = {
  encode(
    message: CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.serviceId !== 0) {
      writer.uint32(8).uint32(message.serviceId);
    }
    if (message.version !== "0") {
      writer.uint32(16).uint64(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCSOCacheSubscribe_CMsgHaveVersions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.serviceId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.version = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
    return {
      serviceId: isSet(object.serviceId) ? globalThis.Number(object.serviceId) : 0,
      version: isSet(object.version) ? globalThis.String(object.version) : "0",
    };
  },

  toJSON(message: CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions): unknown {
    const obj: any = {};
    if (message.serviceId !== 0) {
      obj.serviceId = Math.round(message.serviceId);
    }
    if (message.version !== "0") {
      obj.version = message.version;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions>): CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
    return CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions>,
  ): CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
    const message = createBaseCMsgGCToGCSOCacheSubscribe_CMsgHaveVersions();
    message.serviceId = object.serviceId ?? 0;
    message.version = object.version ?? "0";
    return message;
  },
};

function createBaseCMsgGCToGCSOCacheUnsubscribe(): CMsgGCToGCSOCacheUnsubscribe {
  return { subscriber: "0", unsubscribeFromId: "0", unsubscribeFromType: 0 };
}

export const CMsgGCToGCSOCacheUnsubscribe: MessageFns<CMsgGCToGCSOCacheUnsubscribe> = {
  encode(message: CMsgGCToGCSOCacheUnsubscribe, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscriber !== "0") {
      writer.uint32(9).fixed64(message.subscriber);
    }
    if (message.unsubscribeFromId !== "0") {
      writer.uint32(17).fixed64(message.unsubscribeFromId);
    }
    if (message.unsubscribeFromType !== 0) {
      writer.uint32(24).uint32(message.unsubscribeFromType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCSOCacheUnsubscribe {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCSOCacheUnsubscribe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.subscriber = reader.fixed64().toString();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.unsubscribeFromId = reader.fixed64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.unsubscribeFromType = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCSOCacheUnsubscribe {
    return {
      subscriber: isSet(object.subscriber) ? globalThis.String(object.subscriber) : "0",
      unsubscribeFromId: isSet(object.unsubscribeFromId) ? globalThis.String(object.unsubscribeFromId) : "0",
      unsubscribeFromType: isSet(object.unsubscribeFromType) ? globalThis.Number(object.unsubscribeFromType) : 0,
    };
  },

  toJSON(message: CMsgGCToGCSOCacheUnsubscribe): unknown {
    const obj: any = {};
    if (message.subscriber !== "0") {
      obj.subscriber = message.subscriber;
    }
    if (message.unsubscribeFromId !== "0") {
      obj.unsubscribeFromId = message.unsubscribeFromId;
    }
    if (message.unsubscribeFromType !== 0) {
      obj.unsubscribeFromType = Math.round(message.unsubscribeFromType);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCSOCacheUnsubscribe>): CMsgGCToGCSOCacheUnsubscribe {
    return CMsgGCToGCSOCacheUnsubscribe.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToGCSOCacheUnsubscribe>): CMsgGCToGCSOCacheUnsubscribe {
    const message = createBaseCMsgGCToGCSOCacheUnsubscribe();
    message.subscriber = object.subscriber ?? "0";
    message.unsubscribeFromId = object.unsubscribeFromId ?? "0";
    message.unsubscribeFromType = object.unsubscribeFromType ?? 0;
    return message;
  },
};

function createBaseCMsgGCClientPing(): CMsgGCClientPing {
  return {};
}

export const CMsgGCClientPing: MessageFns<CMsgGCClientPing> = {
  encode(_: CMsgGCClientPing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCClientPing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCClientPing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgGCClientPing {
    return {};
  },

  toJSON(_: CMsgGCClientPing): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgGCClientPing>): CMsgGCClientPing {
    return CMsgGCClientPing.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgGCClientPing>): CMsgGCClientPing {
    const message = createBaseCMsgGCClientPing();
    return message;
  },
};

function createBaseCMsgGCToGCForwardAccountDetails(): CMsgGCToGCForwardAccountDetails {
  return { steamid: "0", accountDetails: undefined, ageSeconds: 0 };
}

export const CMsgGCToGCForwardAccountDetails: MessageFns<CMsgGCToGCForwardAccountDetails> = {
  encode(message: CMsgGCToGCForwardAccountDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.steamid !== "0") {
      writer.uint32(9).fixed64(message.steamid);
    }
    if (message.accountDetails !== undefined) {
      CGCSystemMsgGetAccountDetailsResponse.encode(message.accountDetails, writer.uint32(18).fork()).join();
    }
    if (message.ageSeconds !== 0) {
      writer.uint32(24).uint32(message.ageSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCForwardAccountDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCForwardAccountDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.steamid = reader.fixed64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountDetails = CGCSystemMsgGetAccountDetailsResponse.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.ageSeconds = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCForwardAccountDetails {
    return {
      steamid: isSet(object.steamid) ? globalThis.String(object.steamid) : "0",
      accountDetails: isSet(object.accountDetails)
        ? CGCSystemMsgGetAccountDetailsResponse.fromJSON(object.accountDetails)
        : undefined,
      ageSeconds: isSet(object.ageSeconds) ? globalThis.Number(object.ageSeconds) : 0,
    };
  },

  toJSON(message: CMsgGCToGCForwardAccountDetails): unknown {
    const obj: any = {};
    if (message.steamid !== "0") {
      obj.steamid = message.steamid;
    }
    if (message.accountDetails !== undefined) {
      obj.accountDetails = CGCSystemMsgGetAccountDetailsResponse.toJSON(message.accountDetails);
    }
    if (message.ageSeconds !== 0) {
      obj.ageSeconds = Math.round(message.ageSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCForwardAccountDetails>): CMsgGCToGCForwardAccountDetails {
    return CMsgGCToGCForwardAccountDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToGCForwardAccountDetails>): CMsgGCToGCForwardAccountDetails {
    const message = createBaseCMsgGCToGCForwardAccountDetails();
    message.steamid = object.steamid ?? "0";
    message.accountDetails = (object.accountDetails !== undefined && object.accountDetails !== null)
      ? CGCSystemMsgGetAccountDetailsResponse.fromPartial(object.accountDetails)
      : undefined;
    message.ageSeconds = object.ageSeconds ?? 0;
    return message;
  },
};

function createBaseCMsgGCToGCLoadSessionSOCache(): CMsgGCToGCLoadSessionSOCache {
  return { accountId: 0, forwardAccountDetails: undefined };
}

export const CMsgGCToGCLoadSessionSOCache: MessageFns<CMsgGCToGCLoadSessionSOCache> = {
  encode(message: CMsgGCToGCLoadSessionSOCache, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.forwardAccountDetails !== undefined) {
      CMsgGCToGCForwardAccountDetails.encode(message.forwardAccountDetails, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCLoadSessionSOCache {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCLoadSessionSOCache();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.forwardAccountDetails = CMsgGCToGCForwardAccountDetails.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCLoadSessionSOCache {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      forwardAccountDetails: isSet(object.forwardAccountDetails)
        ? CMsgGCToGCForwardAccountDetails.fromJSON(object.forwardAccountDetails)
        : undefined,
    };
  },

  toJSON(message: CMsgGCToGCLoadSessionSOCache): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.forwardAccountDetails !== undefined) {
      obj.forwardAccountDetails = CMsgGCToGCForwardAccountDetails.toJSON(message.forwardAccountDetails);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCLoadSessionSOCache>): CMsgGCToGCLoadSessionSOCache {
    return CMsgGCToGCLoadSessionSOCache.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToGCLoadSessionSOCache>): CMsgGCToGCLoadSessionSOCache {
    const message = createBaseCMsgGCToGCLoadSessionSOCache();
    message.accountId = object.accountId ?? 0;
    message.forwardAccountDetails =
      (object.forwardAccountDetails !== undefined && object.forwardAccountDetails !== null)
        ? CMsgGCToGCForwardAccountDetails.fromPartial(object.forwardAccountDetails)
        : undefined;
    return message;
  },
};

function createBaseCMsgGCToGCLoadSessionSOCacheResponse(): CMsgGCToGCLoadSessionSOCacheResponse {
  return {};
}

export const CMsgGCToGCLoadSessionSOCacheResponse: MessageFns<CMsgGCToGCLoadSessionSOCacheResponse> = {
  encode(_: CMsgGCToGCLoadSessionSOCacheResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCLoadSessionSOCacheResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCLoadSessionSOCacheResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgGCToGCLoadSessionSOCacheResponse {
    return {};
  },

  toJSON(_: CMsgGCToGCLoadSessionSOCacheResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCLoadSessionSOCacheResponse>): CMsgGCToGCLoadSessionSOCacheResponse {
    return CMsgGCToGCLoadSessionSOCacheResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgGCToGCLoadSessionSOCacheResponse>): CMsgGCToGCLoadSessionSOCacheResponse {
    const message = createBaseCMsgGCToGCLoadSessionSOCacheResponse();
    return message;
  },
};

function createBaseCMsgGCToGCUpdateSessionStats(): CMsgGCToGCUpdateSessionStats {
  return { userSessions: 0, serverSessions: 0, inLogonSurge: false };
}

export const CMsgGCToGCUpdateSessionStats: MessageFns<CMsgGCToGCUpdateSessionStats> = {
  encode(message: CMsgGCToGCUpdateSessionStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userSessions !== 0) {
      writer.uint32(8).uint32(message.userSessions);
    }
    if (message.serverSessions !== 0) {
      writer.uint32(16).uint32(message.serverSessions);
    }
    if (message.inLogonSurge !== false) {
      writer.uint32(24).bool(message.inLogonSurge);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCUpdateSessionStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCUpdateSessionStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userSessions = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.serverSessions = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.inLogonSurge = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCUpdateSessionStats {
    return {
      userSessions: isSet(object.userSessions) ? globalThis.Number(object.userSessions) : 0,
      serverSessions: isSet(object.serverSessions) ? globalThis.Number(object.serverSessions) : 0,
      inLogonSurge: isSet(object.inLogonSurge) ? globalThis.Boolean(object.inLogonSurge) : false,
    };
  },

  toJSON(message: CMsgGCToGCUpdateSessionStats): unknown {
    const obj: any = {};
    if (message.userSessions !== 0) {
      obj.userSessions = Math.round(message.userSessions);
    }
    if (message.serverSessions !== 0) {
      obj.serverSessions = Math.round(message.serverSessions);
    }
    if (message.inLogonSurge !== false) {
      obj.inLogonSurge = message.inLogonSurge;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCUpdateSessionStats>): CMsgGCToGCUpdateSessionStats {
    return CMsgGCToGCUpdateSessionStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToGCUpdateSessionStats>): CMsgGCToGCUpdateSessionStats {
    const message = createBaseCMsgGCToGCUpdateSessionStats();
    message.userSessions = object.userSessions ?? 0;
    message.serverSessions = object.serverSessions ?? 0;
    message.inLogonSurge = object.inLogonSurge ?? false;
    return message;
  },
};

function createBaseCMsgGCToClientRequestDropped(): CMsgGCToClientRequestDropped {
  return {};
}

export const CMsgGCToClientRequestDropped: MessageFns<CMsgGCToClientRequestDropped> = {
  encode(_: CMsgGCToClientRequestDropped, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToClientRequestDropped {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientRequestDropped();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgGCToClientRequestDropped {
    return {};
  },

  toJSON(_: CMsgGCToClientRequestDropped): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToClientRequestDropped>): CMsgGCToClientRequestDropped {
    return CMsgGCToClientRequestDropped.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgGCToClientRequestDropped>): CMsgGCToClientRequestDropped {
    const message = createBaseCMsgGCToClientRequestDropped();
    return message;
  },
};

function createBaseCWorkshopPopulateItemDescriptionsRequest(): CWorkshopPopulateItemDescriptionsRequest {
  return { appid: 0, languages: [] };
}

export const CWorkshopPopulateItemDescriptionsRequest: MessageFns<CWorkshopPopulateItemDescriptionsRequest> = {
  encode(message: CWorkshopPopulateItemDescriptionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appid !== 0) {
      writer.uint32(8).uint32(message.appid);
    }
    for (const v of message.languages) {
      CWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock.encode(v!, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CWorkshopPopulateItemDescriptionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCWorkshopPopulateItemDescriptionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.appid = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.languages.push(
            CWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CWorkshopPopulateItemDescriptionsRequest {
    return {
      appid: isSet(object.appid) ? globalThis.Number(object.appid) : 0,
      languages: globalThis.Array.isArray(object?.languages)
        ? object.languages.map((e: any) =>
          CWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: CWorkshopPopulateItemDescriptionsRequest): unknown {
    const obj: any = {};
    if (message.appid !== 0) {
      obj.appid = Math.round(message.appid);
    }
    if (message.languages?.length) {
      obj.languages = message.languages.map((e) =>
        CWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CWorkshopPopulateItemDescriptionsRequest>): CWorkshopPopulateItemDescriptionsRequest {
    return CWorkshopPopulateItemDescriptionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CWorkshopPopulateItemDescriptionsRequest>): CWorkshopPopulateItemDescriptionsRequest {
    const message = createBaseCWorkshopPopulateItemDescriptionsRequest();
    message.appid = object.appid ?? 0;
    message.languages =
      object.languages?.map((e) =>
        CWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseCWorkshopPopulateItemDescriptionsRequest_SingleItemDescription(): CWorkshopPopulateItemDescriptionsRequest_SingleItemDescription {
  return { gameitemid: 0, itemDescription: "" };
}

export const CWorkshopPopulateItemDescriptionsRequest_SingleItemDescription: MessageFns<
  CWorkshopPopulateItemDescriptionsRequest_SingleItemDescription
> = {
  encode(
    message: CWorkshopPopulateItemDescriptionsRequest_SingleItemDescription,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.gameitemid !== 0) {
      writer.uint32(8).uint32(message.gameitemid);
    }
    if (message.itemDescription !== "") {
      writer.uint32(18).string(message.itemDescription);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CWorkshopPopulateItemDescriptionsRequest_SingleItemDescription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCWorkshopPopulateItemDescriptionsRequest_SingleItemDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.gameitemid = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.itemDescription = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CWorkshopPopulateItemDescriptionsRequest_SingleItemDescription {
    return {
      gameitemid: isSet(object.gameitemid) ? globalThis.Number(object.gameitemid) : 0,
      itemDescription: isSet(object.itemDescription) ? globalThis.String(object.itemDescription) : "",
    };
  },

  toJSON(message: CWorkshopPopulateItemDescriptionsRequest_SingleItemDescription): unknown {
    const obj: any = {};
    if (message.gameitemid !== 0) {
      obj.gameitemid = Math.round(message.gameitemid);
    }
    if (message.itemDescription !== "") {
      obj.itemDescription = message.itemDescription;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CWorkshopPopulateItemDescriptionsRequest_SingleItemDescription>,
  ): CWorkshopPopulateItemDescriptionsRequest_SingleItemDescription {
    return CWorkshopPopulateItemDescriptionsRequest_SingleItemDescription.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CWorkshopPopulateItemDescriptionsRequest_SingleItemDescription>,
  ): CWorkshopPopulateItemDescriptionsRequest_SingleItemDescription {
    const message = createBaseCWorkshopPopulateItemDescriptionsRequest_SingleItemDescription();
    message.gameitemid = object.gameitemid ?? 0;
    message.itemDescription = object.itemDescription ?? "";
    return message;
  },
};

function createBaseCWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock(): CWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock {
  return { language: "", descriptions: [] };
}

export const CWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock: MessageFns<
  CWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock
> = {
  encode(
    message: CWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.language !== "") {
      writer.uint32(10).string(message.language);
    }
    for (const v of message.descriptions) {
      CWorkshopPopulateItemDescriptionsRequest_SingleItemDescription.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.descriptions.push(
            CWorkshopPopulateItemDescriptionsRequest_SingleItemDescription.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock {
    return {
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      descriptions: globalThis.Array.isArray(object?.descriptions)
        ? object.descriptions.map((e: any) =>
          CWorkshopPopulateItemDescriptionsRequest_SingleItemDescription.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: CWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock): unknown {
    const obj: any = {};
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.descriptions?.length) {
      obj.descriptions = message.descriptions.map((e) =>
        CWorkshopPopulateItemDescriptionsRequest_SingleItemDescription.toJSON(e)
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<CWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock>,
  ): CWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock {
    return CWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock>,
  ): CWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock {
    const message = createBaseCWorkshopPopulateItemDescriptionsRequest_ItemDescriptionsLanguageBlock();
    message.language = object.language ?? "";
    message.descriptions =
      object.descriptions?.map((e) => CWorkshopPopulateItemDescriptionsRequest_SingleItemDescription.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseCWorkshopGetContributorsRequest(): CWorkshopGetContributorsRequest {
  return { appid: 0, gameitemid: 0 };
}

export const CWorkshopGetContributorsRequest: MessageFns<CWorkshopGetContributorsRequest> = {
  encode(message: CWorkshopGetContributorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appid !== 0) {
      writer.uint32(8).uint32(message.appid);
    }
    if (message.gameitemid !== 0) {
      writer.uint32(16).uint32(message.gameitemid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CWorkshopGetContributorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCWorkshopGetContributorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.appid = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gameitemid = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CWorkshopGetContributorsRequest {
    return {
      appid: isSet(object.appid) ? globalThis.Number(object.appid) : 0,
      gameitemid: isSet(object.gameitemid) ? globalThis.Number(object.gameitemid) : 0,
    };
  },

  toJSON(message: CWorkshopGetContributorsRequest): unknown {
    const obj: any = {};
    if (message.appid !== 0) {
      obj.appid = Math.round(message.appid);
    }
    if (message.gameitemid !== 0) {
      obj.gameitemid = Math.round(message.gameitemid);
    }
    return obj;
  },

  create(base?: DeepPartial<CWorkshopGetContributorsRequest>): CWorkshopGetContributorsRequest {
    return CWorkshopGetContributorsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CWorkshopGetContributorsRequest>): CWorkshopGetContributorsRequest {
    const message = createBaseCWorkshopGetContributorsRequest();
    message.appid = object.appid ?? 0;
    message.gameitemid = object.gameitemid ?? 0;
    return message;
  },
};

function createBaseCWorkshopGetContributorsResponse(): CWorkshopGetContributorsResponse {
  return { contributors: [] };
}

export const CWorkshopGetContributorsResponse: MessageFns<CWorkshopGetContributorsResponse> = {
  encode(message: CWorkshopGetContributorsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.contributors) {
      writer.fixed64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CWorkshopGetContributorsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCWorkshopGetContributorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 9) {
            message.contributors.push(reader.fixed64().toString());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.contributors.push(reader.fixed64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CWorkshopGetContributorsResponse {
    return {
      contributors: globalThis.Array.isArray(object?.contributors)
        ? object.contributors.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CWorkshopGetContributorsResponse): unknown {
    const obj: any = {};
    if (message.contributors?.length) {
      obj.contributors = message.contributors;
    }
    return obj;
  },

  create(base?: DeepPartial<CWorkshopGetContributorsResponse>): CWorkshopGetContributorsResponse {
    return CWorkshopGetContributorsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CWorkshopGetContributorsResponse>): CWorkshopGetContributorsResponse {
    const message = createBaseCWorkshopGetContributorsResponse();
    message.contributors = object.contributors?.map((e) => e) || [];
    return message;
  },
};

function createBaseCWorkshopSetItemPaymentRulesRequest(): CWorkshopSetItemPaymentRulesRequest {
  return {
    appid: 0,
    gameitemid: 0,
    associatedWorkshopFiles: [],
    partnerAccounts: [],
    validateOnly: false,
    makeWorkshopFilesSubscribable: false,
    associatedWorkshopFileForDirectPayments: undefined,
  };
}

export const CWorkshopSetItemPaymentRulesRequest: MessageFns<CWorkshopSetItemPaymentRulesRequest> = {
  encode(message: CWorkshopSetItemPaymentRulesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appid !== 0) {
      writer.uint32(8).uint32(message.appid);
    }
    if (message.gameitemid !== 0) {
      writer.uint32(16).uint32(message.gameitemid);
    }
    for (const v of message.associatedWorkshopFiles) {
      CWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.partnerAccounts) {
      CWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(40).bool(message.validateOnly);
    }
    if (message.makeWorkshopFilesSubscribable !== false) {
      writer.uint32(48).bool(message.makeWorkshopFilesSubscribable);
    }
    if (message.associatedWorkshopFileForDirectPayments !== undefined) {
      CWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule.encode(
        message.associatedWorkshopFileForDirectPayments,
        writer.uint32(58).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CWorkshopSetItemPaymentRulesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCWorkshopSetItemPaymentRulesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.appid = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gameitemid = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.associatedWorkshopFiles.push(
            CWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.partnerAccounts.push(
            CWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.makeWorkshopFilesSubscribable = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.associatedWorkshopFileForDirectPayments =
            CWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CWorkshopSetItemPaymentRulesRequest {
    return {
      appid: isSet(object.appid) ? globalThis.Number(object.appid) : 0,
      gameitemid: isSet(object.gameitemid) ? globalThis.Number(object.gameitemid) : 0,
      associatedWorkshopFiles: globalThis.Array.isArray(object?.associatedWorkshopFiles)
        ? object.associatedWorkshopFiles.map((e: any) =>
          CWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule.fromJSON(e)
        )
        : [],
      partnerAccounts: globalThis.Array.isArray(object?.partnerAccounts)
        ? object.partnerAccounts.map((e: any) => CWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule.fromJSON(e))
        : [],
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      makeWorkshopFilesSubscribable: isSet(object.makeWorkshopFilesSubscribable)
        ? globalThis.Boolean(object.makeWorkshopFilesSubscribable)
        : false,
      associatedWorkshopFileForDirectPayments: isSet(object.associatedWorkshopFileForDirectPayments)
        ? CWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule.fromJSON(
          object.associatedWorkshopFileForDirectPayments,
        )
        : undefined,
    };
  },

  toJSON(message: CWorkshopSetItemPaymentRulesRequest): unknown {
    const obj: any = {};
    if (message.appid !== 0) {
      obj.appid = Math.round(message.appid);
    }
    if (message.gameitemid !== 0) {
      obj.gameitemid = Math.round(message.gameitemid);
    }
    if (message.associatedWorkshopFiles?.length) {
      obj.associatedWorkshopFiles = message.associatedWorkshopFiles.map((e) =>
        CWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule.toJSON(e)
      );
    }
    if (message.partnerAccounts?.length) {
      obj.partnerAccounts = message.partnerAccounts.map((e) =>
        CWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule.toJSON(e)
      );
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.makeWorkshopFilesSubscribable !== false) {
      obj.makeWorkshopFilesSubscribable = message.makeWorkshopFilesSubscribable;
    }
    if (message.associatedWorkshopFileForDirectPayments !== undefined) {
      obj.associatedWorkshopFileForDirectPayments = CWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule
        .toJSON(message.associatedWorkshopFileForDirectPayments);
    }
    return obj;
  },

  create(base?: DeepPartial<CWorkshopSetItemPaymentRulesRequest>): CWorkshopSetItemPaymentRulesRequest {
    return CWorkshopSetItemPaymentRulesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CWorkshopSetItemPaymentRulesRequest>): CWorkshopSetItemPaymentRulesRequest {
    const message = createBaseCWorkshopSetItemPaymentRulesRequest();
    message.appid = object.appid ?? 0;
    message.gameitemid = object.gameitemid ?? 0;
    message.associatedWorkshopFiles =
      object.associatedWorkshopFiles?.map((e) =>
        CWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule.fromPartial(e)
      ) || [];
    message.partnerAccounts =
      object.partnerAccounts?.map((e) => CWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule.fromPartial(e)) ||
      [];
    message.validateOnly = object.validateOnly ?? false;
    message.makeWorkshopFilesSubscribable = object.makeWorkshopFilesSubscribable ?? false;
    message.associatedWorkshopFileForDirectPayments =
      (object.associatedWorkshopFileForDirectPayments !== undefined &&
          object.associatedWorkshopFileForDirectPayments !== null)
        ? CWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule.fromPartial(
          object.associatedWorkshopFileForDirectPayments,
        )
        : undefined;
    return message;
  },
};

function createBaseCWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule(): CWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule {
  return { workshopFileId: "0", revenuePercentage: 0, ruleDescription: "", ruleType: 1 };
}

export const CWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule: MessageFns<
  CWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule
> = {
  encode(
    message: CWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.workshopFileId !== "0") {
      writer.uint32(8).uint64(message.workshopFileId);
    }
    if (message.revenuePercentage !== 0) {
      writer.uint32(21).float(message.revenuePercentage);
    }
    if (message.ruleDescription !== "") {
      writer.uint32(26).string(message.ruleDescription);
    }
    if (message.ruleType !== 1) {
      writer.uint32(32).uint32(message.ruleType);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.workshopFileId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.revenuePercentage = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ruleDescription = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ruleType = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule {
    return {
      workshopFileId: isSet(object.workshopFileId) ? globalThis.String(object.workshopFileId) : "0",
      revenuePercentage: isSet(object.revenuePercentage) ? globalThis.Number(object.revenuePercentage) : 0,
      ruleDescription: isSet(object.ruleDescription) ? globalThis.String(object.ruleDescription) : "",
      ruleType: isSet(object.ruleType) ? globalThis.Number(object.ruleType) : 1,
    };
  },

  toJSON(message: CWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule): unknown {
    const obj: any = {};
    if (message.workshopFileId !== "0") {
      obj.workshopFileId = message.workshopFileId;
    }
    if (message.revenuePercentage !== 0) {
      obj.revenuePercentage = message.revenuePercentage;
    }
    if (message.ruleDescription !== "") {
      obj.ruleDescription = message.ruleDescription;
    }
    if (message.ruleType !== 1) {
      obj.ruleType = Math.round(message.ruleType);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule>,
  ): CWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule {
    return CWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule>,
  ): CWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule {
    const message = createBaseCWorkshopSetItemPaymentRulesRequest_WorkshopItemPaymentRule();
    message.workshopFileId = object.workshopFileId ?? "0";
    message.revenuePercentage = object.revenuePercentage ?? 0;
    message.ruleDescription = object.ruleDescription ?? "";
    message.ruleType = object.ruleType ?? 1;
    return message;
  },
};

function createBaseCWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule(): CWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule {
  return { workshopFileId: "0", ruleDescription: "" };
}

export const CWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule: MessageFns<
  CWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule
> = {
  encode(
    message: CWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.workshopFileId !== "0") {
      writer.uint32(8).uint64(message.workshopFileId);
    }
    if (message.ruleDescription !== "") {
      writer.uint32(18).string(message.ruleDescription);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.workshopFileId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ruleDescription = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule {
    return {
      workshopFileId: isSet(object.workshopFileId) ? globalThis.String(object.workshopFileId) : "0",
      ruleDescription: isSet(object.ruleDescription) ? globalThis.String(object.ruleDescription) : "",
    };
  },

  toJSON(message: CWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule): unknown {
    const obj: any = {};
    if (message.workshopFileId !== "0") {
      obj.workshopFileId = message.workshopFileId;
    }
    if (message.ruleDescription !== "") {
      obj.ruleDescription = message.ruleDescription;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule>,
  ): CWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule {
    return CWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule>,
  ): CWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule {
    const message = createBaseCWorkshopSetItemPaymentRulesRequest_WorkshopDirectPaymentRule();
    message.workshopFileId = object.workshopFileId ?? "0";
    message.ruleDescription = object.ruleDescription ?? "";
    return message;
  },
};

function createBaseCWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule(): CWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule {
  return { accountId: 0, revenuePercentage: 0, ruleDescription: "" };
}

export const CWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule: MessageFns<
  CWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule
> = {
  encode(
    message: CWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.revenuePercentage !== 0) {
      writer.uint32(21).float(message.revenuePercentage);
    }
    if (message.ruleDescription !== "") {
      writer.uint32(26).string(message.ruleDescription);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.revenuePercentage = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ruleDescription = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      revenuePercentage: isSet(object.revenuePercentage) ? globalThis.Number(object.revenuePercentage) : 0,
      ruleDescription: isSet(object.ruleDescription) ? globalThis.String(object.ruleDescription) : "",
    };
  },

  toJSON(message: CWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.revenuePercentage !== 0) {
      obj.revenuePercentage = message.revenuePercentage;
    }
    if (message.ruleDescription !== "") {
      obj.ruleDescription = message.ruleDescription;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule>,
  ): CWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule {
    return CWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule>,
  ): CWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule {
    const message = createBaseCWorkshopSetItemPaymentRulesRequest_PartnerItemPaymentRule();
    message.accountId = object.accountId ?? 0;
    message.revenuePercentage = object.revenuePercentage ?? 0;
    message.ruleDescription = object.ruleDescription ?? "";
    return message;
  },
};

function createBaseCWorkshopSetItemPaymentRulesResponse(): CWorkshopSetItemPaymentRulesResponse {
  return { validationErrors: [] };
}

export const CWorkshopSetItemPaymentRulesResponse: MessageFns<CWorkshopSetItemPaymentRulesResponse> = {
  encode(message: CWorkshopSetItemPaymentRulesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.validationErrors) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CWorkshopSetItemPaymentRulesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCWorkshopSetItemPaymentRulesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validationErrors.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CWorkshopSetItemPaymentRulesResponse {
    return {
      validationErrors: globalThis.Array.isArray(object?.validationErrors)
        ? object.validationErrors.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CWorkshopSetItemPaymentRulesResponse): unknown {
    const obj: any = {};
    if (message.validationErrors?.length) {
      obj.validationErrors = message.validationErrors;
    }
    return obj;
  },

  create(base?: DeepPartial<CWorkshopSetItemPaymentRulesResponse>): CWorkshopSetItemPaymentRulesResponse {
    return CWorkshopSetItemPaymentRulesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CWorkshopSetItemPaymentRulesResponse>): CWorkshopSetItemPaymentRulesResponse {
    const message = createBaseCWorkshopSetItemPaymentRulesResponse();
    message.validationErrors = object.validationErrors?.map((e) => e) || [];
    return message;
  },
};

function createBaseCCommunityClanAnnouncementInfo(): CCommunityClanAnnouncementInfo {
  return {
    gid: "0",
    clanid: "0",
    posterid: "0",
    headline: "",
    posttime: 0,
    updatetime: 0,
    body: "",
    commentcount: 0,
    tags: [],
    language: 0,
    hidden: false,
    forumTopicId: "0",
  };
}

export const CCommunityClanAnnouncementInfo: MessageFns<CCommunityClanAnnouncementInfo> = {
  encode(message: CCommunityClanAnnouncementInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gid !== "0") {
      writer.uint32(8).uint64(message.gid);
    }
    if (message.clanid !== "0") {
      writer.uint32(16).uint64(message.clanid);
    }
    if (message.posterid !== "0") {
      writer.uint32(24).uint64(message.posterid);
    }
    if (message.headline !== "") {
      writer.uint32(34).string(message.headline);
    }
    if (message.posttime !== 0) {
      writer.uint32(40).uint32(message.posttime);
    }
    if (message.updatetime !== 0) {
      writer.uint32(48).uint32(message.updatetime);
    }
    if (message.body !== "") {
      writer.uint32(58).string(message.body);
    }
    if (message.commentcount !== 0) {
      writer.uint32(64).int32(message.commentcount);
    }
    for (const v of message.tags) {
      writer.uint32(74).string(v!);
    }
    if (message.language !== 0) {
      writer.uint32(80).int32(message.language);
    }
    if (message.hidden !== false) {
      writer.uint32(88).bool(message.hidden);
    }
    if (message.forumTopicId !== "0") {
      writer.uint32(97).fixed64(message.forumTopicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CCommunityClanAnnouncementInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCCommunityClanAnnouncementInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.gid = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.clanid = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.posterid = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.headline = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.posttime = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.updatetime = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.body = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.commentcount = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.language = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.hidden = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 97) {
            break;
          }

          message.forumTopicId = reader.fixed64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CCommunityClanAnnouncementInfo {
    return {
      gid: isSet(object.gid) ? globalThis.String(object.gid) : "0",
      clanid: isSet(object.clanid) ? globalThis.String(object.clanid) : "0",
      posterid: isSet(object.posterid) ? globalThis.String(object.posterid) : "0",
      headline: isSet(object.headline) ? globalThis.String(object.headline) : "",
      posttime: isSet(object.posttime) ? globalThis.Number(object.posttime) : 0,
      updatetime: isSet(object.updatetime) ? globalThis.Number(object.updatetime) : 0,
      body: isSet(object.body) ? globalThis.String(object.body) : "",
      commentcount: isSet(object.commentcount) ? globalThis.Number(object.commentcount) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      language: isSet(object.language) ? globalThis.Number(object.language) : 0,
      hidden: isSet(object.hidden) ? globalThis.Boolean(object.hidden) : false,
      forumTopicId: isSet(object.forumTopicId) ? globalThis.String(object.forumTopicId) : "0",
    };
  },

  toJSON(message: CCommunityClanAnnouncementInfo): unknown {
    const obj: any = {};
    if (message.gid !== "0") {
      obj.gid = message.gid;
    }
    if (message.clanid !== "0") {
      obj.clanid = message.clanid;
    }
    if (message.posterid !== "0") {
      obj.posterid = message.posterid;
    }
    if (message.headline !== "") {
      obj.headline = message.headline;
    }
    if (message.posttime !== 0) {
      obj.posttime = Math.round(message.posttime);
    }
    if (message.updatetime !== 0) {
      obj.updatetime = Math.round(message.updatetime);
    }
    if (message.body !== "") {
      obj.body = message.body;
    }
    if (message.commentcount !== 0) {
      obj.commentcount = Math.round(message.commentcount);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.language !== 0) {
      obj.language = Math.round(message.language);
    }
    if (message.hidden !== false) {
      obj.hidden = message.hidden;
    }
    if (message.forumTopicId !== "0") {
      obj.forumTopicId = message.forumTopicId;
    }
    return obj;
  },

  create(base?: DeepPartial<CCommunityClanAnnouncementInfo>): CCommunityClanAnnouncementInfo {
    return CCommunityClanAnnouncementInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CCommunityClanAnnouncementInfo>): CCommunityClanAnnouncementInfo {
    const message = createBaseCCommunityClanAnnouncementInfo();
    message.gid = object.gid ?? "0";
    message.clanid = object.clanid ?? "0";
    message.posterid = object.posterid ?? "0";
    message.headline = object.headline ?? "";
    message.posttime = object.posttime ?? 0;
    message.updatetime = object.updatetime ?? 0;
    message.body = object.body ?? "";
    message.commentcount = object.commentcount ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.language = object.language ?? 0;
    message.hidden = object.hidden ?? false;
    message.forumTopicId = object.forumTopicId ?? "0";
    return message;
  },
};

function createBaseCCommunityGetClanAnnouncementsRequest(): CCommunityGetClanAnnouncementsRequest {
  return {
    steamid: "0",
    offset: 0,
    count: 0,
    maxchars: 0,
    stripHtml: false,
    requiredTags: [],
    requireNoTags: false,
    languagePreference: [],
    hiddenOnly: false,
    onlyGid: false,
    rtimeOldestDate: 0,
    includeHidden: false,
    includePartnerEvents: false,
  };
}

export const CCommunityGetClanAnnouncementsRequest: MessageFns<CCommunityGetClanAnnouncementsRequest> = {
  encode(message: CCommunityGetClanAnnouncementsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.steamid !== "0") {
      writer.uint32(8).uint64(message.steamid);
    }
    if (message.offset !== 0) {
      writer.uint32(16).uint32(message.offset);
    }
    if (message.count !== 0) {
      writer.uint32(24).uint32(message.count);
    }
    if (message.maxchars !== 0) {
      writer.uint32(32).uint32(message.maxchars);
    }
    if (message.stripHtml !== false) {
      writer.uint32(40).bool(message.stripHtml);
    }
    for (const v of message.requiredTags) {
      writer.uint32(50).string(v!);
    }
    if (message.requireNoTags !== false) {
      writer.uint32(56).bool(message.requireNoTags);
    }
    writer.uint32(66).fork();
    for (const v of message.languagePreference) {
      writer.uint32(v);
    }
    writer.join();
    if (message.hiddenOnly !== false) {
      writer.uint32(72).bool(message.hiddenOnly);
    }
    if (message.onlyGid !== false) {
      writer.uint32(80).bool(message.onlyGid);
    }
    if (message.rtimeOldestDate !== 0) {
      writer.uint32(88).uint32(message.rtimeOldestDate);
    }
    if (message.includeHidden !== false) {
      writer.uint32(96).bool(message.includeHidden);
    }
    if (message.includePartnerEvents !== false) {
      writer.uint32(104).bool(message.includePartnerEvents);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CCommunityGetClanAnnouncementsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCCommunityGetClanAnnouncementsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.steamid = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxchars = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.stripHtml = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.requiredTags.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.requireNoTags = reader.bool();
          continue;
        }
        case 8: {
          if (tag === 64) {
            message.languagePreference.push(reader.uint32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.languagePreference.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.hiddenOnly = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.onlyGid = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.rtimeOldestDate = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.includeHidden = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.includePartnerEvents = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CCommunityGetClanAnnouncementsRequest {
    return {
      steamid: isSet(object.steamid) ? globalThis.String(object.steamid) : "0",
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      maxchars: isSet(object.maxchars) ? globalThis.Number(object.maxchars) : 0,
      stripHtml: isSet(object.stripHtml) ? globalThis.Boolean(object.stripHtml) : false,
      requiredTags: globalThis.Array.isArray(object?.requiredTags)
        ? object.requiredTags.map((e: any) => globalThis.String(e))
        : [],
      requireNoTags: isSet(object.requireNoTags) ? globalThis.Boolean(object.requireNoTags) : false,
      languagePreference: globalThis.Array.isArray(object?.languagePreference)
        ? object.languagePreference.map((e: any) => globalThis.Number(e))
        : [],
      hiddenOnly: isSet(object.hiddenOnly) ? globalThis.Boolean(object.hiddenOnly) : false,
      onlyGid: isSet(object.onlyGid) ? globalThis.Boolean(object.onlyGid) : false,
      rtimeOldestDate: isSet(object.rtimeOldestDate) ? globalThis.Number(object.rtimeOldestDate) : 0,
      includeHidden: isSet(object.includeHidden) ? globalThis.Boolean(object.includeHidden) : false,
      includePartnerEvents: isSet(object.includePartnerEvents)
        ? globalThis.Boolean(object.includePartnerEvents)
        : false,
    };
  },

  toJSON(message: CCommunityGetClanAnnouncementsRequest): unknown {
    const obj: any = {};
    if (message.steamid !== "0") {
      obj.steamid = message.steamid;
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.maxchars !== 0) {
      obj.maxchars = Math.round(message.maxchars);
    }
    if (message.stripHtml !== false) {
      obj.stripHtml = message.stripHtml;
    }
    if (message.requiredTags?.length) {
      obj.requiredTags = message.requiredTags;
    }
    if (message.requireNoTags !== false) {
      obj.requireNoTags = message.requireNoTags;
    }
    if (message.languagePreference?.length) {
      obj.languagePreference = message.languagePreference.map((e) => Math.round(e));
    }
    if (message.hiddenOnly !== false) {
      obj.hiddenOnly = message.hiddenOnly;
    }
    if (message.onlyGid !== false) {
      obj.onlyGid = message.onlyGid;
    }
    if (message.rtimeOldestDate !== 0) {
      obj.rtimeOldestDate = Math.round(message.rtimeOldestDate);
    }
    if (message.includeHidden !== false) {
      obj.includeHidden = message.includeHidden;
    }
    if (message.includePartnerEvents !== false) {
      obj.includePartnerEvents = message.includePartnerEvents;
    }
    return obj;
  },

  create(base?: DeepPartial<CCommunityGetClanAnnouncementsRequest>): CCommunityGetClanAnnouncementsRequest {
    return CCommunityGetClanAnnouncementsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CCommunityGetClanAnnouncementsRequest>): CCommunityGetClanAnnouncementsRequest {
    const message = createBaseCCommunityGetClanAnnouncementsRequest();
    message.steamid = object.steamid ?? "0";
    message.offset = object.offset ?? 0;
    message.count = object.count ?? 0;
    message.maxchars = object.maxchars ?? 0;
    message.stripHtml = object.stripHtml ?? false;
    message.requiredTags = object.requiredTags?.map((e) => e) || [];
    message.requireNoTags = object.requireNoTags ?? false;
    message.languagePreference = object.languagePreference?.map((e) => e) || [];
    message.hiddenOnly = object.hiddenOnly ?? false;
    message.onlyGid = object.onlyGid ?? false;
    message.rtimeOldestDate = object.rtimeOldestDate ?? 0;
    message.includeHidden = object.includeHidden ?? false;
    message.includePartnerEvents = object.includePartnerEvents ?? false;
    return message;
  },
};

function createBaseCCommunityGetClanAnnouncementsResponse(): CCommunityGetClanAnnouncementsResponse {
  return { maxchars: 0, stripHtml: false, announcements: [] };
}

export const CCommunityGetClanAnnouncementsResponse: MessageFns<CCommunityGetClanAnnouncementsResponse> = {
  encode(message: CCommunityGetClanAnnouncementsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxchars !== 0) {
      writer.uint32(8).uint32(message.maxchars);
    }
    if (message.stripHtml !== false) {
      writer.uint32(16).bool(message.stripHtml);
    }
    for (const v of message.announcements) {
      CCommunityClanAnnouncementInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CCommunityGetClanAnnouncementsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCCommunityGetClanAnnouncementsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.maxchars = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.stripHtml = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.announcements.push(CCommunityClanAnnouncementInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CCommunityGetClanAnnouncementsResponse {
    return {
      maxchars: isSet(object.maxchars) ? globalThis.Number(object.maxchars) : 0,
      stripHtml: isSet(object.stripHtml) ? globalThis.Boolean(object.stripHtml) : false,
      announcements: globalThis.Array.isArray(object?.announcements)
        ? object.announcements.map((e: any) => CCommunityClanAnnouncementInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CCommunityGetClanAnnouncementsResponse): unknown {
    const obj: any = {};
    if (message.maxchars !== 0) {
      obj.maxchars = Math.round(message.maxchars);
    }
    if (message.stripHtml !== false) {
      obj.stripHtml = message.stripHtml;
    }
    if (message.announcements?.length) {
      obj.announcements = message.announcements.map((e) => CCommunityClanAnnouncementInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CCommunityGetClanAnnouncementsResponse>): CCommunityGetClanAnnouncementsResponse {
    return CCommunityGetClanAnnouncementsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CCommunityGetClanAnnouncementsResponse>): CCommunityGetClanAnnouncementsResponse {
    const message = createBaseCCommunityGetClanAnnouncementsResponse();
    message.maxchars = object.maxchars ?? 0;
    message.stripHtml = object.stripHtml ?? false;
    message.announcements = object.announcements?.map((e) => CCommunityClanAnnouncementInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCBroadcastPostGameDataFrameRequest(): CBroadcastPostGameDataFrameRequest {
  return { appid: 0, steamid: "0", broadcastId: "0", frameData: Buffer.alloc(0) };
}

export const CBroadcastPostGameDataFrameRequest: MessageFns<CBroadcastPostGameDataFrameRequest> = {
  encode(message: CBroadcastPostGameDataFrameRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appid !== 0) {
      writer.uint32(8).uint32(message.appid);
    }
    if (message.steamid !== "0") {
      writer.uint32(17).fixed64(message.steamid);
    }
    if (message.broadcastId !== "0") {
      writer.uint32(25).fixed64(message.broadcastId);
    }
    if (message.frameData.length !== 0) {
      writer.uint32(34).bytes(message.frameData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CBroadcastPostGameDataFrameRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCBroadcastPostGameDataFrameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.appid = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.steamid = reader.fixed64().toString();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.broadcastId = reader.fixed64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.frameData = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CBroadcastPostGameDataFrameRequest {
    return {
      appid: isSet(object.appid) ? globalThis.Number(object.appid) : 0,
      steamid: isSet(object.steamid) ? globalThis.String(object.steamid) : "0",
      broadcastId: isSet(object.broadcastId) ? globalThis.String(object.broadcastId) : "0",
      frameData: isSet(object.frameData) ? Buffer.from(bytesFromBase64(object.frameData)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CBroadcastPostGameDataFrameRequest): unknown {
    const obj: any = {};
    if (message.appid !== 0) {
      obj.appid = Math.round(message.appid);
    }
    if (message.steamid !== "0") {
      obj.steamid = message.steamid;
    }
    if (message.broadcastId !== "0") {
      obj.broadcastId = message.broadcastId;
    }
    if (message.frameData.length !== 0) {
      obj.frameData = base64FromBytes(message.frameData);
    }
    return obj;
  },

  create(base?: DeepPartial<CBroadcastPostGameDataFrameRequest>): CBroadcastPostGameDataFrameRequest {
    return CBroadcastPostGameDataFrameRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CBroadcastPostGameDataFrameRequest>): CBroadcastPostGameDataFrameRequest {
    const message = createBaseCBroadcastPostGameDataFrameRequest();
    message.appid = object.appid ?? 0;
    message.steamid = object.steamid ?? "0";
    message.broadcastId = object.broadcastId ?? "0";
    message.frameData = object.frameData ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCMsgSerializedSOCache(): CMsgSerializedSOCache {
  return { fileVersion: 0, caches: [], gcSocacheFileVersion: 0 };
}

export const CMsgSerializedSOCache: MessageFns<CMsgSerializedSOCache> = {
  encode(message: CMsgSerializedSOCache, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileVersion !== 0) {
      writer.uint32(8).uint32(message.fileVersion);
    }
    for (const v of message.caches) {
      CMsgSerializedSOCache_Cache.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.gcSocacheFileVersion !== 0) {
      writer.uint32(24).uint32(message.gcSocacheFileVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSerializedSOCache {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSerializedSOCache();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fileVersion = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.caches.push(CMsgSerializedSOCache_Cache.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.gcSocacheFileVersion = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSerializedSOCache {
    return {
      fileVersion: isSet(object.fileVersion) ? globalThis.Number(object.fileVersion) : 0,
      caches: globalThis.Array.isArray(object?.caches)
        ? object.caches.map((e: any) => CMsgSerializedSOCache_Cache.fromJSON(e))
        : [],
      gcSocacheFileVersion: isSet(object.gcSocacheFileVersion) ? globalThis.Number(object.gcSocacheFileVersion) : 0,
    };
  },

  toJSON(message: CMsgSerializedSOCache): unknown {
    const obj: any = {};
    if (message.fileVersion !== 0) {
      obj.fileVersion = Math.round(message.fileVersion);
    }
    if (message.caches?.length) {
      obj.caches = message.caches.map((e) => CMsgSerializedSOCache_Cache.toJSON(e));
    }
    if (message.gcSocacheFileVersion !== 0) {
      obj.gcSocacheFileVersion = Math.round(message.gcSocacheFileVersion);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSerializedSOCache>): CMsgSerializedSOCache {
    return CMsgSerializedSOCache.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSerializedSOCache>): CMsgSerializedSOCache {
    const message = createBaseCMsgSerializedSOCache();
    message.fileVersion = object.fileVersion ?? 0;
    message.caches = object.caches?.map((e) => CMsgSerializedSOCache_Cache.fromPartial(e)) || [];
    message.gcSocacheFileVersion = object.gcSocacheFileVersion ?? 0;
    return message;
  },
};

function createBaseCMsgSerializedSOCache_TypeCache(): CMsgSerializedSOCache_TypeCache {
  return { type: 0, objects: [], serviceId: 0 };
}

export const CMsgSerializedSOCache_TypeCache: MessageFns<CMsgSerializedSOCache_TypeCache> = {
  encode(message: CMsgSerializedSOCache_TypeCache, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).uint32(message.type);
    }
    for (const v of message.objects) {
      writer.uint32(18).bytes(v!);
    }
    if (message.serviceId !== 0) {
      writer.uint32(24).uint32(message.serviceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSerializedSOCache_TypeCache {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSerializedSOCache_TypeCache();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.objects.push(Buffer.from(reader.bytes()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.serviceId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSerializedSOCache_TypeCache {
    return {
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      objects: globalThis.Array.isArray(object?.objects)
        ? object.objects.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      serviceId: isSet(object.serviceId) ? globalThis.Number(object.serviceId) : 0,
    };
  },

  toJSON(message: CMsgSerializedSOCache_TypeCache): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.objects?.length) {
      obj.objects = message.objects.map((e) => base64FromBytes(e));
    }
    if (message.serviceId !== 0) {
      obj.serviceId = Math.round(message.serviceId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSerializedSOCache_TypeCache>): CMsgSerializedSOCache_TypeCache {
    return CMsgSerializedSOCache_TypeCache.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSerializedSOCache_TypeCache>): CMsgSerializedSOCache_TypeCache {
    const message = createBaseCMsgSerializedSOCache_TypeCache();
    message.type = object.type ?? 0;
    message.objects = object.objects?.map((e) => e) || [];
    message.serviceId = object.serviceId ?? 0;
    return message;
  },
};

function createBaseCMsgSerializedSOCache_Cache(): CMsgSerializedSOCache_Cache {
  return { type: 0, id: "0", versions: [], typeCaches: [] };
}

export const CMsgSerializedSOCache_Cache: MessageFns<CMsgSerializedSOCache_Cache> = {
  encode(message: CMsgSerializedSOCache_Cache, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).uint32(message.type);
    }
    if (message.id !== "0") {
      writer.uint32(16).uint64(message.id);
    }
    for (const v of message.versions) {
      CMsgSerializedSOCache_Cache_Version.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.typeCaches) {
      CMsgSerializedSOCache_TypeCache.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSerializedSOCache_Cache {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSerializedSOCache_Cache();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.versions.push(CMsgSerializedSOCache_Cache_Version.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.typeCaches.push(CMsgSerializedSOCache_TypeCache.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSerializedSOCache_Cache {
    return {
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
      versions: globalThis.Array.isArray(object?.versions)
        ? object.versions.map((e: any) => CMsgSerializedSOCache_Cache_Version.fromJSON(e))
        : [],
      typeCaches: globalThis.Array.isArray(object?.typeCaches)
        ? object.typeCaches.map((e: any) => CMsgSerializedSOCache_TypeCache.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSerializedSOCache_Cache): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.id !== "0") {
      obj.id = message.id;
    }
    if (message.versions?.length) {
      obj.versions = message.versions.map((e) => CMsgSerializedSOCache_Cache_Version.toJSON(e));
    }
    if (message.typeCaches?.length) {
      obj.typeCaches = message.typeCaches.map((e) => CMsgSerializedSOCache_TypeCache.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSerializedSOCache_Cache>): CMsgSerializedSOCache_Cache {
    return CMsgSerializedSOCache_Cache.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSerializedSOCache_Cache>): CMsgSerializedSOCache_Cache {
    const message = createBaseCMsgSerializedSOCache_Cache();
    message.type = object.type ?? 0;
    message.id = object.id ?? "0";
    message.versions = object.versions?.map((e) => CMsgSerializedSOCache_Cache_Version.fromPartial(e)) || [];
    message.typeCaches = object.typeCaches?.map((e) => CMsgSerializedSOCache_TypeCache.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSerializedSOCache_Cache_Version(): CMsgSerializedSOCache_Cache_Version {
  return { service: 0, version: "0" };
}

export const CMsgSerializedSOCache_Cache_Version: MessageFns<CMsgSerializedSOCache_Cache_Version> = {
  encode(message: CMsgSerializedSOCache_Cache_Version, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== 0) {
      writer.uint32(8).uint32(message.service);
    }
    if (message.version !== "0") {
      writer.uint32(16).uint64(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSerializedSOCache_Cache_Version {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSerializedSOCache_Cache_Version();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.service = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.version = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSerializedSOCache_Cache_Version {
    return {
      service: isSet(object.service) ? globalThis.Number(object.service) : 0,
      version: isSet(object.version) ? globalThis.String(object.version) : "0",
    };
  },

  toJSON(message: CMsgSerializedSOCache_Cache_Version): unknown {
    const obj: any = {};
    if (message.service !== 0) {
      obj.service = Math.round(message.service);
    }
    if (message.version !== "0") {
      obj.version = message.version;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSerializedSOCache_Cache_Version>): CMsgSerializedSOCache_Cache_Version {
    return CMsgSerializedSOCache_Cache_Version.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSerializedSOCache_Cache_Version>): CMsgSerializedSOCache_Cache_Version {
    const message = createBaseCMsgSerializedSOCache_Cache_Version();
    message.service = object.service ?? 0;
    message.version = object.version ?? "0";
    return message;
  },
};

function createBaseCMsgGCToClientPollConvarRequest(): CMsgGCToClientPollConvarRequest {
  return { convarName: "", pollId: 0 };
}

export const CMsgGCToClientPollConvarRequest: MessageFns<CMsgGCToClientPollConvarRequest> = {
  encode(message: CMsgGCToClientPollConvarRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.convarName !== "") {
      writer.uint32(10).string(message.convarName);
    }
    if (message.pollId !== 0) {
      writer.uint32(16).uint32(message.pollId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToClientPollConvarRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientPollConvarRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.convarName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pollId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientPollConvarRequest {
    return {
      convarName: isSet(object.convarName) ? globalThis.String(object.convarName) : "",
      pollId: isSet(object.pollId) ? globalThis.Number(object.pollId) : 0,
    };
  },

  toJSON(message: CMsgGCToClientPollConvarRequest): unknown {
    const obj: any = {};
    if (message.convarName !== "") {
      obj.convarName = message.convarName;
    }
    if (message.pollId !== 0) {
      obj.pollId = Math.round(message.pollId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToClientPollConvarRequest>): CMsgGCToClientPollConvarRequest {
    return CMsgGCToClientPollConvarRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToClientPollConvarRequest>): CMsgGCToClientPollConvarRequest {
    const message = createBaseCMsgGCToClientPollConvarRequest();
    message.convarName = object.convarName ?? "";
    message.pollId = object.pollId ?? 0;
    return message;
  },
};

function createBaseCMsgGCToClientPollConvarResponse(): CMsgGCToClientPollConvarResponse {
  return { pollId: 0, convarValue: "" };
}

export const CMsgGCToClientPollConvarResponse: MessageFns<CMsgGCToClientPollConvarResponse> = {
  encode(message: CMsgGCToClientPollConvarResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pollId !== 0) {
      writer.uint32(8).uint32(message.pollId);
    }
    if (message.convarValue !== "") {
      writer.uint32(18).string(message.convarValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToClientPollConvarResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientPollConvarResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pollId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.convarValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientPollConvarResponse {
    return {
      pollId: isSet(object.pollId) ? globalThis.Number(object.pollId) : 0,
      convarValue: isSet(object.convarValue) ? globalThis.String(object.convarValue) : "",
    };
  },

  toJSON(message: CMsgGCToClientPollConvarResponse): unknown {
    const obj: any = {};
    if (message.pollId !== 0) {
      obj.pollId = Math.round(message.pollId);
    }
    if (message.convarValue !== "") {
      obj.convarValue = message.convarValue;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToClientPollConvarResponse>): CMsgGCToClientPollConvarResponse {
    return CMsgGCToClientPollConvarResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToClientPollConvarResponse>): CMsgGCToClientPollConvarResponse {
    const message = createBaseCMsgGCToClientPollConvarResponse();
    message.pollId = object.pollId ?? 0;
    message.convarValue = object.convarValue ?? "";
    return message;
  },
};

function createBaseCGCMsgCompressedMsgToClient(): CGCMsgCompressedMsgToClient {
  return { msgId: 0, compressedMsg: Buffer.alloc(0) };
}

export const CGCMsgCompressedMsgToClient: MessageFns<CGCMsgCompressedMsgToClient> = {
  encode(message: CGCMsgCompressedMsgToClient, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msgId !== 0) {
      writer.uint32(8).uint32(message.msgId);
    }
    if (message.compressedMsg.length !== 0) {
      writer.uint32(18).bytes(message.compressedMsg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CGCMsgCompressedMsgToClient {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCMsgCompressedMsgToClient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.msgId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.compressedMsg = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCMsgCompressedMsgToClient {
    return {
      msgId: isSet(object.msgId) ? globalThis.Number(object.msgId) : 0,
      compressedMsg: isSet(object.compressedMsg) ? Buffer.from(bytesFromBase64(object.compressedMsg)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CGCMsgCompressedMsgToClient): unknown {
    const obj: any = {};
    if (message.msgId !== 0) {
      obj.msgId = Math.round(message.msgId);
    }
    if (message.compressedMsg.length !== 0) {
      obj.compressedMsg = base64FromBytes(message.compressedMsg);
    }
    return obj;
  },

  create(base?: DeepPartial<CGCMsgCompressedMsgToClient>): CGCMsgCompressedMsgToClient {
    return CGCMsgCompressedMsgToClient.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCMsgCompressedMsgToClient>): CGCMsgCompressedMsgToClient {
    const message = createBaseCGCMsgCompressedMsgToClient();
    message.msgId = object.msgId ?? 0;
    message.compressedMsg = object.compressedMsg ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCMsgGCToGCMasterBroadcastMessage(): CMsgGCToGCMasterBroadcastMessage {
  return { usersPerSecond: 0, sendToUsers: false, sendToServers: false, msgId: 0, msgData: Buffer.alloc(0) };
}

export const CMsgGCToGCMasterBroadcastMessage: MessageFns<CMsgGCToGCMasterBroadcastMessage> = {
  encode(message: CMsgGCToGCMasterBroadcastMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.usersPerSecond !== 0) {
      writer.uint32(8).uint32(message.usersPerSecond);
    }
    if (message.sendToUsers !== false) {
      writer.uint32(16).bool(message.sendToUsers);
    }
    if (message.sendToServers !== false) {
      writer.uint32(24).bool(message.sendToServers);
    }
    if (message.msgId !== 0) {
      writer.uint32(32).uint32(message.msgId);
    }
    if (message.msgData.length !== 0) {
      writer.uint32(42).bytes(message.msgData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCMasterBroadcastMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCMasterBroadcastMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.usersPerSecond = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sendToUsers = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sendToServers = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.msgId = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.msgData = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCMasterBroadcastMessage {
    return {
      usersPerSecond: isSet(object.usersPerSecond) ? globalThis.Number(object.usersPerSecond) : 0,
      sendToUsers: isSet(object.sendToUsers) ? globalThis.Boolean(object.sendToUsers) : false,
      sendToServers: isSet(object.sendToServers) ? globalThis.Boolean(object.sendToServers) : false,
      msgId: isSet(object.msgId) ? globalThis.Number(object.msgId) : 0,
      msgData: isSet(object.msgData) ? Buffer.from(bytesFromBase64(object.msgData)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CMsgGCToGCMasterBroadcastMessage): unknown {
    const obj: any = {};
    if (message.usersPerSecond !== 0) {
      obj.usersPerSecond = Math.round(message.usersPerSecond);
    }
    if (message.sendToUsers !== false) {
      obj.sendToUsers = message.sendToUsers;
    }
    if (message.sendToServers !== false) {
      obj.sendToServers = message.sendToServers;
    }
    if (message.msgId !== 0) {
      obj.msgId = Math.round(message.msgId);
    }
    if (message.msgData.length !== 0) {
      obj.msgData = base64FromBytes(message.msgData);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCMasterBroadcastMessage>): CMsgGCToGCMasterBroadcastMessage {
    return CMsgGCToGCMasterBroadcastMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToGCMasterBroadcastMessage>): CMsgGCToGCMasterBroadcastMessage {
    const message = createBaseCMsgGCToGCMasterBroadcastMessage();
    message.usersPerSecond = object.usersPerSecond ?? 0;
    message.sendToUsers = object.sendToUsers ?? false;
    message.sendToServers = object.sendToServers ?? false;
    message.msgId = object.msgId ?? 0;
    message.msgData = object.msgData ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCMsgGCToGCMasterSubscribeToCache(): CMsgGCToGCMasterSubscribeToCache {
  return { soidType: 0, soidId: "0", accountIds: [], steamIds: [] };
}

export const CMsgGCToGCMasterSubscribeToCache: MessageFns<CMsgGCToGCMasterSubscribeToCache> = {
  encode(message: CMsgGCToGCMasterSubscribeToCache, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.soidType !== 0) {
      writer.uint32(8).uint32(message.soidType);
    }
    if (message.soidId !== "0") {
      writer.uint32(17).fixed64(message.soidId);
    }
    writer.uint32(26).fork();
    for (const v of message.accountIds) {
      writer.uint32(v);
    }
    writer.join();
    writer.uint32(34).fork();
    for (const v of message.steamIds) {
      writer.fixed64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCMasterSubscribeToCache {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCMasterSubscribeToCache();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.soidType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.soidId = reader.fixed64().toString();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.accountIds.push(reader.uint32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.accountIds.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag === 33) {
            message.steamIds.push(reader.fixed64().toString());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.steamIds.push(reader.fixed64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCMasterSubscribeToCache {
    return {
      soidType: isSet(object.soidType) ? globalThis.Number(object.soidType) : 0,
      soidId: isSet(object.soidId) ? globalThis.String(object.soidId) : "0",
      accountIds: globalThis.Array.isArray(object?.accountIds)
        ? object.accountIds.map((e: any) => globalThis.Number(e))
        : [],
      steamIds: globalThis.Array.isArray(object?.steamIds) ? object.steamIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CMsgGCToGCMasterSubscribeToCache): unknown {
    const obj: any = {};
    if (message.soidType !== 0) {
      obj.soidType = Math.round(message.soidType);
    }
    if (message.soidId !== "0") {
      obj.soidId = message.soidId;
    }
    if (message.accountIds?.length) {
      obj.accountIds = message.accountIds.map((e) => Math.round(e));
    }
    if (message.steamIds?.length) {
      obj.steamIds = message.steamIds;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCMasterSubscribeToCache>): CMsgGCToGCMasterSubscribeToCache {
    return CMsgGCToGCMasterSubscribeToCache.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToGCMasterSubscribeToCache>): CMsgGCToGCMasterSubscribeToCache {
    const message = createBaseCMsgGCToGCMasterSubscribeToCache();
    message.soidType = object.soidType ?? 0;
    message.soidId = object.soidId ?? "0";
    message.accountIds = object.accountIds?.map((e) => e) || [];
    message.steamIds = object.steamIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgGCToGCMasterSubscribeToCacheResponse(): CMsgGCToGCMasterSubscribeToCacheResponse {
  return {};
}

export const CMsgGCToGCMasterSubscribeToCacheResponse: MessageFns<CMsgGCToGCMasterSubscribeToCacheResponse> = {
  encode(_: CMsgGCToGCMasterSubscribeToCacheResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCMasterSubscribeToCacheResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCMasterSubscribeToCacheResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgGCToGCMasterSubscribeToCacheResponse {
    return {};
  },

  toJSON(_: CMsgGCToGCMasterSubscribeToCacheResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCMasterSubscribeToCacheResponse>): CMsgGCToGCMasterSubscribeToCacheResponse {
    return CMsgGCToGCMasterSubscribeToCacheResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgGCToGCMasterSubscribeToCacheResponse>): CMsgGCToGCMasterSubscribeToCacheResponse {
    const message = createBaseCMsgGCToGCMasterSubscribeToCacheResponse();
    return message;
  },
};

function createBaseCMsgGCToGCMasterSubscribeToCacheAsync(): CMsgGCToGCMasterSubscribeToCacheAsync {
  return { subscribeMsg: undefined };
}

export const CMsgGCToGCMasterSubscribeToCacheAsync: MessageFns<CMsgGCToGCMasterSubscribeToCacheAsync> = {
  encode(message: CMsgGCToGCMasterSubscribeToCacheAsync, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscribeMsg !== undefined) {
      CMsgGCToGCMasterSubscribeToCache.encode(message.subscribeMsg, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCMasterSubscribeToCacheAsync {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCMasterSubscribeToCacheAsync();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subscribeMsg = CMsgGCToGCMasterSubscribeToCache.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCMasterSubscribeToCacheAsync {
    return {
      subscribeMsg: isSet(object.subscribeMsg)
        ? CMsgGCToGCMasterSubscribeToCache.fromJSON(object.subscribeMsg)
        : undefined,
    };
  },

  toJSON(message: CMsgGCToGCMasterSubscribeToCacheAsync): unknown {
    const obj: any = {};
    if (message.subscribeMsg !== undefined) {
      obj.subscribeMsg = CMsgGCToGCMasterSubscribeToCache.toJSON(message.subscribeMsg);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCMasterSubscribeToCacheAsync>): CMsgGCToGCMasterSubscribeToCacheAsync {
    return CMsgGCToGCMasterSubscribeToCacheAsync.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToGCMasterSubscribeToCacheAsync>): CMsgGCToGCMasterSubscribeToCacheAsync {
    const message = createBaseCMsgGCToGCMasterSubscribeToCacheAsync();
    message.subscribeMsg = (object.subscribeMsg !== undefined && object.subscribeMsg !== null)
      ? CMsgGCToGCMasterSubscribeToCache.fromPartial(object.subscribeMsg)
      : undefined;
    return message;
  },
};

function createBaseCMsgGCToGCMasterUnsubscribeFromCache(): CMsgGCToGCMasterUnsubscribeFromCache {
  return { soidType: 0, soidId: "0", accountIds: [], steamIds: [] };
}

export const CMsgGCToGCMasterUnsubscribeFromCache: MessageFns<CMsgGCToGCMasterUnsubscribeFromCache> = {
  encode(message: CMsgGCToGCMasterUnsubscribeFromCache, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.soidType !== 0) {
      writer.uint32(8).uint32(message.soidType);
    }
    if (message.soidId !== "0") {
      writer.uint32(17).fixed64(message.soidId);
    }
    writer.uint32(26).fork();
    for (const v of message.accountIds) {
      writer.uint32(v);
    }
    writer.join();
    writer.uint32(34).fork();
    for (const v of message.steamIds) {
      writer.fixed64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCMasterUnsubscribeFromCache {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCMasterUnsubscribeFromCache();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.soidType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.soidId = reader.fixed64().toString();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.accountIds.push(reader.uint32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.accountIds.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag === 33) {
            message.steamIds.push(reader.fixed64().toString());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.steamIds.push(reader.fixed64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCMasterUnsubscribeFromCache {
    return {
      soidType: isSet(object.soidType) ? globalThis.Number(object.soidType) : 0,
      soidId: isSet(object.soidId) ? globalThis.String(object.soidId) : "0",
      accountIds: globalThis.Array.isArray(object?.accountIds)
        ? object.accountIds.map((e: any) => globalThis.Number(e))
        : [],
      steamIds: globalThis.Array.isArray(object?.steamIds) ? object.steamIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CMsgGCToGCMasterUnsubscribeFromCache): unknown {
    const obj: any = {};
    if (message.soidType !== 0) {
      obj.soidType = Math.round(message.soidType);
    }
    if (message.soidId !== "0") {
      obj.soidId = message.soidId;
    }
    if (message.accountIds?.length) {
      obj.accountIds = message.accountIds.map((e) => Math.round(e));
    }
    if (message.steamIds?.length) {
      obj.steamIds = message.steamIds;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCMasterUnsubscribeFromCache>): CMsgGCToGCMasterUnsubscribeFromCache {
    return CMsgGCToGCMasterUnsubscribeFromCache.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToGCMasterUnsubscribeFromCache>): CMsgGCToGCMasterUnsubscribeFromCache {
    const message = createBaseCMsgGCToGCMasterUnsubscribeFromCache();
    message.soidType = object.soidType ?? 0;
    message.soidId = object.soidId ?? "0";
    message.accountIds = object.accountIds?.map((e) => e) || [];
    message.steamIds = object.steamIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgGCToGCMasterDestroyCache(): CMsgGCToGCMasterDestroyCache {
  return { soidType: 0, soidId: "0" };
}

export const CMsgGCToGCMasterDestroyCache: MessageFns<CMsgGCToGCMasterDestroyCache> = {
  encode(message: CMsgGCToGCMasterDestroyCache, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.soidType !== 0) {
      writer.uint32(8).uint32(message.soidType);
    }
    if (message.soidId !== "0") {
      writer.uint32(17).fixed64(message.soidId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToGCMasterDestroyCache {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCMasterDestroyCache();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.soidType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.soidId = reader.fixed64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCMasterDestroyCache {
    return {
      soidType: isSet(object.soidType) ? globalThis.Number(object.soidType) : 0,
      soidId: isSet(object.soidId) ? globalThis.String(object.soidId) : "0",
    };
  },

  toJSON(message: CMsgGCToGCMasterDestroyCache): unknown {
    const obj: any = {};
    if (message.soidType !== 0) {
      obj.soidType = Math.round(message.soidType);
    }
    if (message.soidId !== "0") {
      obj.soidId = message.soidId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCMasterDestroyCache>): CMsgGCToGCMasterDestroyCache {
    return CMsgGCToGCMasterDestroyCache.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToGCMasterDestroyCache>): CMsgGCToGCMasterDestroyCache {
    const message = createBaseCMsgGCToGCMasterDestroyCache();
    message.soidType = object.soidType ?? 0;
    message.soidId = object.soidId ?? "0";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
