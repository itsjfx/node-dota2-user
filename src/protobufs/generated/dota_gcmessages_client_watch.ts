// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.30.1
// source: dota_gcmessages_client_watch.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { CMsgDOTAMatchMinimal } from "./dota_gcmessages_common";

export interface CSourceTVGameSmall {
  activateTime: number;
  deactivateTime: number;
  serverSteamId: string;
  lobbyId: string;
  leagueId: number;
  lobbyType: number;
  gameTime: number;
  delay: number;
  spectators: number;
  gameMode: number;
  averageMmr: number;
  matchId: string;
  seriesId: number;
  teamNameRadiant: string;
  teamNameDire: string;
  teamLogoRadiant: string;
  teamLogoDire: string;
  teamIdRadiant: number;
  teamIdDire: number;
  sortScore: number;
  lastUpdateTime: number;
  radiantLead: number;
  radiantScore: number;
  direScore: number;
  players: CSourceTVGameSmall_Player[];
  buildingState: number;
  weekendTourneyTournamentId: number;
  weekendTourneyDivision: number;
  weekendTourneySkillLevel: number;
  weekendTourneyBracketRound: number;
  customGameDifficulty: number;
}

export interface CSourceTVGameSmall_Player {
  accountId: number;
  heroId: number;
  teamSlot: number;
  team: number;
}

export interface CMsgClientToGCFindTopSourceTVGames {
  searchKey: string;
  leagueId: number;
  heroId: number;
  startGame: number;
  gameListIndex: number;
  lobbyIds: string[];
}

export interface CMsgGCToClientFindTopSourceTVGamesResponse {
  searchKey: string;
  leagueId: number;
  heroId: number;
  startGame: number;
  numGames: number;
  gameListIndex: number;
  gameList: CSourceTVGameSmall[];
  specificGames: boolean;
  botGame: CSourceTVGameSmall | undefined;
}

export interface CMsgGCToClientTopWeekendTourneyGames {
  liveGames: CSourceTVGameSmall[];
}

export interface CMsgClientToGCTopLeagueMatchesRequest {
}

export interface CMsgClientToGCTopFriendMatchesRequest {
}

export interface CMsgClientToGCMatchesMinimalRequest {
  matchIds: string[];
}

export interface CMsgClientToGCMatchesMinimalResponse {
  matches: CMsgDOTAMatchMinimal[];
  lastMatch: boolean;
}

export interface CMsgGCToClientTopLeagueMatchesResponse {
  matches: CMsgDOTAMatchMinimal[];
}

export interface CMsgGCToClientTopFriendMatchesResponse {
  matches: CMsgDOTAMatchMinimal[];
}

export interface CMsgSpectateFriendGame {
  steamId: string;
  live: boolean;
}

export interface CMsgSpectateFriendGameResponse {
  serverSteamid: string;
  watchLiveResult: CMsgSpectateFriendGameResponse_EWatchLiveResult;
}

export enum CMsgSpectateFriendGameResponse_EWatchLiveResult {
  SUCCESS = 0,
  ERROR_GENERIC = 1,
  ERROR_NO_PLUS = 2,
  ERROR_NOT_FRIENDS = 3,
  ERROR_LOBBY_NOT_FOUND = 4,
  ERROR_SPECTATOR_IN_A_LOBBY = 5,
  ERROR_LOBBY_IS_LAN = 6,
  ERROR_WRONG_LOBBY_TYPE = 7,
  ERROR_WRONG_LOBBY_STATE = 8,
  ERROR_PLAYER_NOT_PLAYER = 9,
  ERROR_TOO_MANY_SPECTATORS = 10,
  ERROR_SPECTATOR_SWITCHED_TEAMS = 11,
  ERROR_FRIENDS_ON_BOTH_SIDES = 12,
  ERROR_SPECTATOR_IN_THIS_LOBBY = 13,
  ERROR_LOBBY_IS_LEAGUE = 14,
}

export function cMsgSpectateFriendGameResponse_EWatchLiveResultFromJSON(
  object: any,
): CMsgSpectateFriendGameResponse_EWatchLiveResult {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CMsgSpectateFriendGameResponse_EWatchLiveResult.SUCCESS;
    case 1:
    case "ERROR_GENERIC":
      return CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_GENERIC;
    case 2:
    case "ERROR_NO_PLUS":
      return CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_NO_PLUS;
    case 3:
    case "ERROR_NOT_FRIENDS":
      return CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_NOT_FRIENDS;
    case 4:
    case "ERROR_LOBBY_NOT_FOUND":
      return CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_LOBBY_NOT_FOUND;
    case 5:
    case "ERROR_SPECTATOR_IN_A_LOBBY":
      return CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_SPECTATOR_IN_A_LOBBY;
    case 6:
    case "ERROR_LOBBY_IS_LAN":
      return CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_LOBBY_IS_LAN;
    case 7:
    case "ERROR_WRONG_LOBBY_TYPE":
      return CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_WRONG_LOBBY_TYPE;
    case 8:
    case "ERROR_WRONG_LOBBY_STATE":
      return CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_WRONG_LOBBY_STATE;
    case 9:
    case "ERROR_PLAYER_NOT_PLAYER":
      return CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_PLAYER_NOT_PLAYER;
    case 10:
    case "ERROR_TOO_MANY_SPECTATORS":
      return CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_TOO_MANY_SPECTATORS;
    case 11:
    case "ERROR_SPECTATOR_SWITCHED_TEAMS":
      return CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_SPECTATOR_SWITCHED_TEAMS;
    case 12:
    case "ERROR_FRIENDS_ON_BOTH_SIDES":
      return CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_FRIENDS_ON_BOTH_SIDES;
    case 13:
    case "ERROR_SPECTATOR_IN_THIS_LOBBY":
      return CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_SPECTATOR_IN_THIS_LOBBY;
    case 14:
    case "ERROR_LOBBY_IS_LEAGUE":
      return CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_LOBBY_IS_LEAGUE;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgSpectateFriendGameResponse_EWatchLiveResult",
      );
  }
}

export function cMsgSpectateFriendGameResponse_EWatchLiveResultToJSON(
  object: CMsgSpectateFriendGameResponse_EWatchLiveResult,
): string {
  switch (object) {
    case CMsgSpectateFriendGameResponse_EWatchLiveResult.SUCCESS:
      return "SUCCESS";
    case CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_GENERIC:
      return "ERROR_GENERIC";
    case CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_NO_PLUS:
      return "ERROR_NO_PLUS";
    case CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_NOT_FRIENDS:
      return "ERROR_NOT_FRIENDS";
    case CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_LOBBY_NOT_FOUND:
      return "ERROR_LOBBY_NOT_FOUND";
    case CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_SPECTATOR_IN_A_LOBBY:
      return "ERROR_SPECTATOR_IN_A_LOBBY";
    case CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_LOBBY_IS_LAN:
      return "ERROR_LOBBY_IS_LAN";
    case CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_WRONG_LOBBY_TYPE:
      return "ERROR_WRONG_LOBBY_TYPE";
    case CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_WRONG_LOBBY_STATE:
      return "ERROR_WRONG_LOBBY_STATE";
    case CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_PLAYER_NOT_PLAYER:
      return "ERROR_PLAYER_NOT_PLAYER";
    case CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_TOO_MANY_SPECTATORS:
      return "ERROR_TOO_MANY_SPECTATORS";
    case CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_SPECTATOR_SWITCHED_TEAMS:
      return "ERROR_SPECTATOR_SWITCHED_TEAMS";
    case CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_FRIENDS_ON_BOTH_SIDES:
      return "ERROR_FRIENDS_ON_BOTH_SIDES";
    case CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_SPECTATOR_IN_THIS_LOBBY:
      return "ERROR_SPECTATOR_IN_THIS_LOBBY";
    case CMsgSpectateFriendGameResponse_EWatchLiveResult.ERROR_LOBBY_IS_LEAGUE:
      return "ERROR_LOBBY_IS_LEAGUE";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgSpectateFriendGameResponse_EWatchLiveResult",
      );
  }
}

export interface CDOTAReplayDownloadInfo {
  match: CMsgDOTAMatchMinimal | undefined;
  title: string;
  description: string;
  size: number;
  tags: string[];
  existsOnDisk: boolean;
}

export interface CDOTAReplayDownloadInfo_Highlight {
  timestamp: number;
  description: string;
}

export interface CMsgWatchGame {
  serverSteamid: string;
  clientVersion: number;
  watchServerSteamid: string;
  lobbyId: string;
  regions: number[];
}

export interface CMsgCancelWatchGame {
}

export interface CMsgWatchGameResponse {
  watchGameResult: CMsgWatchGameResponse_WatchGameResult;
  sourceTvPublicAddr: number;
  sourceTvPrivateAddr: number;
  sourceTvPort: number;
  gameServerSteamid: string;
  watchServerSteamid: string;
  watchTvUniqueSecretCode: string;
}

export enum CMsgWatchGameResponse_WatchGameResult {
  PENDING = 0,
  READY = 1,
  GAMESERVERNOTFOUND = 2,
  UNAVAILABLE = 3,
  CANCELLED = 4,
  INCOMPATIBLEVERSION = 5,
  MISSINGLEAGUESUBSCRIPTION = 6,
  LOBBYNOTFOUND = 7,
}

export function cMsgWatchGameResponse_WatchGameResultFromJSON(object: any): CMsgWatchGameResponse_WatchGameResult {
  switch (object) {
    case 0:
    case "PENDING":
      return CMsgWatchGameResponse_WatchGameResult.PENDING;
    case 1:
    case "READY":
      return CMsgWatchGameResponse_WatchGameResult.READY;
    case 2:
    case "GAMESERVERNOTFOUND":
      return CMsgWatchGameResponse_WatchGameResult.GAMESERVERNOTFOUND;
    case 3:
    case "UNAVAILABLE":
      return CMsgWatchGameResponse_WatchGameResult.UNAVAILABLE;
    case 4:
    case "CANCELLED":
      return CMsgWatchGameResponse_WatchGameResult.CANCELLED;
    case 5:
    case "INCOMPATIBLEVERSION":
      return CMsgWatchGameResponse_WatchGameResult.INCOMPATIBLEVERSION;
    case 6:
    case "MISSINGLEAGUESUBSCRIPTION":
      return CMsgWatchGameResponse_WatchGameResult.MISSINGLEAGUESUBSCRIPTION;
    case 7:
    case "LOBBYNOTFOUND":
      return CMsgWatchGameResponse_WatchGameResult.LOBBYNOTFOUND;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgWatchGameResponse_WatchGameResult",
      );
  }
}

export function cMsgWatchGameResponse_WatchGameResultToJSON(object: CMsgWatchGameResponse_WatchGameResult): string {
  switch (object) {
    case CMsgWatchGameResponse_WatchGameResult.PENDING:
      return "PENDING";
    case CMsgWatchGameResponse_WatchGameResult.READY:
      return "READY";
    case CMsgWatchGameResponse_WatchGameResult.GAMESERVERNOTFOUND:
      return "GAMESERVERNOTFOUND";
    case CMsgWatchGameResponse_WatchGameResult.UNAVAILABLE:
      return "UNAVAILABLE";
    case CMsgWatchGameResponse_WatchGameResult.CANCELLED:
      return "CANCELLED";
    case CMsgWatchGameResponse_WatchGameResult.INCOMPATIBLEVERSION:
      return "INCOMPATIBLEVERSION";
    case CMsgWatchGameResponse_WatchGameResult.MISSINGLEAGUESUBSCRIPTION:
      return "MISSINGLEAGUESUBSCRIPTION";
    case CMsgWatchGameResponse_WatchGameResult.LOBBYNOTFOUND:
      return "LOBBYNOTFOUND";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgWatchGameResponse_WatchGameResult",
      );
  }
}

export interface CMsgPartyLeaderWatchGamePrompt {
  gameServerSteamid: string;
}

export interface CDOTABroadcasterInfo {
  accountId: number;
  serverSteamId: string;
  live: boolean;
  teamNameRadiant: string;
  teamNameDire: string;
  seriesGame: number;
  upcomingBroadcastTimestamp: number;
  allowLiveVideo: boolean;
  nodeType: number;
  nodeName: string;
}

export interface CMsgDOTASeries {
  seriesId: number;
  seriesType: number;
  team1: CMsgDOTASeries_TeamInfo | undefined;
  team2: CMsgDOTASeries_TeamInfo | undefined;
  matchMinimal: CMsgDOTAMatchMinimal[];
  liveGame: CMsgDOTASeries_LiveGame | undefined;
}

export interface CMsgDOTASeries_TeamInfo {
  teamId: number;
  teamName: string;
  teamLogoUrl: string;
  wagerCount: number;
}

export interface CMsgDOTASeries_LiveGame {
  serverSteamId: string;
  teamRadiant: CMsgDOTASeries_TeamInfo | undefined;
  teamDire: CMsgDOTASeries_TeamInfo | undefined;
  teamRadiantScore: number;
  teamDireScore: number;
}

function createBaseCSourceTVGameSmall(): CSourceTVGameSmall {
  return {
    activateTime: 0,
    deactivateTime: 0,
    serverSteamId: "0",
    lobbyId: "0",
    leagueId: 0,
    lobbyType: 0,
    gameTime: 0,
    delay: 0,
    spectators: 0,
    gameMode: 0,
    averageMmr: 0,
    matchId: "0",
    seriesId: 0,
    teamNameRadiant: "",
    teamNameDire: "",
    teamLogoRadiant: "0",
    teamLogoDire: "0",
    teamIdRadiant: 0,
    teamIdDire: 0,
    sortScore: 0,
    lastUpdateTime: 0,
    radiantLead: 0,
    radiantScore: 0,
    direScore: 0,
    players: [],
    buildingState: 0,
    weekendTourneyTournamentId: 0,
    weekendTourneyDivision: 0,
    weekendTourneySkillLevel: 0,
    weekendTourneyBracketRound: 0,
    customGameDifficulty: 0,
  };
}

export const CSourceTVGameSmall: MessageFns<CSourceTVGameSmall> = {
  encode(message: CSourceTVGameSmall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.activateTime !== 0) {
      writer.uint32(8).uint32(message.activateTime);
    }
    if (message.deactivateTime !== 0) {
      writer.uint32(16).uint32(message.deactivateTime);
    }
    if (message.serverSteamId !== "0") {
      writer.uint32(24).uint64(message.serverSteamId);
    }
    if (message.lobbyId !== "0") {
      writer.uint32(32).uint64(message.lobbyId);
    }
    if (message.leagueId !== 0) {
      writer.uint32(40).uint32(message.leagueId);
    }
    if (message.lobbyType !== 0) {
      writer.uint32(48).uint32(message.lobbyType);
    }
    if (message.gameTime !== 0) {
      writer.uint32(56).int32(message.gameTime);
    }
    if (message.delay !== 0) {
      writer.uint32(64).uint32(message.delay);
    }
    if (message.spectators !== 0) {
      writer.uint32(72).uint32(message.spectators);
    }
    if (message.gameMode !== 0) {
      writer.uint32(80).uint32(message.gameMode);
    }
    if (message.averageMmr !== 0) {
      writer.uint32(88).uint32(message.averageMmr);
    }
    if (message.matchId !== "0") {
      writer.uint32(96).uint64(message.matchId);
    }
    if (message.seriesId !== 0) {
      writer.uint32(104).uint32(message.seriesId);
    }
    if (message.teamNameRadiant !== "") {
      writer.uint32(122).string(message.teamNameRadiant);
    }
    if (message.teamNameDire !== "") {
      writer.uint32(130).string(message.teamNameDire);
    }
    if (message.teamLogoRadiant !== "0") {
      writer.uint32(193).fixed64(message.teamLogoRadiant);
    }
    if (message.teamLogoDire !== "0") {
      writer.uint32(201).fixed64(message.teamLogoDire);
    }
    if (message.teamIdRadiant !== 0) {
      writer.uint32(240).uint32(message.teamIdRadiant);
    }
    if (message.teamIdDire !== 0) {
      writer.uint32(248).uint32(message.teamIdDire);
    }
    if (message.sortScore !== 0) {
      writer.uint32(136).uint32(message.sortScore);
    }
    if (message.lastUpdateTime !== 0) {
      writer.uint32(149).float(message.lastUpdateTime);
    }
    if (message.radiantLead !== 0) {
      writer.uint32(152).int32(message.radiantLead);
    }
    if (message.radiantScore !== 0) {
      writer.uint32(160).uint32(message.radiantScore);
    }
    if (message.direScore !== 0) {
      writer.uint32(168).uint32(message.direScore);
    }
    for (const v of message.players) {
      CSourceTVGameSmall_Player.encode(v!, writer.uint32(178).fork()).join();
    }
    if (message.buildingState !== 0) {
      writer.uint32(189).fixed32(message.buildingState);
    }
    if (message.weekendTourneyTournamentId !== 0) {
      writer.uint32(208).uint32(message.weekendTourneyTournamentId);
    }
    if (message.weekendTourneyDivision !== 0) {
      writer.uint32(216).uint32(message.weekendTourneyDivision);
    }
    if (message.weekendTourneySkillLevel !== 0) {
      writer.uint32(224).uint32(message.weekendTourneySkillLevel);
    }
    if (message.weekendTourneyBracketRound !== 0) {
      writer.uint32(232).uint32(message.weekendTourneyBracketRound);
    }
    if (message.customGameDifficulty !== 0) {
      writer.uint32(256).uint32(message.customGameDifficulty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CSourceTVGameSmall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSourceTVGameSmall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.activateTime = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.deactivateTime = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.serverSteamId = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lobbyId = reader.uint64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.lobbyType = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.gameTime = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.delay = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.spectators = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.gameMode = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.averageMmr = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.matchId = reader.uint64().toString();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.seriesId = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.teamNameRadiant = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.teamNameDire = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 193) {
            break;
          }

          message.teamLogoRadiant = reader.fixed64().toString();
          continue;
        }
        case 25: {
          if (tag !== 201) {
            break;
          }

          message.teamLogoDire = reader.fixed64().toString();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.teamIdRadiant = reader.uint32();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.teamIdDire = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.sortScore = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 149) {
            break;
          }

          message.lastUpdateTime = reader.float();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.radiantLead = reader.int32();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.radiantScore = reader.uint32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.direScore = reader.uint32();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.players.push(CSourceTVGameSmall_Player.decode(reader, reader.uint32()));
          continue;
        }
        case 23: {
          if (tag !== 189) {
            break;
          }

          message.buildingState = reader.fixed32();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.weekendTourneyTournamentId = reader.uint32();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.weekendTourneyDivision = reader.uint32();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.weekendTourneySkillLevel = reader.uint32();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.weekendTourneyBracketRound = reader.uint32();
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.customGameDifficulty = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSourceTVGameSmall {
    return {
      activateTime: isSet(object.activateTime) ? globalThis.Number(object.activateTime) : 0,
      deactivateTime: isSet(object.deactivateTime) ? globalThis.Number(object.deactivateTime) : 0,
      serverSteamId: isSet(object.serverSteamId) ? globalThis.String(object.serverSteamId) : "0",
      lobbyId: isSet(object.lobbyId) ? globalThis.String(object.lobbyId) : "0",
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      lobbyType: isSet(object.lobbyType) ? globalThis.Number(object.lobbyType) : 0,
      gameTime: isSet(object.gameTime) ? globalThis.Number(object.gameTime) : 0,
      delay: isSet(object.delay) ? globalThis.Number(object.delay) : 0,
      spectators: isSet(object.spectators) ? globalThis.Number(object.spectators) : 0,
      gameMode: isSet(object.gameMode) ? globalThis.Number(object.gameMode) : 0,
      averageMmr: isSet(object.averageMmr) ? globalThis.Number(object.averageMmr) : 0,
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      seriesId: isSet(object.seriesId) ? globalThis.Number(object.seriesId) : 0,
      teamNameRadiant: isSet(object.teamNameRadiant) ? globalThis.String(object.teamNameRadiant) : "",
      teamNameDire: isSet(object.teamNameDire) ? globalThis.String(object.teamNameDire) : "",
      teamLogoRadiant: isSet(object.teamLogoRadiant) ? globalThis.String(object.teamLogoRadiant) : "0",
      teamLogoDire: isSet(object.teamLogoDire) ? globalThis.String(object.teamLogoDire) : "0",
      teamIdRadiant: isSet(object.teamIdRadiant) ? globalThis.Number(object.teamIdRadiant) : 0,
      teamIdDire: isSet(object.teamIdDire) ? globalThis.Number(object.teamIdDire) : 0,
      sortScore: isSet(object.sortScore) ? globalThis.Number(object.sortScore) : 0,
      lastUpdateTime: isSet(object.lastUpdateTime) ? globalThis.Number(object.lastUpdateTime) : 0,
      radiantLead: isSet(object.radiantLead) ? globalThis.Number(object.radiantLead) : 0,
      radiantScore: isSet(object.radiantScore) ? globalThis.Number(object.radiantScore) : 0,
      direScore: isSet(object.direScore) ? globalThis.Number(object.direScore) : 0,
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CSourceTVGameSmall_Player.fromJSON(e))
        : [],
      buildingState: isSet(object.buildingState) ? globalThis.Number(object.buildingState) : 0,
      weekendTourneyTournamentId: isSet(object.weekendTourneyTournamentId)
        ? globalThis.Number(object.weekendTourneyTournamentId)
        : 0,
      weekendTourneyDivision: isSet(object.weekendTourneyDivision)
        ? globalThis.Number(object.weekendTourneyDivision)
        : 0,
      weekendTourneySkillLevel: isSet(object.weekendTourneySkillLevel)
        ? globalThis.Number(object.weekendTourneySkillLevel)
        : 0,
      weekendTourneyBracketRound: isSet(object.weekendTourneyBracketRound)
        ? globalThis.Number(object.weekendTourneyBracketRound)
        : 0,
      customGameDifficulty: isSet(object.customGameDifficulty) ? globalThis.Number(object.customGameDifficulty) : 0,
    };
  },

  toJSON(message: CSourceTVGameSmall): unknown {
    const obj: any = {};
    if (message.activateTime !== 0) {
      obj.activateTime = Math.round(message.activateTime);
    }
    if (message.deactivateTime !== 0) {
      obj.deactivateTime = Math.round(message.deactivateTime);
    }
    if (message.serverSteamId !== "0") {
      obj.serverSteamId = message.serverSteamId;
    }
    if (message.lobbyId !== "0") {
      obj.lobbyId = message.lobbyId;
    }
    if (message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.lobbyType !== 0) {
      obj.lobbyType = Math.round(message.lobbyType);
    }
    if (message.gameTime !== 0) {
      obj.gameTime = Math.round(message.gameTime);
    }
    if (message.delay !== 0) {
      obj.delay = Math.round(message.delay);
    }
    if (message.spectators !== 0) {
      obj.spectators = Math.round(message.spectators);
    }
    if (message.gameMode !== 0) {
      obj.gameMode = Math.round(message.gameMode);
    }
    if (message.averageMmr !== 0) {
      obj.averageMmr = Math.round(message.averageMmr);
    }
    if (message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.seriesId !== 0) {
      obj.seriesId = Math.round(message.seriesId);
    }
    if (message.teamNameRadiant !== "") {
      obj.teamNameRadiant = message.teamNameRadiant;
    }
    if (message.teamNameDire !== "") {
      obj.teamNameDire = message.teamNameDire;
    }
    if (message.teamLogoRadiant !== "0") {
      obj.teamLogoRadiant = message.teamLogoRadiant;
    }
    if (message.teamLogoDire !== "0") {
      obj.teamLogoDire = message.teamLogoDire;
    }
    if (message.teamIdRadiant !== 0) {
      obj.teamIdRadiant = Math.round(message.teamIdRadiant);
    }
    if (message.teamIdDire !== 0) {
      obj.teamIdDire = Math.round(message.teamIdDire);
    }
    if (message.sortScore !== 0) {
      obj.sortScore = Math.round(message.sortScore);
    }
    if (message.lastUpdateTime !== 0) {
      obj.lastUpdateTime = message.lastUpdateTime;
    }
    if (message.radiantLead !== 0) {
      obj.radiantLead = Math.round(message.radiantLead);
    }
    if (message.radiantScore !== 0) {
      obj.radiantScore = Math.round(message.radiantScore);
    }
    if (message.direScore !== 0) {
      obj.direScore = Math.round(message.direScore);
    }
    if (message.players?.length) {
      obj.players = message.players.map((e) => CSourceTVGameSmall_Player.toJSON(e));
    }
    if (message.buildingState !== 0) {
      obj.buildingState = Math.round(message.buildingState);
    }
    if (message.weekendTourneyTournamentId !== 0) {
      obj.weekendTourneyTournamentId = Math.round(message.weekendTourneyTournamentId);
    }
    if (message.weekendTourneyDivision !== 0) {
      obj.weekendTourneyDivision = Math.round(message.weekendTourneyDivision);
    }
    if (message.weekendTourneySkillLevel !== 0) {
      obj.weekendTourneySkillLevel = Math.round(message.weekendTourneySkillLevel);
    }
    if (message.weekendTourneyBracketRound !== 0) {
      obj.weekendTourneyBracketRound = Math.round(message.weekendTourneyBracketRound);
    }
    if (message.customGameDifficulty !== 0) {
      obj.customGameDifficulty = Math.round(message.customGameDifficulty);
    }
    return obj;
  },

  create(base?: DeepPartial<CSourceTVGameSmall>): CSourceTVGameSmall {
    return CSourceTVGameSmall.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSourceTVGameSmall>): CSourceTVGameSmall {
    const message = createBaseCSourceTVGameSmall();
    message.activateTime = object.activateTime ?? 0;
    message.deactivateTime = object.deactivateTime ?? 0;
    message.serverSteamId = object.serverSteamId ?? "0";
    message.lobbyId = object.lobbyId ?? "0";
    message.leagueId = object.leagueId ?? 0;
    message.lobbyType = object.lobbyType ?? 0;
    message.gameTime = object.gameTime ?? 0;
    message.delay = object.delay ?? 0;
    message.spectators = object.spectators ?? 0;
    message.gameMode = object.gameMode ?? 0;
    message.averageMmr = object.averageMmr ?? 0;
    message.matchId = object.matchId ?? "0";
    message.seriesId = object.seriesId ?? 0;
    message.teamNameRadiant = object.teamNameRadiant ?? "";
    message.teamNameDire = object.teamNameDire ?? "";
    message.teamLogoRadiant = object.teamLogoRadiant ?? "0";
    message.teamLogoDire = object.teamLogoDire ?? "0";
    message.teamIdRadiant = object.teamIdRadiant ?? 0;
    message.teamIdDire = object.teamIdDire ?? 0;
    message.sortScore = object.sortScore ?? 0;
    message.lastUpdateTime = object.lastUpdateTime ?? 0;
    message.radiantLead = object.radiantLead ?? 0;
    message.radiantScore = object.radiantScore ?? 0;
    message.direScore = object.direScore ?? 0;
    message.players = object.players?.map((e) => CSourceTVGameSmall_Player.fromPartial(e)) || [];
    message.buildingState = object.buildingState ?? 0;
    message.weekendTourneyTournamentId = object.weekendTourneyTournamentId ?? 0;
    message.weekendTourneyDivision = object.weekendTourneyDivision ?? 0;
    message.weekendTourneySkillLevel = object.weekendTourneySkillLevel ?? 0;
    message.weekendTourneyBracketRound = object.weekendTourneyBracketRound ?? 0;
    message.customGameDifficulty = object.customGameDifficulty ?? 0;
    return message;
  },
};

function createBaseCSourceTVGameSmall_Player(): CSourceTVGameSmall_Player {
  return { accountId: 0, heroId: 0, teamSlot: 0, team: 0 };
}

export const CSourceTVGameSmall_Player: MessageFns<CSourceTVGameSmall_Player> = {
  encode(message: CSourceTVGameSmall_Player, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.heroId !== 0) {
      writer.uint32(16).int32(message.heroId);
    }
    if (message.teamSlot !== 0) {
      writer.uint32(24).uint32(message.teamSlot);
    }
    if (message.team !== 0) {
      writer.uint32(32).uint32(message.team);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CSourceTVGameSmall_Player {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSourceTVGameSmall_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.teamSlot = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.team = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSourceTVGameSmall_Player {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      teamSlot: isSet(object.teamSlot) ? globalThis.Number(object.teamSlot) : 0,
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
    };
  },

  toJSON(message: CSourceTVGameSmall_Player): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.teamSlot !== 0) {
      obj.teamSlot = Math.round(message.teamSlot);
    }
    if (message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    return obj;
  },

  create(base?: DeepPartial<CSourceTVGameSmall_Player>): CSourceTVGameSmall_Player {
    return CSourceTVGameSmall_Player.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSourceTVGameSmall_Player>): CSourceTVGameSmall_Player {
    const message = createBaseCSourceTVGameSmall_Player();
    message.accountId = object.accountId ?? 0;
    message.heroId = object.heroId ?? 0;
    message.teamSlot = object.teamSlot ?? 0;
    message.team = object.team ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCFindTopSourceTVGames(): CMsgClientToGCFindTopSourceTVGames {
  return { searchKey: "", leagueId: 0, heroId: 0, startGame: 0, gameListIndex: 0, lobbyIds: [] };
}

export const CMsgClientToGCFindTopSourceTVGames: MessageFns<CMsgClientToGCFindTopSourceTVGames> = {
  encode(message: CMsgClientToGCFindTopSourceTVGames, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchKey !== "") {
      writer.uint32(10).string(message.searchKey);
    }
    if (message.leagueId !== 0) {
      writer.uint32(16).uint32(message.leagueId);
    }
    if (message.heroId !== 0) {
      writer.uint32(24).int32(message.heroId);
    }
    if (message.startGame !== 0) {
      writer.uint32(32).uint32(message.startGame);
    }
    if (message.gameListIndex !== 0) {
      writer.uint32(40).uint32(message.gameListIndex);
    }
    writer.uint32(50).fork();
    for (const v of message.lobbyIds) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCFindTopSourceTVGames {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCFindTopSourceTVGames();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.searchKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.startGame = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.gameListIndex = reader.uint32();
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.lobbyIds.push(reader.uint64().toString());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.lobbyIds.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCFindTopSourceTVGames {
    return {
      searchKey: isSet(object.searchKey) ? globalThis.String(object.searchKey) : "",
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      startGame: isSet(object.startGame) ? globalThis.Number(object.startGame) : 0,
      gameListIndex: isSet(object.gameListIndex) ? globalThis.Number(object.gameListIndex) : 0,
      lobbyIds: globalThis.Array.isArray(object?.lobbyIds) ? object.lobbyIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CMsgClientToGCFindTopSourceTVGames): unknown {
    const obj: any = {};
    if (message.searchKey !== "") {
      obj.searchKey = message.searchKey;
    }
    if (message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.startGame !== 0) {
      obj.startGame = Math.round(message.startGame);
    }
    if (message.gameListIndex !== 0) {
      obj.gameListIndex = Math.round(message.gameListIndex);
    }
    if (message.lobbyIds?.length) {
      obj.lobbyIds = message.lobbyIds;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCFindTopSourceTVGames>): CMsgClientToGCFindTopSourceTVGames {
    return CMsgClientToGCFindTopSourceTVGames.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCFindTopSourceTVGames>): CMsgClientToGCFindTopSourceTVGames {
    const message = createBaseCMsgClientToGCFindTopSourceTVGames();
    message.searchKey = object.searchKey ?? "";
    message.leagueId = object.leagueId ?? 0;
    message.heroId = object.heroId ?? 0;
    message.startGame = object.startGame ?? 0;
    message.gameListIndex = object.gameListIndex ?? 0;
    message.lobbyIds = object.lobbyIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgGCToClientFindTopSourceTVGamesResponse(): CMsgGCToClientFindTopSourceTVGamesResponse {
  return {
    searchKey: "",
    leagueId: 0,
    heroId: 0,
    startGame: 0,
    numGames: 0,
    gameListIndex: 0,
    gameList: [],
    specificGames: false,
    botGame: undefined,
  };
}

export const CMsgGCToClientFindTopSourceTVGamesResponse: MessageFns<CMsgGCToClientFindTopSourceTVGamesResponse> = {
  encode(message: CMsgGCToClientFindTopSourceTVGamesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchKey !== "") {
      writer.uint32(10).string(message.searchKey);
    }
    if (message.leagueId !== 0) {
      writer.uint32(16).uint32(message.leagueId);
    }
    if (message.heroId !== 0) {
      writer.uint32(24).int32(message.heroId);
    }
    if (message.startGame !== 0) {
      writer.uint32(32).uint32(message.startGame);
    }
    if (message.numGames !== 0) {
      writer.uint32(40).uint32(message.numGames);
    }
    if (message.gameListIndex !== 0) {
      writer.uint32(48).uint32(message.gameListIndex);
    }
    for (const v of message.gameList) {
      CSourceTVGameSmall.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.specificGames !== false) {
      writer.uint32(64).bool(message.specificGames);
    }
    if (message.botGame !== undefined) {
      CSourceTVGameSmall.encode(message.botGame, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToClientFindTopSourceTVGamesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientFindTopSourceTVGamesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.searchKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.startGame = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.numGames = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.gameListIndex = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.gameList.push(CSourceTVGameSmall.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.specificGames = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.botGame = CSourceTVGameSmall.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientFindTopSourceTVGamesResponse {
    return {
      searchKey: isSet(object.searchKey) ? globalThis.String(object.searchKey) : "",
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      startGame: isSet(object.startGame) ? globalThis.Number(object.startGame) : 0,
      numGames: isSet(object.numGames) ? globalThis.Number(object.numGames) : 0,
      gameListIndex: isSet(object.gameListIndex) ? globalThis.Number(object.gameListIndex) : 0,
      gameList: globalThis.Array.isArray(object?.gameList)
        ? object.gameList.map((e: any) => CSourceTVGameSmall.fromJSON(e))
        : [],
      specificGames: isSet(object.specificGames) ? globalThis.Boolean(object.specificGames) : false,
      botGame: isSet(object.botGame) ? CSourceTVGameSmall.fromJSON(object.botGame) : undefined,
    };
  },

  toJSON(message: CMsgGCToClientFindTopSourceTVGamesResponse): unknown {
    const obj: any = {};
    if (message.searchKey !== "") {
      obj.searchKey = message.searchKey;
    }
    if (message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.startGame !== 0) {
      obj.startGame = Math.round(message.startGame);
    }
    if (message.numGames !== 0) {
      obj.numGames = Math.round(message.numGames);
    }
    if (message.gameListIndex !== 0) {
      obj.gameListIndex = Math.round(message.gameListIndex);
    }
    if (message.gameList?.length) {
      obj.gameList = message.gameList.map((e) => CSourceTVGameSmall.toJSON(e));
    }
    if (message.specificGames !== false) {
      obj.specificGames = message.specificGames;
    }
    if (message.botGame !== undefined) {
      obj.botGame = CSourceTVGameSmall.toJSON(message.botGame);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToClientFindTopSourceTVGamesResponse>): CMsgGCToClientFindTopSourceTVGamesResponse {
    return CMsgGCToClientFindTopSourceTVGamesResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGCToClientFindTopSourceTVGamesResponse>,
  ): CMsgGCToClientFindTopSourceTVGamesResponse {
    const message = createBaseCMsgGCToClientFindTopSourceTVGamesResponse();
    message.searchKey = object.searchKey ?? "";
    message.leagueId = object.leagueId ?? 0;
    message.heroId = object.heroId ?? 0;
    message.startGame = object.startGame ?? 0;
    message.numGames = object.numGames ?? 0;
    message.gameListIndex = object.gameListIndex ?? 0;
    message.gameList = object.gameList?.map((e) => CSourceTVGameSmall.fromPartial(e)) || [];
    message.specificGames = object.specificGames ?? false;
    message.botGame = (object.botGame !== undefined && object.botGame !== null)
      ? CSourceTVGameSmall.fromPartial(object.botGame)
      : undefined;
    return message;
  },
};

function createBaseCMsgGCToClientTopWeekendTourneyGames(): CMsgGCToClientTopWeekendTourneyGames {
  return { liveGames: [] };
}

export const CMsgGCToClientTopWeekendTourneyGames: MessageFns<CMsgGCToClientTopWeekendTourneyGames> = {
  encode(message: CMsgGCToClientTopWeekendTourneyGames, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.liveGames) {
      CSourceTVGameSmall.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToClientTopWeekendTourneyGames {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientTopWeekendTourneyGames();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.liveGames.push(CSourceTVGameSmall.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientTopWeekendTourneyGames {
    return {
      liveGames: globalThis.Array.isArray(object?.liveGames)
        ? object.liveGames.map((e: any) => CSourceTVGameSmall.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCToClientTopWeekendTourneyGames): unknown {
    const obj: any = {};
    if (message.liveGames?.length) {
      obj.liveGames = message.liveGames.map((e) => CSourceTVGameSmall.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToClientTopWeekendTourneyGames>): CMsgGCToClientTopWeekendTourneyGames {
    return CMsgGCToClientTopWeekendTourneyGames.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToClientTopWeekendTourneyGames>): CMsgGCToClientTopWeekendTourneyGames {
    const message = createBaseCMsgGCToClientTopWeekendTourneyGames();
    message.liveGames = object.liveGames?.map((e) => CSourceTVGameSmall.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgClientToGCTopLeagueMatchesRequest(): CMsgClientToGCTopLeagueMatchesRequest {
  return {};
}

export const CMsgClientToGCTopLeagueMatchesRequest: MessageFns<CMsgClientToGCTopLeagueMatchesRequest> = {
  encode(_: CMsgClientToGCTopLeagueMatchesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCTopLeagueMatchesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCTopLeagueMatchesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientToGCTopLeagueMatchesRequest {
    return {};
  },

  toJSON(_: CMsgClientToGCTopLeagueMatchesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCTopLeagueMatchesRequest>): CMsgClientToGCTopLeagueMatchesRequest {
    return CMsgClientToGCTopLeagueMatchesRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgClientToGCTopLeagueMatchesRequest>): CMsgClientToGCTopLeagueMatchesRequest {
    const message = createBaseCMsgClientToGCTopLeagueMatchesRequest();
    return message;
  },
};

function createBaseCMsgClientToGCTopFriendMatchesRequest(): CMsgClientToGCTopFriendMatchesRequest {
  return {};
}

export const CMsgClientToGCTopFriendMatchesRequest: MessageFns<CMsgClientToGCTopFriendMatchesRequest> = {
  encode(_: CMsgClientToGCTopFriendMatchesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCTopFriendMatchesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCTopFriendMatchesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientToGCTopFriendMatchesRequest {
    return {};
  },

  toJSON(_: CMsgClientToGCTopFriendMatchesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCTopFriendMatchesRequest>): CMsgClientToGCTopFriendMatchesRequest {
    return CMsgClientToGCTopFriendMatchesRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgClientToGCTopFriendMatchesRequest>): CMsgClientToGCTopFriendMatchesRequest {
    const message = createBaseCMsgClientToGCTopFriendMatchesRequest();
    return message;
  },
};

function createBaseCMsgClientToGCMatchesMinimalRequest(): CMsgClientToGCMatchesMinimalRequest {
  return { matchIds: [] };
}

export const CMsgClientToGCMatchesMinimalRequest: MessageFns<CMsgClientToGCMatchesMinimalRequest> = {
  encode(message: CMsgClientToGCMatchesMinimalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.matchIds) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCMatchesMinimalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCMatchesMinimalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.matchIds.push(reader.uint64().toString());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.matchIds.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCMatchesMinimalRequest {
    return {
      matchIds: globalThis.Array.isArray(object?.matchIds) ? object.matchIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CMsgClientToGCMatchesMinimalRequest): unknown {
    const obj: any = {};
    if (message.matchIds?.length) {
      obj.matchIds = message.matchIds;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCMatchesMinimalRequest>): CMsgClientToGCMatchesMinimalRequest {
    return CMsgClientToGCMatchesMinimalRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCMatchesMinimalRequest>): CMsgClientToGCMatchesMinimalRequest {
    const message = createBaseCMsgClientToGCMatchesMinimalRequest();
    message.matchIds = object.matchIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgClientToGCMatchesMinimalResponse(): CMsgClientToGCMatchesMinimalResponse {
  return { matches: [], lastMatch: false };
}

export const CMsgClientToGCMatchesMinimalResponse: MessageFns<CMsgClientToGCMatchesMinimalResponse> = {
  encode(message: CMsgClientToGCMatchesMinimalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matches) {
      CMsgDOTAMatchMinimal.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.lastMatch !== false) {
      writer.uint32(16).bool(message.lastMatch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgClientToGCMatchesMinimalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCMatchesMinimalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matches.push(CMsgDOTAMatchMinimal.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lastMatch = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCMatchesMinimalResponse {
    return {
      matches: globalThis.Array.isArray(object?.matches)
        ? object.matches.map((e: any) => CMsgDOTAMatchMinimal.fromJSON(e))
        : [],
      lastMatch: isSet(object.lastMatch) ? globalThis.Boolean(object.lastMatch) : false,
    };
  },

  toJSON(message: CMsgClientToGCMatchesMinimalResponse): unknown {
    const obj: any = {};
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => CMsgDOTAMatchMinimal.toJSON(e));
    }
    if (message.lastMatch !== false) {
      obj.lastMatch = message.lastMatch;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCMatchesMinimalResponse>): CMsgClientToGCMatchesMinimalResponse {
    return CMsgClientToGCMatchesMinimalResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCMatchesMinimalResponse>): CMsgClientToGCMatchesMinimalResponse {
    const message = createBaseCMsgClientToGCMatchesMinimalResponse();
    message.matches = object.matches?.map((e) => CMsgDOTAMatchMinimal.fromPartial(e)) || [];
    message.lastMatch = object.lastMatch ?? false;
    return message;
  },
};

function createBaseCMsgGCToClientTopLeagueMatchesResponse(): CMsgGCToClientTopLeagueMatchesResponse {
  return { matches: [] };
}

export const CMsgGCToClientTopLeagueMatchesResponse: MessageFns<CMsgGCToClientTopLeagueMatchesResponse> = {
  encode(message: CMsgGCToClientTopLeagueMatchesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matches) {
      CMsgDOTAMatchMinimal.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToClientTopLeagueMatchesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientTopLeagueMatchesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.matches.push(CMsgDOTAMatchMinimal.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientTopLeagueMatchesResponse {
    return {
      matches: globalThis.Array.isArray(object?.matches)
        ? object.matches.map((e: any) => CMsgDOTAMatchMinimal.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCToClientTopLeagueMatchesResponse): unknown {
    const obj: any = {};
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => CMsgDOTAMatchMinimal.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToClientTopLeagueMatchesResponse>): CMsgGCToClientTopLeagueMatchesResponse {
    return CMsgGCToClientTopLeagueMatchesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToClientTopLeagueMatchesResponse>): CMsgGCToClientTopLeagueMatchesResponse {
    const message = createBaseCMsgGCToClientTopLeagueMatchesResponse();
    message.matches = object.matches?.map((e) => CMsgDOTAMatchMinimal.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGCToClientTopFriendMatchesResponse(): CMsgGCToClientTopFriendMatchesResponse {
  return { matches: [] };
}

export const CMsgGCToClientTopFriendMatchesResponse: MessageFns<CMsgGCToClientTopFriendMatchesResponse> = {
  encode(message: CMsgGCToClientTopFriendMatchesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matches) {
      CMsgDOTAMatchMinimal.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgGCToClientTopFriendMatchesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientTopFriendMatchesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matches.push(CMsgDOTAMatchMinimal.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientTopFriendMatchesResponse {
    return {
      matches: globalThis.Array.isArray(object?.matches)
        ? object.matches.map((e: any) => CMsgDOTAMatchMinimal.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCToClientTopFriendMatchesResponse): unknown {
    const obj: any = {};
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => CMsgDOTAMatchMinimal.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToClientTopFriendMatchesResponse>): CMsgGCToClientTopFriendMatchesResponse {
    return CMsgGCToClientTopFriendMatchesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToClientTopFriendMatchesResponse>): CMsgGCToClientTopFriendMatchesResponse {
    const message = createBaseCMsgGCToClientTopFriendMatchesResponse();
    message.matches = object.matches?.map((e) => CMsgDOTAMatchMinimal.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSpectateFriendGame(): CMsgSpectateFriendGame {
  return { steamId: "0", live: false };
}

export const CMsgSpectateFriendGame: MessageFns<CMsgSpectateFriendGame> = {
  encode(message: CMsgSpectateFriendGame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.steamId !== "0") {
      writer.uint32(9).fixed64(message.steamId);
    }
    if (message.live !== false) {
      writer.uint32(16).bool(message.live);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSpectateFriendGame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSpectateFriendGame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.steamId = reader.fixed64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.live = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSpectateFriendGame {
    return {
      steamId: isSet(object.steamId) ? globalThis.String(object.steamId) : "0",
      live: isSet(object.live) ? globalThis.Boolean(object.live) : false,
    };
  },

  toJSON(message: CMsgSpectateFriendGame): unknown {
    const obj: any = {};
    if (message.steamId !== "0") {
      obj.steamId = message.steamId;
    }
    if (message.live !== false) {
      obj.live = message.live;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSpectateFriendGame>): CMsgSpectateFriendGame {
    return CMsgSpectateFriendGame.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSpectateFriendGame>): CMsgSpectateFriendGame {
    const message = createBaseCMsgSpectateFriendGame();
    message.steamId = object.steamId ?? "0";
    message.live = object.live ?? false;
    return message;
  },
};

function createBaseCMsgSpectateFriendGameResponse(): CMsgSpectateFriendGameResponse {
  return { serverSteamid: "0", watchLiveResult: 0 };
}

export const CMsgSpectateFriendGameResponse: MessageFns<CMsgSpectateFriendGameResponse> = {
  encode(message: CMsgSpectateFriendGameResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serverSteamid !== "0") {
      writer.uint32(33).fixed64(message.serverSteamid);
    }
    if (message.watchLiveResult !== 0) {
      writer.uint32(40).int32(message.watchLiveResult);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSpectateFriendGameResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSpectateFriendGameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.serverSteamid = reader.fixed64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.watchLiveResult = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSpectateFriendGameResponse {
    return {
      serverSteamid: isSet(object.serverSteamid) ? globalThis.String(object.serverSteamid) : "0",
      watchLiveResult: isSet(object.watchLiveResult)
        ? cMsgSpectateFriendGameResponse_EWatchLiveResultFromJSON(object.watchLiveResult)
        : 0,
    };
  },

  toJSON(message: CMsgSpectateFriendGameResponse): unknown {
    const obj: any = {};
    if (message.serverSteamid !== "0") {
      obj.serverSteamid = message.serverSteamid;
    }
    if (message.watchLiveResult !== 0) {
      obj.watchLiveResult = cMsgSpectateFriendGameResponse_EWatchLiveResultToJSON(message.watchLiveResult);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSpectateFriendGameResponse>): CMsgSpectateFriendGameResponse {
    return CMsgSpectateFriendGameResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSpectateFriendGameResponse>): CMsgSpectateFriendGameResponse {
    const message = createBaseCMsgSpectateFriendGameResponse();
    message.serverSteamid = object.serverSteamid ?? "0";
    message.watchLiveResult = object.watchLiveResult ?? 0;
    return message;
  },
};

function createBaseCDOTAReplayDownloadInfo(): CDOTAReplayDownloadInfo {
  return { match: undefined, title: "", description: "", size: 0, tags: [], existsOnDisk: false };
}

export const CDOTAReplayDownloadInfo: MessageFns<CDOTAReplayDownloadInfo> = {
  encode(message: CDOTAReplayDownloadInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.match !== undefined) {
      CMsgDOTAMatchMinimal.encode(message.match, writer.uint32(10).fork()).join();
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.size !== 0) {
      writer.uint32(32).uint32(message.size);
    }
    for (const v of message.tags) {
      writer.uint32(42).string(v!);
    }
    if (message.existsOnDisk !== false) {
      writer.uint32(48).bool(message.existsOnDisk);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CDOTAReplayDownloadInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAReplayDownloadInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.match = CMsgDOTAMatchMinimal.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.size = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.existsOnDisk = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAReplayDownloadInfo {
    return {
      match: isSet(object.match) ? CMsgDOTAMatchMinimal.fromJSON(object.match) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      existsOnDisk: isSet(object.existsOnDisk) ? globalThis.Boolean(object.existsOnDisk) : false,
    };
  },

  toJSON(message: CDOTAReplayDownloadInfo): unknown {
    const obj: any = {};
    if (message.match !== undefined) {
      obj.match = CMsgDOTAMatchMinimal.toJSON(message.match);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.existsOnDisk !== false) {
      obj.existsOnDisk = message.existsOnDisk;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAReplayDownloadInfo>): CDOTAReplayDownloadInfo {
    return CDOTAReplayDownloadInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAReplayDownloadInfo>): CDOTAReplayDownloadInfo {
    const message = createBaseCDOTAReplayDownloadInfo();
    message.match = (object.match !== undefined && object.match !== null)
      ? CMsgDOTAMatchMinimal.fromPartial(object.match)
      : undefined;
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.size = object.size ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.existsOnDisk = object.existsOnDisk ?? false;
    return message;
  },
};

function createBaseCDOTAReplayDownloadInfo_Highlight(): CDOTAReplayDownloadInfo_Highlight {
  return { timestamp: 0, description: "" };
}

export const CDOTAReplayDownloadInfo_Highlight: MessageFns<CDOTAReplayDownloadInfo_Highlight> = {
  encode(message: CDOTAReplayDownloadInfo_Highlight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== 0) {
      writer.uint32(8).uint32(message.timestamp);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CDOTAReplayDownloadInfo_Highlight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAReplayDownloadInfo_Highlight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAReplayDownloadInfo_Highlight {
    return {
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: CDOTAReplayDownloadInfo_Highlight): unknown {
    const obj: any = {};
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAReplayDownloadInfo_Highlight>): CDOTAReplayDownloadInfo_Highlight {
    return CDOTAReplayDownloadInfo_Highlight.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAReplayDownloadInfo_Highlight>): CDOTAReplayDownloadInfo_Highlight {
    const message = createBaseCDOTAReplayDownloadInfo_Highlight();
    message.timestamp = object.timestamp ?? 0;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseCMsgWatchGame(): CMsgWatchGame {
  return { serverSteamid: "0", clientVersion: 0, watchServerSteamid: "0", lobbyId: "0", regions: [] };
}

export const CMsgWatchGame: MessageFns<CMsgWatchGame> = {
  encode(message: CMsgWatchGame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serverSteamid !== "0") {
      writer.uint32(9).fixed64(message.serverSteamid);
    }
    if (message.clientVersion !== 0) {
      writer.uint32(16).uint32(message.clientVersion);
    }
    if (message.watchServerSteamid !== "0") {
      writer.uint32(25).fixed64(message.watchServerSteamid);
    }
    if (message.lobbyId !== "0") {
      writer.uint32(32).uint64(message.lobbyId);
    }
    writer.uint32(42).fork();
    for (const v of message.regions) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgWatchGame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgWatchGame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.serverSteamid = reader.fixed64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.clientVersion = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.watchServerSteamid = reader.fixed64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lobbyId = reader.uint64().toString();
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.regions.push(reader.uint32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.regions.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgWatchGame {
    return {
      serverSteamid: isSet(object.serverSteamid) ? globalThis.String(object.serverSteamid) : "0",
      clientVersion: isSet(object.clientVersion) ? globalThis.Number(object.clientVersion) : 0,
      watchServerSteamid: isSet(object.watchServerSteamid) ? globalThis.String(object.watchServerSteamid) : "0",
      lobbyId: isSet(object.lobbyId) ? globalThis.String(object.lobbyId) : "0",
      regions: globalThis.Array.isArray(object?.regions) ? object.regions.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CMsgWatchGame): unknown {
    const obj: any = {};
    if (message.serverSteamid !== "0") {
      obj.serverSteamid = message.serverSteamid;
    }
    if (message.clientVersion !== 0) {
      obj.clientVersion = Math.round(message.clientVersion);
    }
    if (message.watchServerSteamid !== "0") {
      obj.watchServerSteamid = message.watchServerSteamid;
    }
    if (message.lobbyId !== "0") {
      obj.lobbyId = message.lobbyId;
    }
    if (message.regions?.length) {
      obj.regions = message.regions.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgWatchGame>): CMsgWatchGame {
    return CMsgWatchGame.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgWatchGame>): CMsgWatchGame {
    const message = createBaseCMsgWatchGame();
    message.serverSteamid = object.serverSteamid ?? "0";
    message.clientVersion = object.clientVersion ?? 0;
    message.watchServerSteamid = object.watchServerSteamid ?? "0";
    message.lobbyId = object.lobbyId ?? "0";
    message.regions = object.regions?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgCancelWatchGame(): CMsgCancelWatchGame {
  return {};
}

export const CMsgCancelWatchGame: MessageFns<CMsgCancelWatchGame> = {
  encode(_: CMsgCancelWatchGame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgCancelWatchGame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgCancelWatchGame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgCancelWatchGame {
    return {};
  },

  toJSON(_: CMsgCancelWatchGame): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgCancelWatchGame>): CMsgCancelWatchGame {
    return CMsgCancelWatchGame.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgCancelWatchGame>): CMsgCancelWatchGame {
    const message = createBaseCMsgCancelWatchGame();
    return message;
  },
};

function createBaseCMsgWatchGameResponse(): CMsgWatchGameResponse {
  return {
    watchGameResult: 0,
    sourceTvPublicAddr: 0,
    sourceTvPrivateAddr: 0,
    sourceTvPort: 0,
    gameServerSteamid: "0",
    watchServerSteamid: "0",
    watchTvUniqueSecretCode: "0",
  };
}

export const CMsgWatchGameResponse: MessageFns<CMsgWatchGameResponse> = {
  encode(message: CMsgWatchGameResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.watchGameResult !== 0) {
      writer.uint32(8).int32(message.watchGameResult);
    }
    if (message.sourceTvPublicAddr !== 0) {
      writer.uint32(16).uint32(message.sourceTvPublicAddr);
    }
    if (message.sourceTvPrivateAddr !== 0) {
      writer.uint32(24).uint32(message.sourceTvPrivateAddr);
    }
    if (message.sourceTvPort !== 0) {
      writer.uint32(32).uint32(message.sourceTvPort);
    }
    if (message.gameServerSteamid !== "0") {
      writer.uint32(41).fixed64(message.gameServerSteamid);
    }
    if (message.watchServerSteamid !== "0") {
      writer.uint32(49).fixed64(message.watchServerSteamid);
    }
    if (message.watchTvUniqueSecretCode !== "0") {
      writer.uint32(57).fixed64(message.watchTvUniqueSecretCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgWatchGameResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgWatchGameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.watchGameResult = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sourceTvPublicAddr = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sourceTvPrivateAddr = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sourceTvPort = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.gameServerSteamid = reader.fixed64().toString();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.watchServerSteamid = reader.fixed64().toString();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.watchTvUniqueSecretCode = reader.fixed64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgWatchGameResponse {
    return {
      watchGameResult: isSet(object.watchGameResult)
        ? cMsgWatchGameResponse_WatchGameResultFromJSON(object.watchGameResult)
        : 0,
      sourceTvPublicAddr: isSet(object.sourceTvPublicAddr) ? globalThis.Number(object.sourceTvPublicAddr) : 0,
      sourceTvPrivateAddr: isSet(object.sourceTvPrivateAddr) ? globalThis.Number(object.sourceTvPrivateAddr) : 0,
      sourceTvPort: isSet(object.sourceTvPort) ? globalThis.Number(object.sourceTvPort) : 0,
      gameServerSteamid: isSet(object.gameServerSteamid) ? globalThis.String(object.gameServerSteamid) : "0",
      watchServerSteamid: isSet(object.watchServerSteamid) ? globalThis.String(object.watchServerSteamid) : "0",
      watchTvUniqueSecretCode: isSet(object.watchTvUniqueSecretCode)
        ? globalThis.String(object.watchTvUniqueSecretCode)
        : "0",
    };
  },

  toJSON(message: CMsgWatchGameResponse): unknown {
    const obj: any = {};
    if (message.watchGameResult !== 0) {
      obj.watchGameResult = cMsgWatchGameResponse_WatchGameResultToJSON(message.watchGameResult);
    }
    if (message.sourceTvPublicAddr !== 0) {
      obj.sourceTvPublicAddr = Math.round(message.sourceTvPublicAddr);
    }
    if (message.sourceTvPrivateAddr !== 0) {
      obj.sourceTvPrivateAddr = Math.round(message.sourceTvPrivateAddr);
    }
    if (message.sourceTvPort !== 0) {
      obj.sourceTvPort = Math.round(message.sourceTvPort);
    }
    if (message.gameServerSteamid !== "0") {
      obj.gameServerSteamid = message.gameServerSteamid;
    }
    if (message.watchServerSteamid !== "0") {
      obj.watchServerSteamid = message.watchServerSteamid;
    }
    if (message.watchTvUniqueSecretCode !== "0") {
      obj.watchTvUniqueSecretCode = message.watchTvUniqueSecretCode;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgWatchGameResponse>): CMsgWatchGameResponse {
    return CMsgWatchGameResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgWatchGameResponse>): CMsgWatchGameResponse {
    const message = createBaseCMsgWatchGameResponse();
    message.watchGameResult = object.watchGameResult ?? 0;
    message.sourceTvPublicAddr = object.sourceTvPublicAddr ?? 0;
    message.sourceTvPrivateAddr = object.sourceTvPrivateAddr ?? 0;
    message.sourceTvPort = object.sourceTvPort ?? 0;
    message.gameServerSteamid = object.gameServerSteamid ?? "0";
    message.watchServerSteamid = object.watchServerSteamid ?? "0";
    message.watchTvUniqueSecretCode = object.watchTvUniqueSecretCode ?? "0";
    return message;
  },
};

function createBaseCMsgPartyLeaderWatchGamePrompt(): CMsgPartyLeaderWatchGamePrompt {
  return { gameServerSteamid: "0" };
}

export const CMsgPartyLeaderWatchGamePrompt: MessageFns<CMsgPartyLeaderWatchGamePrompt> = {
  encode(message: CMsgPartyLeaderWatchGamePrompt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gameServerSteamid !== "0") {
      writer.uint32(41).fixed64(message.gameServerSteamid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgPartyLeaderWatchGamePrompt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPartyLeaderWatchGamePrompt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.gameServerSteamid = reader.fixed64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPartyLeaderWatchGamePrompt {
    return { gameServerSteamid: isSet(object.gameServerSteamid) ? globalThis.String(object.gameServerSteamid) : "0" };
  },

  toJSON(message: CMsgPartyLeaderWatchGamePrompt): unknown {
    const obj: any = {};
    if (message.gameServerSteamid !== "0") {
      obj.gameServerSteamid = message.gameServerSteamid;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPartyLeaderWatchGamePrompt>): CMsgPartyLeaderWatchGamePrompt {
    return CMsgPartyLeaderWatchGamePrompt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPartyLeaderWatchGamePrompt>): CMsgPartyLeaderWatchGamePrompt {
    const message = createBaseCMsgPartyLeaderWatchGamePrompt();
    message.gameServerSteamid = object.gameServerSteamid ?? "0";
    return message;
  },
};

function createBaseCDOTABroadcasterInfo(): CDOTABroadcasterInfo {
  return {
    accountId: 0,
    serverSteamId: "0",
    live: false,
    teamNameRadiant: "",
    teamNameDire: "",
    seriesGame: 0,
    upcomingBroadcastTimestamp: 0,
    allowLiveVideo: false,
    nodeType: 0,
    nodeName: "",
  };
}

export const CDOTABroadcasterInfo: MessageFns<CDOTABroadcasterInfo> = {
  encode(message: CDOTABroadcasterInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.serverSteamId !== "0") {
      writer.uint32(17).fixed64(message.serverSteamId);
    }
    if (message.live !== false) {
      writer.uint32(24).bool(message.live);
    }
    if (message.teamNameRadiant !== "") {
      writer.uint32(34).string(message.teamNameRadiant);
    }
    if (message.teamNameDire !== "") {
      writer.uint32(42).string(message.teamNameDire);
    }
    if (message.seriesGame !== 0) {
      writer.uint32(56).uint32(message.seriesGame);
    }
    if (message.upcomingBroadcastTimestamp !== 0) {
      writer.uint32(72).uint32(message.upcomingBroadcastTimestamp);
    }
    if (message.allowLiveVideo !== false) {
      writer.uint32(80).bool(message.allowLiveVideo);
    }
    if (message.nodeType !== 0) {
      writer.uint32(88).uint32(message.nodeType);
    }
    if (message.nodeName !== "") {
      writer.uint32(98).string(message.nodeName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CDOTABroadcasterInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTABroadcasterInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.serverSteamId = reader.fixed64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.live = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.teamNameRadiant = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.teamNameDire = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.seriesGame = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.upcomingBroadcastTimestamp = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.allowLiveVideo = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.nodeType = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.nodeName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTABroadcasterInfo {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      serverSteamId: isSet(object.serverSteamId) ? globalThis.String(object.serverSteamId) : "0",
      live: isSet(object.live) ? globalThis.Boolean(object.live) : false,
      teamNameRadiant: isSet(object.teamNameRadiant) ? globalThis.String(object.teamNameRadiant) : "",
      teamNameDire: isSet(object.teamNameDire) ? globalThis.String(object.teamNameDire) : "",
      seriesGame: isSet(object.seriesGame) ? globalThis.Number(object.seriesGame) : 0,
      upcomingBroadcastTimestamp: isSet(object.upcomingBroadcastTimestamp)
        ? globalThis.Number(object.upcomingBroadcastTimestamp)
        : 0,
      allowLiveVideo: isSet(object.allowLiveVideo) ? globalThis.Boolean(object.allowLiveVideo) : false,
      nodeType: isSet(object.nodeType) ? globalThis.Number(object.nodeType) : 0,
      nodeName: isSet(object.nodeName) ? globalThis.String(object.nodeName) : "",
    };
  },

  toJSON(message: CDOTABroadcasterInfo): unknown {
    const obj: any = {};
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.serverSteamId !== "0") {
      obj.serverSteamId = message.serverSteamId;
    }
    if (message.live !== false) {
      obj.live = message.live;
    }
    if (message.teamNameRadiant !== "") {
      obj.teamNameRadiant = message.teamNameRadiant;
    }
    if (message.teamNameDire !== "") {
      obj.teamNameDire = message.teamNameDire;
    }
    if (message.seriesGame !== 0) {
      obj.seriesGame = Math.round(message.seriesGame);
    }
    if (message.upcomingBroadcastTimestamp !== 0) {
      obj.upcomingBroadcastTimestamp = Math.round(message.upcomingBroadcastTimestamp);
    }
    if (message.allowLiveVideo !== false) {
      obj.allowLiveVideo = message.allowLiveVideo;
    }
    if (message.nodeType !== 0) {
      obj.nodeType = Math.round(message.nodeType);
    }
    if (message.nodeName !== "") {
      obj.nodeName = message.nodeName;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTABroadcasterInfo>): CDOTABroadcasterInfo {
    return CDOTABroadcasterInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTABroadcasterInfo>): CDOTABroadcasterInfo {
    const message = createBaseCDOTABroadcasterInfo();
    message.accountId = object.accountId ?? 0;
    message.serverSteamId = object.serverSteamId ?? "0";
    message.live = object.live ?? false;
    message.teamNameRadiant = object.teamNameRadiant ?? "";
    message.teamNameDire = object.teamNameDire ?? "";
    message.seriesGame = object.seriesGame ?? 0;
    message.upcomingBroadcastTimestamp = object.upcomingBroadcastTimestamp ?? 0;
    message.allowLiveVideo = object.allowLiveVideo ?? false;
    message.nodeType = object.nodeType ?? 0;
    message.nodeName = object.nodeName ?? "";
    return message;
  },
};

function createBaseCMsgDOTASeries(): CMsgDOTASeries {
  return { seriesId: 0, seriesType: 0, team1: undefined, team2: undefined, matchMinimal: [], liveGame: undefined };
}

export const CMsgDOTASeries: MessageFns<CMsgDOTASeries> = {
  encode(message: CMsgDOTASeries, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.seriesId !== 0) {
      writer.uint32(8).uint32(message.seriesId);
    }
    if (message.seriesType !== 0) {
      writer.uint32(16).uint32(message.seriesType);
    }
    if (message.team1 !== undefined) {
      CMsgDOTASeries_TeamInfo.encode(message.team1, writer.uint32(26).fork()).join();
    }
    if (message.team2 !== undefined) {
      CMsgDOTASeries_TeamInfo.encode(message.team2, writer.uint32(34).fork()).join();
    }
    for (const v of message.matchMinimal) {
      CMsgDOTAMatchMinimal.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.liveGame !== undefined) {
      CMsgDOTASeries_LiveGame.encode(message.liveGame, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTASeries {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASeries();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.seriesId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.seriesType = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.team1 = CMsgDOTASeries_TeamInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.team2 = CMsgDOTASeries_TeamInfo.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.matchMinimal.push(CMsgDOTAMatchMinimal.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.liveGame = CMsgDOTASeries_LiveGame.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASeries {
    return {
      seriesId: isSet(object.seriesId) ? globalThis.Number(object.seriesId) : 0,
      seriesType: isSet(object.seriesType) ? globalThis.Number(object.seriesType) : 0,
      team1: isSet(object.team1) ? CMsgDOTASeries_TeamInfo.fromJSON(object.team1) : undefined,
      team2: isSet(object.team2) ? CMsgDOTASeries_TeamInfo.fromJSON(object.team2) : undefined,
      matchMinimal: globalThis.Array.isArray(object?.matchMinimal)
        ? object.matchMinimal.map((e: any) => CMsgDOTAMatchMinimal.fromJSON(e))
        : [],
      liveGame: isSet(object.liveGame) ? CMsgDOTASeries_LiveGame.fromJSON(object.liveGame) : undefined,
    };
  },

  toJSON(message: CMsgDOTASeries): unknown {
    const obj: any = {};
    if (message.seriesId !== 0) {
      obj.seriesId = Math.round(message.seriesId);
    }
    if (message.seriesType !== 0) {
      obj.seriesType = Math.round(message.seriesType);
    }
    if (message.team1 !== undefined) {
      obj.team1 = CMsgDOTASeries_TeamInfo.toJSON(message.team1);
    }
    if (message.team2 !== undefined) {
      obj.team2 = CMsgDOTASeries_TeamInfo.toJSON(message.team2);
    }
    if (message.matchMinimal?.length) {
      obj.matchMinimal = message.matchMinimal.map((e) => CMsgDOTAMatchMinimal.toJSON(e));
    }
    if (message.liveGame !== undefined) {
      obj.liveGame = CMsgDOTASeries_LiveGame.toJSON(message.liveGame);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTASeries>): CMsgDOTASeries {
    return CMsgDOTASeries.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTASeries>): CMsgDOTASeries {
    const message = createBaseCMsgDOTASeries();
    message.seriesId = object.seriesId ?? 0;
    message.seriesType = object.seriesType ?? 0;
    message.team1 = (object.team1 !== undefined && object.team1 !== null)
      ? CMsgDOTASeries_TeamInfo.fromPartial(object.team1)
      : undefined;
    message.team2 = (object.team2 !== undefined && object.team2 !== null)
      ? CMsgDOTASeries_TeamInfo.fromPartial(object.team2)
      : undefined;
    message.matchMinimal = object.matchMinimal?.map((e) => CMsgDOTAMatchMinimal.fromPartial(e)) || [];
    message.liveGame = (object.liveGame !== undefined && object.liveGame !== null)
      ? CMsgDOTASeries_LiveGame.fromPartial(object.liveGame)
      : undefined;
    return message;
  },
};

function createBaseCMsgDOTASeries_TeamInfo(): CMsgDOTASeries_TeamInfo {
  return { teamId: 0, teamName: "", teamLogoUrl: "", wagerCount: 0 };
}

export const CMsgDOTASeries_TeamInfo: MessageFns<CMsgDOTASeries_TeamInfo> = {
  encode(message: CMsgDOTASeries_TeamInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.teamId !== 0) {
      writer.uint32(8).uint32(message.teamId);
    }
    if (message.teamName !== "") {
      writer.uint32(18).string(message.teamName);
    }
    if (message.teamLogoUrl !== "") {
      writer.uint32(26).string(message.teamLogoUrl);
    }
    if (message.wagerCount !== 0) {
      writer.uint32(32).uint32(message.wagerCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTASeries_TeamInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASeries_TeamInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.teamName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.teamLogoUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.wagerCount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASeries_TeamInfo {
    return {
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      teamName: isSet(object.teamName) ? globalThis.String(object.teamName) : "",
      teamLogoUrl: isSet(object.teamLogoUrl) ? globalThis.String(object.teamLogoUrl) : "",
      wagerCount: isSet(object.wagerCount) ? globalThis.Number(object.wagerCount) : 0,
    };
  },

  toJSON(message: CMsgDOTASeries_TeamInfo): unknown {
    const obj: any = {};
    if (message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.teamName !== "") {
      obj.teamName = message.teamName;
    }
    if (message.teamLogoUrl !== "") {
      obj.teamLogoUrl = message.teamLogoUrl;
    }
    if (message.wagerCount !== 0) {
      obj.wagerCount = Math.round(message.wagerCount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTASeries_TeamInfo>): CMsgDOTASeries_TeamInfo {
    return CMsgDOTASeries_TeamInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTASeries_TeamInfo>): CMsgDOTASeries_TeamInfo {
    const message = createBaseCMsgDOTASeries_TeamInfo();
    message.teamId = object.teamId ?? 0;
    message.teamName = object.teamName ?? "";
    message.teamLogoUrl = object.teamLogoUrl ?? "";
    message.wagerCount = object.wagerCount ?? 0;
    return message;
  },
};

function createBaseCMsgDOTASeries_LiveGame(): CMsgDOTASeries_LiveGame {
  return { serverSteamId: "0", teamRadiant: undefined, teamDire: undefined, teamRadiantScore: 0, teamDireScore: 0 };
}

export const CMsgDOTASeries_LiveGame: MessageFns<CMsgDOTASeries_LiveGame> = {
  encode(message: CMsgDOTASeries_LiveGame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serverSteamId !== "0") {
      writer.uint32(9).fixed64(message.serverSteamId);
    }
    if (message.teamRadiant !== undefined) {
      CMsgDOTASeries_TeamInfo.encode(message.teamRadiant, writer.uint32(18).fork()).join();
    }
    if (message.teamDire !== undefined) {
      CMsgDOTASeries_TeamInfo.encode(message.teamDire, writer.uint32(26).fork()).join();
    }
    if (message.teamRadiantScore !== 0) {
      writer.uint32(32).uint32(message.teamRadiantScore);
    }
    if (message.teamDireScore !== 0) {
      writer.uint32(40).uint32(message.teamDireScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgDOTASeries_LiveGame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASeries_LiveGame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.serverSteamId = reader.fixed64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.teamRadiant = CMsgDOTASeries_TeamInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.teamDire = CMsgDOTASeries_TeamInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.teamRadiantScore = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.teamDireScore = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASeries_LiveGame {
    return {
      serverSteamId: isSet(object.serverSteamId) ? globalThis.String(object.serverSteamId) : "0",
      teamRadiant: isSet(object.teamRadiant) ? CMsgDOTASeries_TeamInfo.fromJSON(object.teamRadiant) : undefined,
      teamDire: isSet(object.teamDire) ? CMsgDOTASeries_TeamInfo.fromJSON(object.teamDire) : undefined,
      teamRadiantScore: isSet(object.teamRadiantScore) ? globalThis.Number(object.teamRadiantScore) : 0,
      teamDireScore: isSet(object.teamDireScore) ? globalThis.Number(object.teamDireScore) : 0,
    };
  },

  toJSON(message: CMsgDOTASeries_LiveGame): unknown {
    const obj: any = {};
    if (message.serverSteamId !== "0") {
      obj.serverSteamId = message.serverSteamId;
    }
    if (message.teamRadiant !== undefined) {
      obj.teamRadiant = CMsgDOTASeries_TeamInfo.toJSON(message.teamRadiant);
    }
    if (message.teamDire !== undefined) {
      obj.teamDire = CMsgDOTASeries_TeamInfo.toJSON(message.teamDire);
    }
    if (message.teamRadiantScore !== 0) {
      obj.teamRadiantScore = Math.round(message.teamRadiantScore);
    }
    if (message.teamDireScore !== 0) {
      obj.teamDireScore = Math.round(message.teamDireScore);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTASeries_LiveGame>): CMsgDOTASeries_LiveGame {
    return CMsgDOTASeries_LiveGame.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTASeries_LiveGame>): CMsgDOTASeries_LiveGame {
    const message = createBaseCMsgDOTASeries_LiveGame();
    message.serverSteamId = object.serverSteamId ?? "0";
    message.teamRadiant = (object.teamRadiant !== undefined && object.teamRadiant !== null)
      ? CMsgDOTASeries_TeamInfo.fromPartial(object.teamRadiant)
      : undefined;
    message.teamDire = (object.teamDire !== undefined && object.teamDire !== null)
      ? CMsgDOTASeries_TeamInfo.fromPartial(object.teamDire)
      : undefined;
    message.teamRadiantScore = object.teamRadiantScore ?? 0;
    message.teamDireScore = object.teamDireScore ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
